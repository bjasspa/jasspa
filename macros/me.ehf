!   me
!   home
!   MicroEmacs
!   Contents
| home
MicroEmacs '02
|
 
| osd-help(3)
    Help on help
| Help Information
    Help commands
| Frequently Asked Questions
    Frequently Asked Questions
| Installation
    Installation
| Contact Information
    Contact Information
| Copyright
    Copyright
|
 
|
Contents
|
 
| MainMenu(3)
    Top Main Menu
| Essential Commands
    Essential Commands
| Bindings(2)
    Key Bindings
|
 
| File Handling Commands
    File Handling
| Dialogs and Menus
    Dialogs and Menus
| Cursor Movement Commands
    Cursor Movement
| Insertion and Deletion Commands
    Insertion and Deletion
| Paragraph and Text Formatting Commands
    Paragraph and Text Formatting
| Capitalization and Transposition Commands
    Capitalization and Transposition
| Searching and Replacing
    Searching and Replacing
| Macro Commands
    Macro Commands
| Buffer Manipulation Commands
    Buffer Manipulation
| Window Commands
    Window Manipulation
|
 
| Keyboard Binding Commands
    Keyboard Binding
| Operating Modes
    Operating Modes
| Shell and Command Controls
    Shell and Command Controls
| Spelling Commands
    Spelling Commands
| Hilighting, Color and Screen Appearance
    Hilighting, Screen Appearance
| Comparison and Differencing
    Comparison and Differencing
| Short Cuts and Abbreviations
    Short Cuts and Abbreviations
| Message Line Commands
    Message Line Commands
| Printing Commands
    Printing
| Macro Development Commands
    Macro Development
| Registry
    Registry
| Command Line Filters
    Command Line Filters
| MicroEmacs '02 - Games
    Games
|
 
|
Glossaries
|
 
| Command Glossary
    Command Glossary
| Variable Glossary
    Variable Glossary
| Macro Language Glossary
    Macro Language Glossary
| Global Glossary
    Global Glossary
|
 
|
Miscellaneous Information
|
 
| languageTemplates(2)
    Language Templates
| fileHooks(2)
    File Hooks
| Editor File Types
    Editor Files
| Compatibility(2)
    Compatibility
| Interfacing(2)
    Interfacing to external components
| MicroEmacs '02 - Supported File Types
    Supported File Types
| Client-Server(2)
    Client-Server Interface
| RegularExpressions(2)
    Regular Expressions
| Build(2)
    Building the software

cEcEMICROEMACS cEcA


    cDMicroEmacs '02cA, JASSPA Distribution, is defined as follows, refer to lslmme(1)le 
    for a description of the command line variables. 

    The following sections describe the topics that are available as part of 
    the on-line cDMicroEmacs '02cA manual pages. 

    lsMicroEmacs '02 - AcknowledgmentslmAcknowledgmentsle, lslmCopyrightle, lsMicroEmacs '02 - OriginslmOriginsle and lslmContact Informationle. 
    lslmFrequently Asked Questionsle. 

    See lslmHelp!le for some information on using the hypertext manual pages. 

        lsInstallation(1)lmInstallation Informationle 
        lsUserProfiles(2)lmSetting Up A User Profilele 
        lsCompanyProfiles(2)lmSetting Up a Company Profilele 

        lsMainMenu(3)lmTop Main Menule 
        lslmEssential Commandsle 
        lslmHelp Informationle 
        lsBindings(2)lmKey Bindingsle 

        lslmFile Handling Commandsle 
        lslmDialogs and Menusle 
        lslmCursor Movement Commandsle 
        lslmInsertion and Deletion Commandsle 
        lslmParagraph and Text Formatting Commandsle 
        lslmCapitalization and Transposition Commandsle 
        lslmSearching and Replacingle 
        lslmMacro Commandsle 
        lslmBuffer Manipulation Commandsle 
        lslmWindow Commandsle 

        lslmKeyboard Binding Commandsle 
        lslmOperating Modesle 
        lslmShell and Command Controlsle 
        lslmSpelling Commandsle 
        lslmHilighting, Color and Screen Appearancele 
        lsComparison and DifferencinglmComparison and Differencing Commandsle 
        lslmShort Cuts and Abbreviationsle 
        lslmMessage Line Commandsle 
        lslmPrinting Commandsle 
        lslmMacro Development Commandsle 
        lsRegistrylmRegistry Commandsle 
        lslmCommand Line Filtersle 
        lsMicroEmacs '02 - GameslmGamesle 


cEGlossaries cA


    lslmCommand Glossaryle 
    lslmVariable Glossaryle 
    lslmMacro Language Glossaryle 
    lslmGlobal Glossaryle 


cEMiscellaneous Information cA


    The following topics provide more in depth information:- 

        lslanguageTemplates(2)lmLanguage Templatesle 
        lsfileHooks(2)lmFile Hooksle 
        lsEditor File TypeslmEditor Filesle 
        lsCompatibility(2)lmCompatibility with the original MicroEMACSle 
        lsInterfacing(2)lmInterfacing to external componentsle 
        lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 
        lsClient-Server(2)lmClient-Server Interfacele 
        lsRegularExpressions(2)lmRegular Expressionsle 
        lsBuild(2)lmBuilding the sourcele 

!   Help!
cEcEHelp! cEcA


    The on-line manual pages are defined as follows:- 

        [logo] cDTitlecA 
        [link1][link2]..[linkn] 

    The components of the header are defined as follows:- 

    cC[logo]cA 
        The MicroEmacs '02 Logo in the top left hand corner of the screen 
        exists on every page and hides a hypertext link. Selecting this item 
        will take you back to the main lslmMicroEmacs '02le page (Only present on 
        HTML and Windows help pages). 

    cDTitle cA
        The title identifies the title of the topic that you are viewing. 

    cD[link] cA
        The link line provides quick links to other related material in the 
        on-line manual pages. Use these to take you to a chosen topic. The 
        cD[home]cA link returns to the contents page of the currently viewed 
        topic, this is equivalent to the cDContentscA button when viewing 
        Microsoft Windows help files. 


cESection Numbering cA


    The section numbering conventions used in these pages is defined as 
    follows:- 

        (1) - Executable command line. 
        (2) - Editor built in commands. 
        (2m) - Editor built in modes. 
        (3) - Editor commands implemented as macros. 
        (4) - Editor macro language syntax 
        (5) - Editor variables 
        (8) - Editor specific file formats 

!   Essential Commands
cEcEESSENTIAL COMMANDS cEcA


    The very essential commands which are the most important commands to know 
    include: 

    lslmabort-command(2)le (cDC-gcA) Abort command 
    lslmbackward-char(2)le (cDC-bcA) Move the cursor left 
    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the 
    cursor position 
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line 
    lslmfile-browser(3)le (cDf10cA) Browse the file system 
    lslmfile-browser-close(3)le Close the file-browser 
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows 
    lslmforward-char(2)le (cDC-fcA) Move the cursor right 
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor 
    position 
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line 
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive) 
    lslmquick-exit(2)le (cDesc zcA) Exit the editor writing changes 
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file 
    lslmsave-buffers-exit-emacs(2)le (cDesc zcA) Exit the editor prompt user to write 
    changes 
    lslmundo(2)le (cDC-x ucA) Undo the last edit 

!   Cursor Movement Commands
cEcECURSOR MOVEMENT COMMANDS cEcA


    The cursor movement commands control how the cursor is moved around the 
    buffer. 


cECommands cA


    lslmbackward-char(2)le (cDC-bcA) Move the cursor left 
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line 
    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph 
    lslmbackward-word(2)le (cDesc bcA) Move the cursor to the previous word 
    lslmbeginning-of-buffer(2)le (cDesc <cA) Move to beginning of buffer/file 
    lslmbeginning-of-line(2)le (cDC-acA) Move to beginning of line 
    lslmend-of-buffer(2)le (cDesc >cA) Move to end of buffer/file 
    lslmend-of-line(2)le (cDC-ecA) Move to end of line 
    lslmforward-char(2)le (cDC-fcA) Move the cursor right 
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line 
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph 
    lslmforward-word(2)le (cDesc fcA) Move the cursor to the next word 
    lslmgoto-line(2)le (cDesc gcA) Move the cursor to specified line 
    lslmgoto-matching-fence(2)le (cDesc C-fcA) Move the cursor to matching fence 
    lslmgoto-position(2)le Restore a stored position 
    lslmgoto-window(2)le Restore a saved window to the current window (historic) 
    lslmlist-commands(2)le (cDC-h ccA) List available commands 
    lslmlist-variables(2)le (cDC-h vcA) List defined variables 
    lslmrecenter(2)le (cDC-lcA) Recenter the window (refresh the screen) 
    lslmset-position(2)le Store the current position 
    lslmset-window(2)le Save the current window for restore (historic) 
    lslmuniversal-argument(2)le (cDC-ucA) Set the command argument count 


cEVariables cA


    lslm$fmatchdelay(5)le Fence matching delay time 

!   Insertion and Deletion Commands
cEcEINSERTION AND DELETION COMMANDS cEcA


    Commands that initiate insertion or deletion of text include: 


cEDeletion cA


    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the 
    cursor position 
    lslmbackward-delete-tab(2)le (cDS-tabcA) Delete white space to previous tab-stop 
    lslmbackward-kill-word(2)le (cDesc backspacecA) Delete the previous word at the 
    cursor position 
    lslmclean(3)le Remove redundant white spaces from the current buffer 
    lslmdelete-blank-lines(2)le (cDC-x C-ocA) Delete blank lines about cursor 
    lslmdelete-indentation(3)le Join 2 lines deleting white spaces 
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor 
    position 
    lslmforward-kill-word(2)le (cDesc dcA) Delete the next word at the cursor position 
    lslmkill-line(2)le (cDC-kcA) Delete all characters to the end of the line 
    lslmkill-paragraph(2)le Delete a paragraph 
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text 
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region 
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text 


cEInsertion cA


    lslminsert-newline(2)le (cDC-ocA) Insert new line at cursor position 
    lslminsert-tab(2)le (cDC-icA) Insert tab(s) into current buffer 
    lslmnormal-tab(3)le Insert a normal tab 
    lslmquote-char(2)le (cDC-qcA) Insert literal character 
    lslmreyank(2)le (cDesc ycA) Restore next yank buffer 
    lslmtab(2)le (cDtabcA) Handle the tab key 
    lslmyank(2)le (cDC-ycA) Paste (copy) kill buffer contents into buffer 


cEVariables cA


    lslm$tabsize(5)le Tab character width 
    lslm$tabwidth(5)le Tab character interval 

!   Paragraph and Text Formatting Commands
cEcEPARAGRAPH AND TEXT FORMATTING COMMANDS cEcA


    Commands that operate on paragraphs, and the layout of paragraphs: 


cEParagraph cA


    Paragraphs are separated by blank lines. A single paragraph is defined as 
    all of the text enclosed between two blank lines, with no intervening 
    blank lines. 

    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph 
    lslmfill-paragraph(2)le (cDesc ocA) Format a paragraph 
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph 
    lslmifill-paragraph(3)le (cDesc qcA) Format a paragraph 
    lslmkill-paragraph(2)le Delete a paragraph 
    lslmparagraph-to-line(3)le Convert a paragraph to a single line 
    lslmwrap-word(2)le Wrap word onto next line 


cERegions and Marks cA


    A region is the text located between the cDpointcA (the current cursor 
    position) and the cDmarkcA defined by lsset-mark(2)lmset-markle. 

    lslmcopy-region(2)le (cDesc wcA) Copy a region of the buffer 
    lslmcount-words(2)le (cDesc C-ccA) Count the number of words in a region 
    lslmexchange-point-and-mark(2)le (cDC-x C-xcA) Exchange the cursor and marked 
    position 
    lslmgoto-alpha-mark(2)le (cDC-x acA) Move the cursor to a alpha marked location 
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text 
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region 
    lslmset-alpha-mark(2)le (cDC-x C-acA) Place an alphabetic marker in the buffer 
    lslmset-mark(2)le (cDesc spacecA) Set starting point of region 
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text 


cEVariables cA


    lslm$fill-bullet(5)le Paragraph filling bullet character set 
    lslm$fill-bullet-len(5)le Paragraph filling bullet search depth 
    lslm$fill-col(5)le Paragraph Mode; right fill column 
    lslm$fill-eos(5)le Paragraph filling; end of sentence fill characters 
    lslm$fill-eos-len(5)le Paragraph filling; end of sentence padding length 
    lslm$fill-ignore(5)le Ignore paragraph filling character(s) 
    lslm$fill-mode(5)le Paragraph mode; justification method 

!   Short Cuts and Abbreviations
cEcESHORT CUTS cEcA


    Automatic commands, history and automatic formatting modes such as cDC-modecA 
    (see lslmcmode(2m)le). 


cECommands cA


    lslmbuffer-abbrev-file(2)le Set buffers' abbreviation file 
    lslmexpand-abbrev(2)le Expand an abbreviation 
    lslmexpand-abbrev-handle(3)le (cDesc esccA) Expand an abbreviation handler 
    lslmfind-tag(2)le (cDesc tcA) Find tag, auto-load file and move to tag position 
    lslmgenerate-tags-file(3)le Generate a tags file 
    lslmglobal-abbrev-file(2)le Set global abbreviation file 
    lslmindent(2)le Manage the auto-indentation methods 
    lslmiso-accents-expand(3)le Expand an ISO accent 
    lslmiso-accents-mode(3)le ISO accent expansion short-cut mode 
    lslmread-history(2)le Read in session history information 
    lslmsave-history(2)le Write history information to history file 
    lslmspell-complete-word(3)le Complete a word by invocation of the speller 


cEVariables cA


    lslm$c-brace(5)le C-mode; brace indentation 
    lslm$c-case(5)le C-mode; case indentation 
    lslm$c-contcomm(5)le C-mode; comment continuation string 
    lslm$c-continue(5)le C-mode; line continuation indent 
    lslm$c-contmax(5)le C-mode; line continuation maximum indent 
    lslm$c-margin(5)le C-mode; trailing comment margin 
    lslm$c-statement(5)le C-mode; statement indentation 
    lslm$c-switch(5)le C-mode; switch indentation 
    lslm%tag-file(5)le Tag file name 
    lslm%tag-option(5)le Tag file search option 
    lslm%tag-template(5)le Tag file search string 

!   Registry
cEcEREGISTRY cEcA


    The registry commands provide an interface to manage the registry files 
    defined by lslmerf(8)le. The registry is a mechanism which allows the binding of 
    information to a hierarchical tree node, using a file system metaphor to 
    access the data. cDMicroEmacscA uses a reserved root node cGhistorycA to save 
    session information (see lslmsave-history(2)le). 


cECommands cA


    lslmdelete-registry(2)le Delete a registry tree 
    lslmfind-registry(2)le Index search of a registry sub-tree 
    lslmget-registry(2)le Retrieve a node value from the registry 
    lslmlist-registry(2)le Display the registry in a buffer 
    lslmmark-registry(2)le Modify the operating mode of a registry node 
    lslmread-registry(2)le Read in a registry definition file 
    lslmsave-registry(2)le Write a registry definition file 
    lslmset-registry(2)le Modify a node value in the registry 


cEMacro Functions cA


    lslm&reg(4)le Retrieve a registry value (with default) 

!   Command Line Filters
cEcECOMMAND LINE FILTERS cEcA


    MicroEmacs may be invoked from the command line to perform a specific set 
    of filtering tasks, under control of a dedicated start up macro, see lslmme(1)le 
    and lslmstart-up(3)le. A number of standard macros are provided, most of which 
    are invoked automatically from the editor itself when requested by the 
    user. Having said that, it has not been unknown for a colleague of mine to 
    use the editor as a replacement for a more intelligent cDsed(1)cA filter, with 
    12 hours to go and a huge ugly 3-D geometric database to convert, what 
    better way than run it through a set of MicroEmacs macros to turn it into 
    another database format that can be handled - probably not for the 
    uninitiated, but that person did pull it off and went home for tea !! 


cEMacro Command Line Filters cA


    lslmbenchmrk(3f)le Benchmark MicroEmacs macro processor speed 
    lslmctags(3f)le Generate a C tags file 
    lslmdos2unix(3f)le Convert DOS format files to UNIX format files 
    lslmehftools(3f)le Generate a MicroEmacs help file 
    lslmemftags(3f)le Generate a MicroEmacs macro tags file 
    lslmgdiff(3f)le Command line graphical file difference 
    lslmjavatags(3f)le Generate a C tags file from Java sources 
    lslmntags(3f)le Generate a nroff tags file 
    lslmprintall(3f)le Formatted print job 
    lslmtcltags(3f)le Generate a Tcl/Tk tags file 
    lslmtextags(3f)le Generate a LaTeX/BibTeX tags file 


cEMacro Functions cA


    lslmshut-down(3)le Editor exit callback command 
    lslmstart-up(3)le Editor startup callback command 


cEMacro Variables cA

!   Searching and Replacing
cEcESEARCHING AND REPLACING cEcA


    Text searching and replacing commands: 

    lslmhunt-backward(2)le (cDC-x C-hcA) Resume previous search in backward direction 
    lslmhunt-forward(2)le (cDC-x hcA) Resume previous search in forward direction 
    lslmisearch-backward(2)le (cDC-rcA) Search backwards incrementally (interactive) 
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive) 
    lslmitem-list(3)le (cDF7cA) Abbreviated search and list buffer contents 
    lslmitem-list-close(3)le (cDesc F7cA) Close the item list 
    lslmitem-list-find(3)le Find the selected item in the item list 
    lslmline-scheme-search(3)le Search and annotate the current buffer 
    lslmoccur(3)le Regular expression search for occurrences 
    lslmquery-replace-all-string(3)le Query replace string in a list of files 
    lslmquery-replace-string(2)le (cDesc C-rcA) Search and replace a string - with query 
    lslmRegularExpressions(2)le Regular Expressions 
    lslmregex-backward(3)le Search for a magic string in the backward direction 
    lslmregex-forward(3)le Search for a magic string in the forward direction 
    lslmreplace-all-pairs(3)le Replace string pairs in a list of files 
    lslmreplace-all-string(3)le Replace string with new string in a list of files 
    lslmreplace-string(2)le (cDesc rcA) Replace string with new string 
    lslmsearch-backward(2)le (cDC-x rcA) Search for a string in the backward direction 
    lslmsearch-forward(2)le (cDC-x scA) Search for a string in the forward direction 

!   Comparison and Differencing
cEcEComparison and Differencing cEcA


    Commands that perform comparisons and differences:- 


cECommands cA


    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace 
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace 
    lslmdiff(3)le Difference files or directories 
    lslmdiff-changes(3)le Find the differences from a previous edit session 
    lslmgdiff(3)le Graphical file difference 


cEVariables cA


    lslm%diff-com(5)le Diff command line 
    lslm%gdiff-com(5)le Gdiff command line 

!   Hilighting, Color and Screen Appearance
cEcEHILIGHTING, COLOR AND SCREEN APPEARANCE cEcA


    Commands that change the hilighting, screen color and screen appearance: 


cECommands cA


    lslmadd-color(2)le Create a new color 
    lslmadd-color-scheme(2)le Create a new color scheme 
    lslmchange-font(2)le Change the screen font 
    lslmchange-screen-depth(2)le Change the number of lines on the screen 
    lslmchange-screen-width(2)le Change the number of columns on the screen 
    lslmhilight(2)le Manage the buffer hilighting schemes 
    lslmindent(2)le Manage the auto-indentation methods 
    lslmline-scheme-search(3)le Search and annotate the current buffer 
    lslmprint-color(2)le Create a new printer color 
    lslmprint-scheme(2)le Create a new printer color and font scheme 
    lslmrestyle-buffer(3)le Automatically reformat a buffer's indentation 
    lslmrestyle-region(3)le Automatically reformat a regions indentation 
    lslmscheme-editor(3)le Color Scheme Editor 
    lslmshow-region(2)le Show the current copy region 


cEVariables cA


    lslm$box-chars(5)le Characters used to draw lines 
    lslm$buffer-hilight(5)le Define current buffer hilighting scheme 
    lslm$buffer-scheme(5)le Buffer color scheme 
    lslm$cursor-blink(5)le Cursor blink rate 
    lslm$cursor-color(5)le Cursor foreground color 
    lslm$global-scheme(5)le Global buffer color scheme 
    lslm$line-scheme(5)le Set the current line color scheme 
    lslm$mode-line(5)le Mode line format 
    lslm$mode-line-scheme(5)le Mode line color scheme 
    lslm$mouse-pos(5)le Mouse position information 
    lslm$screen-depth(5)le Number of character lines on the screen canvas 
    lslm$screen-width(5)le Number of character columns on the screen canvas 
    lslm$scroll-bar(5)le Scroll bar configuration 
    lslm$scroll-bar-scheme(5)le Scroll bar color scheme 
    lslm$show-modes(5)le Select buffer modes to display 
    lslm$show-region(5)le Enable the hilighting of regions 
    lslm$system(5)le System configuration variable 
    lslm$trunc-scheme(5)le Truncation color scheme 
    lslm$window-chars(5)le Character set used to render the windows 

!   Keyboard Binding Commands
cEcEKEYBOARD BINDING COMMANDS cEcA


    Keyboard binding allows key strokes to be associated with commands and 
    macros such that when a bound key stroke sequence is recognized its 
    associated (or bound) command is invoked, thereby controlling the editor. 
    A set of lsBindings(2)lmDefault Bindingsle exist for MicroEmacs '02 which may be altered 
    using the binding commands. There are three types of key bindings: 

    cDGlobalcA 
        Associates a key-stroke with a command for all buffers. Used to 
        establish the standard keyboard controls i.e. cursor movement, search, 
        replace etc. 

    cDLocalcA 
        Associates a key-stroke with a command for a specified buffer only, 
        i.e. a binding local to the buffer. Local bindings allow macro 
        accelerators to be bound to keys without affecting other buffers 
        containing different types of data. Local bindings are used 
        extensively in the buffer hook commands. 

    cDMessage LinecA 
        Associates a key binding for use on the command line only, allowing 
        command completion to be diverted etc. 

    To bind a command to a key, the command and key names must be known, see 
    lslmCommand Glossaryle for a complete list of commands and lskeyNames(2)lmKey Namesle for a 
    complete list of key names. 

    The binding related commands are defined as follows: 


cECommands cA


    lslmbuffer-bind-key(2)le Create local key binding for current buffer 
    lslmbuffer-unbind-key(2)le Remove local key binding for current buffer 
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept 
    lslmdescribe-bindings(2)le (cDC-h bcA) Show current command/key binding 
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding 
    lslmglobal-bind-key(2)le (cDesc kcA) Bind a key to a named command or macro 
    lslmglobal-unbind-key(2)le (cDesc C-kcA) Unbind a key from a named command or macro 
    lslmiso-accents-expand(3)le Expand an ISO accent 
    lslmiso-accents-mode(3)le ISO accent expansion short-cut mode 
    lslmml-bind-key(2)le Create key binding for message line 
    lslmml-unbind-key(2)le Remove key binding from message line 
    lslmosd-bind-key(2)le Create key binding for OSD dialog 
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog 
    lslmset-char-mask(2)le Set character word mask 
    lslmtranslate-key(2)le Translate key 


cEVariables cA


cEAlt Key cA


    The cDAlt KeycA has special binding priorities defined as follows:- 

        * Direct key binding (e.g. cDA-bcA executes lsfile-browser(3)lmfile-browserle) 
        * Main menu hot key (e.g. cDA-fcA opens the File menu) 
        * Meta key binding (e.g. cDA-spacecA -> cDesc spacecA -> lsset-mark(2)lmset-markle) 

    If the cGALTcA key is to be used strictly as the Emacs Meta key then the 
    bindings for the menu should be over-ridden by cCDirect Key BindingscA from 
    the user configuration file i.e. to re-map the default MicroEmacs Alt key 
    to equivalent cGesccA keys then the following keys should be re-bound. 
emf-scheme

        global-bind-key forward-word "A-f"      ; Over-ride File menu binding 
        :                                       ; For all of the other menu items. 
        : 
        global-bind-key backward-word "A-b"     ; Over-ride the file browser. 
        global-bind-key replace-string "A-r"    ; Over-ride tools binding. 

ehf-scheme

    This creates a higher priority binding which overrides the underlying 
    default. The commands that are displaced would have to be re-bound to 
    different keys if required. 

!   Buffer Manipulation Commands
cEcEBUFFER MANIPULATION COMMANDS cEcA


    A buffer is where MicroEmacs '02 stores text. Normally text is read from a 
    file and is visible in an editing lsWindow Commandslmwindowle. The name, associated file and 
    operating modes of the buffer, are generally shown in the lsMode Linelmmode linele. 

    Commands that deal with buffers include: 


cECommands cA


    lslmbuffer-info(2)le (cDC-x =cA) Status information on current buffer position 
    lslmchange-buffer-name(2)le (cDesc C-ncA) Change name of current buffer 
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer 
    lslmdelete-buffer(2)le (cDC-x kcA) Delete a buffer 
    lslmdelete-some-buffers(2)le Delete buffers with query 
    lslmexecute-buffer(2)le Execute script lines from a buffer 
    lslmexecute-line(2)le Execute a typed in script line 
    lslmfind-buffer(2)le (cDC-x bcA) Switch to a named buffer 
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer 
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status 
    lslmnarrow-buffer(2)le Hide buffer lines 
    lslmnext-buffer(2)le (cDC-x xcA) Switch to the next buffer 
    lslmsave-all(3)le Save all modified files (with query) 
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with 
    query) 


cEVariables cA


    lslm$MEBACKUPPATH(5)le Backup file location 
    lslm$MEBACKUPSUB(5)le Backup file name modifier 
    lslm$buffer-backup(5)le Buffer backup file name 
    lslm$buffer-bname(5)le Name of the current buffer 
    lslm$buffer-fmod(5)le Buffer file modes (or attributes) 
    lslm$buffer-fname(5)le Name of the current buffer's file name 
    lslm$buffer-mask(5)le Current buffer word class mask 
    lslm$buffer-mode-line(5)le Buffer mode line string 
    lslm$buffer-names(5)le Filtered buffer name list 
    lslm$file-names(5)le Filtered file name list 
    lslm$global-fmod(5)le Global file modes (or attributes) 
    lslm$mode-line(5)le Mode line format 
    lslm$mode-line-scheme(5)le Mode line color scheme 
    lslm$show-modes(5)le Select buffer modes to display 

!   Capitalization and Transposition Commands
cEcECAPITALIZATION AND TRANSPOSITION COMMANDS cEcA


    Commands to change the capitalization and transposition of text: 

    lslmcapitalize-word(2)le (cDesc ccA) Capitalize word 
    lslmlower-case-region(2)le (cDC-x C-lcA) Lowercase a region (downcase) 
    lslmlower-case-word(2)le (cDesc lcA) Lowercase word (downcase) 
    lslmsort-lines(2)le Alphabetically sort lines 
    lslmsort-lines-ignore-case(3)le Alphabetically sort lines ignoring case 
    lslmtranspose-chars(2)le (cDC-tcA) Exchange (swap) adjacent characters 
    lslmtranspose-lines(2)le (cDC-x C-tcA) Exchange (swap) adjacent lines 
    lslmuniq(3)le Make lines in a sorted list unique 
    lslmupper-case-region(2)le (cDC-x C-ucA) Uppercase a region (upcase) 
    lslmupper-case-word(2)le (cDesc ucA) Uppercase word (upcase) 

!   File Handling Commands
cEcEFILE HANDLING COMMANDS cEcA


    Commands to read, write and interact with files: 


cECommands cA


    lslmappend-buffer(2)le Write contents of buffer to end of named file 
    lslmchange-directory(2)le [cDC-x C-dcA] Change the current working directory 
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer 
    lslmdirectory-tree(2)le Draw the file directory tree 
    lslmfile-attrib(3)le Set the current buffers system file attributes 
    lslmfile-browser(3)le (cDf10cA) Browse the file system 
    lslmfile-browser-close(3)le Close the file-browser 
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows 
    lslmfile-op(2)le File system operations command 
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data 
    lslmfind-cfile(3)le Load a crypted file 
    lslmfind-file(2)le (cDC-x C-fcA) Load a file 
    lslmfind-zfile(3)le Compressed file support 
    lslmftp(3)le Initiate an FTP connection 
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer 
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer 
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer 
    lslmreread-file(3)le Reload the current buffer's file 
    lslmsave-all(3)le Save all modified files (with query) 
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file 
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with 
    query) 
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key 
    lslmsuspend-emacs(2)le Suspend editor and place in background 
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only 
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file 
    lslmzfile-setup(3)le Compressed file support setup 


cEVariables cA


    lslm$auto-time(5)le Automatic buffer save time 
    lslm$file-ignore(5)le File extensions to ignore 
    lslm$home(5)le Users `home' directory location 
    lslm$kept-versions(5)le Number of backups to be kept 
    lslm$timestamp(5)le Time stamp string 
    lslm%ftp-flags(5)le Configure the FTP console 
    lslm%http-flags(5)le Configure the HTTP console 
    lslm%http-proxy-addr(5)le Set HTTP proxy server address 
    lslm%http-proxy-port(5)le Set HTTP proxy server port 
    lslmDialogs and Menusle 

!   Dialogs and Menus
cEcEDIALOGS AND MENUS cEcA


    Menus and dialogs in the system: 


cECommands cA


    lslmbuffer-help(3)le Displays help page for current buffer 
    lslmbuffer-setup(3)le Configures the current buffer settings 
    lslmdescribe-word(3)le Display a dictionary definition of a word 
    lslmfind-word(3)le Find a using spelling dictionaries 
    lslmgenerate-tags-file(3)le Generate a tags file 
    lslmline-scheme-search(3)le Search and annotate the current buffer 
    lslmMainMenu(3)le The top main menu 
    lslmorganizer(3)le Calendar and address organizer 
    lslmosd(2)le Manage the On-Screen Display 
    lslmosd-dialog(3)le OSD dialog box 
    lslmosd-entry(3)le OSD entry dialog box 
    lslmosd-xdialog(3)le OSD Extended dialog box 
    lslmprint-setup(3)le Configure (*mS's printer interface 
    lslmscheme-editor(3)le Color Scheme Editor 
    lslmspell-buffer(3)le Spell check the current buffer 
    lslmspell-edit-word(3)le Edits a spell word entry 
    lslmspell-word(3)le (cDesc $cA) Spell check a single word 
    lslmsymbol(3)le Insert an ASCII character 
    lslmuser-setup(3)le Configure MicroEmacs for a specific user 


cEVariables cA


    lslm$osd-scheme(5)le OSD color scheme 

!   Editor File Types
cEcEEDITOR FILE TYPES cEcA


    Different file types used by MicroEmacs '02: 

    lslmeaf(8)le MicroEmacs abbreviation file format 
    lslmedf(8)le MicroEmacs spelling dictionary file 
    lslmehf(8)le MicroEmacs help file 
    lslmemf(8)le MicroEmacs macro file 
    lslmerf(8)le MicroEmacs registry file 
    lslmetf(8)le MicroEmacs template file format 

!   Spelling Commands
cEcESPELLING COMMANDS cEcA


    Commands related to spelling: 


cECommands cA


    lslmadd-dictionary(2)le Declare existence of a spelling dictionary 
    lslmadd-spell-rule(2)le Add a new spelling rule to the dictionary 
    lslmauto-spell(3)le Auto-spell support 
    lslmauto-spell-buffer(3)le Auto-spell whole buffer 
    lslmauto-spell-reset(3)le Auto-spell hilight reset 
    lslmdelete-dictionary(2)le Remove a spelling dictionary from memory 
    lslmdescribe-word(3)le Display a dictionary definition of a word 
    lslmedit-dictionary(3)le Insert a dictionary in a buffer 
    lslmfind-word(3)le Find a using spelling dictionaries 
    lslmrestore-dictionary(3)le Save dictionary user changes 
    lslmsave-dictionary(2)le Save changed spelling dictionaries 
    lslmspell(2)le Spell checker service provider 
    lslmspell-add-word(3)le Add a word to the main dictionary 
    lslmspell-buffer(3)le Spell check the current buffer 
    lslmspell-complete-word(3)le Complete a word by invocation of the speller 
    lslmspell-edit-word(3)le Edits a spell word entry 
    lslmspell-word(3)le (cDesc $cA) Spell check a single word 


cEVariables cA


    lslm$find-words(5)le Filtered word list 

!   Macro Commands
cEcEMACRO COMMANDS cEcA


    Everyday macro commands used by the user. See lslmMacro Development Commandsle 
    for commands related to macro development. 


cECommands cA


    lslmend-kbd-macro(2)le (cDC-x )cA) Stop recording keyboard macro 
    lslmexecute-buffer(2)le Execute script lines from a buffer 
    lslmexecute-file(2)le (cDesc /cA) Execute script lines from a file 
    lslmexecute-kbd-macro(2)le (cDC-x ecA) Execute a keyboard macro 
    lslmexecute-line(2)le Execute a typed in script line 
    lslmexecute-named-command(2)le [cDesc xcA] Execute a named command 
    lslminsert-macro(2)le Insert keyboard macro into buffer 
    lslmkbd-macro-query(2)le (cDC-x qcA) Query termination of keyboard macro 
    lslmname-kbd-macro(2)le Assign a name to the last keyboard macro 
    lslmstart-kbd-macro(2)le (cDC-x (cA) Start recording keyboard macro 


cEVariables cA


    lslm$debug(5)le Macro debugging flag 

!   Macro Development Commands
cEcEMACRO DEVELOPMENT COMMANDS cEcA


    Commands used in macro development, and more specialized commands which 
    are only invoked from macros. Refer to lslmMacro Commandsle for keyboard macros 
    etc. 

    An additional set of commands for use with macros is outlined in the 
    lslmIntroduction to Variable Functionsle section. The lslmMacro Language Glossaryle 
    contains a full list of macro related commands and special variables. 


cECommands cA


    lslmadd-file-hook(2)le Declare file name context dependent configuration 
    lslmascii-time(3)le Return the current time as a string 
    lslmcommand-wait(2)le Conditional wait command 
    lslmcreate-callback(2)le Create a timer callback 
    lslmdefine-macro-file(2)le Define macro file location 
    lslmdirectory-tree(2)le Draw the file directory tree 
    lslmetfinsrt(3)le Insert template file into current buffer 
    lslmexecute-string(2)le Execute a string as a command 
    lslmfile-op(2)le File system operations command 
    lslmfileHooks(2)le File Hooks 
    lslmgoto-position(2)le Restore a stored position 
    lslmgoto-window(2)le Restore a saved window to the current window (historic) 
    lslmhilight(2)le Manage the buffer hilighting schemes 
    lslminsert-space(2)le Insert space(s) into current buffer 
    lslminsert-string(2)le Insert character string into current buffer 
    lslmlanguageTemplates(2)le File Language Templates 
    lslmlocaleSupport(2)le Locale Support 
    lslmnewline(2)le (cDreturncA) Insert a new line 
    lslmosd-dialog(3)le OSD dialog box 
    lslmosd-entry(3)le OSD entry dialog box 
    lslmosd-xdialog(3)le OSD Extended dialog box 
    lslmpopup-window(2)le Pop-up a window on the screen 
    lslmregex-backward(3)le Search for a magic string in the backward direction 
    lslmregex-forward(3)le Search for a magic string in the forward direction 
    lslmscreen-poke(2)le Immediate write string to the screen 
    lslmscreen-update(2)le (cDredrawcA) Force screen update 
    lslmset-cursor-to-mouse(2)le Move the cursor to the current mouse position 
    lslmset-position(2)le Store the current position 
    lslmset-scroll-with-mouse(2)le Scroll the window with the mouse 
    lslmset-variable(2)le (cDC-x vcA) Assign a new value to a variable 
    lslmset-window(2)le Save the current window for restore (historic) 
    lslmshow-cursor(2)le Change the visibility of the cursor 
    lslmshut-down(3)le Editor exit callback command 
    lslmspell(2)le Spell checker service provider 
    lslmstart-up(3)le Editor startup callback command 
    lslmunset-variable(2)le Delete a variable 
    lslmvoid(2)le Null command 


cEVariables cA


    lslm$MEBACKUPPATH(5)le Backup file location 
    lslm$MEBACKUPSUB(5)le Backup file name modifier 
    lslm$buffer-backup(5)le Buffer backup file name 
    lslm$buffer-bhook(5)le Buffer macro hook command name (buffer current) 
    lslm$buffer-dhook(5)le Buffer macro hook command name (buffer deletion) 
    lslm$buffer-ehook(5)le Buffer macro hook command name (buffer swapped) 
    lslm$buffer-fhook(5)le Buffer macro hook command name (buffer creation) 
    lslm$buffer-fmod(5)le Buffer file modes (or attributes) 
    lslm$buffer-indent(5)le Current buffer indentation scheme 
    lslm$buffer-input(5)le Divert buffer input through macro 
    lslm$buffer-ipipe(5)le Divert buffer incremental pipe input through macro 
    lslm$buffer-names(5)le Filtered buffer name list 
    lslm$command-names(5)le Filtered command name list 
    lslm$cursor-x(5)le Mouse X (horizontal) position 
    lslm$cursor-y(5)le Mouse Y (vertical) position 
    lslm$debug(5)le Macro debugging flag 
    lslm$file-names(5)le Filtered file name list 
    lslm$find-words(5)le Filtered word list 
    lslm$global-fmod(5)le Global file modes (or attributes) 
    lslm$mode-names(5)le Filtered mode name list 
    lslm$mouse(5)le Mouse configuration variable 
    lslm$mouse-x(5)le Mouse X (horizontal) position 
    lslm$mouse-y(5)le Mouse Y (vertical) position 
    lslm$platform(5)le MicroEmacs host platform identifier 
    lslm$progname(5)le Program file name 
    lslm$random(5)le Generate a random number 
    lslm$result(5)le Various command return values 
    lslm$status(5)le Macro command execution status 
    lslm$system(5)le System configuration variable 
    lslm$temp-name(5)le Temporary file name 
    lslm$variable-names(5)le Filtered variable name list 
    lslm$version(5)le MicroEmacs version date-code 
    lslm$window-mode-line(5)le Window mode line position 
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position 
    lslm.calc.result(5)le Last calc calculation result 

!   Help Information
cEcEHELP INFORMATION cEcA


    Commands to retrieve on-line help information and status. 

    lslmabout(2)le Information About MicroEmacs 
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept 
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding 
    lslmdescribe-variable(2)le (cDC-h vcA) Describe current setting of a variable 
    lslmhelp(2)le (cDesc ?cA) Help; high level introduction to help 
    lslmhelp-command(2)le (cDC-h C-ccA) Help; command information 
    lslmhelp-item(2)le (cDC-h C-icA) Help; item information 
    lslmhelp-variable(2)le (cDC-h C-vcA) Help; variable information 
    lslminfo(3)le Display a GNU Info database 
    lslminfo-goto-link(3)le Display Info on a given link 
    lslminfo-on(3)le Display Info on a given topic 
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status 
    lslmosd-help(3)le GUI based on-line help 

!   Operating Modes
cEcEOPERATING MODES cEcA


    cDModescA are switches (or states) that may be applied globally or on a per 
    buffer basis whose settings determine how MicroEmacs '02 operates. Modes 
    affect operations within a buffer, global modes determine the modes of 
    newly created buffers. 

    Commands to alter the operating state: 

        lslmadd-global-mode(3)le Set a global buffer mode 
        lslmadd-mode(3)le Set a local buffer mode 
        lslmbuffer-mode(2)le (cDC-x mcA) Change a local buffer mode 
        lslmdelete-global-mode(3)le Remove a global buffer mode 
        lslmdelete-mode(3)le Remove a local buffer mode 
        lslmglobal-mode(2)le (cDesc mcA) Change a global buffer mode 
        lslmnamed-buffer-mode(2)le Change a named buffer mode 
        lslmunmark-buffer(3)le Remove buffer edited flag 


cEModes cA


    The operating modes are defined as follows: 

        lslmauto(2m)le Automatic source file line type detection 
        lslmautosv(2m)le Automatic file save 
        lslmbackup(2m)le Automatic file backup of last edit 
        lslmbinary(2m)le Binary editor mode 
        lslmcmode(2m)le C Programming language mode 
        lslmcrlf(2m)le File's line feed style 
        lslmcrypt(2m)le Encrypted file mode 
        lslmctrlz(2m)le File's termination style 
        lslmdel(2m)le Flag buffer to be deleted 
        lslmdir(2m)le Buffer is a directory listing 
        lslmedit(2m)le Buffer has be changed 
        lslmexact(2m)le Searching and sorting case sensitivity 
        lslmfence(2m)le Auto fence matching mode 
        lslmhide(2m)le Hide buffer 
        lslmindent(2m)le Automatic indentation 
        lslmjustify(2m)le Justification Mode 
        lslmletter(2m)le Letter kill policy 
        lslmline(2m)le Line kill policy 
        lslmlock(2m)le Pipe cursor position lock 
        lslmmagic(2m)le Regular expression search 
        lslmnact(2m)le Buffer not active 
        lslmnarrow(2m)le Buffer contains a narrow 
        lslmover(2m)le Over-strike Mode 
        lslmpipe(2m)le Incremental Pipe running 
        lslmquiet(2m)le Quiet mode 
        lslmrbin(2m)le Reduced binary editor mode 
        lslmsave(2m)le Flag buffer to be saved 
        lslmtab(2m)le Tabulation mode 
        lslmtime(2m)le File time stamping 
        lslmundo(2m)le Retain edit modifications 
        lslmusr(2m)le User buffer modes 
        lslmview(2m)le Read only 
        lslmwrap(2m)le Line wrap entered text 


cEMode Line cA


    The buffer modes may be shown on the lsMode Linelmmode linele as single letter mnemonics 
    as follows:- 

        cDAcAuto, cDacAutosv, cDBcAackup, cDbcAinary, cDCcAmode, cDccArlf, crcDYcApt, ctrlcDzcA, cDdcAel, cDDcAir, 
        cDecAdit, cDEcAxact, cDHcAide, cDIcAndent, cDJcAustify, cDlcAetter, cDLcAine, loccDkcA, cDMcAagic, cDncAact, 
        cDNcAarrow, cDOcAver, cDPcAipe, cDQcAuiet, cDScAave, cDTcAab, cDtcAime, cDUcAndo, usrcD1cA, usrcD2cA, usrcD3cA, 
        usrcD4cA, usrcD5cA, usrcD6cA, usrcD7cA, usrcD8cA, cDVcAiew, cDWcArap. 

!   Shell and Command Controls
cEcESHELL AND COMMAND CONTROLS cEcA


    Operating system and external system call invocations: 


cECommands cA


    lslmadd-next-line(2)le Define the searching behavior of command output 
    lslmcompile(3)le Start a compilation process 
    lslmcvs(3)le MicroEmacs CVS interface 
    lslmcvs-add(3)le MicroEmacs CVS interface - add file 
    lslmcvs-checkout(3)le MicroEmacs CVS interface - checkout files 
    lslmcvs-commit(3)le MicroEmacs CVS interface - commit changes 
    lslmcvs-diff(3)le MicroEmacs CVS interface - diff changes 
    lslmcvs-gdiff(3)le MicroEmacs CVS interface - graphical diff changes 
    lslmcvs-log(3)le MicroEmacs CVS interface - log changes 
    lslmcvs-remove(3)le MicroEmacs CVS interface - remove file 
    lslmcvs-resolve-conflicts(3)le MicroEmacs CVS interface - resolve conflicts 
    lslmcvs-state(3)le MicroEmacs CVS interface - list state of directory files 
    lslmcvs-update(3)le MicroEmacs CVS interface - update directory files 
    lslmcygnus(3)le Open a Cygwin BASH window 
    lslmdbx(3)le UNIX Debugger 
    lslmdiff(3)le Difference files or directories 
    lslmdiff-changes(3)le Find the differences from a previous edit session 
    lslmexecute-tool(3)le Execute a user defined shell tool 
    lslmfilter-buffer(2)le (cDC-x #cA) Filter the current buffer through an O/S command 
    lslmgdb(3)le GNU Debugger 
    lslmgdiff(3)le Graphical file difference 
    lslmgenerate-tags-file(3)le Generate a tags file 
    lslmget-next-line(2)le (cDC-x `cA) Find the next command line 
    lslmgrep(3)le Execute grep command 
    lslmipipe-kill(2)le Kill a incremental pipe 
    lslmipipe-shell-command(2)le (cDesc \cA) Incremental pipe (non-suspending 
    system call) 
    lslmipipe-write(2)le Write a string to an incremental pipe 
    lslmishell(3)le Open a Cygwin BASH window 
    lslmitem-list(3)le (cDF7cA) Abbreviated search and list buffer contents 
    lslmitem-list-close(3)le (cDesc F7cA) Close the item list 
    lslmitem-list-find(3)le Find the selected item in the item list 
    lslmoccur(3)le Regular expression search for occurrences 
    lslmperldb(3)le Perl Debugger 
    lslmpipe-shell-command(2)le (cDesc @cA) Execute a single operating system command 
    lslmrcs-file(2)le (cDC-x C-qcA) Handle Revision Control System (RCS) files 
    lslmrgrep(3)le Execute recursive grep command 
    lslmshell(2)le [cDC-x ccA] Create a new command processor or shell 
    lslmshell-command(2)le Perform an operating system command 


cEVariables cA


    lslm$ME_ISHELL(5)le Windows ishell command.com 
    lslm$ME_PIPE_STDERR(5)le Command line diversion to stderr symbol 
    lslm$buffer-ipipe(5)le Divert buffer incremental pipe input through macro 
    lslm$file-template(5)le Regular expression file search string 
    lslm$line-template(5)le Command line regular expression search string 
    lslm$rcs-ci-com(5)le RCS (and SCCS) check in command 
    lslm$rcs-cif-com(5)le RCS (and SCCS) check in first command 
    lslm$rcs-co-com(5)le RCS (and SCCS) check out command 
    lslm$rcs-cou-com(5)le RCS (and SCCS) check out unlock command 
    lslm$rcs-file(5)le RCS (and SCCS) file name 
    lslm$rcs-ue-com(5)le RCS (and SCCS) unedit file command 
    lslm$result(5)le Various command return values 
    lslm%compile-com(5)le Default system compile command line 
    lslm%cygnus-bin-path(5)le Cygwin BASH directory 
    lslm%cygnus-hilight(5)le Cygwin shell hilight enable flag 
    lslm%cygnus-prompt(5)le Cygwin shell prompt 
    lslm%diff-com(5)le Diff command line 
    lslm%gdiff-com(5)le Gdiff command line 
    lslm%grep-com(5)le Grep command line 

!   Message Line Commands
cEcEMESSAGE LINE COMMANDS cEcA


    The message line appears at the bottom of the screen and is used for the 
    input of commands and also to receive errors and information (see also 
    lslmMode Linele). 

    Commands and variables that interact with the message line include: 


cECommands cA


    lslmml-bind-key(2)le Create key binding for message line 
    lslmml-clear(2)le Clear the message line 
    lslmml-unbind-key(2)le Remove key binding from message line 
    lslmml-write(2)le Write message on message line 
    lslmosd-bind-key(2)le Create key binding for OSD dialog 
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog 


cEVariables cA


    lslm$ml-scheme(5)le Message line color scheme 

!   Window Commands
cEcEWINDOW COMMANDS cEcA


    MicroEmacs '02 uses windows to display and allow you to edit the contents 
    of lsBuffer Manipulation Commandslmbuffersle. Multiple windows may be present on the lsHilighting, Color and Screen Appearancelmscreenle at once, each is 
    separated by a lsMode Linelmmode linele which describes the contents of the window above 
    it. 

    You can scroll text vertically and horizontally within a window by using 
    the lsCursor Movement Commandslmcursorle commands. Note that if a line of text extends beyond the 
    boundary of a window, a dollar "cD$cA" sign is displayed instead of the 
    first/last visible character. 

    Commands that operate on windows are defined as follows: 


cECommands cA


    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace 
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace 
    lslmdelete-other-windows(2)le (cDC-x 1cA) Delete other windows 
    lslmdelete-window(2)le (cDC-x 0cA) Delete current window 
    lslmgrow-window-horizontally(2)le Enlarge current window horizontally (relative) 
    lslmgrow-window-vertically(2)le (cDC-x zcA) Enlarge the current window (relative 
    change) 
    lslmnext-window(2)le (cDC-x ocA) Move the cursor to the next window 
    lslmnext-window-find-buffer(2)le [cDcA] Split the current window and show new buffer 
    lslmnext-window-find-file(2)le (cDC-x 4cA) Split the current window and find file 
    lslmprevious-window(2)le (cDC-x pcA) Move the cursor to the previous window 
    lslmresize-all-windows(2)le Resize all windows (automatic change) 
    lslmresize-window-horizontally(2)le Resize current window horizontally 
    (absolute) 
    lslmresize-window-vertically(2)le (cDC-x wcA) Resize the current window (absolute 
    change) 
    lslmscroll-down(2)le (cDC-ncA) Move the window down (scrolling) 
    lslmscroll-left(2)le (cDC-x <cA) Move the window left (scrolling) 
    lslmscroll-next-window-down(2)le (cDesc C-vcA) Scroll next window down 
    lslmscroll-next-window-up(2)le (cDesc C-zcA) Scroll next window up 
    lslmscroll-right(2)le (cDC-x >cA) Move the window right (scrolling) 
    lslmscroll-up(2)le (cDC-pcA) Move the window up (scrolling) 
    lslmshrink-window-horizontally(2)le Shrink current window horizontally 
    (relative) 
    lslmshrink-window-vertically(2)le (cDC-x C-zcA) Shrink the current window (relative 
    change) 
    lslmsplit-window-horizontally(2)le (cDC-x 5cA) Split current window into two 
    (horizontally) 
    lslmsplit-window-vertically(2)le (cDC-x 2cA) Split the current window into two 


cEVariables cA


    lslm$scroll(5)le Screen scroll control 
    lslm$scroll-bar(5)le Scroll bar configuration 
    lslm$window-acol(5)le Window cursor actual column 
    lslm$window-aline(5)le Window cursor actual line 
    lslm$window-col(5)le Window cursor column (no expansion) 
    lslm$window-depth(5)le Number of text lines in a window 
    lslm$window-line(5)le Window cursor line 
    lslm$window-mode-line(5)le Window mode line position 
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position 
    lslm$window-wcol(5)le Window cursor column (historic) 
    lslm$window-width(5)le Number of character columns in a window 
    lslm$window-wline(5)le Window cursor line (historic) 
    lslm$window-x-scroll(5)le Current window X scroll 
    lslm$window-xcl-scroll(5)le Current window current line X scroll 
    lslm$window-y-scroll(5)le Current window Y scroll 

!   Printing Commands
cEcEPRINTING COMMANDS cEcA


    Printing within MicroEmacs '02 is fairly restrictive, the following 
    commands are used in conjunction with the print facility. 

    lslmprint-buffer(2)le Print buffer, with formatting 
    lslmprint-color(2)le Create a new printer color 
    lslmprint-region(2)le Print region, with formatting 
    lslmprint-scheme(2)le Create a new printer color and font scheme 
    lslmprint-setup(3)le Configure (*mS's printer interface 

!   Introduction to Variable Functions
cEcEVARIABLE FUNCTIONS cEcA


    Functions can be used to manipulate variables in various ways. Functions 
    have in general one, two, or three arguments. These arguments will always 
    be placed after the function on the current command line. For example, if 
    we wanted to increase the current fill column by two, using MicroEmacs 
    '02's lslmset-variable(2)le (C-x v) command, we would write: 

        set-variable $fill-col &add $fill-col 2 
            \            \      \       \     \____second operand 
             \            \      \       \_________first operand 
              \            \      \________________function to execute 
               \            \______________________variable to set 
                \__________________________________set-variable (C-x v) command 


    Functions always begin with an ampersand (cD&cA) character, and are only 
    significant to the first 3 characters after the ampersand. Functions will 
    normally expect one of three types of arguments, and will automatically 
    convert types when needed. 

    cD<num>cA 
        An ASCII string of digits which is interpreted as a numeric value. Any 
        string which does not start with a digit or a minus sign (-) will be 
        considered zero. 

    cD<str>cA 
        An arbitrary string of characters. At the moment, strings are limited 
        to 128 characters in length. 

    cD<log>cA 
        A logical value consisting of a non-zero number for cDTRUEcA (e.g. "cG1cA"), 
        anything else is considered cDFALSEcA (e.g. "cG0cA" or "cGfoocA"). This differs 
        from earlier versions of MicroEmacs where the strings "cGTRUEcA" and 
        "cGFALSEcA" were used. 

    A list of the currently available functions follows: 

        cDNumeric FunctionscA (returns cC<num>cA) 

        lslm&abs(4)le Absolute value of a number 
        lslm&add(4)le Add two numbers 
        lslm&dec(4)le Pre-decrement variable 
        lslm&divide(4)le Division of two numbers 
        lslm&inc(4)le Pre-increment variable 
        lslm&mod(4)le Modulus of two numbers 
        lslm&multiply(4)le Multiply two numbers 
        lslm&negate(4)le Negation of two numbers 
        lslm&pdec(4)le Post-decrement variable 
        lslm&pinc(4)le Post-increment variable 
        lslm&sub(4)le Subtract two numbers 

        cDBitwise FunctionscA (returns cC<num>cA) 

        lslm&band(4)le Bitwise AND operator 
        lslm&bnot(4)le Bitwise NOT operator 
        lslm&bor(4)le Bitwise OR operator 
        lslm&bxor(4)le Bitwise XOR operator 

        cDString manipulation functionscA (returns cC<str>cA) 

        lslm&cat(4)le Concatenate two strings together 
        lslm&left(4)le Return the left most characters from a string 
        lslm&len(4)le Return the length of a string 
        lslm&mid(4)le Return a portion (middle) of a string 
        lslm&right(4)le Return the right most characters from a string 
        lslm&slower(4)le Return the string converted to lower case 
        lslm&sprintf(4)le Formatted string construction 
        lslm&supper(4)le Return the string converted to upper case 
        lslm&trboth(4)le Return string trimmed of white chars on both sides 
        lslm&trleft(4)le Return string trimmed of white chars on left side 
        lslm&trright(4)le Return string trimmed of white chars on right side 

        cDList manipulation functionscA (returns cC<str>cA) 

        lslm&ldel(4)le Delete list item 
        lslm&lfind(4)le Find list item 
        lslm&lget(4)le Get list item 
        lslm&linsert(4)le Insert list item 
        lslm&lset(4)le Set list item 

        cDLogical testing functionscA (returns cC<log>cA) 

        lslm&and(4)le Logical AND operator 
        lslm&equal(4)le Numerical equivalence operator 
        lslm&great(4)le Numerical greater than operator 
        lslm&isequal(4)le Case insensitive String equivalence operator 
        lslm&less(4)le Numerical less than operator 
        lslm&not(4)le Logical NOT operator 
        lslm&or(4)le Logical OR operator 
        lslm&sequal(4)le String equivalence operator 
        lslm&sgreat(4)le String greater than operator 
        lslm&sless(4)le String less than operator 
        lslm&xisequal(4)le Case insensitive regex String equivalence operator 
        lslm&xsequal(4)le Regex string equivalence operator 

        cDMiscellaneous functionscA 

        lslm&atoi(4)le ASCII to integer conversion 
        lslm&bmode(4)le Determine buffer mode 
        lslm&cbind(4)le Return the command a key is bound to 
        lslm&cond(4)le Conditional expression operator 
        lslm&exist(4)le Test if a variable or command exists 
        lslm&find(4)le Find a file on the search path 
        lslm&gmode(4)le Determine global mode 
        lslm&indirect(4)le Evaluate a string as a variable 
        lslm&inword(4)le Test for a word character 
        lslm&irep(4)le Case insensitive replace string in string 
        lslm&isin(4)le Case insensitive test for string in string 
        lslm&itoa(4)le Integer to ASCII conversion 
        lslm&kbind(4)le Return the key a command is bound to 
        lslm&nbind(4)le Return the numerial argument of a binding 
        lslm&nbmode(4)le Determine named buffer mode 
        lslm&rep(4)le Replace string in string 
        lslm&risin(4)le Recursive case insensitive test for string in string 
        lslm&rsin(4)le Recursively test for string in string 
        lslm&set(4)le In-line macro variable assignment 
        lslm&sin(4)le Test for string in string 
        lslm&stat(4)le Retrieve a file statistic 
        lslm&which(4)le Find a program on the path 
        lslm&xirep(4)le Regex case insensitive Replace string in string 
        lslm&xrep(4)le Regex replace string in string 


cEcESEE ALSO cEcA


    Directives 

!   Mode Line
cEcEMODE LINE cEcA


    The cDmodeLinecA is the line of text shown at the bottom of each lsWindow Commandslmwindowle 
    identifying the window being displayed. The mode line typically contains 
    the name of the lsBuffer Manipulation Commandslmbufferle, the file and operating mode associated with the 
    buffer displayed in the window. e.g. 

        #*-me (BEI) - 250 foo (foo.txt) ---------------- 


    cDNotecA that only a sub-set of the modes are visible on the mode line, this 
    reduces the cluttering of the mode line. Use the lslmabout(2)le command to 
    determine the exact modes that are active. 

    The text content and color of the mode line is fully configurable and may 
    be defined in the users start-up script. The currently active buffer is 
    generally indicated by the state of the mode line, e.g. highlighted color 
    (typically red) and/or double line separator characters cD===cA; conversely 
    inactive buffers are shown in a dull color with single line separator 
    characters cD---cA. 

    The mode line may be configured or interrogated using the following 
    variables:- 

    lslm$buffer-mode-line(5)le Buffer mode line string 
    lslm$mode-line(5)le Mode line format 
    lslm$mode-line-scheme(5)le Mode line color scheme 
    lslm$show-modes(5)le Select buffer modes to display 
    lslm$window-mode-line(5)le Window mode line position 
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position 

!   MicroEmacs Files
cEcEFILE HANDLING COMMANDS cEcA


    Commands to read, write and interact with files: 


cECommands cA


    lslmappend-buffer(2)le Write contents of buffer to end of named file 
    lslmchange-directory(2)le [cDC-x C-dcA] Change the current working directory 
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer 
    lslmdirectory-tree(2)le Draw the file directory tree 
    lslmfile-attrib(3)le Set the current buffers system file attributes 
    lslmfile-browser(3)le (cDf10cA) Browse the file system 
    lslmfile-browser-close(3)le Close the file-browser 
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows 
    lslmfile-op(2)le File system operations command 
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data 
    lslmfind-cfile(3)le Load a crypted file 
    lslmfind-file(2)le (cDC-x C-fcA) Load a file 
    lslmfind-zfile(3)le Compressed file support 
    lslmftp(3)le Initiate an FTP connection 
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer 
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer 
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer 
    lslmreread-file(3)le Reload the current buffer's file 
    lslmsave-all(3)le Save all modified files (with query) 
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file 
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with 
    query) 
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key 
    lslmsuspend-emacs(2)le Suspend editor and place in background 
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only 
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file 
    lslmzfile-setup(3)le Compressed file support setup 


cEVariables cA


    lslm$auto-time(5)le Automatic buffer save time 
    lslm$file-ignore(5)le File extensions to ignore 
    lslm$home(5)le Users `home' directory location 
    lslm$kept-versions(5)le Number of backups to be kept 
    lslm$timestamp(5)le Time stamp string 
    lslm%ftp-flags(5)le Configure the FTP console 
    lslm%http-flags(5)le Configure the HTTP console 
    lslm%http-proxy-addr(5)le Set HTTP proxy server address 
    lslm%http-proxy-port(5)le Set HTTP proxy server port 

!   MicroEmacs '02 - Games
cEcEGAMES cEcA


    The following is a list of all of the games provided by cDMicroEmacs '02cA: 

    lslmMahjongg(3)le MicroEmacs '02 version of the solitaire Mah Jongg game 
    lslmMatch-It(3)le MicroEmacs '02 version of the Match-It game 
    lslmMetris(3)le MicroEmacs '02 version of the falling blocks game 
    lslmPatience(3)le MicroEmacs '02 version of Patience (or Solitaire) 
    lslmTriangle(3)le MicroEmacs '02 version of Triangle patience game 

!   MicroEmacs '02 - Supported File Types
cEcESUPPORTED FILE TYPES cEcA


    The file types currently supported by MicroEmacs '02 are defined in the 
    following list. Other file types may be supported by definition of an 
    appropriate hook function to handle the file, see lslmfileHooks(2)le. 

    lslm0-9(9)le UNIX t/nroff file 
    lslmasm(9)le Assembler File 
    lslmasn.1(9)le ASN.1 file 
    lslmawk(9)le AWK File 
    lslmbas(9)le Visual Basic 
    lslmbat(9)le MS-DOS Batch File 
    lslmbnf(9)le Backus-Naur Form 
    lslmbtm(9)le 4-DOS Batch File 
    lslmc(9)le C programming language 
    lslmcbl(9)le Cobol (85) File 
    lslmcc(9)le C++ programming language 
    lslmcls(9)le Visual Basic 
    lslmcpp(9)le C++ programming language 
    lslmcsh(9)le C-Shell file 
    lslmdef(9)le C or C++ definition file 
    lslmdoc(9)le ASCII plain text document file 
    lslmehf(9)le MicroEmacs '02 help file 
    lslmemf(9)le MicroEmacs '02 Macro File 
    lslmerf(9)le MicroEmacs '02 registry file 
    lslmf(9)le Fortran File 
    lslmf77(9)le Fortran 77 File 
    lslmf90(9)le Fortran 90 File 
    lslmfvwm(9)le FVWM configuration file 
    lslmfvwmrc(9)le FVWM configuration file 
    lslmgawk(9)le GNU AWK File 
    lslmh(9)le C programming language header 
    lslmhpj(9)le MS-Windows Help Project File 
    lslmhtm(9)le HyperText Markup Language File 
    lslmhtml(9)le HyperText Markup Language File 
    lslmi(9)le C/C++ preprocessor outpuit file 
    lslmimakefile(9)le Make file 
    lslminfo(9)le GNU Info file 
    lslmini(9)le MS-Windows Initialization File 
    lslmjav(9)le Java programming language 
    lslmjava(9)le Java programming language 
    lslmksh(9)le Korn shell file 
    lslml(9)le LEX programming language 
    lslmlatex(9)le TeX Documentation 
    lslmlogin(9)le Shell user login file 
    lslmMetaFont(9)le MetaFont/MetaPost File 
    lslmm4(9)le M4 Macro Processor 
    lslmmakefile(9)le Make file 
    lslmman(9)le UNIX Manual Page 
    lslmmf(9)le MetaFont File 
    lslmmp(9)le MetaPost File 
    lslmnawk(9)le New AWK File 
    lslmnroff(9)le UNIX nroff file 
    lslmp(9)le Pascal File 
    lslmpas(9)le Pascal File 
    lslmperl(9)le Practical Extraction and Report Language File 
    lslmpl(9)le Practical Extraction and Report Language File 
    lslmpm(9)le Practical Extraction and Report Language File 
    lslmprofile(9)le Shell user profile 
    lslmpy(9)le Python Language File 
    lslmpython(9)le Python Language File 
    lslmrc(9)le Microsoft Developer resource file 
    lslmreg(9)le Registry file 
    lslmrgy(9)le Registry file 
    lslmrul(9)le Install Shield Rules 
    lslms(9)le Assembler File 
    lslmsch(9)le Scheme File 
    lslmscheme(9)le Scheme File 
    lslmscm(9)le Scheme File 
    lslmsh(9)le Bourne shell file 
    lslmso(9)le UNIX t/nroff include file 
    lslmsql(9)le SQL File 
    lslmtcl(9)le TCL programming language 
    lslmtcshrc(9)le T-Shell start up file 
    lslmtex(9)le TeX Documentation 
    lslmtexi(9)le GNU Texinfo documentation file 
    lslmtexinfo(9)le GNU Texinfo documentation file 
    lslmtk(9)le TK programming language 
    lslmtni(9)le UNIX t/nroff include file 
    lslmtroff(9)le UNIX troff file 
    lslmtxt(9)le ASCII plain text file 
    lslmvb(9)le Visual Basic 
    lslmvhdl(9)le VHDL hardware simulation File 
    lslmvrml(9)le VRML File 
    lslmwish(9)le TCL shell file 
    lslmx86(9)le Intel .x86 Assembler File 
    lslmy(9)le YACC programming language 
    lslmzsh(9)le Z-Shell file 

!   MicroEmacs '02 - Command Glossary
!9  Command Glossary - MicroEmacs '02
cEcECOMMAND GLOSSARY cEcA


    The following is a list of all of the commands (built-in and macro) 
    provided by cDMicroEmacs '02cA [See lsMicroEmacs '02 - Split Command Glossarylmsplit listingle]: 

    lslmabort-command(2)le (cDC-gcA) Abort command 
    lslmabout(2)le Information About MicroEmacs 
    lslmadd-color(2)le Create a new color 
    lslmadd-color-scheme(2)le Create a new color scheme 
    lslmadd-dictionary(2)le Declare existence of a spelling dictionary 
    lslmadd-file-hook(2)le Declare file name context dependent configuration 
    lslmadd-global-mode(3)le Set a global buffer mode 
    lslmadd-mode(3)le Set a local buffer mode 
    lslmadd-next-line(2)le Define the searching behavior of command output 
    lslmadd-spell-rule(2)le Add a new spelling rule to the dictionary 
    lslmalarm(3)le Set an alarm 
    lslmaman(3)le Compile an nroff file into a buffer (UNIX) 
    lslmappend-buffer(2)le Write contents of buffer to end of named file 
    lslmascii-time(3)le Return the current time as a string 
    lslmauto-spell(3)le Auto-spell support 
    lslmauto-spell-buffer(3)le Auto-spell whole buffer 
    lslmauto-spell-reset(3)le Auto-spell hilight reset 
    lslmbackward-char(2)le (cDC-bcA) Move the cursor left 
    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the 
    cursor position 
    lslmbackward-delete-tab(2)le (cDS-tabcA) Delete white space to previous tab-stop 
    lslmbackward-kill-word(2)le (cDesc backspacecA) Delete the previous word at the 
    cursor position 
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line 
    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph 
    lslmbackward-word(2)le (cDesc bcA) Move the cursor to the previous word 
    lslmbeginning-of-buffer(2)le (cDesc <cA) Move to beginning of buffer/file 
    lslmbeginning-of-line(2)le (cDC-acA) Move to beginning of line 
    lslmbuffer-abbrev-file(2)le Set buffers' abbreviation file 
    lslmbuffer-bind-key(2)le Create local key binding for current buffer 
    lslmbuffer-help(3)le Displays help page for current buffer 
    lslmbuffer-info(2)le (cDC-x =cA) Status information on current buffer position 
    lslmbuffer-mode(2)le (cDC-x mcA) Change a local buffer mode 
    lslmbuffer-setup(3)le Configures the current buffer settings 
    lslmbuffer-unbind-key(2)le Remove local key binding for current buffer 
    lslmc-hash-del(3)le Remove C/C++ #define evaluation 
    lslmc-hash-eval(3)le Evaluate C/C++ #defines 
    lslmc-hash-set-define(3)le Set a C/C++ #define 
    lslmc-hash-unset-define(3)le Unset a C/C++ #define 
    lslmcalc(3)le Integer calculator 
    lslmcapitalize-word(2)le (cDesc ccA) Capitalize word 
    lslmchange-buffer-name(2)le (cDesc C-ncA) Change name of current buffer 
    lslmchange-directory(2)le [cDC-x C-dcA] Change the current working directory 
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer 
    lslmchange-font(2)le Change the screen font 
    lslmchange-screen-depth(2)le Change the number of lines on the screen 
    lslmchange-screen-width(2)le Change the number of columns on the screen 
    lslmcharset-change(3)le Convert buffer between two character sets 
    lslmcharset-iso-to-user(3)le Convert buffer from ISO standard to user character 
    set 
    lslmcharset-user-to-iso(3)le Convert buffer from user to ISO standard character 
    set 
    lslmcheck-line-length(3)le Check the length of text lines are valid 
    lslmclean(3)le Remove redundant white spaces from the current buffer 
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept 
    lslmcommand-wait(2)le Conditional wait command 
    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace 
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace 
    lslmcompile(3)le Start a compilation process 
    lslmcopy-region(2)le (cDesc wcA) Copy a region of the buffer 
    lslmcount-words(2)le (cDesc C-ccA) Count the number of words in a region 
    lslmcreate-callback(2)le Create a timer callback 
    lslmcvs(3)le MicroEmacs CVS interface 
    lslmcvs-add(3)le MicroEmacs CVS interface - add file 
    lslmcvs-checkout(3)le MicroEmacs CVS interface - checkout files 
    lslmcvs-commit(3)le MicroEmacs CVS interface - commit changes 
    lslmcvs-diff(3)le MicroEmacs CVS interface - diff changes 
    lslmcvs-gdiff(3)le MicroEmacs CVS interface - graphical diff changes 
    lslmcvs-log(3)le MicroEmacs CVS interface - log changes 
    lslmcvs-remove(3)le MicroEmacs CVS interface - remove file 
    lslmcvs-resolve-conflicts(3)le MicroEmacs CVS interface - resolve conflicts 
    lslmcvs-state(3)le MicroEmacs CVS interface - list state of directory files 
    lslmcvs-update(3)le MicroEmacs CVS interface - update directory files 
    lslmcygnus(3)le Open a Cygwin BASH window 
    lslmdefine-help(2)le Define help information 
    lslmdefine-macro(2)le Define a new macro 
    lslmdefine-macro-file(2)le Define macro file location 
    lslmdelete-blank-lines(2)le (cDC-x C-ocA) Delete blank lines about cursor 
    lslmdelete-buffer(2)le (cDC-x kcA) Delete a buffer 
    lslmdelete-dictionary(2)le Remove a spelling dictionary from memory 
    lslmdelete-global-mode(3)le Remove a global buffer mode 
    lslmdelete-indentation(3)le Join 2 lines deleting white spaces 
    lslmdelete-mode(3)le Remove a local buffer mode 
    lslmdelete-other-windows(2)le (cDC-x 1cA) Delete other windows 
    lslmdelete-registry(2)le Delete a registry tree 
    lslmdelete-some-buffers(2)le Delete buffers with query 
    lslmdelete-window(2)le (cDC-x 0cA) Delete current window 
    lslmdescribe-bindings(2)le (cDC-h bcA) Show current command/key binding 
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding 
    lslmdescribe-variable(2)le (cDC-h vcA) Describe current setting of a variable 
    lslmdescribe-word(3)le Display a dictionary definition of a word 
    lslmdiff(3)le Difference files or directories 
    lslmdiff-changes(3)le Find the differences from a previous edit session 
    lslmdirectory-tree(2)le Draw the file directory tree 
    lslmdisplay-white-chars(3)le Toggle the displaying of white characters 
    lslmdraw(3)le Simple line drawing utility 
    lslmedit-dictionary(3)le Insert a dictionary in a buffer 
    lslmend-kbd-macro(2)le (cDC-x )cA) Stop recording keyboard macro 
    lslmend-of-buffer(2)le (cDesc >cA) Move to end of buffer/file 
    lslmend-of-line(2)le (cDC-ecA) Move to end of line 
    lslmetfinsrt(3)le Insert template file into current buffer 
    lslmexchange-point-and-mark(2)le (cDC-x C-xcA) Exchange the cursor and marked 
    position 
    lslmexecute-buffer(2)le Execute script lines from a buffer 
    lslmexecute-file(2)le (cDesc /cA) Execute script lines from a file 
    lslmexecute-kbd-macro(2)le (cDC-x ecA) Execute a keyboard macro 
    lslmexecute-line(2)le Execute a typed in script line 
    lslmexecute-named-command(2)le [cDesc xcA] Execute a named command 
    lslmexecute-string(2)le Execute a string as a command 
    lslmexecute-tool(3)le Execute a user defined shell tool 
    lslmexit-emacs(2)le Exit MicroEmacs 
    lslmexpand-abbrev(2)le Expand an abbreviation 
    lslmexpand-abbrev-handle(3)le (cDesc esccA) Expand an abbreviation handler 
    lslmfile-attrib(3)le Set the current buffers system file attributes 
    lslmfile-browser(3)le (cDf10cA) Browse the file system 
    lslmfile-browser-close(3)le Close the file-browser 
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows 
    lslmfile-op(2)le File system operations command 
    lslmfill-paragraph(2)le (cDesc ocA) Format a paragraph 
    lslmfilter-buffer(2)le (cDC-x #cA) Filter the current buffer through an O/S command 
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data 
    lslmfind-buffer(2)le (cDC-x bcA) Switch to a named buffer 
    lslmfind-cfile(3)le Load a crypted file 
    lslmfind-file(2)le (cDC-x C-fcA) Load a file 
    lslmfind-registry(2)le Index search of a registry sub-tree 
    lslmfind-tag(2)le (cDesc tcA) Find tag, auto-load file and move to tag position 
    lslmfind-word(3)le Find a using spelling dictionaries 
    lslmfind-zfile(3)le Compressed file support 
    lslmfold-all(3)le (cDf3cA) (Un)Fold all regions in the current buffer 
    lslmfold-current(3)le (cDf2cA) (un)Fold a region in the current buffer 
    lslmforward-char(2)le (cDC-fcA) Move the cursor right 
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor 
    position 
    lslmforward-kill-word(2)le (cDesc dcA) Delete the next word at the cursor position 
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line 
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph 
    lslmforward-word(2)le (cDesc fcA) Move the cursor to the next word 
    lslmftp(3)le Initiate an FTP connection 
    lslmgdiff(3)le Graphical file difference 
    lslmgenerate-tags-file(3)le Generate a tags file 
    lslmget-next-line(2)le (cDC-x `cA) Find the next command line 
    lslmget-registry(2)le Retrieve a node value from the registry 
    lslmglobal-abbrev-file(2)le Set global abbreviation file 
    lslmglobal-bind-key(2)le (cDesc kcA) Bind a key to a named command or macro 
    lslmglobal-mode(2)le (cDesc mcA) Change a global buffer mode 
    lslmglobal-unbind-key(2)le (cDesc C-kcA) Unbind a key from a named command or macro 
    lslmgoto-alpha-mark(2)le (cDC-x acA) Move the cursor to a alpha marked location 
    lslmgoto-line(2)le (cDesc gcA) Move the cursor to specified line 
    lslmgoto-matching-fence(2)le (cDesc C-fcA) Move the cursor to matching fence 
    lslmgoto-position(2)le Restore a stored position 
    lslmgoto-window(2)le Restore a saved window to the current window (historic) 
    lslmgrep(3)le Execute grep command 
    lslmgrow-window-horizontally(2)le Enlarge current window horizontally (relative) 
    lslmgrow-window-vertically(2)le (cDC-x zcA) Enlarge the current window (relative 
    change) 
    lslmhelp(2)le (cDesc ?cA) Help; high level introduction to help 
    lslmhelp-command(2)le (cDC-h C-ccA) Help; command information 
    lslmhelp-item(2)le (cDC-h C-icA) Help; item information 
    lslmhelp-variable(2)le (cDC-h C-vcA) Help; variable information 
    lslmhilight(2)le Manage the buffer hilighting schemes 
    lslmhunt-backward(2)le (cDC-x C-hcA) Resume previous search in backward direction 
    lslmhunt-forward(2)le (cDC-x hcA) Resume previous search in forward direction 
    lslmifill-paragraph(3)le (cDesc qcA) Format a paragraph 
    lslmindent(2)le Manage the auto-indentation methods 
    lslminfo(3)le Display a GNU Info database 
    lslminfo-goto-link(3)le Display Info on a given link 
    lslminfo-on(3)le Display Info on a given topic 
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer 
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer 
    lslminsert-macro(2)le Insert keyboard macro into buffer 
    lslminsert-newline(2)le (cDC-ocA) Insert new line at cursor position 
    lslminsert-space(2)le Insert space(s) into current buffer 
    lslminsert-string(2)le Insert character string into current buffer 
    lslminsert-tab(2)le (cDC-icA) Insert tab(s) into current buffer 
    lslmipipe-kill(2)le Kill a incremental pipe 
    lslmipipe-shell-command(2)le (cDesc \cA) Incremental pipe (non-suspending 
    system call) 
    lslmipipe-write(2)le Write a string to an incremental pipe 
    lslmisearch-backward(2)le (cDC-rcA) Search backwards incrementally (interactive) 
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive) 
    lslmishell(3)le Open a Cygwin BASH window 
    lslmkbd-macro-query(2)le (cDC-x qcA) Query termination of keyboard macro 
    lslmkill-line(2)le (cDC-kcA) Delete all characters to the end of the line 
    lslmkill-paragraph(2)le Delete a paragraph 
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text 
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region 
    lslmline-scheme-search(3)le Search and annotate the current buffer 
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status 
    lslmlist-commands(2)le (cDC-h ccA) List available commands 
    lslmlist-registry(2)le Display the registry in a buffer 
    lslmlist-variables(2)le (cDC-h vcA) List defined variables 
    lslmlower-case-region(2)le (cDC-x C-lcA) Lowercase a region (downcase) 
    lslmlower-case-word(2)le (cDesc lcA) Lowercase word (downcase) 
    lslmMahjongg(3)le MicroEmacs '02 version of the solitaire Mah Jongg game 
    lslmMainMenu(3)le The top main menu 
    lslmMatch-It(3)le MicroEmacs '02 version of the Match-It game 
    lslmMetris(3)le MicroEmacs '02 version of the falling blocks game 
    lslmmail(3)le Compose and send an email 
    lslmmail-check(3)le Check for new email 
    lslmman(3)le UNIX manual page viewer 
    lslmman-clean(3)le Clean UNIX manual page 
    lslmmark-registry(2)le Modify the operating mode of a registry node 
    lslmml-bind-key(2)le Create key binding for message line 
    lslmml-clear(2)le Clear the message line 
    lslmml-unbind-key(2)le Remove key binding from message line 
    lslmml-write(2)le Write message on message line 
    lslmname-kbd-macro(2)le Assign a name to the last keyboard macro 
    lslmnamed-buffer-mode(2)le Change a named buffer mode 
    lslmnarrow-buffer(2)le Hide buffer lines 
    lslmnewline(2)le (cDreturncA) Insert a new line 
    lslmnext-buffer(2)le (cDC-x xcA) Switch to the next buffer 
    lslmnext-window(2)le (cDC-x ocA) Move the cursor to the next window 
    lslmnext-window-find-buffer(2)le [cDcA] Split the current window and show new buffer 
    lslmnext-window-find-file(2)le (cDC-x 4cA) Split the current window and find file 
    lslmnormal-tab(3)le Insert a normal tab 
    lslmorganizer(3)le Calendar and address organizer 
    lslmosd(2)le Manage the On-Screen Display 
    lslmosd-bind-key(2)le Create key binding for OSD dialog 
    lslmosd-dialog(3)le OSD dialog box 
    lslmosd-entry(3)le OSD entry dialog box 
    lslmosd-help(3)le GUI based on-line help 
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog 
    lslmosd-xdialog(3)le OSD Extended dialog box 
    lslmPatience(3)le MicroEmacs '02 version of Patience (or Solitaire) 
    lslmparagraph-to-line(3)le Convert a paragraph to a single line 
    lslmpipe-shell-command(2)le (cDesc @cA) Execute a single operating system command 
    lslmpopup-window(2)le Pop-up a window on the screen 
    lslmprefix(2)le Key prefix command 
    lslmprevious-window(2)le (cDC-x pcA) Move the cursor to the previous window 
    lslmprint-buffer(2)le Print buffer, with formatting 
    lslmprint-color(2)le Create a new printer color 
    lslmprint-region(2)le Print region, with formatting 
    lslmprint-scheme(2)le Create a new printer color and font scheme 
    lslmprint-setup(3)le Configure (*mS's printer interface 
    lslmquery-replace-all-string(3)le Query replace string in a list of files 
    lslmquery-replace-string(2)le (cDesc C-rcA) Search and replace a string - with query 
    lslmquick-exit(2)le (cDesc zcA) Exit the editor writing changes 
    lslmquote-char(2)le (cDC-qcA) Insert literal character 
    lslmrcs-file(2)le (cDC-x C-qcA) Handle Revision Control System (RCS) files 
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer 
    lslmread-history(2)le Read in session history information 
    lslmread-registry(2)le Read in a registry definition file 
    lslmrecenter(2)le (cDC-lcA) Recenter the window (refresh the screen) 
    lslmregex-backward(3)le Search for a magic string in the backward direction 
    lslmregex-forward(3)le Search for a magic string in the forward direction 
    lslmreplace-all-pairs(3)le Replace string pairs in a list of files 
    lslmreplace-all-string(3)le Replace string with new string in a list of files 
    lslmreplace-string(2)le (cDesc rcA) Replace string with new string 
    lslmreread-file(3)le Reload the current buffer's file 
    lslmresize-all-windows(2)le Resize all windows (automatic change) 
    lslmresize-window-horizontally(2)le Resize current window horizontally 
    (absolute) 
    lslmresize-window-vertically(2)le (cDC-x wcA) Resize the current window (absolute 
    change) 
    lslmrestore-dictionary(3)le Save dictionary user changes 
    lslmrestyle-buffer(3)le Automatically reformat a buffer's indentation 
    lslmrestyle-region(3)le Automatically reformat a regions indentation 
    lslmreyank(2)le (cDesc ycA) Restore next yank buffer 
    lslmrgrep(3)le Execute recursive grep command 
    lslmsave-all(3)le Save all modified files (with query) 
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file 
    lslmsave-buffers-exit-emacs(2)le (cDesc zcA) Exit the editor prompt user to write 
    changes 
    lslmsave-dictionary(2)le Save changed spelling dictionaries 
    lslmsave-history(2)le Write history information to history file 
    lslmsave-registry(2)le Write a registry definition file 
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with 
    query) 
    lslmscheme-editor(3)le Color Scheme Editor 
    lslmscreen-poke(2)le Immediate write string to the screen 
    lslmscreen-update(2)le (cDredrawcA) Force screen update 
    lslmscroll-down(2)le (cDC-ncA) Move the window down (scrolling) 
    lslmscroll-left(2)le (cDC-x <cA) Move the window left (scrolling) 
    lslmscroll-next-window-down(2)le (cDesc C-vcA) Scroll next window down 
    lslmscroll-next-window-up(2)le (cDesc C-zcA) Scroll next window up 
    lslmscroll-right(2)le (cDC-x >cA) Move the window right (scrolling) 
    lslmscroll-up(2)le (cDC-pcA) Move the window up (scrolling) 
    lslmsearch-backward(2)le (cDC-x rcA) Search for a string in the backward direction 
    lslmsearch-forward(2)le (cDC-x scA) Search for a string in the forward direction 
    lslmset-alpha-mark(2)le (cDC-x C-acA) Place an alphabetic marker in the buffer 
    lslmset-char-mask(2)le Set character word mask 
    lslmset-cursor-to-mouse(2)le Move the cursor to the current mouse position 
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key 
    lslmset-mark(2)le (cDesc spacecA) Set starting point of region 
    lslmset-position(2)le Store the current position 
    lslmset-registry(2)le Modify a node value in the registry 
    lslmset-scroll-with-mouse(2)le Scroll the window with the mouse 
    lslmset-variable(2)le (cDC-x vcA) Assign a new value to a variable 
    lslmset-window(2)le Save the current window for restore (historic) 
    lslmshell(2)le [cDC-x ccA] Create a new command processor or shell 
    lslmshell-command(2)le Perform an operating system command 
    lslmshow-cursor(2)le Change the visibility of the cursor 
    lslmshow-region(2)le Show the current copy region 
    lslmshrink-window-horizontally(2)le Shrink current window horizontally 
    (relative) 
    lslmshrink-window-vertically(2)le (cDC-x C-zcA) Shrink the current window (relative 
    change) 
    lslmshut-down(3)le Editor exit callback command 
    lslmsort-lines(2)le Alphabetically sort lines 
    lslmsort-lines-ignore-case(3)le Alphabetically sort lines ignoring case 
    lslmspell(2)le Spell checker service provider 
    lslmspell-add-word(3)le Add a word to the main dictionary 
    lslmspell-buffer(3)le Spell check the current buffer 
    lslmspell-complete-word(3)le Complete a word by invocation of the speller 
    lslmspell-edit-word(3)le Edits a spell word entry 
    lslmspell-word(3)le (cDesc $cA) Spell check a single word 
    lslmsplit-window-horizontally(2)le (cDC-x 5cA) Split current window into two 
    (horizontally) 
    lslmsplit-window-vertically(2)le (cDC-x 2cA) Split the current window into two 
    lslmstart-kbd-macro(2)le (cDC-x (cA) Start recording keyboard macro 
    lslmstart-up(3)le Editor startup callback command 
    lslmstop-mail-check(3)le Disable the check for new email 
    lslmsuspend-emacs(2)le Suspend editor and place in background 
    lslmsymbol(3)le Insert an ASCII character 
    lslmTriangle(3)le MicroEmacs '02 version of Triangle patience game 
    lslmtab(2)le (cDtabcA) Handle the tab key 
    lslmtabs-to-spaces(3)le Converts all tabs to spaces 
    lslmtex2nr(3)le Convert a Latex file into nroff 
    lslmtime(3)le Command time evaluator 
    lslmtranslate-key(2)le Translate key 
    lslmtranspose-chars(2)le (cDC-tcA) Exchange (swap) adjacent characters 
    lslmtranspose-lines(2)le (cDC-x C-tcA) Exchange (swap) adjacent lines 
    lslmundo(2)le (cDC-x ucA) Undo the last edit 
    lslmuniq(3)le Make lines in a sorted list unique 
    lslmuniversal-argument(2)le (cDC-ucA) Set the command argument count 
    lslmunmark-buffer(3)le Remove buffer edited flag 
    lslmunset-variable(2)le Delete a variable 
    lslmupper-case-region(2)le (cDC-x C-ucA) Uppercase a region (upcase) 
    lslmupper-case-word(2)le (cDesc ucA) Uppercase word (upcase) 
    lslmuser-setup(3)le Configure MicroEmacs for a specific user 
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only 
    lslmvm(3)le Email viewer 
    lslmvoid(2)le Null command 
    lslmwhich(3)le Program finder 
    lslmwrap-word(2)le Wrap word onto next line 
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file 
    lslmyank(2)le (cDC-ycA) Paste (copy) kill buffer contents into buffer 
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text 
    lslmzfile-setup(3)le Compressed file support setup 

!   MicroEmacs '02 - Split Command Glossary
cEcESPLIT COMMAND GLOSSARY cEcA


    The following is a list of all of the built in commands provided by 
    cDMicroEmacs '02cA [See lsMicroEmacs '02 - Command Glossarylmmixed listingle]: 

    lslmabort-command(2)le (cDC-gcA) Abort command 
    lslmabout(2)le Information About MicroEmacs 
    lslmadd-color(2)le Create a new color 
    lslmadd-color-scheme(2)le Create a new color scheme 
    lslmadd-dictionary(2)le Declare existence of a spelling dictionary 
    lslmadd-file-hook(2)le Declare file name context dependent configuration 
    lslmadd-next-line(2)le Define the searching behavior of command output 
    lslmadd-spell-rule(2)le Add a new spelling rule to the dictionary 
    lslmappend-buffer(2)le Write contents of buffer to end of named file 
    lslmbackward-char(2)le (cDC-bcA) Move the cursor left 
    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the 
    cursor position 
    lslmbackward-delete-tab(2)le (cDS-tabcA) Delete white space to previous tab-stop 
    lslmbackward-kill-word(2)le (cDesc backspacecA) Delete the previous word at the 
    cursor position 
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line 
    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph 
    lslmbackward-word(2)le (cDesc bcA) Move the cursor to the previous word 
    lslmbeginning-of-buffer(2)le (cDesc <cA) Move to beginning of buffer/file 
    lslmbeginning-of-line(2)le (cDC-acA) Move to beginning of line 
    lslmbuffer-abbrev-file(2)le Set buffers' abbreviation file 
    lslmbuffer-bind-key(2)le Create local key binding for current buffer 
    lslmbuffer-info(2)le (cDC-x =cA) Status information on current buffer position 
    lslmbuffer-mode(2)le (cDC-x mcA) Change a local buffer mode 
    lslmbuffer-unbind-key(2)le Remove local key binding for current buffer 
    lslmcapitalize-word(2)le (cDesc ccA) Capitalize word 
    lslmchange-buffer-name(2)le (cDesc C-ncA) Change name of current buffer 
    lslmchange-directory(2)le [cDC-x C-dcA] Change the current working directory 
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer 
    lslmchange-font(2)le Change the screen font 
    lslmchange-screen-depth(2)le Change the number of lines on the screen 
    lslmchange-screen-width(2)le Change the number of columns on the screen 
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept 
    lslmcommand-wait(2)le Conditional wait command 
    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace 
    lslmcopy-region(2)le (cDesc wcA) Copy a region of the buffer 
    lslmcount-words(2)le (cDesc C-ccA) Count the number of words in a region 
    lslmcreate-callback(2)le Create a timer callback 
    lslmdefine-help(2)le Define help information 
    lslmdefine-macro(2)le Define a new macro 
    lslmdefine-macro-file(2)le Define macro file location 
    lslmdelete-blank-lines(2)le (cDC-x C-ocA) Delete blank lines about cursor 
    lslmdelete-buffer(2)le (cDC-x kcA) Delete a buffer 
    lslmdelete-dictionary(2)le Remove a spelling dictionary from memory 
    lslmdelete-other-windows(2)le (cDC-x 1cA) Delete other windows 
    lslmdelete-registry(2)le Delete a registry tree 
    lslmdelete-some-buffers(2)le Delete buffers with query 
    lslmdelete-window(2)le (cDC-x 0cA) Delete current window 
    lslmdescribe-bindings(2)le (cDC-h bcA) Show current command/key binding 
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding 
    lslmdescribe-variable(2)le (cDC-h vcA) Describe current setting of a variable 
    lslmdirectory-tree(2)le Draw the file directory tree 
    lslmend-kbd-macro(2)le (cDC-x )cA) Stop recording keyboard macro 
    lslmend-of-buffer(2)le (cDesc >cA) Move to end of buffer/file 
    lslmend-of-line(2)le (cDC-ecA) Move to end of line 
    lslmexchange-point-and-mark(2)le (cDC-x C-xcA) Exchange the cursor and marked 
    position 
    lslmexecute-buffer(2)le Execute script lines from a buffer 
    lslmexecute-file(2)le (cDesc /cA) Execute script lines from a file 
    lslmexecute-kbd-macro(2)le (cDC-x ecA) Execute a keyboard macro 
    lslmexecute-line(2)le Execute a typed in script line 
    lslmexecute-named-command(2)le [cDesc xcA] Execute a named command 
    lslmexecute-string(2)le Execute a string as a command 
    lslmexit-emacs(2)le Exit MicroEmacs 
    lslmexpand-abbrev(2)le Expand an abbreviation 
    lslmfile-op(2)le File system operations command 
    lslmfill-paragraph(2)le (cDesc ocA) Format a paragraph 
    lslmfilter-buffer(2)le (cDC-x #cA) Filter the current buffer through an O/S command 
    lslmfind-buffer(2)le (cDC-x bcA) Switch to a named buffer 
    lslmfind-file(2)le (cDC-x C-fcA) Load a file 
    lslmfind-registry(2)le Index search of a registry sub-tree 
    lslmfind-tag(2)le (cDesc tcA) Find tag, auto-load file and move to tag position 
    lslmforward-char(2)le (cDC-fcA) Move the cursor right 
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor 
    position 
    lslmforward-kill-word(2)le (cDesc dcA) Delete the next word at the cursor position 
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line 
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph 
    lslmforward-word(2)le (cDesc fcA) Move the cursor to the next word 
    lslmget-next-line(2)le (cDC-x `cA) Find the next command line 
    lslmget-registry(2)le Retrieve a node value from the registry 
    lslmglobal-abbrev-file(2)le Set global abbreviation file 
    lslmglobal-bind-key(2)le (cDesc kcA) Bind a key to a named command or macro 
    lslmglobal-mode(2)le (cDesc mcA) Change a global buffer mode 
    lslmglobal-unbind-key(2)le (cDesc C-kcA) Unbind a key from a named command or macro 
    lslmgoto-alpha-mark(2)le (cDC-x acA) Move the cursor to a alpha marked location 
    lslmgoto-line(2)le (cDesc gcA) Move the cursor to specified line 
    lslmgoto-matching-fence(2)le (cDesc C-fcA) Move the cursor to matching fence 
    lslmgoto-position(2)le Restore a stored position 
    lslmgoto-window(2)le Restore a saved window to the current window (historic) 
    lslmgrow-window-horizontally(2)le Enlarge current window horizontally (relative) 
    lslmgrow-window-vertically(2)le (cDC-x zcA) Enlarge the current window (relative 
    change) 
    lslmhelp(2)le (cDesc ?cA) Help; high level introduction to help 
    lslmhelp-command(2)le (cDC-h C-ccA) Help; command information 
    lslmhelp-item(2)le (cDC-h C-icA) Help; item information 
    lslmhelp-variable(2)le (cDC-h C-vcA) Help; variable information 
    lslmhilight(2)le Manage the buffer hilighting schemes 
    lslmhunt-backward(2)le (cDC-x C-hcA) Resume previous search in backward direction 
    lslmhunt-forward(2)le (cDC-x hcA) Resume previous search in forward direction 
    lslmindent(2)le Manage the auto-indentation methods 
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer 
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer 
    lslminsert-macro(2)le Insert keyboard macro into buffer 
    lslminsert-newline(2)le (cDC-ocA) Insert new line at cursor position 
    lslminsert-space(2)le Insert space(s) into current buffer 
    lslminsert-string(2)le Insert character string into current buffer 
    lslminsert-tab(2)le (cDC-icA) Insert tab(s) into current buffer 
    lslmipipe-kill(2)le Kill a incremental pipe 
    lslmipipe-shell-command(2)le (cDesc \cA) Incremental pipe (non-suspending 
    system call) 
    lslmipipe-write(2)le Write a string to an incremental pipe 
    lslmisearch-backward(2)le (cDC-rcA) Search backwards incrementally (interactive) 
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive) 
    lslmkbd-macro-query(2)le (cDC-x qcA) Query termination of keyboard macro 
    lslmkill-line(2)le (cDC-kcA) Delete all characters to the end of the line 
    lslmkill-paragraph(2)le Delete a paragraph 
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text 
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region 
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status 
    lslmlist-commands(2)le (cDC-h ccA) List available commands 
    lslmlist-registry(2)le Display the registry in a buffer 
    lslmlist-variables(2)le (cDC-h vcA) List defined variables 
    lslmlower-case-region(2)le (cDC-x C-lcA) Lowercase a region (downcase) 
    lslmlower-case-word(2)le (cDesc lcA) Lowercase word (downcase) 
    lslmmark-registry(2)le Modify the operating mode of a registry node 
    lslmml-bind-key(2)le Create key binding for message line 
    lslmml-clear(2)le Clear the message line 
    lslmml-unbind-key(2)le Remove key binding from message line 
    lslmml-write(2)le Write message on message line 
    lslmname-kbd-macro(2)le Assign a name to the last keyboard macro 
    lslmnamed-buffer-mode(2)le Change a named buffer mode 
    lslmnarrow-buffer(2)le Hide buffer lines 
    lslmnewline(2)le (cDreturncA) Insert a new line 
    lslmnext-buffer(2)le (cDC-x xcA) Switch to the next buffer 
    lslmnext-window(2)le (cDC-x ocA) Move the cursor to the next window 
    lslmnext-window-find-buffer(2)le [cDcA] Split the current window and show new buffer 
    lslmnext-window-find-file(2)le (cDC-x 4cA) Split the current window and find file 
    lslmosd(2)le Manage the On-Screen Display 
    lslmosd-bind-key(2)le Create key binding for OSD dialog 
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog 
    lslmpipe-shell-command(2)le (cDesc @cA) Execute a single operating system command 
    lslmpopup-window(2)le Pop-up a window on the screen 
    lslmprefix(2)le Key prefix command 
    lslmprevious-window(2)le (cDC-x pcA) Move the cursor to the previous window 
    lslmprint-buffer(2)le Print buffer, with formatting 
    lslmprint-color(2)le Create a new printer color 
    lslmprint-region(2)le Print region, with formatting 
    lslmprint-scheme(2)le Create a new printer color and font scheme 
    lslmquery-replace-string(2)le (cDesc C-rcA) Search and replace a string - with query 
    lslmquick-exit(2)le (cDesc zcA) Exit the editor writing changes 
    lslmquote-char(2)le (cDC-qcA) Insert literal character 
    lslmrcs-file(2)le (cDC-x C-qcA) Handle Revision Control System (RCS) files 
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer 
    lslmread-history(2)le Read in session history information 
    lslmread-registry(2)le Read in a registry definition file 
    lslmrecenter(2)le (cDC-lcA) Recenter the window (refresh the screen) 
    lslmreplace-string(2)le (cDesc rcA) Replace string with new string 
    lslmresize-all-windows(2)le Resize all windows (automatic change) 
    lslmresize-window-horizontally(2)le Resize current window horizontally 
    (absolute) 
    lslmresize-window-vertically(2)le (cDC-x wcA) Resize the current window (absolute 
    change) 
    lslmreyank(2)le (cDesc ycA) Restore next yank buffer 
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file 
    lslmsave-buffers-exit-emacs(2)le (cDesc zcA) Exit the editor prompt user to write 
    changes 
    lslmsave-dictionary(2)le Save changed spelling dictionaries 
    lslmsave-history(2)le Write history information to history file 
    lslmsave-registry(2)le Write a registry definition file 
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with 
    query) 
    lslmscreen-poke(2)le Immediate write string to the screen 
    lslmscreen-update(2)le (cDredrawcA) Force screen update 
    lslmscroll-down(2)le (cDC-ncA) Move the window down (scrolling) 
    lslmscroll-left(2)le (cDC-x <cA) Move the window left (scrolling) 
    lslmscroll-next-window-down(2)le (cDesc C-vcA) Scroll next window down 
    lslmscroll-next-window-up(2)le (cDesc C-zcA) Scroll next window up 
    lslmscroll-right(2)le (cDC-x >cA) Move the window right (scrolling) 
    lslmscroll-up(2)le (cDC-pcA) Move the window up (scrolling) 
    lslmsearch-backward(2)le (cDC-x rcA) Search for a string in the backward direction 
    lslmsearch-forward(2)le (cDC-x scA) Search for a string in the forward direction 
    lslmset-alpha-mark(2)le (cDC-x C-acA) Place an alphabetic marker in the buffer 
    lslmset-char-mask(2)le Set character word mask 
    lslmset-cursor-to-mouse(2)le Move the cursor to the current mouse position 
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key 
    lslmset-mark(2)le (cDesc spacecA) Set starting point of region 
    lslmset-position(2)le Store the current position 
    lslmset-registry(2)le Modify a node value in the registry 
    lslmset-scroll-with-mouse(2)le Scroll the window with the mouse 
    lslmset-variable(2)le (cDC-x vcA) Assign a new value to a variable 
    lslmset-window(2)le Save the current window for restore (historic) 
    lslmshell(2)le [cDC-x ccA] Create a new command processor or shell 
    lslmshell-command(2)le Perform an operating system command 
    lslmshow-cursor(2)le Change the visibility of the cursor 
    lslmshow-region(2)le Show the current copy region 
    lslmshrink-window-horizontally(2)le Shrink current window horizontally 
    (relative) 
    lslmshrink-window-vertically(2)le (cDC-x C-zcA) Shrink the current window (relative 
    change) 
    lslmsort-lines(2)le Alphabetically sort lines 
    lslmspell(2)le Spell checker service provider 
    lslmsplit-window-horizontally(2)le (cDC-x 5cA) Split current window into two 
    (horizontally) 
    lslmsplit-window-vertically(2)le (cDC-x 2cA) Split the current window into two 
    lslmstart-kbd-macro(2)le (cDC-x (cA) Start recording keyboard macro 
    lslmsuspend-emacs(2)le Suspend editor and place in background 
    lslmtab(2)le (cDtabcA) Handle the tab key 
    lslmtranslate-key(2)le Translate key 
    lslmtranspose-chars(2)le (cDC-tcA) Exchange (swap) adjacent characters 
    lslmtranspose-lines(2)le (cDC-x C-tcA) Exchange (swap) adjacent lines 
    lslmundo(2)le (cDC-x ucA) Undo the last edit 
    lslmuniversal-argument(2)le (cDC-ucA) Set the command argument count 
    lslmunset-variable(2)le Delete a variable 
    lslmupper-case-region(2)le (cDC-x C-ucA) Uppercase a region (upcase) 
    lslmupper-case-word(2)le (cDesc ucA) Uppercase word (upcase) 
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only 
    lslmvoid(2)le Null command 
    lslmwrap-word(2)le Wrap word onto next line 
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file 
    lslmyank(2)le (cDC-ycA) Paste (copy) kill buffer contents into buffer 
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text 

    The following is a list of documented macro commands provided by 
    cDMicroEmacs '02cA: 

    lslmadd-global-mode(3)le Set a global buffer mode 
    lslmadd-mode(3)le Set a local buffer mode 
    lslmalarm(3)le Set an alarm 
    lslmaman(3)le Compile an nroff file into a buffer (UNIX) 
    lslmascii-time(3)le Return the current time as a string 
    lslmauto-spell(3)le Auto-spell support 
    lslmauto-spell-buffer(3)le Auto-spell whole buffer 
    lslmauto-spell-reset(3)le Auto-spell hilight reset 
    lslmbuffer-help(3)le Displays help page for current buffer 
    lslmbuffer-setup(3)le Configures the current buffer settings 
    lslmc-hash-del(3)le Remove C/C++ #define evaluation 
    lslmc-hash-eval(3)le Evaluate C/C++ #defines 
    lslmc-hash-set-define(3)le Set a C/C++ #define 
    lslmc-hash-unset-define(3)le Unset a C/C++ #define 
    lslmcalc(3)le Integer calculator 
    lslmcharset-change(3)le Convert buffer between two character sets 
    lslmcharset-iso-to-user(3)le Convert buffer from ISO standard to user character 
    set 
    lslmcharset-user-to-iso(3)le Convert buffer from user to ISO standard character 
    set 
    lslmcheck-line-length(3)le Check the length of text lines are valid 
    lslmclean(3)le Remove redundant white spaces from the current buffer 
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace 
    lslmcompile(3)le Start a compilation process 
    lslmcvs(3)le MicroEmacs CVS interface 
    lslmcvs-add(3)le MicroEmacs CVS interface - add file 
    lslmcvs-checkout(3)le MicroEmacs CVS interface - checkout files 
    lslmcvs-commit(3)le MicroEmacs CVS interface - commit changes 
    lslmcvs-diff(3)le MicroEmacs CVS interface - diff changes 
    lslmcvs-gdiff(3)le MicroEmacs CVS interface - graphical diff changes 
    lslmcvs-log(3)le MicroEmacs CVS interface - log changes 
    lslmcvs-remove(3)le MicroEmacs CVS interface - remove file 
    lslmcvs-resolve-conflicts(3)le MicroEmacs CVS interface - resolve conflicts 
    lslmcvs-state(3)le MicroEmacs CVS interface - list state of directory files 
    lslmcvs-update(3)le MicroEmacs CVS interface - update directory files 
    lslmcygnus(3)le Open a Cygwin BASH window 
    lslmdelete-global-mode(3)le Remove a global buffer mode 
    lslmdelete-indentation(3)le Join 2 lines deleting white spaces 
    lslmdelete-mode(3)le Remove a local buffer mode 
    lslmdescribe-word(3)le Display a dictionary definition of a word 
    lslmdiff(3)le Difference files or directories 
    lslmdiff-changes(3)le Find the differences from a previous edit session 
    lslmdisplay-white-chars(3)le Toggle the displaying of white characters 
    lslmdraw(3)le Simple line drawing utility 
    lslmedit-dictionary(3)le Insert a dictionary in a buffer 
    lslmetfinsrt(3)le Insert template file into current buffer 
    lslmexecute-tool(3)le Execute a user defined shell tool 
    lslmexpand-abbrev-handle(3)le (cDesc esccA) Expand an abbreviation handler 
    lslmfile-attrib(3)le Set the current buffers system file attributes 
    lslmfile-browser(3)le (cDf10cA) Browse the file system 
    lslmfile-browser-close(3)le Close the file-browser 
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows 
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data 
    lslmfind-cfile(3)le Load a crypted file 
    lslmfind-word(3)le Find a using spelling dictionaries 
    lslmfind-zfile(3)le Compressed file support 
    lslmfold-all(3)le (cDf3cA) (Un)Fold all regions in the current buffer 
    lslmfold-current(3)le (cDf2cA) (un)Fold a region in the current buffer 
    lslmftp(3)le Initiate an FTP connection 
    lslmgdiff(3)le Graphical file difference 
    lslmgenerate-tags-file(3)le Generate a tags file 
    lslmgrep(3)le Execute grep command 
    lslmifill-paragraph(3)le (cDesc qcA) Format a paragraph 
    lslminfo(3)le Display a GNU Info database 
    lslminfo-goto-link(3)le Display Info on a given link 
    lslminfo-on(3)le Display Info on a given topic 
    lslmishell(3)le Open a Cygwin BASH window 
    lslmline-scheme-search(3)le Search and annotate the current buffer 
    lslmMahjongg(3)le MicroEmacs '02 version of the solitaire Mah Jongg game 
    lslmMainMenu(3)le The top main menu 
    lslmMatch-It(3)le MicroEmacs '02 version of the Match-It game 
    lslmMetris(3)le MicroEmacs '02 version of the falling blocks game 
    lslmmail(3)le Compose and send an email 
    lslmmail-check(3)le Check for new email 
    lslmman(3)le UNIX manual page viewer 
    lslmman-clean(3)le Clean UNIX manual page 
    lslmnormal-tab(3)le Insert a normal tab 
    lslmorganizer(3)le Calendar and address organizer 
    lslmosd-dialog(3)le OSD dialog box 
    lslmosd-entry(3)le OSD entry dialog box 
    lslmosd-help(3)le GUI based on-line help 
    lslmosd-xdialog(3)le OSD Extended dialog box 
    lslmPatience(3)le MicroEmacs '02 version of Patience (or Solitaire) 
    lslmparagraph-to-line(3)le Convert a paragraph to a single line 
    lslmprint-setup(3)le Configure (*mS's printer interface 
    lslmquery-replace-all-string(3)le Query replace string in a list of files 
    lslmregex-backward(3)le Search for a magic string in the backward direction 
    lslmregex-forward(3)le Search for a magic string in the forward direction 
    lslmreplace-all-pairs(3)le Replace string pairs in a list of files 
    lslmreplace-all-string(3)le Replace string with new string in a list of files 
    lslmreread-file(3)le Reload the current buffer's file 
    lslmrestore-dictionary(3)le Save dictionary user changes 
    lslmrestyle-buffer(3)le Automatically reformat a buffer's indentation 
    lslmrestyle-region(3)le Automatically reformat a regions indentation 
    lslmrgrep(3)le Execute recursive grep command 
    lslmsave-all(3)le Save all modified files (with query) 
    lslmscheme-editor(3)le Color Scheme Editor 
    lslmshut-down(3)le Editor exit callback command 
    lslmsort-lines-ignore-case(3)le Alphabetically sort lines ignoring case 
    lslmspell-add-word(3)le Add a word to the main dictionary 
    lslmspell-buffer(3)le Spell check the current buffer 
    lslmspell-complete-word(3)le Complete a word by invocation of the speller 
    lslmspell-edit-word(3)le Edits a spell word entry 
    lslmspell-word(3)le (cDesc $cA) Spell check a single word 
    lslmstart-up(3)le Editor startup callback command 
    lslmstop-mail-check(3)le Disable the check for new email 
    lslmsymbol(3)le Insert an ASCII character 
    lslmTriangle(3)le MicroEmacs '02 version of Triangle patience game 
    lslmtabs-to-spaces(3)le Converts all tabs to spaces 
    lslmtex2nr(3)le Convert a Latex file into nroff 
    lslmtime(3)le Command time evaluator 
    lslmuniq(3)le Make lines in a sorted list unique 
    lslmunmark-buffer(3)le Remove buffer edited flag 
    lslmuser-setup(3)le Configure MicroEmacs for a specific user 
    lslmvm(3)le Email viewer 
    lslmwhich(3)le Program finder 
    lslmzfile-setup(3)le Compressed file support setup 

!   MicroEmacs '02 - Variable Glossary
!9  Variable Glossary - MicroEmacs '02
cEcEVARIABLE GLOSSARY cEcA


    The following is an alphabetic list of cDMicroEmacs '02cA variables:- 

    lslm$INFOPATH(5)le GNU info files base directory 
    lslm$LOGNAME(5)le System user name (UNIX) 
    lslm$MEBACKUPPATH(5)le Backup file location 
    lslm$MEBACKUPSUB(5)le Backup file name modifier 
    lslm$MENAME(5)le MicroEmacs user name 
    lslm$MEPATH(5)le MicroEmacs search path 
    lslm$ME_ISHELL(5)le Windows ishell command.com 
    lslm$ME_PIPE_STDERR(5)le Command line diversion to stderr symbol 
    lslm$auto-time(5)le Automatic buffer save time 
    lslm$box-chars(5)le Characters used to draw lines 
    lslm$buffer-backup(5)le Buffer backup file name 
    lslm$buffer-bhook(5)le Buffer macro hook command name (buffer current) 
    lslm$buffer-bname(5)le Name of the current buffer 
    lslm$buffer-dhook(5)le Buffer macro hook command name (buffer deletion) 
    lslm$buffer-ehook(5)le Buffer macro hook command name (buffer swapped) 
    lslm$buffer-fhook(5)le Buffer macro hook command name (buffer creation) 
    lslm$buffer-fmod(5)le Buffer file modes (or attributes) 
    lslm$buffer-fname(5)le Name of the current buffer's file name 
    lslm$buffer-hilight(5)le Define current buffer hilighting scheme 
    lslm$buffer-indent(5)le Current buffer indentation scheme 
    lslm$buffer-input(5)le Divert buffer input through macro 
    lslm$buffer-ipipe(5)le Divert buffer incremental pipe input through macro 
    lslm$buffer-mask(5)le Current buffer word class mask 
    lslm$buffer-mode-line(5)le Buffer mode line string 
    lslm$buffer-names(5)le Filtered buffer name list 
    lslm$buffer-scheme(5)le Buffer color scheme 
    lslm$c-brace(5)le C-mode; brace indentation 
    lslm$c-case(5)le C-mode; case indentation 
    lslm$c-contcomm(5)le C-mode; comment continuation string 
    lslm$c-continue(5)le C-mode; line continuation indent 
    lslm$c-contmax(5)le C-mode; line continuation maximum indent 
    lslm$c-margin(5)le C-mode; trailing comment margin 
    lslm$c-statement(5)le C-mode; statement indentation 
    lslm$c-switch(5)le C-mode; switch indentation 
    lslm$command-names(5)le Filtered command name list 
    lslm$cursor-blink(5)le Cursor blink rate 
    lslm$cursor-color(5)le Cursor foreground color 
    lslm$cursor-x(5)le Mouse X (horizontal) position 
    lslm$cursor-y(5)le Mouse Y (vertical) position 
    lslm$debug(5)le Macro debugging flag 
    lslm$delay-time(5)le Mouse time event delay time 
    lslm$file-ignore(5)le File extensions to ignore 
    lslm$file-names(5)le Filtered file name list 
    lslm$file-template(5)le Regular expression file search string 
    lslm$fill-bullet(5)le Paragraph filling bullet character set 
    lslm$fill-bullet-len(5)le Paragraph filling bullet search depth 
    lslm$fill-col(5)le Paragraph Mode; right fill column 
    lslm$fill-eos(5)le Paragraph filling; end of sentence fill characters 
    lslm$fill-eos-len(5)le Paragraph filling; end of sentence padding length 
    lslm$fill-ignore(5)le Ignore paragraph filling character(s) 
    lslm$fill-mode(5)le Paragraph mode; justification method 
    lslm$find-words(5)le Filtered word list 
    lslm$fmatchdelay(5)le Fence matching delay time 
    lslm$global-fmod(5)le Global file modes (or attributes) 
    lslm$global-scheme(5)le Global buffer color scheme 
    lslm$home(5)le Users `home' directory location 
    lslm$idle-time(5)le System idle event delay time 
    lslm$kept-versions(5)le Number of backups to be kept 
    lslm$line-scheme(5)le Set the current line color scheme 
    lslm$line-template(5)le Command line regular expression search string 
    lslm$ml-scheme(5)le Message line color scheme 
    lslm$mode-line(5)le Mode line format 
    lslm$mode-line-scheme(5)le Mode line color scheme 
    lslm$mode-names(5)le Filtered mode name list 
    lslm$mouse(5)le Mouse configuration variable 
    lslm$mouse-pos(5)le Mouse position information 
    lslm$mouse-x(5)le Mouse X (horizontal) position 
    lslm$mouse-y(5)le Mouse Y (vertical) position 
    lslm$osd-scheme(5)le OSD color scheme 
    lslm$platform(5)le MicroEmacs host platform identifier 
    lslm$progname(5)le Program file name 
    lslm$random(5)le Generate a random number 
    lslm$rcs-ci-com(5)le RCS (and SCCS) check in command 
    lslm$rcs-cif-com(5)le RCS (and SCCS) check in first command 
    lslm$rcs-co-com(5)le RCS (and SCCS) check out command 
    lslm$rcs-cou-com(5)le RCS (and SCCS) check out unlock command 
    lslm$rcs-file(5)le RCS (and SCCS) file name 
    lslm$rcs-ue-com(5)le RCS (and SCCS) unedit file command 
    lslm$recent-keys(5)le Recent key history 
    lslm$repeat-time(5)le Mouse time event repeat time 
    lslm$result(5)le Various command return values 
    lslm$screen-depth(5)le Number of character lines on the screen canvas 
    lslm$screen-width(5)le Number of character columns on the screen canvas 
    lslm$scroll(5)le Screen scroll control 
    lslm$scroll-bar(5)le Scroll bar configuration 
    lslm$scroll-bar-scheme(5)le Scroll bar color scheme 
    lslm$search-path(5)le MicroEmacs search path 
    lslm$show-modes(5)le Select buffer modes to display 
    lslm$show-region(5)le Enable the hilighting of regions 
    lslm$status(5)le Macro command execution status 
    lslm$system(5)le System configuration variable 
    lslm$tabsize(5)le Tab character width 
    lslm$tabwidth(5)le Tab character interval 
    lslm$temp-name(5)le Temporary file name 
    lslm$time(5)le The current system time 
    lslm$timestamp(5)le Time stamp string 
    lslm$trunc-scheme(5)le Truncation color scheme 
    lslm$variable-names(5)le Filtered variable name list 
    lslm$version(5)le MicroEmacs version date-code 
    lslm$window-acol(5)le Window cursor actual column 
    lslm$window-aline(5)le Window cursor actual line 
    lslm$window-chars(5)le Character set used to render the windows 
    lslm$window-col(5)le Window cursor column (no expansion) 
    lslm$window-depth(5)le Number of text lines in a window 
    lslm$window-line(5)le Window cursor line 
    lslm$window-mode-line(5)le Window mode line position 
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position 
    lslm$window-wcol(5)le Window cursor column (historic) 
    lslm$window-width(5)le Number of character columns in a window 
    lslm$window-wline(5)le Window cursor line (historic) 
    lslm$window-x-scroll(5)le Current window X scroll 
    lslm$window-xcl-scroll(5)le Current window current line X scroll 
    lslm$window-y-scroll(5)le Current window Y scroll 
    lslm%compile-com(5)le Default system compile command line 
    lslm%cygnus-bin-path(5)le Cygwin BASH directory 
    lslm%cygnus-hilight(5)le Cygwin shell hilight enable flag 
    lslm%cygnus-prompt(5)le Cygwin shell prompt 
    lslm%diff-com(5)le Diff command line 
    lslm%ftp-flags(5)le Configure the FTP console 
    lslm%gdiff-com(5)le Gdiff command line 
    lslm%grep-com(5)le Grep command line 
    lslm%http-flags(5)le Configure the HTTP console 
    lslm%http-proxy-addr(5)le Set HTTP proxy server address 
    lslm%http-proxy-port(5)le Set HTTP proxy server port 
    lslm%tag-file(5)le Tag file name 
    lslm%tag-option(5)le Tag file search option 
    lslm%tag-template(5)le Tag file search string 
    lslm.calc.result(5)le Last calc calculation result 

!   MicroEmacs '02 - Macro Language Glossary
!9  Macro Language Glossary - MicroEmacs '02
cEcEMACRO LANGUAGE GLOSSARY cEcA


    The following is a list of all of the macro language commands available in 
    cDMicroEmacs '02cA. 


cEFunctions cA


    All functions are denoted by a cD&cA prefix as follows:- 

    lslm&abs(4)le Absolute value of a number 
    lslm&add(4)le Add two numbers 
    lslm&and(4)le Logical AND operator 
    lslm&atoi(4)le ASCII to integer conversion 
    lslm&band(4)le Bitwise AND operator 
    lslm&bmode(4)le Determine buffer mode 
    lslm&bnot(4)le Bitwise NOT operator 
    lslm&bor(4)le Bitwise OR operator 
    lslm&bxor(4)le Bitwise XOR operator 
    lslm&cat(4)le Concatenate two strings together 
    lslm&cbind(4)le Return the command a key is bound to 
    lslm&cond(4)le Conditional expression operator 
    lslm&dec(4)le Pre-decrement variable 
    lslm&divide(4)le Division of two numbers 
    lslm&equal(4)le Numerical equivalence operator 
    lslm&exist(4)le Test if a variable or command exists 
    lslm&find(4)le Find a file on the search path 
    lslm&gmode(4)le Determine global mode 
    lslm&great(4)le Numerical greater than operator 
    lslm&inc(4)le Pre-increment variable 
    lslm&indirect(4)le Evaluate a string as a variable 
    lslm&inword(4)le Test for a word character 
    lslm&irep(4)le Case insensitive replace string in string 
    lslm&isequal(4)le Case insensitive String equivalence operator 
    lslm&isin(4)le Case insensitive test for string in string 
    lslm&itoa(4)le Integer to ASCII conversion 
    lslm&kbind(4)le Return the key a command is bound to 
    lslm&ldel(4)le Delete list item 
    lslm&left(4)le Return the left most characters from a string 
    lslm&len(4)le Return the length of a string 
    lslm&less(4)le Numerical less than operator 
    lslm&lfind(4)le Find list item 
    lslm&lget(4)le Get list item 
    lslm&linsert(4)le Insert list item 
    lslm&lset(4)le Set list item 
    lslm&mid(4)le Return a portion (middle) of a string 
    lslm&mod(4)le Modulus of two numbers 
    lslm&multiply(4)le Multiply two numbers 
    lslm&nbind(4)le Return the numerial argument of a binding 
    lslm&nbmode(4)le Determine named buffer mode 
    lslm&negate(4)le Negation of two numbers 
    lslm&not(4)le Logical NOT operator 
    lslm&or(4)le Logical OR operator 
    lslm&pdec(4)le Post-decrement variable 
    lslm&pinc(4)le Post-increment variable 
    lslm&reg(4)le Retrieve a registry value (with default) 
    lslm&rep(4)le Replace string in string 
    lslm&right(4)le Return the right most characters from a string 
    lslm&risin(4)le Recursive case insensitive test for string in string 
    lslm&rsin(4)le Recursively test for string in string 
    lslm&sequal(4)le String equivalence operator 
    lslm&set(4)le In-line macro variable assignment 
    lslm&sgreat(4)le String greater than operator 
    lslm&sin(4)le Test for string in string 
    lslm&sless(4)le String less than operator 
    lslm&slower(4)le Return the string converted to lower case 
    lslm&sprintf(4)le Formatted string construction 
    lslm&stat(4)le Retrieve a file statistic 
    lslm&sub(4)le Subtract two numbers 
    lslm&supper(4)le Return the string converted to upper case 
    lslm&trboth(4)le Return string trimmed of white chars on both sides 
    lslm&trleft(4)le Return string trimmed of white chars on left side 
    lslm&trright(4)le Return string trimmed of white chars on right side 
    lslm&which(4)le Find a program on the path 
    lslm&xirep(4)le Regex case insensitive Replace string in string 
    lslm&xisequal(4)le Case insensitive regex String equivalence operator 
    lslm&xrep(4)le Regex replace string in string 
    lslm&xsequal(4)le Regex string equivalence operator 


cEDirectives cA


    The macro directives are denoted by a cD!cA prefix as follows:- 

    lslm!abort(4)le Exit macro with a FALSE status 
    lslm!bell(4)le Sound audio alarm 
    lslm!continue(4)le Restart a conditional loop 
    lslm!done(4)le End a conditional loop 
    lslm!ehelp(4)le Terminate a help definition 
    lslm!elif(4)le Conditional test statement, continuation 
    lslm!else(4)le Conditional alternative statement 
    lslm!emacro(4)le Terminate a macro definition 
    lslm!endif(4)le Conditional test termination 
    lslm!force(4)le Ignore command or macro status 
    lslm!goto(4)le Unconditional labeled jump 
    lslm!if(4)le Conditional test statement 
    lslm!jump(4)le Unconditional jump 
    lslm!nmacro(4)le Ignore command or macro status 
    lslm!repeat(4)le Conditional loop (post testing) 
    lslm!return(4)le Exit macro with a TRUE status 
    lslm!tgoto(4)le Conditional labeled jump 
    lslm!tjump(4)le Unconditional relative branch 
    lslm!until(4)le Test a conditional loop 
    lslm!while(4)le Conditional loop 


cEVariables cA


    The macro variables are denoted by a cD%cA for user variables; cD#cA for a 
    register variable and cD@cA for an interactive variable as follows:- 

    lslm@0(4)le Macro arguments (macro name) 
    lslm@1(4)le Macro arguments (first argument) 
    lslm@2(4)le Macro arguments (second argument) 
    lslm@?(4)le Macro arguments (numeric argument given) 
    lslm@cc(4)le Current command name 
    lslm@cck(4)le Current command key 
    lslm@cg(4)le Get a command name from the user 
    lslm@cgk(4)le Get a key from the user 
    lslm@cl(4)le Last command name 
    lslm@clk(4)le Last command key 
    lslm@cq(4)le Get a quoted command name from the user 
    lslm@cqk(4)le Get a quoted key from the user 
    lslm@fs(4)le Frame store variable 
    lslm@#(4)le Macro arguments (numeric argument value) 
    lslm@mc(4)le Message line character input request 
    lslm@ml(4)le Message line input request 
    lslm@mn(4)le Message line input as normal request 
    lslm@mna(4)le All input from Message line as normal 
    lslm@mx(4)le Message line input by executing command 
    lslm@mxa(4)le All input from Message line by executing command 
    lslm@p(4)le Macro arguments (calling macro name) 
    lslm@s0(4)le Last search's whole match string 
    lslm@s1(4)le Last search's first group value 
    lslm@s2(4)le Last search's second group value 
    lslm@wc(4)le Extract character from the current buffer 
    lslm@wl(4)le Extract a line from the current buffer 
    lslm@y(4)le Yank buffer variable 
    lslmBufferVariables(4)le Buffer variables 
    lslmCmdVariables(4)le Command variables 
    lslmCommandVariables(4)le Last, current and get a command key/name 
    lslmCurrentBufferVariables(4)le Extract information from the current buffer 
    lslmMacroArguments(4)le Arguments to macros 
    lslmMacroNumericArguments(4)le Numeric arguments to macros 
    lslmMessageLineVaraibles(4)le Prompt the user for input on message line 
    lslmRegisterVariables(4)le Register variables 
    lslmSearchGroups(4)le Last search group values 
    lslmVariables(4)le User defined macro variables 

!   MicroEmacs '02 - Global Glossary
!8  Global Glossary - MicroEmacs '02
cEcEGLOSSARY cEcA


    The following is a list of all keywords associated with cDMicroEmacs '02cA: 

    lslm!abort(4)le Exit macro with a FALSE status 
    lslm!bell(4)le Sound audio alarm 
    lslm!continue(4)le Restart a conditional loop 
    lslm!done(4)le End a conditional loop 
    lslm!ehelp(4)le Terminate a help definition 
    lslm!elif(4)le Conditional test statement, continuation 
    lslm!else(4)le Conditional alternative statement 
    lslm!emacro(4)le Terminate a macro definition 
    lslm!endif(4)le Conditional test termination 
    lslm!force(4)le Ignore command or macro status 
    lslm!goto(4)le Unconditional labeled jump 
    lslm!if(4)le Conditional test statement 
    lslm!jump(4)le Unconditional jump 
    lslm!nmacro(4)le Ignore command or macro status 
    lslm!repeat(4)le Conditional loop (post testing) 
    lslm!return(4)le Exit macro with a TRUE status 
    lslm!tgoto(4)le Conditional labeled jump 
    lslm!tjump(4)le Unconditional relative branch 
    lslm!until(4)le Test a conditional loop 
    lslm!while(4)le Conditional loop 
    lslm$INFOPATH(5)le GNU info files base directory 
    lslm$LOGNAME(5)le System user name (UNIX) 
    lslm$MEBACKUPPATH(5)le Backup file location 
    lslm$MEBACKUPSUB(5)le Backup file name modifier 
    lslm$MENAME(5)le MicroEmacs user name 
    lslm$MEPATH(5)le MicroEmacs search path 
    lslm$ME_ISHELL(5)le Windows ishell command.com 
    lslm$ME_PIPE_STDERR(5)le Command line diversion to stderr symbol 
    lslm$auto-time(5)le Automatic buffer save time 
    lslm$box-chars(5)le Characters used to draw lines 
    lslm$buffer-backup(5)le Buffer backup file name 
    lslm$buffer-bhook(5)le Buffer macro hook command name (buffer current) 
    lslm$buffer-bname(5)le Name of the current buffer 
    lslm$buffer-dhook(5)le Buffer macro hook command name (buffer deletion) 
    lslm$buffer-ehook(5)le Buffer macro hook command name (buffer swapped) 
    lslm$buffer-fhook(5)le Buffer macro hook command name (buffer creation) 
    lslm$buffer-fmod(5)le Buffer file modes (or attributes) 
    lslm$buffer-fname(5)le Name of the current buffer's file name 
    lslm$buffer-hilight(5)le Define current buffer hilighting scheme 
    lslm$buffer-indent(5)le Current buffer indentation scheme 
    lslm$buffer-input(5)le Divert buffer input through macro 
    lslm$buffer-ipipe(5)le Divert buffer incremental pipe input through macro 
    lslm$buffer-mask(5)le Current buffer word class mask 
    lslm$buffer-mode-line(5)le Buffer mode line string 
    lslm$buffer-names(5)le Filtered buffer name list 
    lslm$buffer-scheme(5)le Buffer color scheme 
    lslm$c-brace(5)le C-mode; brace indentation 
    lslm$c-case(5)le C-mode; case indentation 
    lslm$c-contcomm(5)le C-mode; comment continuation string 
    lslm$c-continue(5)le C-mode; line continuation indent 
    lslm$c-contmax(5)le C-mode; line continuation maximum indent 
    lslm$c-margin(5)le C-mode; trailing comment margin 
    lslm$c-statement(5)le C-mode; statement indentation 
    lslm$c-switch(5)le C-mode; switch indentation 
    lslm$command-names(5)le Filtered command name list 
    lslm$cursor-blink(5)le Cursor blink rate 
    lslm$cursor-color(5)le Cursor foreground color 
    lslm$cursor-x(5)le Mouse X (horizontal) position 
    lslm$cursor-y(5)le Mouse Y (vertical) position 
    lslm$debug(5)le Macro debugging flag 
    lslm$delay-time(5)le Mouse time event delay time 
    lslm$file-ignore(5)le File extensions to ignore 
    lslm$file-names(5)le Filtered file name list 
    lslm$file-template(5)le Regular expression file search string 
    lslm$fill-bullet(5)le Paragraph filling bullet character set 
    lslm$fill-bullet-len(5)le Paragraph filling bullet search depth 
    lslm$fill-col(5)le Paragraph Mode; right fill column 
    lslm$fill-eos(5)le Paragraph filling; end of sentence fill characters 
    lslm$fill-eos-len(5)le Paragraph filling; end of sentence padding length 
    lslm$fill-ignore(5)le Ignore paragraph filling character(s) 
    lslm$fill-mode(5)le Paragraph mode; justification method 
    lslm$find-words(5)le Filtered word list 
    lslm$fmatchdelay(5)le Fence matching delay time 
    lslm$global-fmod(5)le Global file modes (or attributes) 
    lslm$global-scheme(5)le Global buffer color scheme 
    lslm$home(5)le Users `home' directory location 
    lslm$idle-time(5)le System idle event delay time 
    lslm$kept-versions(5)le Number of backups to be kept 
    lslm$line-scheme(5)le Set the current line color scheme 
    lslm$line-template(5)le Command line regular expression search string 
    lslm$ml-scheme(5)le Message line color scheme 
    lslm$mode-line(5)le Mode line format 
    lslm$mode-line-scheme(5)le Mode line color scheme 
    lslm$mode-names(5)le Filtered mode name list 
    lslm$mouse(5)le Mouse configuration variable 
    lslm$mouse-pos(5)le Mouse position information 
    lslm$mouse-x(5)le Mouse X (horizontal) position 
    lslm$mouse-y(5)le Mouse Y (vertical) position 
    lslm$osd-scheme(5)le OSD color scheme 
    lslm$platform(5)le MicroEmacs host platform identifier 
    lslm$progname(5)le Program file name 
    lslm$random(5)le Generate a random number 
    lslm$rcs-ci-com(5)le RCS (and SCCS) check in command 
    lslm$rcs-cif-com(5)le RCS (and SCCS) check in first command 
    lslm$rcs-co-com(5)le RCS (and SCCS) check out command 
    lslm$rcs-cou-com(5)le RCS (and SCCS) check out unlock command 
    lslm$rcs-file(5)le RCS (and SCCS) file name 
    lslm$rcs-ue-com(5)le RCS (and SCCS) unedit file command 
    lslm$recent-keys(5)le Recent key history 
    lslm$repeat-time(5)le Mouse time event repeat time 
    lslm$result(5)le Various command return values 
    lslm$screen-depth(5)le Number of character lines on the screen canvas 
    lslm$screen-width(5)le Number of character columns on the screen canvas 
    lslm$scroll(5)le Screen scroll control 
    lslm$scroll-bar(5)le Scroll bar configuration 
    lslm$scroll-bar-scheme(5)le Scroll bar color scheme 
    lslm$search-path(5)le MicroEmacs search path 
    lslm$show-modes(5)le Select buffer modes to display 
    lslm$show-region(5)le Enable the hilighting of regions 
    lslm$status(5)le Macro command execution status 
    lslm$system(5)le System configuration variable 
    lslm$tabsize(5)le Tab character width 
    lslm$tabwidth(5)le Tab character interval 
    lslm$temp-name(5)le Temporary file name 
    lslm$time(5)le The current system time 
    lslm$timestamp(5)le Time stamp string 
    lslm$trunc-scheme(5)le Truncation color scheme 
    lslm$variable-names(5)le Filtered variable name list 
    lslm$version(5)le MicroEmacs version date-code 
    lslm$window-acol(5)le Window cursor actual column 
    lslm$window-aline(5)le Window cursor actual line 
    lslm$window-chars(5)le Character set used to render the windows 
    lslm$window-col(5)le Window cursor column (no expansion) 
    lslm$window-depth(5)le Number of text lines in a window 
    lslm$window-line(5)le Window cursor line 
    lslm$window-mode-line(5)le Window mode line position 
    lslm$window-scroll-bar(5)le Window scroll bar (or separator) position 
    lslm$window-wcol(5)le Window cursor column (historic) 
    lslm$window-width(5)le Number of character columns in a window 
    lslm$window-wline(5)le Window cursor line (historic) 
    lslm$window-x-scroll(5)le Current window X scroll 
    lslm$window-xcl-scroll(5)le Current window current line X scroll 
    lslm$window-y-scroll(5)le Current window Y scroll 
    lslm%compile-com(5)le Default system compile command line 
    lslm%cygnus-bin-path(5)le Cygwin BASH directory 
    lslm%cygnus-hilight(5)le Cygwin shell hilight enable flag 
    lslm%cygnus-prompt(5)le Cygwin shell prompt 
    lslm%diff-com(5)le Diff command line 
    lslm%ftp-flags(5)le Configure the FTP console 
    lslm%gdiff-com(5)le Gdiff command line 
    lslm%grep-com(5)le Grep command line 
    lslm%http-flags(5)le Configure the HTTP console 
    lslm%http-proxy-addr(5)le Set HTTP proxy server address 
    lslm%http-proxy-port(5)le Set HTTP proxy server port 
    lslm%tag-file(5)le Tag file name 
    lslm%tag-option(5)le Tag file search option 
    lslm%tag-template(5)le Tag file search string 
    lslm&abs(4)le Absolute value of a number 
    lslm&add(4)le Add two numbers 
    lslm&and(4)le Logical AND operator 
    lslm&atoi(4)le ASCII to integer conversion 
    lslm&band(4)le Bitwise AND operator 
    lslm&bmode(4)le Determine buffer mode 
    lslm&bnot(4)le Bitwise NOT operator 
    lslm&bor(4)le Bitwise OR operator 
    lslm&bxor(4)le Bitwise XOR operator 
    lslm&cat(4)le Concatenate two strings together 
    lslm&cbind(4)le Return the command a key is bound to 
    lslm&cond(4)le Conditional expression operator 
    lslm&dec(4)le Pre-decrement variable 
    lslm&divide(4)le Division of two numbers 
    lslm&equal(4)le Numerical equivalence operator 
    lslm&exist(4)le Test if a variable or command exists 
    lslm&find(4)le Find a file on the search path 
    lslm&gmode(4)le Determine global mode 
    lslm&great(4)le Numerical greater than operator 
    lslm&inc(4)le Pre-increment variable 
    lslm&indirect(4)le Evaluate a string as a variable 
    lslm&inword(4)le Test for a word character 
    lslm&irep(4)le Case insensitive replace string in string 
    lslm&isequal(4)le Case insensitive String equivalence operator 
    lslm&isin(4)le Case insensitive test for string in string 
    lslm&itoa(4)le Integer to ASCII conversion 
    lslm&kbind(4)le Return the key a command is bound to 
    lslm&ldel(4)le Delete list item 
    lslm&left(4)le Return the left most characters from a string 
    lslm&len(4)le Return the length of a string 
    lslm&less(4)le Numerical less than operator 
    lslm&lfind(4)le Find list item 
    lslm&lget(4)le Get list item 
    lslm&linsert(4)le Insert list item 
    lslm&lset(4)le Set list item 
    lslm&mid(4)le Return a portion (middle) of a string 
    lslm&mod(4)le Modulus of two numbers 
    lslm&multiply(4)le Multiply two numbers 
    lslm&nbind(4)le Return the numerial argument of a binding 
    lslm&nbmode(4)le Determine named buffer mode 
    lslm&negate(4)le Negation of two numbers 
    lslm&not(4)le Logical NOT operator 
    lslm&or(4)le Logical OR operator 
    lslm&pdec(4)le Post-decrement variable 
    lslm&pinc(4)le Post-increment variable 
    lslm&reg(4)le Retrieve a registry value (with default) 
    lslm&rep(4)le Replace string in string 
    lslm&right(4)le Return the right most characters from a string 
    lslm&risin(4)le Recursive case insensitive test for string in string 
    lslm&rsin(4)le Recursively test for string in string 
    lslm&sequal(4)le String equivalence operator 
    lslm&set(4)le In-line macro variable assignment 
    lslm&sgreat(4)le String greater than operator 
    lslm&sin(4)le Test for string in string 
    lslm&sless(4)le String less than operator 
    lslm&slower(4)le Return the string converted to lower case 
    lslm&sprintf(4)le Formatted string construction 
    lslm&stat(4)le Retrieve a file statistic 
    lslm&sub(4)le Subtract two numbers 
    lslm&supper(4)le Return the string converted to upper case 
    lslm&trboth(4)le Return string trimmed of white chars on both sides 
    lslm&trleft(4)le Return string trimmed of white chars on left side 
    lslm&trright(4)le Return string trimmed of white chars on right side 
    lslm&which(4)le Find a program on the path 
    lslm&xirep(4)le Regex case insensitive Replace string in string 
    lslm&xisequal(4)le Case insensitive regex String equivalence operator 
    lslm&xrep(4)le Regex replace string in string 
    lslm&xsequal(4)le Regex string equivalence operator 
    lslm.calc.result(5)le Last calc calculation result 
    lslm.which.result(5)le Program path 
    lslm0-9(9)le UNIX t/nroff file 
    lslm@0(4)le Macro arguments (macro name) 
    lslm@1(4)le Macro arguments (first argument) 
    lslm@2(4)le Macro arguments (second argument) 
    lslm@?(4)le Macro arguments (numeric argument given) 
    lslm@cc(4)le Current command name 
    lslm@cck(4)le Current command key 
    lslm@cg(4)le Get a command name from the user 
    lslm@cgk(4)le Get a key from the user 
    lslm@cl(4)le Last command name 
    lslm@clk(4)le Last command key 
    lslm@cq(4)le Get a quoted command name from the user 
    lslm@cqk(4)le Get a quoted key from the user 
    lslm@fs(4)le Frame store variable 
    lslm@#(4)le Macro arguments (numeric argument value) 
    lslm@mc(4)le Message line character input request 
    lslm@ml(4)le Message line input request 
    lslm@mn(4)le Message line input as normal request 
    lslm@mna(4)le All input from Message line as normal 
    lslm@mx(4)le Message line input by executing command 
    lslm@mxa(4)le All input from Message line by executing command 
    lslm@p(4)le Macro arguments (calling macro name) 
    lslm@s0(4)le Last search's whole match string 
    lslm@s1(4)le Last search's first group value 
    lslm@s2(4)le Last search's second group value 
    lslm@wc(4)le Extract character from the current buffer 
    lslm@wl(4)le Extract a line from the current buffer 
    lslm@y(4)le Yank buffer variable 
    lslmabort-command(2)le (cDC-gcA) Abort command 
    lslmabout(2)le Information About MicroEmacs 
    lslmadd-color(2)le Create a new color 
    lslmadd-color-scheme(2)le Create a new color scheme 
    lslmadd-dictionary(2)le Declare existence of a spelling dictionary 
    lslmadd-file-hook(2)le Declare file name context dependent configuration 
    lslmadd-global-mode(3)le Set a global buffer mode 
    lslmadd-mode(3)le Set a local buffer mode 
    lslmadd-next-line(2)le Define the searching behavior of command output 
    lslmadd-spell-rule(2)le Add a new spelling rule to the dictionary 
    lslmalarm(3)le Set an alarm 
    lslmaman(3)le Compile an nroff file into a buffer (UNIX) 
    lslmappend-buffer(2)le Write contents of buffer to end of named file 
    lslmascii-time(3)le Return the current time as a string 
    lslmasm(9)le Assembler File 
    lslmasn.1(9)le ASN.1 file 
    lslmauto(2m)le Automatic source file line type detection 
    lslmauto-spell(3)le Auto-spell support 
    lslmauto-spell-buffer(3)le Auto-spell whole buffer 
    lslmauto-spell-reset(3)le Auto-spell hilight reset 
    lslmautosv(2m)le Automatic file save 
    lslmawk(9)le AWK File 
    lslmBindings(2)le Default Key Bindings 
    lslmBufferVariables(4)le Buffer variables 
    lslmBuild(2)le Build 
    lslmbackup(2m)le Automatic file backup of last edit 
    lslmbackward-char(2)le (cDC-bcA) Move the cursor left 
    lslmbackward-delete-char(2)le (cDbackspacecA) Delete the previous character at the 
    cursor position 
    lslmbackward-delete-tab(2)le (cDS-tabcA) Delete white space to previous tab-stop 
    lslmbackward-kill-word(2)le (cDesc backspacecA) Delete the previous word at the 
    cursor position 
    lslmbackward-line(2)le (cDC-pcA) Move the cursor to the previous line 
    lslmbackward-paragraph(2)le (cDesc pcA) Move the cursor to the previous paragraph 
    lslmbackward-word(2)le (cDesc bcA) Move the cursor to the previous word 
    lslmbas(9)le Visual Basic 
    lslmbat(9)le MS-DOS Batch File 
    lslmbeginning-of-buffer(2)le (cDesc <cA) Move to beginning of buffer/file 
    lslmbeginning-of-line(2)le (cDC-acA) Move to beginning of line 
    lslmbenchmrk(3f)le Benchmark MicroEmacs macro processor speed 
    lslmbinary(2m)le Binary editor mode 
    lslmbnf(9)le Backus-Naur Form 
    lslmbtm(9)le 4-DOS Batch File 
    lslmbuffer-abbrev-file(2)le Set buffers' abbreviation file 
    lslmbuffer-bind-key(2)le Create local key binding for current buffer 
    lslmbuffer-help(3)le Displays help page for current buffer 
    lslmbuffer-info(2)le (cDC-x =cA) Status information on current buffer position 
    lslmbuffer-mode(2)le (cDC-x mcA) Change a local buffer mode 
    lslmbuffer-setup(3)le Configures the current buffer settings 
    lslmbuffer-unbind-key(2)le Remove local key binding for current buffer 
    lslmClient-Server(2)le Client-Server Model 
    lslmCmdVariables(4)le Command variables 
    lslmCommandVariables(4)le Last, current and get a command key/name 
    lslmCompanyProfiles(2)le Defining a company profile 
    lslmCompatibility(2)le Compatibility with the original MicroEmacs 
    lslmCurrentBufferVariables(4)le Extract information from the current buffer 
    lslmc(9)le C programming language 
    lslmc-hash-del(3)le Remove C/C++ #define evaluation 
    lslmc-hash-eval(3)le Evaluate C/C++ #defines 
    lslmc-hash-set-define(3)le Set a C/C++ #define 
    lslmc-hash-unset-define(3)le Unset a C/C++ #define 
    lslmcalc(3)le Integer calculator 
    lslmcapitalize-word(2)le (cDesc ccA) Capitalize word 
    lslmcbl(9)le Cobol (85) File 
    lslmcc(9)le C++ programming language 
    lslmchange-buffer-name(2)le (cDesc C-ncA) Change name of current buffer 
    lslmchange-directory(2)le [cDC-x C-dcA] Change the current working directory 
    lslmchange-file-name(2)le (cDC-x ncA) Change the file name of the current buffer 
    lslmchange-font(2)le Change the screen font 
    lslmchange-screen-depth(2)le Change the number of lines on the screen 
    lslmchange-screen-width(2)le Change the number of columns on the screen 
    lslmcharset-change(3)le Convert buffer between two character sets 
    lslmcharset-iso-to-user(3)le Convert buffer from ISO standard to user character 
    set 
    lslmcharset-user-to-iso(3)le Convert buffer from user to ISO standard character 
    set 
    lslmcheck-line-length(3)le Check the length of text lines are valid 
    lslmclean(3)le Remove redundant white spaces from the current buffer 
    lslmcls(9)le Visual Basic 
    lslmcmode(2m)le C Programming language mode 
    lslmcommand-apropos(2)le (cDC-h acA) List commands involving a concept 
    lslmcommand-wait(2)le Conditional wait command 
    lslmcompare-windows(2)le Compare buffer windows, ignore whitespace 
    lslmcompare-windows-exact(3)le Compare buffer windows, with whitespace 
    lslmcompile(3)le Start a compilation process 
    lslmcopy-region(2)le (cDesc wcA) Copy a region of the buffer 
    lslmcount-words(2)le (cDesc C-ccA) Count the number of words in a region 
    lslmcpp(9)le C++ programming language 
    lslmcreate-callback(2)le Create a timer callback 
    lslmcrlf(2m)le File's line feed style 
    lslmcrypt(2m)le Encrypted file mode 
    lslmcsh(9)le C-Shell file 
    lslmctags(3f)le Generate a C tags file 
    lslmctrlz(2m)le File's termination style 
    lslmcvs(3)le MicroEmacs CVS interface 
    lslmcvs-add(3)le MicroEmacs CVS interface - add file 
    lslmcvs-checkout(3)le MicroEmacs CVS interface - checkout files 
    lslmcvs-commit(3)le MicroEmacs CVS interface - commit changes 
    lslmcvs-diff(3)le MicroEmacs CVS interface - diff changes 
    lslmcvs-gdiff(3)le MicroEmacs CVS interface - graphical diff changes 
    lslmcvs-log(3)le MicroEmacs CVS interface - log changes 
    lslmcvs-remove(3)le MicroEmacs CVS interface - remove file 
    lslmcvs-resolve-conflicts(3)le MicroEmacs CVS interface - resolve conflicts 
    lslmcvs-state(3)le MicroEmacs CVS interface - list state of directory files 
    lslmcvs-update(3)le MicroEmacs CVS interface - update directory files 
    lslmcygnus(3)le Open a Cygwin BASH window 
    lslmdbx(3)le UNIX Debugger 
    lslmdef(9)le C or C++ definition file 
    lslmdefine-help(2)le Define help information 
    lslmdefine-macro(2)le Define a new macro 
    lslmdefine-macro-file(2)le Define macro file location 
    lslmdel(2m)le Flag buffer to be deleted 
    lslmdelete-blank-lines(2)le (cDC-x C-ocA) Delete blank lines about cursor 
    lslmdelete-buffer(2)le (cDC-x kcA) Delete a buffer 
    lslmdelete-dictionary(2)le Remove a spelling dictionary from memory 
    lslmdelete-global-mode(3)le Remove a global buffer mode 
    lslmdelete-indentation(3)le Join 2 lines deleting white spaces 
    lslmdelete-mode(3)le Remove a local buffer mode 
    lslmdelete-other-windows(2)le (cDC-x 1cA) Delete other windows 
    lslmdelete-registry(2)le Delete a registry tree 
    lslmdelete-some-buffers(2)le Delete buffers with query 
    lslmdelete-window(2)le (cDC-x 0cA) Delete current window 
    lslmdescribe-bindings(2)le (cDC-h bcA) Show current command/key binding 
    lslmdescribe-key(2)le (cDC-x ?cA) Report keyboard key name and binding 
    lslmdescribe-variable(2)le (cDC-h vcA) Describe current setting of a variable 
    lslmdescribe-word(3)le Display a dictionary definition of a word 
    lslmdiff(3)le Difference files or directories 
    lslmdiff-changes(3)le Find the differences from a previous edit session 
    lslmdir(2m)le Buffer is a directory listing 
    lslmdirectory-tree(2)le Draw the file directory tree 
    lslmdisplay-white-chars(3)le Toggle the displaying of white characters 
    lslmdoc(9)le ASCII plain text document file 
    lslmdos2unix(3f)le Convert DOS format files to UNIX format files 
    lslmdraw(3)le Simple line drawing utility 
    lslmeaf(8)le MicroEmacs abbreviation file format 
    lslmedf(8)le MicroEmacs spelling dictionary file 
    lslmedit(2m)le Buffer has be changed 
    lslmedit-dictionary(3)le Insert a dictionary in a buffer 
    lslmehf(8)le MicroEmacs help file 
    lslmehf(9)le MicroEmacs '02 help file 
    lslmehftools(3f)le Generate a MicroEmacs help file 
    lslmemf(8)le MicroEmacs macro file 
    lslmemf(9)le MicroEmacs '02 Macro File 
    lslmemftags(3f)le Generate a MicroEmacs macro tags file 
    lslmend-kbd-macro(2)le (cDC-x )cA) Stop recording keyboard macro 
    lslmend-of-buffer(2)le (cDesc >cA) Move to end of buffer/file 
    lslmend-of-line(2)le (cDC-ecA) Move to end of line 
    lslmerf(8)le MicroEmacs registry file 
    lslmerf(9)le MicroEmacs '02 registry file 
    lslmetf(8)le MicroEmacs template file format 
    lslmetfinsrt(3)le Insert template file into current buffer 
    lslmexact(2m)le Searching and sorting case sensitivity 
    lslmexchange-point-and-mark(2)le (cDC-x C-xcA) Exchange the cursor and marked 
    position 
    lslmexecute-buffer(2)le Execute script lines from a buffer 
    lslmexecute-file(2)le (cDesc /cA) Execute script lines from a file 
    lslmexecute-kbd-macro(2)le (cDC-x ecA) Execute a keyboard macro 
    lslmexecute-line(2)le Execute a typed in script line 
    lslmexecute-named-command(2)le [cDesc xcA] Execute a named command 
    lslmexecute-string(2)le Execute a string as a command 
    lslmexecute-tool(3)le Execute a user defined shell tool 
    lslmexit-emacs(2)le Exit MicroEmacs 
    lslmexpand-abbrev(2)le Expand an abbreviation 
    lslmexpand-abbrev-handle(3)le (cDesc esccA) Expand an abbreviation handler 
    lslmf(9)le Fortran File 
    lslmf77(9)le Fortran 77 File 
    lslmf90(9)le Fortran 90 File 
    lslmfence(2m)le Auto fence matching mode 
    lslmfile-attrib(3)le Set the current buffers system file attributes 
    lslmfile-browser(3)le (cDf10cA) Browse the file system 
    lslmfile-browser-close(3)le Close the file-browser 
    lslmfile-browser-swap-buffers(3)le Swap between file-browser windows 
    lslmfile-op(2)le File system operations command 
    lslmfileHooks(2)le File Hooks 
    lslmfill-paragraph(2)le (cDesc ocA) Format a paragraph 
    lslmfilter-buffer(2)le (cDC-x #cA) Filter the current buffer through an O/S command 
    lslmfind-bfile(3)le (cDC-x 9cA) Load a file as binary data 
    lslmfind-buffer(2)le (cDC-x bcA) Switch to a named buffer 
    lslmfind-cfile(3)le Load a crypted file 
    lslmfind-file(2)le (cDC-x C-fcA) Load a file 
    lslmfind-registry(2)le Index search of a registry sub-tree 
    lslmfind-tag(2)le (cDesc tcA) Find tag, auto-load file and move to tag position 
    lslmfind-word(3)le Find a using spelling dictionaries 
    lslmfind-zfile(3)le Compressed file support 
    lslmfold-all(3)le (cDf3cA) (Un)Fold all regions in the current buffer 
    lslmfold-current(3)le (cDf2cA) (un)Fold a region in the current buffer 
    lslmforward-char(2)le (cDC-fcA) Move the cursor right 
    lslmforward-delete-char(2)le (cDC-dcA) Delete the next character at the cursor 
    position 
    lslmforward-kill-word(2)le (cDesc dcA) Delete the next word at the cursor position 
    lslmforward-line(2)le (cDC-ncA) Move the cursor to the next line 
    lslmforward-paragraph(2)le (cDesc ncA) Move the cursor to the next paragraph 
    lslmforward-word(2)le (cDesc fcA) Move the cursor to the next word 
    lslmftp(3)le Initiate an FTP connection 
    lslmfvwm(9)le FVWM configuration file 
    lslmfvwmrc(9)le FVWM configuration file 
    lslmgawk(9)le GNU AWK File 
    lslmgdb(3)le GNU Debugger 
    lslmgdiff(3)le Graphical file difference 
    lslmgdiff(3f)le Command line graphical file difference 
    lslmgenerate-tags-file(3)le Generate a tags file 
    lslmget-next-line(2)le (cDC-x `cA) Find the next command line 
    lslmget-registry(2)le Retrieve a node value from the registry 
    lslmglobal-abbrev-file(2)le Set global abbreviation file 
    lslmglobal-bind-key(2)le (cDesc kcA) Bind a key to a named command or macro 
    lslmglobal-mode(2)le (cDesc mcA) Change a global buffer mode 
    lslmglobal-unbind-key(2)le (cDesc C-kcA) Unbind a key from a named command or macro 
    lslmgoto-alpha-mark(2)le (cDC-x acA) Move the cursor to a alpha marked location 
    lslmgoto-line(2)le (cDesc gcA) Move the cursor to specified line 
    lslmgoto-matching-fence(2)le (cDesc C-fcA) Move the cursor to matching fence 
    lslmgoto-position(2)le Restore a stored position 
    lslmgoto-window(2)le Restore a saved window to the current window (historic) 
    lslmgrep(3)le Execute grep command 
    lslmgrow-window-horizontally(2)le Enlarge current window horizontally (relative) 
    lslmgrow-window-vertically(2)le (cDC-x zcA) Enlarge the current window (relative 
    change) 
    lslmh(9)le C programming language header 
    lslmhelp(2)le (cDesc ?cA) Help; high level introduction to help 
    lslmhelp-command(2)le (cDC-h C-ccA) Help; command information 
    lslmhelp-item(2)le (cDC-h C-icA) Help; item information 
    lslmhelp-variable(2)le (cDC-h C-vcA) Help; variable information 
    lslmhide(2m)le Hide buffer 
    lslmhilight(2)le Manage the buffer hilighting schemes 
    lslmhpj(9)le MS-Windows Help Project File 
    lslmhtm(9)le HyperText Markup Language File 
    lslmhtml(9)le HyperText Markup Language File 
    lslmhunt-backward(2)le (cDC-x C-hcA) Resume previous search in backward direction 
    lslmhunt-forward(2)le (cDC-x hcA) Resume previous search in forward direction 
    lslmInstallation(1)le Installation details for MicroEmacs 
    lslmInterfacing(2)le Interfacing to external components 
    lslmi(9)le C/C++ preprocessor outpuit file 
    lslmifill-paragraph(3)le (cDesc qcA) Format a paragraph 
    lslmimakefile(9)le Make file 
    lslmindent(2)le Manage the auto-indentation methods 
    lslmindent(2m)le Automatic indentation 
    lslminfo(3)le Display a GNU Info database 
    lslminfo(9)le GNU Info file 
    lslminfo-goto-link(3)le Display Info on a given link 
    lslminfo-on(3)le Display Info on a given topic 
    lslmini(9)le MS-Windows Initialization File 
    lslminsert-file(2)le (cDC-x C-icA) Insert file into current buffer 
    lslminsert-file-name(2)le (cDC-x C-ycA) Insert filename into current buffer 
    lslminsert-macro(2)le Insert keyboard macro into buffer 
    lslminsert-newline(2)le (cDC-ocA) Insert new line at cursor position 
    lslminsert-space(2)le Insert space(s) into current buffer 
    lslminsert-string(2)le Insert character string into current buffer 
    lslminsert-tab(2)le (cDC-icA) Insert tab(s) into current buffer 
    lslmipipe-kill(2)le Kill a incremental pipe 
    lslmipipe-shell-command(2)le (cDesc \cA) Incremental pipe (non-suspending 
    system call) 
    lslmipipe-write(2)le Write a string to an incremental pipe 
    lslmisearch-backward(2)le (cDC-rcA) Search backwards incrementally (interactive) 
    lslmisearch-forward(2)le (cDC-scA) Search forward incrementally (interactive) 
    lslmishell(3)le Open a Cygwin BASH window 
    lslmiso-accents-expand(3)le Expand an ISO accent 
    lslmiso-accents-mode(3)le ISO accent expansion short-cut mode 
    lslmitem-list(3)le (cDF7cA) Abbreviated search and list buffer contents 
    lslmitem-list-close(3)le (cDesc F7cA) Close the item list 
    lslmitem-list-find(3)le Find the selected item in the item list 
    lslmjav(9)le Java programming language 
    lslmjava(9)le Java programming language 
    lslmjavatags(3f)le Generate a C tags file from Java sources 
    lslmjustify(2m)le Justification Mode 
    lslmkbd-macro-query(2)le (cDC-x qcA) Query termination of keyboard macro 
    lslmkeyNames(2)le Key Binding Names 
    lslmkill-line(2)le (cDC-kcA) Delete all characters to the end of the line 
    lslmkill-paragraph(2)le Delete a paragraph 
    lslmkill-rectangle(2)le (cDesc C-wcA) Delete a column of text 
    lslmkill-region(2)le (cDC-wcA) Delete all characters in the marked region 
    lslmksh(9)le Korn shell file 
    lslml(9)le LEX programming language 
    lslmlanguageTemplates(2)le File Language Templates 
    lslmlatex(9)le TeX Documentation 
    lslmletter(2m)le Letter kill policy 
    lslmline(2m)le Line kill policy 
    lslmline-scheme-search(3)le Search and annotate the current buffer 
    lslmlist-buffers(2)le (cDC-x C-bcA) List all buffers and show their status 
    lslmlist-commands(2)le (cDC-h ccA) List available commands 
    lslmlist-registry(2)le Display the registry in a buffer 
    lslmlist-variables(2)le (cDC-h vcA) List defined variables 
    lslmlocaleSupport(2)le Locale Support 
    lslmlock(2m)le Pipe cursor position lock 
    lslmlogin(9)le Shell user login file 
    lslmlower-case-region(2)le (cDC-x C-lcA) Lowercase a region (downcase) 
    lslmlower-case-word(2)le (cDesc lcA) Lowercase word (downcase) 
    lslmMacroArguments(4)le Arguments to macros 
    lslmMacroNumericArguments(4)le Numeric arguments to macros 
    lslmMahjongg(3)le MicroEmacs '02 version of the solitaire Mah Jongg game 
    lslmMainMenu(3)le The top main menu 
    lslmMatch-It(3)le MicroEmacs '02 version of the Match-It game 
    lslmMessageLineVaraibles(4)le Prompt the user for input on message line 
    lslmMetaFont(9)le MetaFont/MetaPost File 
    lslmMetris(3)le MicroEmacs '02 version of the falling blocks game 
    lslmm4(9)le M4 Macro Processor 
    lslmmagic(2m)le Regular expression search 
    lslmmail(3)le Compose and send an email 
    lslmmail-check(3)le Check for new email 
    lslmmakefile(9)le Make file 
    lslmman(3)le UNIX manual page viewer 
    lslmman(9)le UNIX Manual Page 
    lslmman-clean(3)le Clean UNIX manual page 
    lslmmark-registry(2)le Modify the operating mode of a registry node 
    lslmme(1)le MicroEmacs '02 text editor 
    lslmme32.ini(8)le Microsoft Window's Initialization (ini) File 
    lslmmemsdev(1)le Microsoft Developer Studio Add-in for MicroEmacs '02 
    lslmmf(9)le MetaFont File 
    lslmml-bind-key(2)le Create key binding for message line 
    lslmml-clear(2)le Clear the message line 
    lslmml-unbind-key(2)le Remove key binding from message line 
    lslmml-write(2)le Write message on message line 
    lslmmp(9)le MetaPost File 
    lslmnact(2m)le Buffer not active 
    lslmname-kbd-macro(2)le Assign a name to the last keyboard macro 
    lslmnamed-buffer-mode(2)le Change a named buffer mode 
    lslmnarrow(2m)le Buffer contains a narrow 
    lslmnarrow-buffer(2)le Hide buffer lines 
    lslmnawk(9)le New AWK File 
    lslmnewline(2)le (cDreturncA) Insert a new line 
    lslmnext-buffer(2)le (cDC-x xcA) Switch to the next buffer 
    lslmnext-window(2)le (cDC-x ocA) Move the cursor to the next window 
    lslmnext-window-find-buffer(2)le [cDcA] Split the current window and show new buffer 
    lslmnext-window-find-file(2)le (cDC-x 4cA) Split the current window and find file 
    lslmnormal-tab(3)le Insert a normal tab 
    lslmnroff(9)le UNIX nroff file 
    lslmntags(3f)le Generate a nroff tags file 
    lslmoccur(3)le Regular expression search for occurrences 
    lslmorganizer(3)le Calendar and address organizer 
    lslmosd(2)le Manage the On-Screen Display 
    lslmosd-bind-key(2)le Create key binding for OSD dialog 
    lslmosd-dialog(3)le OSD dialog box 
    lslmosd-entry(3)le OSD entry dialog box 
    lslmosd-help(3)le GUI based on-line help 
    lslmosd-unbind-key(2)le Remove key binding from OSD dialog 
    lslmosd-xdialog(3)le OSD Extended dialog box 
    lslmover(2m)le Over-strike Mode 
    lslmPatience(3)le MicroEmacs '02 version of Patience (or Solitaire) 
    lslmp(9)le Pascal File 
    lslmparagraph-to-line(3)le Convert a paragraph to a single line 
    lslmpas(9)le Pascal File 
    lslmperl(9)le Practical Extraction and Report Language File 
    lslmperldb(3)le Perl Debugger 
    lslmpipe(2m)le Incremental Pipe running 
    lslmpipe-shell-command(2)le (cDesc @cA) Execute a single operating system command 
    lslmpl(9)le Practical Extraction and Report Language File 
    lslmpm(9)le Practical Extraction and Report Language File 
    lslmpopup-window(2)le Pop-up a window on the screen 
    lslmprefix(2)le Key prefix command 
    lslmprevious-window(2)le (cDC-x pcA) Move the cursor to the previous window 
    lslmprint-buffer(2)le Print buffer, with formatting 
    lslmprint-color(2)le Create a new printer color 
    lslmprint-region(2)le Print region, with formatting 
    lslmprint-scheme(2)le Create a new printer color and font scheme 
    lslmprint-setup(3)le Configure (*mS's printer interface 
    lslmprintall(3f)le Formatted print job 
    lslmprofile(9)le Shell user profile 
    lslmpy(9)le Python Language File 
    lslmpython(9)le Python Language File 
    lslmquery-replace-all-string(3)le Query replace string in a list of files 
    lslmquery-replace-string(2)le (cDesc C-rcA) Search and replace a string - with query 
    lslmquick-exit(2)le (cDesc zcA) Exit the editor writing changes 
    lslmquiet(2m)le Quiet mode 
    lslmquote-char(2)le (cDC-qcA) Insert literal character 
    lslmRegisterVariables(4)le Register variables 
    lslmRegularExpressions(2)le Regular Expressions 
    lslmrbin(2m)le Reduced binary editor mode 
    lslmrc(9)le Microsoft Developer resource file 
    lslmrcs-file(2)le (cDC-x C-qcA) Handle Revision Control System (RCS) files 
    lslmread-file(2)le (cDC-x C-rcA) Find and load file replacing current buffer 
    lslmread-history(2)le Read in session history information 
    lslmread-registry(2)le Read in a registry definition file 
    lslmrecenter(2)le (cDC-lcA) Recenter the window (refresh the screen) 
    lslmreg(9)le Registry file 
    lslmregex-backward(3)le Search for a magic string in the backward direction 
    lslmregex-forward(3)le Search for a magic string in the forward direction 
    lslmreplace-all-pairs(3)le Replace string pairs in a list of files 
    lslmreplace-all-string(3)le Replace string with new string in a list of files 
    lslmreplace-string(2)le (cDesc rcA) Replace string with new string 
    lslmreread-file(3)le Reload the current buffer's file 
    lslmresize-all-windows(2)le Resize all windows (automatic change) 
    lslmresize-window-horizontally(2)le Resize current window horizontally 
    (absolute) 
    lslmresize-window-vertically(2)le (cDC-x wcA) Resize the current window (absolute 
    change) 
    lslmrestore-dictionary(3)le Save dictionary user changes 
    lslmrestyle-buffer(3)le Automatically reformat a buffer's indentation 
    lslmrestyle-region(3)le Automatically reformat a regions indentation 
    lslmreyank(2)le (cDesc ycA) Restore next yank buffer 
    lslmrgrep(3)le Execute recursive grep command 
    lslmrgy(9)le Registry file 
    lslmrul(9)le Install Shield Rules 
    lslmSearchGroups(4)le Last search group values 
    lslms(9)le Assembler File 
    lslmsave(2m)le Flag buffer to be saved 
    lslmsave-all(3)le Save all modified files (with query) 
    lslmsave-buffer(2)le (cDC-x C-scA) Save contents of changed buffer to file 
    lslmsave-buffers-exit-emacs(2)le (cDesc zcA) Exit the editor prompt user to write 
    changes 
    lslmsave-dictionary(2)le Save changed spelling dictionaries 
    lslmsave-history(2)le Write history information to history file 
    lslmsave-registry(2)le Write a registry definition file 
    lslmsave-some-buffers(2)le Save contents of all changed buffers to file (with 
    query) 
    lslmsch(9)le Scheme File 
    lslmscheme(9)le Scheme File 
    lslmscheme-editor(3)le Color Scheme Editor 
    lslmscm(9)le Scheme File 
    lslmscreen-poke(2)le Immediate write string to the screen 
    lslmscreen-update(2)le (cDredrawcA) Force screen update 
    lslmscroll-down(2)le (cDC-ncA) Move the window down (scrolling) 
    lslmscroll-left(2)le (cDC-x <cA) Move the window left (scrolling) 
    lslmscroll-next-window-down(2)le (cDesc C-vcA) Scroll next window down 
    lslmscroll-next-window-up(2)le (cDesc C-zcA) Scroll next window up 
    lslmscroll-right(2)le (cDC-x >cA) Move the window right (scrolling) 
    lslmscroll-up(2)le (cDC-pcA) Move the window up (scrolling) 
    lslmsearch-backward(2)le (cDC-x rcA) Search for a string in the backward direction 
    lslmsearch-forward(2)le (cDC-x scA) Search for a string in the forward direction 
    lslmset-alpha-mark(2)le (cDC-x C-acA) Place an alphabetic marker in the buffer 
    lslmset-char-mask(2)le Set character word mask 
    lslmset-cursor-to-mouse(2)le Move the cursor to the current mouse position 
    lslmset-encryption-key(2)le (cDesc ecA) Define the encryption key 
    lslmset-mark(2)le (cDesc spacecA) Set starting point of region 
    lslmset-position(2)le Store the current position 
    lslmset-registry(2)le Modify a node value in the registry 
    lslmset-scroll-with-mouse(2)le Scroll the window with the mouse 
    lslmset-variable(2)le (cDC-x vcA) Assign a new value to a variable 
    lslmset-window(2)le Save the current window for restore (historic) 
    lslmsh(9)le Bourne shell file 
    lslmshell(2)le [cDC-x ccA] Create a new command processor or shell 
    lslmshell-command(2)le Perform an operating system command 
    lslmshow-cursor(2)le Change the visibility of the cursor 
    lslmshow-region(2)le Show the current copy region 
    lslmshrink-window-horizontally(2)le Shrink current window horizontally 
    (relative) 
    lslmshrink-window-vertically(2)le (cDC-x C-zcA) Shrink the current window (relative 
    change) 
    lslmshut-down(3)le Editor exit callback command 
    lslmso(9)le UNIX t/nroff include file 
    lslmsort-lines(2)le Alphabetically sort lines 
    lslmsort-lines-ignore-case(3)le Alphabetically sort lines ignoring case 
    lslmspell(2)le Spell checker service provider 
    lslmspell-add-word(3)le Add a word to the main dictionary 
    lslmspell-buffer(3)le Spell check the current buffer 
    lslmspell-complete-word(3)le Complete a word by invocation of the speller 
    lslmspell-edit-word(3)le Edits a spell word entry 
    lslmspell-word(3)le (cDesc $cA) Spell check a single word 
    lslmsplit-window-horizontally(2)le (cDC-x 5cA) Split current window into two 
    (horizontally) 
    lslmsplit-window-vertically(2)le (cDC-x 2cA) Split the current window into two 
    lslmsql(9)le SQL File 
    lslmstart-kbd-macro(2)le (cDC-x (cA) Start recording keyboard macro 
    lslmstart-up(3)le Editor startup callback command 
    lslmstop-mail-check(3)le Disable the check for new email 
    lslmsuspend-emacs(2)le Suspend editor and place in background 
    lslmsymbol(3)le Insert an ASCII character 
    lslmTriangle(3)le MicroEmacs '02 version of Triangle patience game 
    lslmtab(2)le (cDtabcA) Handle the tab key 
    lslmtab(2m)le Tabulation mode 
    lslmtabs-to-spaces(3)le Converts all tabs to spaces 
    lslmtcl(9)le TCL programming language 
    lslmtcltags(3f)le Generate a Tcl/Tk tags file 
    lslmtcshrc(9)le T-Shell start up file 
    lslmtex(9)le TeX Documentation 
    lslmtex2nr(3)le Convert a Latex file into nroff 
    lslmtexi(9)le GNU Texinfo documentation file 
    lslmtexinfo(9)le GNU Texinfo documentation file 
    lslmtextags(3f)le Generate a LaTeX/BibTeX tags file 
    lslmtime(2m)le File time stamping 
    lslmtime(3)le Command time evaluator 
    lslmtk(9)le TK programming language 
    lslmtni(9)le UNIX t/nroff include file 
    lslmtranslate-key(2)le Translate key 
    lslmtranspose-chars(2)le (cDC-tcA) Exchange (swap) adjacent characters 
    lslmtranspose-lines(2)le (cDC-x C-tcA) Exchange (swap) adjacent lines 
    lslmtroff(9)le UNIX troff file 
    lslmtxt(9)le ASCII plain text file 
    lslmUserProfiles(2)le Defining a user profile 
    lslmundo(2)le (cDC-x ucA) Undo the last edit 
    lslmundo(2m)le Retain edit modifications 
    lslmuniq(3)le Make lines in a sorted list unique 
    lslmuniversal-argument(2)le (cDC-ucA) Set the command argument count 
    lslmunmark-buffer(3)le Remove buffer edited flag 
    lslmunset-variable(2)le Delete a variable 
    lslmupper-case-region(2)le (cDC-x C-ucA) Uppercase a region (upcase) 
    lslmupper-case-word(2)le (cDesc ucA) Uppercase word (upcase) 
    lslmuser-setup(3)le Configure MicroEmacs for a specific user 
    lslmusr(2m)le User buffer modes 
    lslmVariables(4)le User defined macro variables 
    lslmvb(9)le Visual Basic 
    lslmvhdl(9)le VHDL hardware simulation File 
    lslmview(2m)le Read only 
    lslmview-file(2)le (cDC-x C-vcA) Load a file read only 
    lslmvm(3)le Email viewer 
    lslmvoid(2)le Null command 
    lslmvrml(9)le VRML File 
    lslmwhich(3)le Program finder 
    lslmwish(9)le TCL shell file 
    lslmwrap(2m)le Line wrap entered text 
    lslmwrap-word(2)le Wrap word onto next line 
    lslmwrite-buffer(2)le (cDC-x C-wcA) Write contents of buffer to named (new) file 
    lslmx86(9)le Intel .x86 Assembler File 
    lslmy(9)le YACC programming language 
    lslmyank(2)le (cDC-ycA) Paste (copy) kill buffer contents into buffer 
    lslmyank-rectangle(2)le (cDesc C-ycA) Insert a column of text 
    lslmzfile-setup(3)le Compressed file support setup 
    lslmzsh(9)le Z-Shell file 

!   MicroEmacs '02 - Acknowledgments
cEcEACKNOWLEDGMENTS cEcA


    The following persons contributed to this release of cDMicroEmacs '02cA over 
    the last decade, roughly in the order of participation. This list 
    represents the main developers:- 

        Danial M. Lawrence (Original Author) 
        Martin House 
        cDJon GreencA - cCCurrent MaintainercA 
        Callen McNally 
        cDSteven PhillipscA - cCCurrent MaintainercA 

    Additional contributions have been made as follows, in chrononlogical 
    order:- 

        Detlef Groth cC[June 1999]cA 
            Setting up and validating the German environment. 
            Latex features and excellent feedback. 

        Pedro Gomes cC[May 1999]cA 
            Portuguese Dictionary. 
            Cobol and Intel x86 language templates. 
            Metapost/Meta Font templates. 

        Matthew Robinson cC[Feburary 1999]cA 
            Developed the WinConsole version for Windows NT. 

    Thanks to everybody else that has used and abused it locally feeding back 
    comments and preferences, wishes and desires. 

!   MicroEmacs '02 - Copyright
!9  Copyright - MicroEmacs '02
cEcECOPYRIGHT cEcA


cEGNU General Public License (GPL) cA


    All source and macro code is covered by the GPL. 

              GNU GENERAL PUBLIC LICENSE 
                 Version 2, June 1991 

         Copyright (C) 1989, 1991 Free Software Foundation, Inc. 
            59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
         Everyone is permitted to copy and distribute verbatim copies 
         of this license document, but changing it is not allowed. 

               Preamble 

          The licenses for most software are designed to take away your 
        freedom to share and change it.  By contrast, the GNU General Public 
        License is intended to guarantee your freedom to share and change free 
        software--to make sure the software is free for all its users.  This 
        General Public License applies to most of the Free Software 
        Foundation's software and to any other program whose authors commit to 
        using it.  (Some other Free Software Foundation software is covered by 
        the GNU Library General Public License instead.)  You can apply it to 
        your programs, too. 

          When we speak of free software, we are referring to freedom, not 
        price.  Our General Public Licenses are designed to make sure that you 
        have the freedom to distribute copies of free software (and charge for 
        this service if you wish), that you receive source code or can get it 
        if you want it, that you can change the software or use pieces of it 
        in new free programs; and that you know you can do these things. 

          To protect your rights, we need to make restrictions that forbid 
        anyone to deny you these rights or to ask you to surrender the rights. 
        These restrictions translate to certain responsibilities for you if you 
        distribute copies of the software, or if you modify it. 

          For example, if you distribute copies of such a program, whether 
        gratis or for a fee, you must give the recipients all the rights that 
        you have.  You must make sure that they, too, receive or can get the 
        source code.  And you must show them these terms so they know their 
        rights. 

          We protect your rights with two steps: (1) copyright the software, and 
        (2) offer you this license which gives you legal permission to copy, 
        distribute and/or modify the software. 

          Also, for each author's protection and ours, we want to make certain 
        that everyone understands that there is no warranty for this free 
        software.  If the software is modified by someone else and passed on, we 
        want its recipients to know that what they have is not the original, so 
        that any problems introduced by others will not reflect on the original 
        authors' reputations. 

          Finally, any free program is threatened constantly by software 
        patents.  We wish to avoid the danger that redistributors of a free 
        program will individually obtain patent licenses, in effect making the 
        program proprietary.  To prevent this, we have made it clear that any 
        patent must be licensed for everyone's free use or not licensed at all. 

          The precise terms and conditions for copying, distribution and 
        modification follow. 

              GNU GENERAL PUBLIC LICENSE 
           TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 

          0. This License applies to any program or other work which contains 
        a notice placed by the copyright holder saying it may be distributed 
        under the terms of this General Public License.  The "Program", below, 
        refers to any such program or work, and a "work based on the Program" 
        means either the Program or any derivative work under copyright law: 
        that is to say, a work containing the Program or a portion of it, 
        either verbatim or with modifications and/or translated into another 
        language.  (Hereinafter, translation is included without limitation in 
        the term "modification".)  Each licensee is addressed as "you". 

        Activities other than copying, distribution and modification are not 
        covered by this License; they are outside its scope.  The act of 
        running the Program is not restricted, and the output from the Program 
        is covered only if its contents constitute a work based on the 
        Program (independent of having been made by running the Program). 
        Whether that is true depends on what the Program does. 

          1. You may copy and distribute verbatim copies of the Program's 
        source code as you receive it, in any medium, provided that you 
        conspicuously and appropriately publish on each copy an appropriate 
        copyright notice and disclaimer of warranty; keep intact all the 
        notices that refer to this License and to the absence of any warranty; 
        and give any other recipients of the Program a copy of this License 
        along with the Program. 

        You may charge a fee for the physical act of transferring a copy, and 
        you may at your option offer warranty protection in exchange for a fee. 

          2. You may modify your copy or copies of the Program or any portion 
        of it, thus forming a work based on the Program, and copy and 
        distribute such modifications or work under the terms of Section 1 
        above, provided that you also meet all of these conditions: 

            a) You must cause the modified files to carry prominent notices 
            stating that you changed the files and the date of any change. 

            b) You must cause any work that you distribute or publish, that in 
            whole or in part contains or is derived from the Program or any 
            part thereof, to be licensed as a whole at no charge to all third 
            parties under the terms of this License. 

            c) If the modified program normally reads commands interactively 
            when run, you must cause it, when started running for such 
            interactive use in the most ordinary way, to print or display an 
            announcement including an appropriate copyright notice and a 
            notice that there is no warranty (or else, saying that you provide 
            a warranty) and that users may redistribute the program under 
            these conditions, and telling the user how to view a copy of this 
            License.  (Exception: if the Program itself is interactive but 
            does not normally print such an announcement, your work based on 
            the Program is not required to print an announcement.) 

        These requirements apply to the modified work as a whole.  If 
        identifiable sections of that work are not derived from the Program, 
        and can be reasonably considered independent and separate works in 
        themselves, then this License, and its terms, do not apply to those 
        sections when you distribute them as separate works.  But when you 
        distribute the same sections as part of a whole which is a work based 
        on the Program, the distribution of the whole must be on the terms of 
        this License, whose permissions for other licensees extend to the 
        entire whole, and thus to each and every part regardless of who wrote it. 

        Thus, it is not the intent of this section to claim rights or contest 
        your rights to work written entirely by you; rather, the intent is to 
        exercise the right to control the distribution of derivative or 
        collective works based on the Program. 

        In addition, mere aggregation of another work not based on the Program 
        with the Program (or with a work based on the Program) on a volume of 
        a storage or distribution medium does not bring the other work under 
        the scope of this License. 

          3. You may copy and distribute the Program (or a work based on it, 
        under Section 2) in object code or executable form under the terms of 
        Sections 1 and 2 above provided that you also do one of the following: 

            a) Accompany it with the complete corresponding machine-readable 
            source code, which must be distributed under the terms of Sections 
            1 and 2 above on a medium customarily used for software interchange; or, 

            b) Accompany it with a written offer, valid for at least three 
            years, to give any third party, for a charge no more than your 
            cost of physically performing source distribution, a complete 
            machine-readable copy of the corresponding source code, to be 
            distributed under the terms of Sections 1 and 2 above on a medium 
            customarily used for software interchange; or, 

            c) Accompany it with the information you received as to the offer 
            to distribute corresponding source code.  (This alternative is 
            allowed only for noncommercial distribution and only if you 
            received the program in object code or executable form with such 
            an offer, in accord with Subsection b above.) 

        The source code for a work means the preferred form of the work for 
        making modifications to it.  For an executable work, complete source 
        code means all the source code for all modules it contains, plus any 
        associated interface definition files, plus the scripts used to 
        control compilation and installation of the executable.  However, as a 
        special exception, the source code distributed need not include 
        anything that is normally distributed (in either source or binary 
        form) with the major components (compiler, kernel, and so on) of the 
        operating system on which the executable runs, unless that component 
        itself accompanies the executable. 

        If distribution of executable or object code is made by offering 
        access to copy from a designated place, then offering equivalent 
        access to copy the source code from the same place counts as 
        distribution of the source code, even though third parties are not 
        compelled to copy the source along with the object code. 

          4. You may not copy, modify, sublicense, or distribute the Program 
        except as expressly provided under this License.  Any attempt 
        otherwise to copy, modify, sublicense or distribute the Program is 
        void, and will automatically terminate your rights under this License. 
        However, parties who have received copies, or rights, from you under 
        this License will not have their licenses terminated so long as such 
        parties remain in full compliance. 

          5. You are not required to accept this License, since you have not 
        signed it.  However, nothing else grants you permission to modify or 
        distribute the Program or its derivative works.  These actions are 
        prohibited by law if you do not accept this License.  Therefore, by 
        modifying or distributing the Program (or any work based on the 
        Program), you indicate your acceptance of this License to do so, and 
        all its terms and conditions for copying, distributing or modifying 
        the Program or works based on it. 

          6. Each time you redistribute the Program (or any work based on the 
        Program), the recipient automatically receives a license from the 
        original licensor to copy, distribute or modify the Program subject to 
        these terms and conditions.  You may not impose any further 
        restrictions on the recipients' exercise of the rights granted herein. 
        You are not responsible for enforcing compliance by third parties to 
        this License. 

          7. If, as a consequence of a court judgment or allegation of patent 
        infringement or for any other reason (not limited to patent issues), 
        conditions are imposed on you (whether by court order, agreement or 
        otherwise) that contradict the conditions of this License, they do not 
        excuse you from the conditions of this License.  If you cannot 
        distribute so as to satisfy simultaneously your obligations under this 
        License and any other pertinent obligations, then as a consequence you 
        may not distribute the Program at all.  For example, if a patent 
        license would not permit royalty-free redistribution of the Program by 
        all those who receive copies directly or indirectly through you, then 
        the only way you could satisfy both it and this License would be to 
        refrain entirely from distribution of the Program. 

        If any portion of this section is held invalid or unenforceable under 
        any particular circumstance, the balance of the section is intended to 
        apply and the section as a whole is intended to apply in other 
        circumstances. 

        It is not the purpose of this section to induce you to infringe any 
        patents or other property right claims or to contest validity of any 
        such claims; this section has the sole purpose of protecting the 
        integrity of the free software distribution system, which is 
        implemented by public license practices.  Many people have made 
        generous contributions to the wide range of software distributed 
        through that system in reliance on consistent application of that 
        system; it is up to the author/donor to decide if he or she is willing 
        to distribute software through any other system and a licensee cannot 
        impose that choice. 

        This section is intended to make thoroughly clear what is believed to 
        be a consequence of the rest of this License. 

          8. If the distribution and/or use of the Program is restricted in 
        certain countries either by patents or by copyrighted interfaces, the 
        original copyright holder who places the Program under this License 
        may add an explicit geographical distribution limitation excluding 
        those countries, so that distribution is permitted only in or among 
        countries not thus excluded.  In such case, this License incorporates 
        the limitation as if written in the body of this License. 

          9. The Free Software Foundation may publish revised and/or new versions 
        of the General Public License from time to time.  Such new versions will 
        be similar in spirit to the present version, but may differ in detail to 
        address new problems or concerns. 

        Each version is given a distinguishing version number.  If the Program 
        specifies a version number of this License which applies to it and "any 
        later version", you have the option of following the terms and conditions 
        either of that version or of any later version published by the Free 
        Software Foundation.  If the Program does not specify a version number of 
        this License, you may choose any version ever published by the Free Software 
        Foundation. 

          10. If you wish to incorporate parts of the Program into other free 
        programs whose distribution conditions are different, write to the author 
        to ask for permission.  For software which is copyrighted by the Free 
        Software Foundation, write to the Free Software Foundation; we sometimes 
        make exceptions for this.  Our decision will be guided by the two goals 
        of preserving the free status of all derivatives of our free software and 
        of promoting the sharing and reuse of software generally. 

               NO WARRANTY 

          11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY 
        FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN 
        OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES 
        PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED 
        OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
        MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS 
        TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE 
        PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, 
        REPAIR OR CORRECTION. 

          12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
        WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
        REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
        INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
        OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED 
        TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY 
        YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER 
        PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE 
        POSSIBILITY OF SUCH DAMAGES. 

               END OF TERMS AND CONDITIONS 

             How to Apply These Terms to Your New Programs 

          If you develop a new program, and you want it to be of the greatest 
        possible use to the public, the best way to achieve this is to make it 
        free software which everyone can redistribute and change under these terms. 

          To do so, attach the following notices to the program.  It is safest 
        to attach them to the start of each source file to most effectively 
        convey the exclusion of warranty; and each file should have at least 
        the "copyright" line and a pointer to where the full notice is found. 

            <one line to give the program's name and a brief idea of what it does.> 
            Copyright (C) <year>  <name of author> 

            This program is free software; you can redistribute it and/or modify 
            it under the terms of the GNU General Public License as published by 
            the Free Software Foundation; either version 2 of the License, or 
            (at your option) any later version. 

            This program is distributed in the hope that it will be useful, 
            but WITHOUT ANY WARRANTY; without even the implied warranty of 
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
            GNU General Public License for more details. 

            You should have received a copy of the GNU General Public License 
            along with this program; if not, write to the Free Software 
            Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 


        Also add information on how to contact you by electronic and paper mail. 

        If the program is interactive, make it output a short notice like this 
        when it starts in an interactive mode: 

            Gnomovision version 69, Copyright (C) year name of author 
            Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'. 
            This is free software, and you are welcome to redistribute it 
            under certain conditions; type `show c' for details. 

        The hypothetical commands `show w' and `show c' should show the appropriate 
        parts of the General Public License.  Of course, the commands you use may 
        be called something other than `show w' and `show c'; they could even be 
        mouse-clicks or menu items--whatever suits your program. 

        You should also get your employer (if you work as a programmer) or your 
        school, if any, to sign a "copyright disclaimer" for the program, if 
        necessary.  Here is a sample; alter the names: 

          Yoyodyne, Inc., hereby disclaims all copyright interest in the program 
          `Gnomovision' (which makes passes at compilers) written by James Hacker. 

          <signature of Ty Coon>, 1 April 1989 
          Ty Coon, President of Vice 

        This General Public License does not permit incorporating your program into 
        proprietary programs.  If your program is a subroutine library, you may 
        consider it more useful to permit linking proprietary applications with the 
        library.  If this is what you want to do, use the GNU Library General 
        Public License instead of this License. 


cEGNU Free Documentation License (GFDL) cA


    All documentation is covered by the GFDL. 

          GNU Free Documentation License 
             Version 1.1, March 2000 

         Copyright (C) 2000  Free Software Foundation, Inc. 
             59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
         Everyone is permitted to copy and distribute verbatim copies 
         of this license document, but changing it is not allowed. 


        0. PREAMBLE 

        The purpose of this License is to make a manual, textbook, or other 
        written document "free" in the sense of freedom: to assure everyone 
        the effective freedom to copy and redistribute it, with or without 
        modifying it, either commercially or noncommercially.  Secondarily, 
        this License preserves for the author and publisher a way to get 
        credit for their work, while not being considered responsible for 
        modifications made by others. 

        This License is a kind of "copyleft", which means that derivative 
        works of the document must themselves be free in the same sense.  It 
        complements the GNU General Public License, which is a copyleft 
        license designed for free software. 

        We have designed this License in order to use it for manuals for free 
        software, because free software needs free documentation: a free 
        program should come with manuals providing the same freedoms that the 
        software does.  But this License is not limited to software manuals; 
        it can be used for any textual work, regardless of subject matter or 
        whether it is published as a printed book.  We recommend this License 
        principally for works whose purpose is instruction or reference. 


        1. APPLICABILITY AND DEFINITIONS 

        This License applies to any manual or other work that contains a 
        notice placed by the copyright holder saying it can be distributed 
        under the terms of this License.  The "Document", below, refers to any 
        such manual or work.  Any member of the public is a licensee, and is 
        addressed as "you". 

        A "Modified Version" of the Document means any work containing the 
        Document or a portion of it, either copied verbatim, or with 
        modifications and/or translated into another language. 

        A "Secondary Section" is a named appendix or a front-matter section of 
        the Document that deals exclusively with the relationship of the 
        publishers or authors of the Document to the Document's overall subject 
        (or to related matters) and contains nothing that could fall directly 
        within that overall subject.  (For example, if the Document is in part a 
        textbook of mathematics, a Secondary Section may not explain any 
        mathematics.)  The relationship could be a matter of historical 
        connection with the subject or with related matters, or of legal, 
        commercial, philosophical, ethical or political position regarding 
        them. 

        The "Invariant Sections" are certain Secondary Sections whose titles 
        are designated, as being those of Invariant Sections, in the notice 
        that says that the Document is released under this License. 

        The "Cover Texts" are certain short passages of text that are listed, 
        as Front-Cover Texts or Back-Cover Texts, in the notice that says that 
        the Document is released under this License. 

        A "Transparent" copy of the Document means a machine-readable copy, 
        represented in a format whose specification is available to the 
        general public, whose contents can be viewed and edited directly and 
        straightforwardly with generic text editors or (for images composed of 
        pixels) generic paint programs or (for drawings) some widely available 
        drawing editor, and that is suitable for input to text formatters or 
        for automatic translation to a variety of formats suitable for input 
        to text formatters.  A copy made in an otherwise Transparent file 
        format whose markup has been designed to thwart or discourage 
        subsequent modification by readers is not Transparent.  A copy that is 
        not "Transparent" is called "Opaque". 

        Examples of suitable formats for Transparent copies include plain 
        ASCII without markup, Texinfo input format, LaTeX input format, SGML 
        or XML using a publicly available DTD, and standard-conforming simple 
        HTML designed for human modification.  Opaque formats include 
        PostScript, PDF, proprietary formats that can be read and edited only 
        by proprietary word processors, SGML or XML for which the DTD and/or 
        processing tools are not generally available, and the 
        machine-generated HTML produced by some word processors for output 
        purposes only. 

        The "Title Page" means, for a printed book, the title page itself, 
        plus such following pages as are needed to hold, legibly, the material 
        this License requires to appear in the title page.  For works in 
        formats which do not have any title page as such, "Title Page" means 
        the text near the most prominent appearance of the work's title, 
        preceding the beginning of the body of the text. 


        2. VERBATIM COPYING 

        You may copy and distribute the Document in any medium, either 
        commercially or noncommercially, provided that this License, the 
        copyright notices, and the license notice saying this License applies 
        to the Document are reproduced in all copies, and that you add no other 
        conditions whatsoever to those of this License.  You may not use 
        technical measures to obstruct or control the reading or further 
        copying of the copies you make or distribute.  However, you may accept 
        compensation in exchange for copies.  If you distribute a large enough 
        number of copies you must also follow the conditions in section 3. 

        You may also lend copies, under the same conditions stated above, and 
        you may publicly display copies. 


        3. COPYING IN QUANTITY 

        If you publish printed copies of the Document numbering more than 100, 
        and the Document's license notice requires Cover Texts, you must enclose 
        the copies in covers that carry, clearly and legibly, all these Cover 
        Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on 
        the back cover.  Both covers must also clearly and legibly identify 
        you as the publisher of these copies.  The front cover must present 
        the full title with all words of the title equally prominent and 
        visible.  You may add other material on the covers in addition. 
        Copying with changes limited to the covers, as long as they preserve 
        the title of the Document and satisfy these conditions, can be treated 
        as verbatim copying in other respects. 

        If the required texts for either cover are too voluminous to fit 
        legibly, you should put the first ones listed (as many as fit 
        reasonably) on the actual cover, and continue the rest onto adjacent 
        pages. 

        If you publish or distribute Opaque copies of the Document numbering 
        more than 100, you must either include a machine-readable Transparent 
        copy along with each Opaque copy, or state in or with each Opaque copy 
        a publicly-accessible computer-network location containing a complete 
        Transparent copy of the Document, free of added material, which the 
        general network-using public has access to download anonymously at no 
        charge using public-standard network protocols.  If you use the latter 
        option, you must take reasonably prudent steps, when you begin 
        distribution of Opaque copies in quantity, to ensure that this 
        Transparent copy will remain thus accessible at the stated location 
        until at least one year after the last time you distribute an Opaque 
        copy (directly or through your agents or retailers) of that edition to 
        the public. 

        It is requested, but not required, that you contact the authors of the 
        Document well before redistributing any large number of copies, to give 
        them a chance to provide you with an updated version of the Document. 


        4. MODIFICATIONS 

        You may copy and distribute a Modified Version of the Document under 
        the conditions of sections 2 and 3 above, provided that you release 
        the Modified Version under precisely this License, with the Modified 
        Version filling the role of the Document, thus licensing distribution 
        and modification of the Modified Version to whoever possesses a copy 
        of it.  In addition, you must do these things in the Modified Version: 

        A. Use in the Title Page (and on the covers, if any) a title distinct 
           from that of the Document, and from those of previous versions 
           (which should, if there were any, be listed in the History section 
           of the Document).  You may use the same title as a previous version 
           if the original publisher of that version gives permission. 
        B. List on the Title Page, as authors, one or more persons or entities 
           responsible for authorship of the modifications in the Modified 
           Version, together with at least five of the principal authors of the 
           Document (all of its principal authors, if it has less than five). 
        C. State on the Title page the name of the publisher of the 
           Modified Version, as the publisher. 
        D. Preserve all the copyright notices of the Document. 
        E. Add an appropriate copyright notice for your modifications 
           adjacent to the other copyright notices. 
        F. Include, immediately after the copyright notices, a license notice 
           giving the public permission to use the Modified Version under the 
           terms of this License, in the form shown in the Addendum below. 
        G. Preserve in that license notice the full lists of Invariant Sections 
           and required Cover Texts given in the Document's license notice. 
        H. Include an unaltered copy of this License. 
        I. Preserve the section entitled "History", and its title, and add to 
           it an item stating at least the title, year, new authors, and 
           publisher of the Modified Version as given on the Title Page.  If 
           there is no section entitled "History" in the Document, create one 
           stating the title, year, authors, and publisher of the Document as 
           given on its Title Page, then add an item describing the Modified 
           Version as stated in the previous sentence. 
        J. Preserve the network location, if any, given in the Document for 
           public access to a Transparent copy of the Document, and likewise 
           the network locations given in the Document for previous versions 
           it was based on.  These may be placed in the "History" section. 
           You may omit a network location for a work that was published at 
           least four years before the Document itself, or if the original 
           publisher of the version it refers to gives permission. 
        K. In any section entitled "Acknowledgements" or "Dedications", 
           preserve the section's title, and preserve in the section all the 
           substance and tone of each of the contributor acknowledgements 
           and/or dedications given therein. 
        L. Preserve all the Invariant Sections of the Document, 
           unaltered in their text and in their titles.  Section numbers 
           or the equivalent are not considered part of the section titles. 
        M. Delete any section entitled "Endorsements".  Such a section 
           may not be included in the Modified Version. 
        N. Do not retitle any existing section as "Endorsements" 
           or to conflict in title with any Invariant Section. 

        If the Modified Version includes new front-matter sections or 
        appendices that qualify as Secondary Sections and contain no material 
        copied from the Document, you may at your option designate some or all 
        of these sections as invariant.  To do this, add their titles to the 
        list of Invariant Sections in the Modified Version's license notice. 
        These titles must be distinct from any other section titles. 

        You may add a section entitled "Endorsements", provided it contains 
        nothing but endorsements of your Modified Version by various 
        parties--for example, statements of peer review or that the text has 
        been approved by an organization as the authoritative definition of a 
        standard. 

        You may add a passage of up to five words as a Front-Cover Text, and a 
        passage of up to 25 words as a Back-Cover Text, to the end of the list 
        of Cover Texts in the Modified Version.  Only one passage of 
        Front-Cover Text and one of Back-Cover Text may be added by (or 
        through arrangements made by) any one entity.  If the Document already 
        includes a cover text for the same cover, previously added by you or 
        by arrangement made by the same entity you are acting on behalf of, 
        you may not add another; but you may replace the old one, on explicit 
        permission from the previous publisher that added the old one. 

        The author(s) and publisher(s) of the Document do not by this License 
        give permission to use their names for publicity for or to assert or 
        imply endorsement of any Modified Version. 


        5. COMBINING DOCUMENTS 

        You may combine the Document with other documents released under this 
        License, under the terms defined in section 4 above for modified 
        versions, provided that you include in the combination all of the 
        Invariant Sections of all of the original documents, unmodified, and 
        list them all as Invariant Sections of your combined work in its 
        license notice. 

        The combined work need only contain one copy of this License, and 
        multiple identical Invariant Sections may be replaced with a single 
        copy.  If there are multiple Invariant Sections with the same name but 
        different contents, make the title of each such section unique by 
        adding at the end of it, in parentheses, the name of the original 
        author or publisher of that section if known, or else a unique number. 
        Make the same adjustment to the section titles in the list of 
        Invariant Sections in the license notice of the combined work. 

        In the combination, you must combine any sections entitled "History" 
        in the various original documents, forming one section entitled 
        "History"; likewise combine any sections entitled "Acknowledgements", 
        and any sections entitled "Dedications".  You must delete all sections 
        entitled "Endorsements." 


        6. COLLECTIONS OF DOCUMENTS 

        You may make a collection consisting of the Document and other documents 
        released under this License, and replace the individual copies of this 
        License in the various documents with a single copy that is included in 
        the collection, provided that you follow the rules of this License for 
        verbatim copying of each of the documents in all other respects. 

        You may extract a single document from such a collection, and distribute 
        it individually under this License, provided you insert a copy of this 
        License into the extracted document, and follow this License in all 
        other respects regarding verbatim copying of that document. 


        7. AGGREGATION WITH INDEPENDENT WORKS 

        A compilation of the Document or its derivatives with other separate 
        and independent documents or works, in or on a volume of a storage or 
        distribution medium, does not as a whole count as a Modified Version 
        of the Document, provided no compilation copyright is claimed for the 
        compilation.  Such a compilation is called an "aggregate", and this 
        License does not apply to the other self-contained works thus compiled 
        with the Document, on account of their being thus compiled, if they 
        are not themselves derivative works of the Document. 

        If the Cover Text requirement of section 3 is applicable to these 
        copies of the Document, then if the Document is less than one quarter 
        of the entire aggregate, the Document's Cover Texts may be placed on 
        covers that surround only the Document within the aggregate. 
        Otherwise they must appear on covers around the whole aggregate. 


        8. TRANSLATION 

        Translation is considered a kind of modification, so you may 
        distribute translations of the Document under the terms of section 4. 
        Replacing Invariant Sections with translations requires special 
        permission from their copyright holders, but you may include 
        translations of some or all Invariant Sections in addition to the 
        original versions of these Invariant Sections.  You may include a 
        translation of this License provided that you also include the 
        original English version of this License.  In case of a disagreement 
        between the translation and the original English version of this 
        License, the original English version will prevail. 


        9. TERMINATION 

        You may not copy, modify, sublicense, or distribute the Document except 
        as expressly provided for under this License.  Any other attempt to 
        copy, modify, sublicense or distribute the Document is void, and will 
        automatically terminate your rights under this License.  However, 
        parties who have received copies, or rights, from you under this 
        License will not have their licenses terminated so long as such 
        parties remain in full compliance. 


        10. FUTURE REVISIONS OF THIS LICENSE 

        The Free Software Foundation may publish new, revised versions 
        of the GNU Free Documentation License from time to time.  Such new 
        versions will be similar in spirit to the present version, but may 
        differ in detail to address new problems or concerns.  See 
        http://www.gnu.org/copyleft/. 

        Each version of the License is given a distinguishing version number. 
        If the Document specifies that a particular numbered version of this 
        License "or any later version" applies to it, you have the option of 
        following the terms and conditions either of that specified version or 
        of any later version that has been published (not as a draft) by the 
        Free Software Foundation.  If the Document does not specify a version 
        number of this License, you may choose any version ever published (not 
        as a draft) by the Free Software Foundation. 


        ADDENDUM: How to use this License for your documents 

        To use this License in a document you have written, include a copy of 
        the License in the document and put the following copyright and 
        license notices just after the title page: 

              Copyright (c)  YEAR  YOUR NAME. 
              Permission is granted to copy, distribute and/or modify this document 
              under the terms of the GNU Free Documentation License, Version 1.1 
              or any later version published by the Free Software Foundation; 
              with the Invariant Sections being LIST THEIR TITLES, with the 
              Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST. 
              A copy of the license is included in the section entitled "GNU 
              Free Documentation License". 

        If you have no Invariant Sections, write "with no Invariant Sections" 
        instead of saying which ones are invariant.  If you have no 
        Front-Cover Texts, write "no Front-Cover Texts" instead of 
        "Front-Cover Texts being LIST"; likewise for Back-Cover Texts. 

        If your document contains nontrivial examples of program code, we 
        recommend releasing these examples in parallel under your choice of 
        free software license, such as the GNU General Public License, 
        to permit their use in free software. 


cEcELicense History cEcA


    JASSPA MicroEmacs is derived from the MicroEmacs 3.8 source base of 1998. 
    As such, all of the software has been under a commercially restrictive 
    license. JASSPA has upheld the original license terms laid down my the 
    original author and copyright holder Danial M Lawrence. 

    JASSPA is the collective name given to the maintainers of JASSPA 
    MicroEmacs. The current maintainers at the 1st January 2002 are Steven 
    Phillips and Jon Green. 

    On Wednesday 19th January 2001 JASSPA applied for, and was granted, 
    permission by Danial M Lawrence to move to the less restrictive licensing 
    terms of GPL. As of 1st January 2002 the JASSPA distribution of MicroEmacs 
    shall be supplied under this licensing arrangement. The licence is not 
    transferable to earlier versions of the distribution or to the original 
    program from which is was derived known as MicroEmacs. 


cELicense Terms to 1988 cA


    The following copyrights apply from the original source code of version 
    3.8. No explicit copyrights were found with the original distribution 
    apart from the following found in the main source code, 

        cD(C)opyright 1987 by Daniel M. LawrencecA 
        MicroEMACS can be copied and distributed freely for any non-commercial 
        purposes. Commercial users may use MicroEMACS inhouse. Shareware 
        distributors may redistribute MicroEMACS for media costs only. 
        MicroEMACS can only be incorporated into commercial software or resold 
        with the permission of the current author. 


cELicense Terms 1998-2001 cA


    The following notices apply after 1988 to 31st December 2001 

        cDCopyright (C) 1988 - 2001, JASSPAcA 
        JASSPA MicroEmacs can be copied and distributed freely for any 
        non-commercial purposes. Commercial users may use JASSPA MicroEmacs 
        inhouse. Shareware distributors may redistribute JASSPA MicroEmacs for 
        media costs only. JASSPA MicroEmacs can only be incorporated into 
        commercial software or resold with the permission of the current 
        author. 


cELicense Terms 2002 and subsequent years cA


    GNU Public License (GPL) for all source material. GNU Free Documentation 
    License (GFDL) for all documentation material. 

!   MicroEmacs '02 - Contact Information
cESpelling Dictionary Copyrights cA


    The spelling dictionaries are converted from cCispellcA dictionaries, each 
    spelling dictionary has it's own copyright which is reproduced within the 
    appropriate language spelling macro file. 


cENO WARRANTY cA


    THIS PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE 
    PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE 
    STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE 
    PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
    AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY 
    AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE 
    DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR 
    CORRECTION. 

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL 
    ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
    REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
    INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES 
    ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT 
    LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES 
    SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE 
    WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN 
    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 

    cDTHIS NOTICE MUST BE CARRIED IN ALL COPIES OF THE DISTRIBUTIONcA 
!7  Contact Information - MicroEmacs '02


cEcECONTACT INFORMATION cEcA


    The following contact point may be used to report all problems and request 
    information:- 

        cGEmail:support@jasspa.comcA 

    Also visit our web site's on the Internet:- 

       cG http://www.jasspa.comcA 
       cG http://www.geocities.com/jasspacA 

    This page carries the latest information and patches on the distribution. 


cEE-Mail Reflector cA


    A E-Mail reflector is available onto which questions, suggestions and code 
    fragments may be posted. This is an un-moderated E-Mail group. The mailing 
    list archives may be found at:- 

       cG http://groups.yahoo.com/group/jasspa/cA 

    These should be referenced before posting any questions, as an answer may 
    have already been given. This mailing list is likely to contain the most 
    up-to-date information available, as JASSPA will use this for any 
    notifications. 

    If you want to join the E-Mail reflector then mail a request, with an 
    empty message body to:- 

       cG jasspa-subscribe@yahoogroups.comcA 

    This should add you to the mailing list. If you want to be subsequently 
    removed from the mailing list then mail an empty message to:- 

       cG jasspa-unsubscribe@yahoogroups.comcA 

    and you will be removed from the lists. There are facilities on the site 
    to allow you to receive digests, rather than multiple posts to the group 
    once you have subscribed. 

    The mailing list is hosted by cDYAHOO! GroupscA. General help information on 
    the mailgroup is available at their site:- 

       cG http://groups.yahoo.comcA 


cEHelp, FAQ and other queries cA


    Please use cDYAHOO! GroupscA help information for any queries about the 
    mailing lists, JASSPA have simply registered and E-Mail group at the site 
    and have not investigated fully all of the facilities that may be 
    available. 

    Please check the lslmFrequently Asked Questionsle. list and the home page FAQ 
    before you submit any information to JASSPA, your problem may have already 
    been addressed in these pages. 

    Every effort will be made to deal with your problem as soon as possible. 
    Please send mail with the titles indicated below so that it maybe 
    filtered. Unless explicitly requested (or appropriate) JASSPA will only 
    respond through the FAQ lists on the Internet site. It will not be 
    possible to answer individual enquiries and questions. 

    Any sites that wish to mirror the JASSPA distribution should contact 
    JASSPA first (use PORT), we will then include details of the mirror on the 
    home page. 


cEReporting Problems cA


    Mail as:- 

        cCTitle:cA cDBUGcA 
        cCMessage Body:cA Description of the problem .... 

    Problems should be reported such that they may be reproduced, this may not 
    be that easy. The information that is required is:- 

    cDPlatformcA 
        The host platform which is exhibiting a problem 

    cDVersioncA 
        The version of MicroEmacs '02. Use the cGesc x aboutcA to retrieve the 
        information e.g. 

            cGMicroEmacs 01 - Date 01/01/01 - win32cA 

    cDDescriptioncA 
        A description of the problem. Try to include as much information as 
        possible. Include any material necessary to reproduce the problem 
        (i.e. macro files, text file that demonstrates problem etc). 


cESuggestions cA


    Mail as:- 

        cCTitle:cA cDSUGGESTcA 
        cCMessage Body:cA Your suggestion, macro code fragment etc. 

    We always appreciate suggestions, new macro code fragments etc. We do not 
    have support for all languages, e.g. cDPerlcA, cDLatexcA... If you wish have 
    developed new macro templates, or games (we get a bit bored with the ones 
    that we have developed ourselves) then please mail them to cGSUGGESTcA and we 
    will incorporate them into the release. 


cEFeedback cA


    Mail as:- 

        cCTitle:cA cDFEEDBACKcA 
        cCMessage Body:cA Your feedback. 

    Any general comments (which are not suggestions), your feelings about this 
    version of MicroEmacs or any other non-technical dialogue. 


cEPorting cA


    Mail as:- 

        cCTitle:cA cDPORTcA 
        cCMessage Body:cA Details 

    If you wish to port MicroEmacs '02 to another platform and are willing to 
    undertake responsibility for maintenance of that platform then we would 
    like to here from you. Send us some details. 

!   MicroEmacs '02 - Origins
cEcEORIGINS cEcA


    This version of MicroEmacs is based on an early cCMicroEmacscA release of 3.8 
    in 1988, the origins of which are unknown, except to say it was delivered 
    on a unmarked 5 1/2" floppy disk. 

    The program was originally ported to a Motorola MVME147 UNIX box as an 
    alternative to cDvicA. Reliability of the program proved to be a problem as it 
    constantly crashed. In an attempt to rectify the problems the development 
    of MicroEmacs '02 commenced. 

    Development has continued from 1988 through to today, on the whole 
    oblivious to further developments of the existing cDMicroEmacscA program. This 
    was due to no Internet access. It was not until 1996 the next version of 
    cDMicroEmacscA and cDmewincA (Microsoft Windows (TM) port of the same program) was 
    downloaded from the Internet and compared. By this time MicroEmacs '02 was 
    radically different and we were not about to mesh the two together - that 
    would be a step backwards. 

    Development of MicroEmacs '02 has been biased towards the UNIX platform, 
    as most of the early development was performed in the UNIX domain. The 
    first of the window servers was X-Windows, which in turn has shaped the 
    implementation of the Microsoft Windows port. Latterly, we have seen the 
    resurgence of the IBM-PC platform which is now commonplace. For the return 
    port to the DOS environment, and subsequent development of the Microsoft 
    Windows port, a UNIX like interface was required. Most existing users 
    could not abide the primitive editors found on these machines; Microsoft 
    Windows was an alien and hostile environment when compared with UNIX. 
    Hence, the MicroEmacs '02 interface utilizes UNIX style cut and paste 
    across all platforms. 

    For portability, MicroEmacs '02 utilizes character rendering on all 
    platforms regardless of the window manager. Under X-Windows and Microsoft 
    Windows, the display is still treated as a character based display, the 
    subtle difference is that the display pane is re-sizable. This means that 
    the scroll bars, fonts etc. are not as slick as they could be, certainly 
    under Microsoft Windows MicroEmacs '02 looks positively primitive!! 
    Regardless of the look, the goal of a common editor across all working 
    platforms has been achieved! 


cEDevelopment History cA


    1988-92 

            * Ported to MVME147, UNIX using curses. 
            * Fire fighting to get a stable version. 
            * Expanded regular expression syntax. 

    1992-1993 

            * Ported to IBM AIX 
            * Ported to Silicon Graphics 

    1994 

            * DOS built with djgpp, allowed large files to be edited. 
            * Color hi-lighting. 
            * Re-implemented the macro language. Allowed separately named 
              macros. 
            * Get-next-line support. 
            * File hooks added. 
            * Implemented Electric C. 
            * RCS support. 
            * Re-implemented backups and auto-saves. 
            * Re-implemented isearch. 
            * Re-implemented of keyboard macros. 
            * Binary file reading support. 

    1995 

            * Integral speller. 
            * Ported to HP-UX. 
            * Multiple ipipes supported on Unix. 
            * Poke-screen support. 
            * Call-back macro support. 
            * Metris created. 
            * Abbreviation and completion. 
            * First implementation of mailing and View Mail. 
            * Isearch expanded to support magic mode. 
            * Session history support. 
            * First ported to X-Terminal. 
            * Mouse support. 
            * Initial printer support. 

    1996 

            * Ported to Slackware Linux. 
            * First menu system (implemented in macros). 
            * Undo support. 
            * First ported to Microsoft Windows 95. 
            * Re-implementation of get-next-line. 
            * Auto mode support. 
            * Magic file hooks added. 
            * Proper key name support. 
            * Key bindings support numeric arguments. 

    1997 

            * Re-implementation of ipipes to enable terminal support. 
            * Initial Directory-Tree support. 
            * First implementation of the On Screen Display (OSD) menus and 
              dialogues. 
            * Horizontal split window support. 
            * Scroll bar support. 
            * Added menu bar. 
            * Cursor position correction for hilights with invisible 
              character. 
            * Indentation scheme support. 
            * Ported to Microsoft NT 
            * Ipipes supported on NT. 

    1998 

            * Registry features for configuration. 
            * Re-implementation of OSD. 
            * Re-implementation of termcap extended key support. 
            * Narrow support. 
            * Re-implementation of the session history. 
            * Re-implemented the speller based on ispell dictionaries. 
            * Re-worked the printer interface for Windows. 
            * Rationalised mouse key bindings. 
            * Added $system variable to configure MicroEmacs. 
            * Added random hilight-token addition and removal support. 
            * cD1st ReleasecA - September 1998. 
            * Support True-type fonts under windows, font selection dialog. 
            * cDMinor PatchcA - October 1998. 
            * Enhanced the operation of the Window pipe's 
            * Undo past the last save operation. 
            * Added Tabbed entries to OSD. 
            * Enhanced user setup using OSD. 

    1999 

            * Introduction of the address and date lslmorganizer(3)le (replacing the 
              existing cDcalcA interface) 
            * Generic buffer folding using lslmnarrow-buffer(2)le 
            * Rendered cursor support on all platforms. 
            * Smooth scrolling mode. 
            * Win32s port, for Microsoft 3.1/3.11 O/S. 
            * Re-worked cDtranslate-tcap-keycA to generic lslmtranslate-key(2)le to 
              solve many of the foreign language problems. 
            * Re-worked the ALT key mapping to allow conventional Emacs meta 
              key bindings. 
            * Implemented Auto-Spell utility. 
            * Introduction of private macro variables of the form cC.namecA and 
              cC.macro.namecA. 
            * Port to Sun Solaris Intel platform (2.6) 
            * Merged the init-hilight and hilight-token into the single 
              lslmhilight(2)le command. Similarly for lslmindent(2)le. 
            * Enhanced the regexp support in lshilight(2)lmhilightle tokens, vastly improving 
              it capability and usability. Similarly for indent tokens. 
            * Reorganized the hilighting files. Introduction of the 
              lslmscheme-editor(3)le and cCHilight SearchcA OSD's. 
            * Implemented box character override support ( lslm$system(5)le bit 
              0x10000) on Win32 and Xterm platforms. 
            * Microsoft Windows native console support. 
            * cD2nd Release - Beta #1cA - May 1999. 
            * Bug fixes with multi-language support and spelling dictionaries. 
            * Fixed lslmfill-paragraph(2)le such that it retains the cursor position 
              in the paragraph when invoked without arguments. 
            * Moved to GNU regex for search/replace engine. 
            * Enhanced cCisearchcA such that it operates in cC*shell*cA buffers 
              (again). 
            * lslmgdiff(3)le macro implementation of a graphical diff to allow color 
              annotation of differences and difference selection. Uses the 
              output of a standard cDdiff(1)cA utility. 
            * 2nd port to IBM AIX. 
            * cD2nd Release - Beta #2cA - November 1999 
            * Enhanced the lslmlatex(9)le support macros following various 
              contributions from users. 
            * Added cCFavoritescA to the cCFilecA pull down menu. This is a simple 
              mechanism to allow the user to add a file to a favorites list. 
            * Ground up implementation of the regular expression pattern 
              matcher, following licensing problems with the GNU regex. The 
              resultant pattern matcher is now a little faster than GNU regex 
              and is capable of all of the standard regular expression pattern 
              matches. The pattern matcher has diverged from GNU in that 
              double backslashes are required in the character classes cG[..]cA to 
              allow for escape sequence short cuts such as 'cG\ncA' (newline), 
              'cG\tcA' (tab) etc. It was felt that this compromise was better than 
              having to quote the more obscure search characters. 
            * Changed the hilighting and indenting syntax to be GNU regex 
              compliant. 
            * Modified lslmcompare-windows(2)le to ignore white space by default, 
              lslmcompare-windows-exact(3)le performs an exact character for 
              character comparison. 
            * Enhanced the tags support to handle multiple tags and recursive 
              directory tree searching. 
            * Implemented osd-help, a gui front end to the on-line help. 
              Required changes to the help system which gives macros access to 
              the on-line help buffer, needed for the index and search. 
            * Over-hauled the hilighting scheme files and editor to support 
              the disabling of buffer hilighting. 
            * Many bugs fixed on all platforms, in particular unix cutting and 
              pasting (crashes exceed) and focus problems and NT exit delay. 
            * Added tab and newline character printing in buffers. 
            * Introduced message line variables @mx and @mxa. 
            * Added ftp support with a new ftp 'file-browser' interface to 
              give easy to use ftp capability. 

    2000 

            * Fixed several millennium bugs :) 
            * Revamped the printing interface to support colors 
            * Started using cDCVS(1)cA at last, much better history from now on. 
            * Got the emain #define's properly supported again so options so 
              MicroEmacs can be successfully compiled without options like 
              SPELL and OSD etc. This can reduce the binary size by up to 37%. 
            * Improved the macro based tag generators to support source code 
              trees and many new items of information, added new generation 
              GUI. 
            * Greatly improved the OSD based search and replace dialog, also 
              added the line hilight into this dialog. 
            * Added new -k and -u command-line options and improved -s option. 
            * Greatly improved and increase the file system operations via the 
              new lslmfile-op(2)le command, created better menus in the 
              lslmfile-browser(3)le. 
            * Added new lslmset-position(2)le which can be used to store all 
              information about the current window and lslmgoto-position(2)le which 
              will then restore them. Allowed macros to use non-letter 
              characters for alpha marks and positions so they no longer need 
              to clobber user ones. 
            * Greatly improved ipipe-shell-command efficiency on windows by 
              introducing a new thread approach to listen for activity. 
              Implemented a shell command-line in an ipiped environment so 
              lslmishell(3)le command is now usable on Windows platforms. 
            * Revamped the main ftp GUI to make it work much more rationally. 

    2001 

            * Changed buffer variables to except the form 
              :<buffer-name>:<variable>, like command variables. This allows 
              macros to access variable not defined in the current buffer. 
            * Added new lslmcommand-wait(2)le command to enable macros to wait for 
              user dependent completion, used in cDgdiffcA. 
            * Added support for new lslm$buffer-backup(5)le variable for setting the 
              back-up file location. 
            * Major work to enable the complete rebinding of all keys so the 
              user interface to MicroEmacs can be completely changed, this 
              allows for example a Windows feel to be created. This required 
              many internal ghosts to be exorcised and add new macro functions 
            * Added new generic buffer setup, menu and help macros, creating 
              the new lslmbuffer-setup(3)le command. Ported all existing file hooks 
              to this new interface greatly reducing the buffer hook size 
              while increasing its functionality and consistency. 
            * Added generic commands for the creation, deletion and 
              reformatting of comments now used by most of the file hooks. 
            * cD3rd ReleasecA - July 2001. Fixed many bugs in the last 12 months 
              as well as adding the above features. lslm&cbind(4)le, lslm&kbind(4)le and 
              lslm&nbind(4)le. 


cEWork In Progress or Planned cA


    Development of MicroEmacs '02 is an on-going process, follows is a list of 
    work items which is currently being undertaken or planned:- 

        * Integrate the mouse interaction, especially the pop-up menus of the 
          right mouse to be buffer sensitive and to deal with regions. (Macro 
          implementation). 
        * Native printer support for the generation of postscript. 
        * GNU Emacs compatibility macro file. 


cERelease History cA


    cDMay 1999cA 
        2nd Major Release - MicroEmacs '99. 

    cDOctober 1998cA 
        Minor patch to MicroEmacs '98 to correct a font problem on Windows 
        platforms. 

    cDSeptember 1998cA 
        1st Major Release - MicroEmacs '98. 


cEDocumentation cA


    The documentation is all written in UNIX cDnroff(1)cA and converted to HTML, 
    Microsoft Windows Help File format and MicroEmacs Help file format. 

!   Frequently Asked Questions
cEcEFAQ cEcA


    This page contains frequently asked questions submitted to JASSPA. 

    lsFAQs(0f)lmFAQsle - FAQ Contact information 
    lsfaq00(0f)lmfaq00le - New functionality; what is useful to me as an old MicroEmacs user 
    ?? 
    lsfaq01(0f)lmfaq01le - Languages; Are any foreign languages supported other than English 
    ?? 
    lsfaq02(0f)lmfaq02le - C++ is not default, C is - how do I change this ?? 
    lsfaq03(0f)lmfaq03le - GNU Emacs; are there any GNU Emacs bindings. ? 
    lsfaq04(0f)lmfaq04le - Icons are not displayed correctly in Microsoft Windows 
    environments !! 
    lsfaq05(0f)lmfaq05le - ipipes not working on Microsoft Windows network drives ? 
    lsfaq06(0f)lmfaq06le - Language not supported - will it be ?? 
    lsfaq07(0f)lmfaq07le - Language file is incomplete 
    lsfaq08(0f)lmfaq08le - Input locked up and not accepting keys; how do I unlock ? 
    lsfaq09(0f)lmfaq09le - MicroEmacs Bindings; How do I get the original MicroEmacs bindings 
    ? 
    lsfaq10(0f)lmfaq10le - Microsoft Windows Locks up after killing an ipipe. 
    lsfaq11(0f)lmfaq11le - Mouse support under Microsoft windows is strange !! 
    lsfaq12(0f)lmfaq12le - Scroll bars too narrow !! 
    lsfaq13(0f)lmfaq13le - Tab key; Why does the tab key not operate in some windows ?? 
    lsfaq14(0f)lmfaq14le - Termcap; On a color terminal why is there no color ?? 
    lsfaq15(0f)lmfaq15le - Termcap; Some of the keys do not work - how can I bind them ? 
    lsfaq16(0f)lmfaq16le - Timestamp; Format incorrect, how can I change to MMDDYY.hhmm ? 
    lsfaq17(0f)lmfaq17le - Windows; Component characters rendered incorrectly, how do I fix ? 
    lsfaq18(0f)lmfaq18le - Windows Autosave and Backup files; are these potentially a problem 
    ? 
    lsfaq19(0f)lmfaq19le - Printing; Why in Windows does the output come out in a buffer ?? 
    lsfaq20(0f)lmfaq20le - Printing; On Windows which font should I use ?? 
    lsfaq21(0f)lmfaq21le - Printing; My printer is not supported ? 
    lsfaq22(0f)lmfaq22le - Alt key maps to the Menu, how do I change ? 
    lsfaq23(0f)lmfaq23le - me32.ini - Where does it go, how do I know it's being processed ?? 
    lsfaq24(0f)lmfaq24le - Windows - Where is app850.fon ? 
    lsfaq25(0f)lmfaq25le - Time; mode line is showing the date in DD/MM/YY format how do I 
    change ? 
    lsfaq26(0f)lmfaq26le - C or C++ indentation and effects; how can I turn off ? 
    lsfaq27(0f)lmfaq27le - fill-paragraph function does not fill ?? 
    lsfaq28(0f)lmfaq28le - Key modifier which acts as the ESC key; what is it ? 
    lsfaq29(0f)lmfaq29le - find-file start location; where is it ? 
    lsfaq30(0f)lmfaq30le - Re-using a MicroEmacs session; how to ?? 
    lsfaq31(0f)lmfaq31le - Microsoft Drag and Drop; is it supported ?? 
    lsfaq32(0f)lmfaq32le - Cut and Paste to/from other applications; is it supported ?? 
    lsfaq33(0f)lmfaq33le - Fonts; how can I change the font ?? 
    lsfaq34(0f)lmfaq34le - Colors; how can I change screen colors ?? 
    lsfaq35(0f)lmfaq35le - File Types; how do I interchange between UNIX, Windows and DOS 
    files ?? 
    lsfaq36(0f)lmfaq36le - Non-English Languages; What font should I select ?? 
    lsfaq37(0f)lmfaq37le - MicroEmacs '99; How do I up-grade from MicroEmacs'98 ?? 
    lsfaq38(0f)lmfaq38le - Some keys on my foreign keyboard do not work properly, how do I 
    get them working ?? 
    lsfaq39(0f)lmfaq39le - Tabs; How to change the tab width ?? 
    lsfaq40(0f)lmfaq40le - Windows/DOS; Where do I get grep/diff etc. ?? 
    lsfaq41(0f)lmfaq41le - Home/End Keys; How do I change the default bindings ?? 
    lsfaq42(0f)lmfaq42le - tags; How do I generate a MicroEmacs compatible tags file ?? 

! 0ffaq00
cEcEQUESTION (00) cEcA


    New functionality; what is useful to me as an old MicroEmacs user ?? 


cEcEANSWER cEcA


    There are a lot of new features in this distribution. Assuming that you 
    just want to use the editor (and have cottoned onto the fact that there 
    are now scroll bars etc.) then the most frequent commands that we use 
    are:- 

        * lslmgrep(3)le - May need to set up in cC<user>.emfcA. 
        * lslmdiff(3)le - May need to set up in cC<user>.emfcA. 
        * lslmcompile(3)le - May need to set up in cC<user>.emfcA. 
        * lslmclean(3)le - cleans a buffer, removing spaces etc. 
        * lslmrestyle-buffer(3)le - Reformats 'C' + known languages. 
        * lslmspell-buffer(3)le - For documentation work, spells the buffer. 
        * cDC-scA - lslmisearch-forward(2)le incremental search. 
        * cDC-x ucA or cGC-_cA - lslmundo(2)le undoes edits. 
        * cDF10cA - lslmfile-browser(3)le allows the file system to be browsed 

    Other useful macros include:- 

        * lslmtabs-to-spaces(3)le - Good for sorting out the mess made by Microsoft 
          Developer Studio. 
        * lslmsort-lines(2)le - Two versions of this, allows marked lines to be 
          sorted alphabetically. 

    Be wary of:- 

        * cDesc-ocA - lslmfill-paragraph(2)le. The default mode is an automatic mode 
          which attempts to guess at the format required. It works most of the 
          time. Also works in 'C'. 

    Most of the other new features are in the background, such as the macro 
    processor, indentation control, color hilighting, indentation control, 
    auto-saving etc. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq01
cEcEQUESTION (01) cEcA


    Languages; Are any foreign languages supported other than English ?? 


cEcEANSWER cEcA


    Unfortunately as we started with V3.8 as a base many years ago, we missed 
    the distribution with foreign language extensions. We have not 
    incorporated them into the release. 

    The May 1999 release improves the language support by supporting the 
    ISO-Latin character sets. 

    We do have spelling dictionaries for French, Spanish, Portuguese and 
    German. Other languages may be supported by transforming native cDispell(1)cA 
    dictionaries. 

    If there is enough interest in this release from people with foreign 
    languages then we may consider including support for foreign language(s). 
    However we would be very much reliant on external help for local testing 
    and translation. We would be open to suggestions. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq02
cEcEQUESTION (02) cEcA


    C++ is not default, C is - how do I change this ?? 


cEcEANSWER cEcA


    If your main programming language is C++, then you will require the cG.defcA 
    and cG.hcA files to be loaded in C++ mode by default, rather than 'C'. To 
    modify this hen the order of the file hooks has to be re-defined. 

    Within your cC<user>.emfcA, over-ride the default ordering by including the 
    line:- 
sB
        add-file-hook ".h .def"                                     fhook-cpp 

sA
    This adds a newer binding for "cG.hcA" and "cG.defcA" to C++, over-riding the 
    existing 'C' binding. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq03
cEcEQUESTION (03) cEcA


    GNU Emacs; are there any GNU Emacs bindings. ? 


cEcEANSWER cEcA


    No not at the moment. The GNU Emacs bindings would be added as a 
    compatibility file (meemacs.emf) in much the same way that the me3.8 
    bindings are added, see meme3_8.emf. 

    From the user-setup(3), the user would then ask for "gnu" compatibility. 

    We would welcome submissions for a gnu compatibility file, gnu.emf, to add 
    to the release. 

    The cDMetacA key (typically cGAltcA) may be bound to key strokes, as opposed to 
    the menu short-cut from the lslmuser-setup(3)le as follows:- 

        cDHelpcA -> cDUser SetupcA -> cDGeneralcA -> cDAlt -> Main MenucA = N 
        cDHelpcA -> cDUser SetupcA -> cDGeneralcA -> cDAlt -> Esc PrefixcA = Y 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq04
cEcEQUESTION (04) cEcA


    Icons are not displayed correctly in Microsoft Windows environments !! 


cEcEANSWER cEcA


    After installing on Microsoft platforms, the Icons in the Explorer window 
    may not be showing correctly. To remedy the situation then the following 
    steps may be taken. 

    cDWindows '95cA 
        Try re-starting the system first. If the icons are still incorrect 
        then re-start in Safe mode and delete the file: 

        cGc:\windows\ShellIconCachecA 

        Restart and the Icons should be correct. 

    cDWindow '98cA 
        Try re-starting the system first. If the Icons are still incorrect 
        then re-start in Safe mode, this should re-generate the Icon cache. 
        Restart windows. 

    cDNTcA 
        Restart the system. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq05
cEcEQUESTION (05) cEcA


    ipipes not working on Microsoft Windows network drives ? 


cEcEANSWER cEcA


    We are aware of a problem with the ipipe commands with '95 and '98 (not 
    sure about NT) when the current drive is a Novel network drive. 

    Although we have not been ably to fully characterize the problem, we know 
    that:- 

        * Old Novel Clients prior to 2.2 - Does not work 
        * Novel Intranetware Client 2.2 - Does not work. 
        * Novel Network Client 2.5 - Does work. 
        * Novel Client 3.01 - Does work. 

    Any other information in this area would be appreciated to fully 
    characterize the problem. 

    To get around the problem then disable ipipes using lslm$system(5)le. From 
    within your cC<user>.emfcA knock off bit 0x800 from lslm$system(5)le. This will 
    enable regular pipes, which will work, albeit not in the background. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq06
cEcEQUESTION (06) cEcA


    Language not supported - will it be ?? 


cEcEANSWER cEcA


    We only support the (programming) languages that we have come into contact 
    with. If you are using a language that we are not supporting then you will 
    need to write a new cGhk<language>.emfcA file. See lslanguageTemplates(2)lmLanguage Templatesle on how 
    to map a new programming language. The list of currently supported file 
    types is defined in lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle. 

    Jasspa would appreciate any new templates that people define for standard 
    file types so that we can add them to the distribution. 

    For Microsoft Windows, any associated "me" icons types would also be 
    appreciated. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq07
cEcEQUESTION (07) cEcA


    Language file is incomplete 


cEcEANSWER cEcA


    For a number of the (programming) language templates we have only provided 
    a sub-set of the commands, this is typically because we only use a sub-set 
    ourselves. 

    For a number of templates, there is no indent support (see lslmindent(2)le and 
    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle). 

    Note that when extending the template then only standard words should be 
    added. Words which are local extensions should be added to a cGmyXXX.emfcA. 

    Jasspa would appreciate completed template definitions. 


cEcESEE ALSO cEcA


    lsfaq06(0f)lmFAQ06le 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq08
cEcEQUESTION (08) cEcA


    Input locked up and not accepting keys; how do I unlock ? 


cEcEANSWER cEcA


    This sometimes happens if a macro has been aborted badly. Typically a few 
    "Ctrl-G"s (see lslmabort-command(2)le) will terminate the macro and return 
    control back to the caller. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq09
cEcEQUESTION (09) cEcA


    MicroEmacs Bindings; How do I get the original MicroEmacs bindings ? 


cEcEANSWER cEcA


    From lslmuser-setup(3)le set the Emulation to "cGMicroEmacs v3.8cA". On re-starting 
    (or Current) the macro file cGmeme3_8.emfcA is executed and the bindings 
    loaded. This file should restore your familiar execution set. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq10
cEcEQUESTION (10) cEcA


    Microsoft Windows Locks up after killing an ipipe. 


cEcEANSWER cEcA


    This is a known problem for '95/'98 (not NT), on killing an ipipe. 
    Sometimes the "Winoldapp" locks up, if this is the case use "Alt-Ctrl-Del" 
    to bring up the "cDClose ProgramcA" dialogue, kill off the "cGWinOldAppcA" if it 
    is not responding. 

    MicroEmacs will then come back. We are looking for ways around this 
    problem at the moment. From the programming perspective Windows is just 
    not as nice as UNIX - which just works !! 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq11
cEcEQUESTION (11) cEcA


    Mouse support under Microsoft windows is strange !! 


cEcEANSWER cEcA


    The mouse operation under Microsoft windows (and DOS) is biased towards a 
    3-button mouse operation (Logitech is ideal !!), operating in a similar 
    way to UNIX. i.e. <select> operation gets text <Middle button> yanks text 
    back. 

    This stems from the fact that we all came from UNIX backgrounds. We have 
    had a number of comments about this already and do plan to address this 
    issue. 

    cDNote:-cA Those of you that have already had a little dip into the operation 
    of the mouse will have probably worked out that the whole of the visible 
    mouse/screen interaction is driven through macros, so this functionality 
    is actually a macro change. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq12
cEcEQUESTION (12) cEcA


    Scroll bars too narrow !! 


cEcEANSWER cEcA


    You can change the width of the scroll bars to double width from 
    lslmuser-setup(3)le "Wide Scroll Bars". Alternatively, you may do this yourself 
    from cG<user>.emfcA by:- 
sB
        set-variable $scroll-bar &bor $scroll-bar 1 

sA
    See lslm$scroll-bar(5)le. 

    Remember if you have enabled wide scroll bars, under windows, or 
    X-Windows, you may want to change your start-up screen width to cG82cA 
    characters rather than cG80cA - see lslmchange-screen-width(2)le. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq13
cEcEQUESTION (13) cEcA


    Tab key; Why does the tab key not operate in some windows ?? 


cEcEANSWER cEcA


    In buffers with indentation information the tab key re-computes the 
    indentation of the line. This behavior may be changed from the user-setup. 

    Refer to documentation for lslm$system(5)le and lslmuser-setup(3)le. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq14
cEcEQUESTION (14) cEcA


    Termcap; On a color terminal why is there no color ?? 


cEcEANSWER cEcA


    MicroEmacs has to be enabled to show color by default. From lslmuser-setup(3)le 
    enable "Termcap Color". This will give you basic colors. 

    You may also try enabling "With Bold" - this may increase the range of 
    colors. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq15
cEcEQUESTION (15) cEcA


    Termcap; Some of the keys do not work - how can I bind them ? 


cEcEANSWER cEcA


    In your user setup <user>.emf add the new keys. You have to be careful as 
    to the environment and probably need to do something like the following:- 
sB
        ; First check we are not an Xterm 
        !if &not $use-x 
            ; Quick check on the terminal type. We probably need to 
            ; distinguish between terminal types for different bindings 
            !if &seq $TERM "myterm" 
                translate-key "<from>" "<to>" 
                ... 
                translate-key "<from>" "<to>" 
            !endif 
        !endif 

sA
    See lslmtranslate-key(2)le for details of translating termcap keys. See 
    lslmdescribe-key(2)le to help identify the key. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq16
cEcEQUESTION (16) cEcA


    Timestamp; Format incorrect, how can I change to MMDDYY.hhmm ? 


cEcEANSWER cEcA


    From within your cC<user.emf>cA set the time stamp default format i.e. 
sB
        set-variable $timestamp "<%M%D%Y.%h%m>" 

sA
    See lslm$timestamp(5)le. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq17
cEcEQUESTION (17) cEcA


    Windows; Component characters rendered incorrectly, how do I fix ? 


cEcEANSWER cEcA


    If some of the components of the windows are rendered incorrectly, 
    typically caused by local variations of character sets, then new window 
    component characters may be defined. See lslm$window-chars(5)le for details on 
    how to define new character replacements. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq18
cEcEQUESTION (18) cEcA


    Windows Autosave and Backup files; are these potentially a problem ? 


cEcEANSWER cEcA


    For windows '95 up until OEM service release 2, the OS could not 
    distinguish the difference between the files:- 

        .xxx 
        .xxx~ 


    on a read, we have managed to find a work around for this, however we 
    would advise that the 3 letter extension is adhered to for these releases. 
    For releases of '95 OEM service release 2 and greater, '98 and NT we have 
    not found a problem with any of the auto save and backup naming. 

    Obviously, the backup naming will depend on the native file system. For 
    instance if your system administrator has not enabled long file names on 
    your Novel server. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq19
cEcEQUESTION (19) cEcA


    Printing; Why in Windows does the output come out in a buffer ?? 


cEcEANSWER cEcA


    Use the cDFilecA -> cDPrinter SetupcA dialog and change the destination to the 
    "cDDirect to printercA". 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq20
cEcEQUESTION (20) cEcA


    Printing; On Windows which font should I use ?? 


cEcEANSWER cEcA


    We suggest that "cDCourier NewcA" is used as the print font. This scales well 
    and supports the full character set. Problems have been reported with 
    networked postscript printers when used in conjunction with fixed fonts. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq21
cEcEQUESTION (21) cEcA


    Printing; My printer is not supported ? 


cEcEANSWER cEcA


    We are in the process of providing native postscript generation - UNIX 
    users can stream their output through "a2ps" and then into their standard 
    printer queues. 

    Windows, the support is already built in. 

    For DOS then you need to get your printer manual out and sort out how to 
    map the printer codes onto fonts. The printer codes are added to 
    "cGprinter.erfcA". We have already provided support for the HP DeskJet printer 
    (PCL), look at this printer definition for some help as to the type of 
    information that you need to set up. It's all a bit fiddley, but you do 
    not get much choice if you want more than plain ASCII out. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq22
cEcEQUESTION (22) cEcA


    Alt key maps to the Menu, how do I change ? 

    A-f opens the main File menu instead of executing forward-word (esc f). 
    How do I make the Alt key act like the Meta key all the time? 


cEcEANSWER cEcA


    The cDMetacA key (typically cGAltcA) may be bound to key strokes, as opposed to 
    the menu short-cut from the lslmuser-setup(3)le as follows:- 

        cDHelpcA -> cDUser SetupcA -> cDGeneralcA -> cDAlt -> Main MenucA = N 
        cDHelpcA -> cDUser SetupcA -> cDGeneralcA -> cDAlt -> Esc PrefixcA = Y 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq23
cEcEQUESTION (23) cEcA


    me32.ini - Where does it go, how do I know it's being processed ?? 


cEcEANSWER cEcA


    Question posed as:- 

        > 1)  Am I right in assuming that for NT the file me32.ini goes 
        >     into  %windir%, i.e. into c: 


    Yes, this is where the other .ini files are. 

        > 2)  How do I know me32.ini is being processed?  Creating one, 
        >     as described in the readme.txt file doesn't seem to have 
        >     any visible effect. 


    From within the editor, if you show the variable lslm$MEPATH(5)le, then it 
    should echo the paths that you have defined in the me32.ini file. 

        esc-x describe-variable 
        $MEPATH 


    See: lslmme32.ini(8)le, lsInstallation(1)lmInstallation Informationle, lsUserProfiles(2)lmSetting Up A User Profilele. 

        > 3) What does the "fontfile" statement do ? 


    For releases after May 1999 then the cCfontfilecA statement may be omitted as 
    typically cDLucida ConsolecA or cDCourier NewcA is used. If you want to use the 
    fixed OEM fonts then cCfontfilecA should be defined as cDapp860.foncA (or local 
    language equivalent), this forces the font to be loaded as a resource, 
    prior to use. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq24
cEcEQUESTION (24) cEcA


    Windows - Where is app850.fon ? 


cEcEANSWER cEcA


    "app850.fon" is the font file used for the DOS window under '95/'95/NT. 
    You should find it in your c: hidden. If you search from the 
    Explorer->Tools->Find "app850.fon" it should be found in the fonts 
    directory. There is nothing to be done - the file exists and is in the 
    correct location. 

    If you do not have this file then, you might have "appXXX.fon", or some 
    other fixed font. You can locate the file that you want as follows:- 

        Start->Settings->Control Panel->Fonts 

    Display the font list as 'details'. Within that list you should find a 
    "MS-DOS CPXXX" entry. It will be a red font (if you are in monochrome then 
    it will have a 'A' in the box rather than a 'Tt'). This is a fixed font 
    and will be a good alternative to "app850.fon", you can also try the 
    "Fixedsys" font file which has some weird name. 

    To be honest I do not know what Microsoft are currently shipping. Most of 
    the Windows platforms that I have used have been upgrades or been abused 
    by so many people you never know what is original !! 

    We would be interested in any details of other fixed fonts, which support 
    the full OEM character set that are better alternatives to the DOS ones. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq25
cEcEQUESTION (25) cEcA


    Time; mode line is showing the date in DD/MM/YY format how do I change ? 


cEcEANSWER cEcA


    From within your user setup, over-ride the default mode line setting with 
    the modifications you require. i.e. to change the date format to MM/DD/YY 
    use:- 
sB
        set-variable $mode-line "%s%r%u%k %b %l - %h:%m %M/%D/%Y (%e) - (%f) " 

sA

cEcESEE ALSO cEcA


    lslm$mode-line(5)le. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq26
cEcEQUESTION (26) cEcA


    C or C++ indentation and effects; how can I turn off ? 


cEcEANSWER cEcA


    The lslmcmode(2m)le is supposed to make editing 'C' easier, by forcing the user 
    to follow a preset editing convection. The layout is pretty standard, 
    following a 4 space indent, writing either K&R or standard 'Pascal' type 
    layout, with braces aligning vertically. 

    The problem most new users have is the inability of the tab key to 
    function, or more simply do not want to be 'forced' to write in a 
    particular style (GNU writers will probably not like this either - 
    conversely they will be using GNU emacs !!). However the constrained 
    layout can be configured to create most styles and does help in a project 
    situation, whereby most of the authored code roughly adheres to the same 
    sort of layout conventions. For C++ users then edit "cGhkcpp.emfcA" rather 
    than "cGhkc.emfcA". 


cETo turn off all automatic 'C' layout cA


    To disable ALL automatic layout then edit "hkc.emf" and turn "cmode" off. 
    It is probably quite useful to apply "indent", this will return the cursor 
    to the same indentation column whenever a new line is inserted. i.e. in 
    "fhook-c" of hkc.emf:- 
sB
        0 buffer-mode "cmode" 
        1 buffer-mode "indent" 

sA
    If you want proper tabs then you may also want to add:- 
sB
        0 buffer-mode "tab" 

sA
    This inserts the <tab> character into the text, rather than translating to 
    spaces. Alternatively disable cDtabcA mode for all file type using 
    lslmuser-setup(3)le i.e. 

        cDHelpcA -> cDUser SetupcA -> cDGeneralcA -> cDTabcA 


cETo re-enable the <tab> key cA


    To retain the 'C' layout aid, but re-enable the tab key operation then 
    disable the cDTab To IndentcA option in lslmuser-setup(3)le i.e. 

        cDHelpcA -> cDUser SetupcA -> cDGeneralcA -> cDTab To IndentcA 

    This enables the use of the TAB key in all column positions with the 
    exception of column 0. A <tab> in Column 0 will still enable the automatic 
    line re-formatting. 

    If you want real <Tabs> then disable the cDtabcA mode using lslmuser-setup(3)le i.e. 

        cDHelpcA -> cDUser SetupcA -> cDGeneralcA -> cDTabcA 


cETo change the 'C' Indentation Layout cA


    The 'C' layout indentation is controlled from the system variables:- 

        lslm$c-case(5)le, lslm$c-contcomm(5)le, lslm$c-continue(5)le, lslm$c-margin(5)le, lslm$c-brace(5)le, 
        lslm$c-statement(5)le. 

    These settings may be defined in your <user>.emf to change the default 
    layout. Refer to the on-line documentation for details. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq27
cEcEQUESTION (27) cEcA


    fill-paragraph function does not fill ?? 

    I can't seem to get the fill-paragraph function to fill the following 
    paragraph: 

        This is a very 
        poorly formed paragraph 
        which refuses to fill 
        properly! 


cEcEANSWER cEcA


    The default justification mode is Auto which tries to work out the mode 
    required for each paragraph. Its fairly smart at maintaining a documents 
    indentation, e.g. consider the example right hand justified: 

                                                            This is a very 
                                                   poorly formed paragraph 
                                                     which refuses to fill 
                                                                 properly! 


    It will maintain this indentation. The problem comes when the detected 
    form is not the required form as in the example. The detected paragraph 
    justification to be used is "none" because the lines are short. There are 
    2 ways to solve this problem: 

        * You can change the lslm$fill-mode(5)le to left or both (in fhook-doc mode 
          use C-c l or C-c b) and then use fill-paragraph as normal. 
        * Manually concatenate the first few lines into one to create a longer 
          first line and then use the fill-paragraph a normal, i.e. change the 
          paragraph to: 

        cGThis is a very poorly formed paragraph which refuses to fillcA cGproperly 
        !cA 

        and then fill. This works because the longer line will lead to a 
        different assessment of what's required. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq28
cEcEQUESTION (28) cEcA


    Key modifier which acts as the ESC key; what is it ? 

    What is the modifier key which acts as the ESC key ? Having to type ESCAPE 
    and then f to move one word forward is very boring. 

    With Gnu Emacs (on Unix systems), there is a "meta" modifier key which is 
    a shortcut for pressing ESCAPE followed by the command key. The "meta" key 
    should be the "Alt" key. 


cEcEANSWER cEcA


    The "meta" key is the "Alt" key. But 'F' is the Main menu hot-key for the 
    'File' sub-menu so by default 'A-f' will open the File sub-menu. This can 
    be disabled by clearing bit 0x2000 in the $system variable. This option 
    can now be set using user-setup (Alt -> Main Menu). 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq29
cEcEQUESTION (29) cEcA


    find-file start location; where is it ? 


cEcEANSWER cEcA


    The lslmfind-file(2)le start location is defined as follows:- 

        * cG*scratch*cA is current buffer; the current working directory. 
        * cGfilecA is current buffer; the directory location containing cCfilecA. 

    Running under Microsoft Windows or UNIX, using an icon launch, then it may 
    become frustrating that the start location is always cGC:\ProgramcA 
    cGFiles\JASSPA\MicroEmacscA (Microsoft windows) or cG/usr/local/bincA (UNIX) this 
    is simply resolved by starting the executable with the cD-ccA option, as 
    defined by lslmme(1)le. The cD-ccA option starts the editor with the last editing 
    session, this is typically where a user will want to commence an editing 
    session. 

    If the cD-ccA approach is not acceptable, then it is worth defining the 
    environment variable cG$HOMEcA within the start up script, or in the users 
    environment. Using cDfind-filecA with tilde (cG~cA) implies that the directory 
    start path is cG$HOMEcA. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq30
cEcEQUESTION (30) cEcA


    Re-using a MicroEmacs session; how to ?? 


cEcEANSWER cEcA


    A MicroEmacs editing session may be re-used, such that the current editor 
    is prompted to load a new file externally. This is typically invoked from 
    a short-cut launch from a file manager i.e. cDExplorer(1)cA, cDTkdesk(1)cA etc. 

    In order to facilitate the re-use of the session, then lslmme(1)le is invoked 
    with the cD-ocA option, this locates the active editor session and passes the 
    file load request. If an existing session does not exist then a new 
    session is started. 

    In order for this mechanism to operate, then the lsClient-Server(2)lmClient-Server Interfacele 
    must be enabled from the lslmuser-setup(3)le i.e. 

        [cDHelpcA -> cDUser SetupcA -> cDPlatformcA -> cDClient ServercA = cGYcA] 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq31
cEcEQUESTION (31) cEcA


    Microsoft Drag and Drop; is it supported ?? 


cEcEANSWER cEcA


    MicroEmacs '02 supports Microsoft cCdrag and dropcA interaction. Multiple 
    files and directories may be dragged from Microsoft Explorer (or other 
    application) and dropped into a buffer window. The destination buffer 
    window is the window in which the dropped file(s) are displayed. 

    cDNotecA if the user is currently on the command line, then the command line 
    operation is aborted in order to facilitate the cCdroppedcA files. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq32
cEcEQUESTION (32) cEcA


    Cut and Paste to/from other applications; is it supported ?? 


cEcEANSWER cEcA


    MicroEmacs '02 supports cCcut and pastecA operations on all platforms. 

    To copy a region from MicroEmacs '02 to another application 
        Select a region (with the mouse or keys) - there is no need to invoke 
        a copy operation. All selected text is immediately available to other 
        applications. 

        Move to the new application and paste, as dictated by the platform. 

    To copy a region from another application to MicroEmacs '02 
        Select the region in the application into the clipboard, as dictated 
        by the platform. 

        Move to MicroEmacs '02, position the cursor and lslmyank(2)le (cGC-ycA or 
        typically the middle mouse button) the clipboard text. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq33
cEcEQUESTION (33) cEcA


    Fonts; how can I change the font ?? 


cEcEANSWER cEcA


    The currently selected font may be modified from the lslmuser-setup(3)le. 

        cDHelpcA -> cDUser SetupcA -> cDPlatformcA 

    The font selection depends upon the platform, in all cases a fixed font 
    should be selected, otherwise rendering anomalies will result. 

    If you are running on Microsoft platforms ensure that the cDOEM/ANSIcA flag 
    matches the settings of the cDDisplay Font SetcA entry. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq34
cEcEQUESTION (34) cEcA


    Colors; how can I change screen colors ?? 


cEcEANSWER cEcA


    The screen colors are selected from the lslmuser-setup(3)le. 

        cDHelpcA -> cDUser SetupcA -> cDPlatformcA -> cDColor SchemecA 

    The default setting is cCWhite on BlackcA, the cCBlack on CreamcA is the most 
    popular setting. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq35
cEcEQUESTION (35) cEcA


    File Types; how do I interchange between UNIX, Windows and DOS files ?? 


cEcEANSWER cEcA


    MicroEmacs '02 facilitates the editing of the standard file types on all 
    platforms. All files retain their line ending type through edits. i.e. if 
    a DOS file is edited on a UNIX system, the file is still written as a DOS 
    file. When new files are created, they are created with the standard 
    attributes of the host O/S. 

    The line ending of the file may be modified from the menu 

        cDfilecA -> cDattributescA 

    This brings up a dialog that allows the file type and attributes to be 
    modified. 

    Note that the only ending that is NOT preserved are files whose lines end 
    in cG<CR>cA's only. The line format is correctly interpreted on reading, but 
    is not retained on the write. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq36
cEcEQUESTION (36) cEcA


    Non-English Languages; What font should I select ?? 


cEcEANSWER cEcA


    MicroEmacs '02 has only been tested with Western Lanuguages only. Within 
    the Microsoft Windows environment an ANSI type font should be selected, 
    assuming of course that the characters required are in the ISO-Latin 
    character set. UNIX typically supports ISO-Latin character sets. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq37
cEcEQUESTION (37) cEcA


    MicroEmacs '99; How do I up-grade from MicroEmacs'98 ?? 


cEcEANSWER cEcA


    Backup your current version! 

    Follow the MicroEmacs'99 installation procedure to install and get 
    MicroEmacs'99 running. 

    Due to the great improvement to lslmuser-setup(3)le it is advised that the user 
    creates a new setup using cDuser-setupcA and then migrates required macro code 
    changes from the old release into the new. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq38
cEcEQUESTION (38) cEcA


    Some keys on my foreign keyboard do not work properly, how do I get them 
    working ?? 


cEcEANSWER cEcA


    The most common problem are with foreign keyboards where the <AltGr> key 
    is used to generate some characters in a similar fashion to the <Shift> 
    key. For example, on a Belgian keyboard the '9' key produces a '{' 
    character when the <AltGr> key is also pressed. 

    The quickest and best solution is to use the cDKeyboardcA setup on the 
    Start-Up page of lslmuser-setup(3)le. This however may not provide the solution 
    as not all keyboards are currently supported. If you are using an 
    unsupported keyboard please send configuration information back to JASSPA 
    for inclusion in the next release. The keyboard configuration information 
    is stored in the macro file cGkeyboard.emfcA. 

    If cDuser-setupcA does not currently support your keyboard, or you wish to 
    remap some keys, then the command lslmtranslate-key(2)le should be used. 
    cDtranslate-keycA remaps generated key stroke(s) into another key at a low 
    level so the mapping is supported in all areas. If a macro and key binding 
    were used instead, while they would work in the main text windows, they 
    would not work in the message line. See help on cDtranslate-keycA for more 
    information. 

    Note that some <AltGr> keys can produce 2 keys, for example on a Belgian 
    keyboard '<AltGr>-9' produces the key 'A-C-9' first, immediately followed 
    by 'A-C-{'. This is an unfortunate side effect of windows, it is better to 
    have two keys rather than none. But this does add confusion to the 
    problem! Again, see cDtranslate-keycA for more information. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq39
cEcEQUESTION (39) cEcA


    Tabs; How to change the tab width ?? 


cEcEANSWER cEcA


    There are two variables that change the width of the tab lslm$tabwidth(5)le and 
    lslm$tabsize(5)le they control the size of a displayed tab character (number of 
    spaces) and the simulated tab character size, where the user entered tab 
    character is replaced by a number of space characters. The latter is only 
    used when lslmtab(2m)le mode is enabled (it is typically enabled by default). 

    To change the tab character width then the lslmset-variable(2)le command is 
    used: 

        esc x set-variable 


    You will then be prompted for the remaining arguments. cG<TAB>cA is the 
    completion so:- 

        esc x set-v<TAB> 
        $tabw<TAB> 
        2 


    If this is the setting that you always want to use then it is easier if 
    you put this in your <user.emf> as:- 
sB
        set-variable $tabwidth 2 

sB
    then whenever you start a new session you will always have the $tabwidth 
    defined as you want it. 

    We would recommend that lslm$tabwidth(5)le is not modified because it turns the 
    all tab's to 2 so when you read it into something like Microsoft notepad 
    the indentation is not as you like it because it displays tabs as 8 
    characters. 

    Instead, set the cD$tabsizecA to 2, and run with lslmtab(2m)le enabled (this is the 
    default). This turns cG<TAB>cA's to spaces, hence the layout is retained. This 
    makes the file slightly larger, but the presentation is maintained. 

    If you are reading in a file with TAB's embedded then you can convert all 
    of the <TAB>'s to spaces using lslmtabs-to-spaces(3)le: 

        esc x tabs-to-spaces 


    If these TAB's are 8 characters, and they should be displayed as 2, then 
    prior to conversion change the tabwidth, convert and then restore. 

        * Change the $tabwidth to 2 
        * tabs-to-spaces 
        * Restore the $tabwidth to 8 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq40
cEcEQUESTION (40) cEcA


    Windows/DOS; Where do I get grep/diff etc. ?? 


cEcEANSWER cEcA


    For windows and DOS users the UNIX tools may be obtained from:- 

        ftp://ftp.cdrom.com/pub/garbo/garbo_pc/unix/uxutl23a.zip (238 Kb) 
        ftp://ftp.cdrom.com/pub/garbo/garbo_pc/unix/uxutl23b.zip (227 Kb) 
        ftp://ftp.cdrom.com/pub/garbo/garbo_pc/unix/uxutl23c.zip (221 Kb) 
        ftp://ftp.cdrom.com/pub/garbo/garbo_pc/unix/uxutl23d.zip (160 Kb) 


    comments for this at: 

        http://www.geocities.com/SiliconValley/Lakes/1401/softlib1.htm 


    One awk-port; the Gnuish project has 16 bit and 32 bit versions of cDgawk(1)cA 
    in: 

        ftp://mirrors.aol.com/pub/simtelnet/gnu/gnuish/gawk303x.zip (1997, 495K) 


    Acknowledgment: cDDGcA - 99/07/02 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq41
cEcEQUESTION (41) cEcA


    Home/End Keys; How do I change the default bindings ?? 


cEcEANSWER cEcA


    Some users prefer the cGHOMEcA and cGENDcA keys to map to the beginning and end of 
    the line, rather than beginning/end of the buffer, respectively. Within 
    the cC<user>.emfcA the following global bindings may be applied to re-assign 
    the key mappings:- 
sB
        global-bind-key "beginning-of-buffer" "C-home" 
        global-bind-key "end-of-buffer"       "C-end" 
        global-bind-key "end-of-line"         "end" 
        global-bind-key "beginning-of-line"   "home" 

sA
    Acknowledgment: cDDGcA - 99/07/02 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0ffaq42
cEcEQUESTION (42) cEcA


    tags; How do I generate a MicroEmacs compatible tags file ?? 


cEcEANSWER cEcA


    A cDtagscA file is used by the lslmfind-tag(2)le command. This is used to hypertext 
    to the cCtaggedcA definition or variable. The standard cDctags(1)cA format is used 
    by MicroEmacs. The cDtagscA file itself may be generated by MicroEmacs '02 
    from the menu (cCTools->XX Tools->Create Tags FilecA). Alternatively a cDtagscA 
    file may be generated by the cDctags(1)cA utility. This is typically standard 
    on UNIX platforms. For Windows and DOS platforms then the cDExuberant CtagscA 
    is recommended, this is available from:- 

       cG http://darren.hiebert.comcA 

    A MicroEmacs '02 compatible tags file may be generated using the command 
    line "cGctags -N --format=1 ."cA cataloging the current directory. To generate 
    cDtagscA for a directory tree then use "cGctags -NR --format=1 .cA". Refer to the 
    cDExuberant CtagscA documentation for a more detailed description of the 
    utility. 

    The user variable lslm%tag-option(5)le may be used to enable lslmfind-tag(2)le to 
    locate a recursivelly generated cDtagscA file from a parent directory. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 0fFAQs
!3  faqs - FAQ Contact information
cEcEFREQUENTLY ASKED QUESTIONS - Contact Information cEcA


    This document contains frequently asked questions submitted to JASSPA. Use 
    the E-Mail reflector and associated logs, described in the lsMicroEmacs '02 - Contact InformationlmContactln
    lnInformationle section, alternatively questions may be submitted to:- 

        cGEmail:support@jasspa.comcA 

    We cannot promise to resolve all questions, but will endeavor to answer 
    most. We would also appreciate comments on how to improve the readability 
    of the documentation or suggestions for improvements where you think the 
    documentation is deficient. 

    lsFrequently Asked Questionslm[FAQ Index]le. 

! 1 me
cEcENAME cEcA


    me - MicroEmacs '02 text editor 


cEcESYNOPSIS cEcA


    cDmecA [cCoptionscA] [cCfiles ...cA] 

    cDmecA [cD@cAcCstartupFilecA] [cD-bcA] [cD-ccA] [cD-dcA] [cD-hcA] [cD-icA] [cD-lcAcClineNocA] [cD-mcAcCcommandcA] [cD-ncA] 
    [cD-0cAcCfilecA] [cD-pcA] [cD-rcA] [cD-scAcCstringcA] [cD-ucAcCusernamecA] [cD-vcAcCvariable=stringcA] [cD-xcA] 
    cCfiles...cA 


cEcEDESCRIPTION cEcA


    cDMicroEmacs '02cA is a cut down version of the EMACS text editor, based on 
    Danial Lawrences MicroEmacs. cDMicroEmacs '02cA is a tool for creating and 
    changing documents, programs, and other text files. It is both relatively 
    easy for the novice to use, but also very powerful in the hands of an 
    expert. MicroEmacs '02 can be extensively customized for the needs of the 
    individual user. 

    cDMicroEmacs '02cA allows multiple files to be edited at the same time. The 
    screen may be split into different windows and screens, and text may be 
    moved freely from one window on any screen to the next. Depending on the 
    type of file being edited, cDMicroEmacs '02cA can change how it behaves to 
    make editing simple. Editing standard text files, program files and word 
    processing documents are all possible at the same time. 

    There are extensive capabilities to make word processing and editing 
    easier. These include commands for string searching and replacing, 
    paragraph reformatting and deleting, automatic word wrapping, word move 
    and deletes, easy case controlling, and automatic word counts. 

    For complex and repetitive editing tasks editing macros can be written. 
    These macros allow the user a great degree of flexibility in determining 
    how cDMicroEmacs '02cA behaves. Also, any and all the commands can be used by 
    any key stroke by changing, or rebinding, what commands various keys 
    invoke. 

    Special features are also available to perform a diverse set of operations 
    such as file encryption, automatic backup file generation, entabbing and 
    detabbing lines, executing operating system commands and filtering of text 
    through other programs. 

    The command line options to cDMicroEmacs '02cA are defined as follows:- 

    cD@cAcCstartFilecA 
        Initialize MicroEmacs '02 using cCstartFilecA[cD.emfcA]. The default when 
        omitted is cDme.emfcA. See lslmstart-up(3)le and lslmCommand Line Filtersle for more 
        information. 

    cD-bcA 
        Load next file as a binary file (binary editor mode, uses lslmbinary(2m)le 
        buffer mode). 

    cD-ccA 
        Continuation mode. Load cDMicroEmacs '02cA last edit session, restoring 
        the buffers to their previous loaded state and position. Note that 
        history mode must be enabled. The cD-ccA option is generally used with 
        windowing interfaces (X-Windows/Microsoft Windows) as the shortcut 
        icon invocation. 

    cD-dcA 
        Enable debug mode (for macro files). 

    cD-hcA 
        Show the help page (does not start the editor). 

    cD-icA 
        MS-DOS versions of cDMicroEmacs '02cA only. Insert the contents of the 
        current screen into the cD*scratch*cA buffer 

    cD-kcA[cCkeycA] 
        Load next file as an encrypted file (uses lslmcrypt(2m)le buffer mode). The 
        optional adjoining argument can be used to specify the decrypting key, 
        if this argument is not specify the user will be prompted for it on 
        start-up. 

    cD-lcAcClineNocA 
        Go to line cClineNocA in the next given file. Typically used with 
        utilities such a cDmore(1)cA where an external editor may be invoked from 
        other viewer. 

    cD-mcAcCcommandcA 
        Sends a lsClient-Server(2)lmclient-serverle command to an existing MicroEmacs session. The 
        command takes the form "cDC:cAcC<client>cAcD:cAcC<command>cA" i.e. to write "cGHellocA 
        cGWorldcA" on the message line then a client may issue the command:- 

            ; launch server 
            me & 
            ; send message 
            me -m "C:ME:ml-write \"Hello world\" 


        Note that the cC<command>cA is a MicroEmacs macro command, the escape 
        sequences must be adhered to. The cCclient-servercA interface is typically 
        used to load a file, this may be performed as follows:- 

            me -m "C:myutility:find-file \"/path/foo.bar\"" 


        The absolute path is specified in this type of transaction as the 
        current working directory of the active MicroEmacs session is unknown. 
        The cD-mcA option de-iconize's the existing editor session and bring it to 
        the foreground. 

    cD-ncA 
        UNIX X-Windows environments only and MicroSoft Windows NT console 
        versions. Execute cDMicroEmacs '02cA using termcap rather than X-Windows 
        for UNIX; typically used within an cDxtermcA shell to fire up cDMicroEmacs 
        '02cA for a quick edit. For Microsoft Windows, a console window is 
        started as opposed to a GUI window. 

    cD-ocAcC<file>cA 
        Use already running version of MicroEmacs '02 to load the cC<file>cA, if 
        it exists, otherwise start a new editor session. This uses the 
        cCclient-servercA interface to push the new file into the existing editor 
        session. Refer to the lsClient-Server(2)lmClient-Server Interfacele for details. 

    cD-pcA 
        Pipe cCstdincA into buffer cD*stdin*cA, when saved output to cCstdoutcA, following 
        is a simple example which changes 'cGacA's to 'cGbcA's: 
sB
                define-macro start-up 
                    find-buffer "*stdin*" 
                    beginning-of-buffer 
                    replace-string "a" "b" 
                    save-buffer 
                    quick-exit 
                !emacro 

sA
        This can be used in the following manner: 

                me "@testpipe.emf" < foo.a > foo.b 


    cD-rcA 
        Read-only, all buffers will be in view mode 

    cD-scAcCstringcA 
        Search for string "cCstringcA" in the current buffer. e.g. cGme -sfoo barcA 
        starts cDMicroEmacs '02cA, loads file cGbarcA and initiates a search for cCfoocA. 
        The cursor is left at the end of the string if located, otherwise at 
        the top of the buffer. 

    cD-ucAcCusernamecA 
        Set the current user name to cCusernamecA before MicroEmacs is 
        initialized. This is done by setting the environment variable 
        ls$MENAME(5)lmMENAME(5)le to the given value. 

    cD-vcAcCvariable=stringcA 
        Assign the MicroEmacs '02 cCvariablecA with cCstringcA. The assignment is 
        performed before the buffers are loaded. Typically used to change the 
        start-up characteristics of the startup file(s). 

    cD-xcA 
        UNIX environments. Disable the capture of signals. cDMicroEmacs '02cA by 
        default captures an handles all illicit signal interrupts. The option 
        is enabled when debugging the source code allowing exception 
        conditions to be trapped within the debugger. 

    cD-ycA 
        Load next file as a reduced binary file (uses lslmrbin(2m)le buffer mode). 


cEcEENVIRONMENT cEcA


    The following environment variables are used by cDMicroEmacs '02cA. 

    cDDISPLAYcA 
        UNIX environments running X-Windows only. The identity of the 
        X-Windows server. Typically set to cDunix:0.0cA, refer to the X-Windows 
        documentation for details of this environment variable. 

    cDMENAMEcA and cDLOGNAMEcA 
        The identity of the user, cD$MENAMEcA takes precedence over cD$LOGNAMEcA. 
        cD$LOGNAMEcA variable is generally defined within UNIX as part of the 
        login script. The variables are used to determine which start-up 
        configuration to use in the initialization of cDMicroEmacs '02cA 
        (cC$MENAMEcA.erf). 

        Non-UNIX platforms usually need to explicitly set the cD$MENAMEcA 
        environment variable to identify the aforementioned files. for MS-DOS 
        and Microsoft Windows this is typically performed in the cGAUTOEXEC.BATcA 
        file. 

    cDPATHcA 
        The cD$PATHcA environment variable is used on most operating systems as a 
        search path for executable files. This cD$PATHcA environment variable must 
        be defined with cDMicroEmacs '02cA on the search path. Under UNIX this is 
        set in the cG.logincA, cG.cshrccA or cG.profilecA file i.e. 

            export PATH $PATH:/usr/name/me 

        Within MS-DOS or Microsoft Windows environments it is defined in the 
        cGAUTOEXEC.BATcA file. e.g. 

            set PATH=%PATH%;c:\me 

        cDMicroEmacs '02cA utilizes information in the cD$PATHcA environment variable 
        to locate the start-up files, dictionaries etc. 

    cDTERMcA 
        The terminal identification sting. In UNIX environments the 
        environment variable cD$TERMcA is set to "cGvt...cA", in this case it is 
        assumed that the machine is a server, and the host cannot support X 
        (see command line option cD-ncA). 

        In MS-DOS the environment variable is usually set to define the 
        graphics adapter mode. cD%TERMcA is assigned a string, understood by the 
        cGme.emfcA start-up file, to set the graphics mode. Predefined strings 
        include:- 

        cDE80x50cA 
            Initiates an 80 column by 50 line screen. 

        cDE80x25cA 
            Initiates an 80 column by 25 line screen. 

        cCuserDefinedcA 
            A user defined string to set an explicit graphics card mode. The 
            operation is dependent upon the support offered by the graphics 
            adapter. 

    cDMEPATHcA 
        MicroEmacs '02 uses the environment variable cG$MEPATHcA as the 
        directory(s) used to search for the macro files (see lslmemf(8)le). Within 
        the UNIX cG$MEPATHcA is a semi-colon separated list of directories which 
        are used to search for the MicroEmacs '02 macro files. The path is 
        searched from left to right. The environment variable is typically 
        defined in the in the cG.logincA, cG.cshrccA or cG.profilecA file i.e. 

            export MEPATH /usr/name/me/macros:/usr/local/microemacs 

        The default when omitted is cG/usr/local/microemacscA. 

        Within MS-DOS or Microsoft Windows environments it is defined in the 
        cGAUTOEXEC.BATcA file. e.g. 

            set MEPATH=c:\me\username;\me\macros 

        There is no default location in these environments. For Microsoft 
        Windows environments refer to lslmme32.ini(8)le for a method of setting up 
        the cG$MEPATHcA from the windows configuration file. 

    cDINFOPATHcA 
        MicroEmacs '02 uses the environment variable cG$INFOPATHcA as the 
        directory(s) used to search for GNU cDInfocA files. Within the UNIX 
        cG$INFOPATHcA is a semi-colon separated list of directories which are used 
        to search for the MicroEmacs '02 macro files. The path is searched 
        from left to right. The environment variable is typically defined in 
        the in the cG.logincA, cG.cshrccA or cG.profilecA file i.e. 

            export INFOPATH /usr/local/info:$HOME/info 

        The default when omitted is cG/usr/local/infocA. 

        Within MS-DOS or Microsoft Windows environments it is defined in the 
        cGAUTOEXEC.BATcA file. e.g. 

            set MEPATH=c:\usr\local\info 

        There is no default location in these environments. For Microsoft 
        Windows environments refer to lslmme32.ini(8)le for a method of setting up 
        the cG$INFOPATHcA from the windows configuration file. 


cEcEFILES cEcA


    All of the macro files and dictionaries are located in the cDMicroEmacscA home 
    directory. The standard file extensions that are utilized are:- 

    lseaf(8)lm.eafle 
        cDMicroEmacs '02cA abbreviation file, defines completion definitions for 
        buffer dependent text expansion. 

    lsedf(8)lm.edfle 
        A cDMicroEmacs '02cA spelling dictionary. cC<language>cAcD.edfcA provide language 
        specific dictionaries; cC$LOGNAMEcAcD.edfcA is personal spelling dictionary. 

    lsehf(8)lm.ehfle 
        cDMicroEmacs '02cA help file information. On-line help information for 
        emacs, the main file is cGme.ehfcA. 

    lsemf(8)lm.emfle 
        A cDMicroEmacs '02cA macro file. The following classes of macro file 
        exist: 

        cDme.emfcA 
            The default startup file. 

        cC<platform>.emfcA 
            A platform specify startup file, these include UNIX generic 
            (cGunixterm.emfcA), UNIX specific (cGirix.emfcA, cGhpux.emfcA, cGunixwr1.emfcA, 
            cGlinux.emfcA, cGsunos.emfcA etc), Microsoft Windows (cGwin32.emfcA), MS-DOS 
            (cGdos.emfcA). 

        cDhkcAcCxxxxxxcAcD.emfcA 
            Buffer context specific hook files to initialize a buffer with 
            macros and highlighting appropriate to the contents of the file 
            type. e.g. 'C' language editing (cGhkc.emfcA), N/Troff typesetting 
            (cGhknroff.emfcA), UNIX Manual page display (cGhkman.emfcA), Makefiles 
            (cGhkmake.emfcA), etc. 

    lserf(8)lm.erfle 
        Registry files, used to retain personal information, users history in 
        the file etc. 

    lsetf(8)lm.etfle 
        Template files used to seed new files. Typically contains standard 
        header information, copyright notices etc. that are placed at the head 
        of files. The 'C' programming language is called cGc.etfcA 


cEcEMICROSOFT WINDOWS cEcA


    Microsoft Windows environments should refer to lslmme32.ini(8)le for a method of 
    setting up the environment variables without editing the cGAUTOEXEC.BATcA 
    configuration file. 


cEcESEE ALSO cEcA


    lslmemf(8)le, lslmerf(8)le, cDemacs(1)cA [GNU], cDmore(1)cA, cDvi(1)cA. 
    lsClient-Server(2)lmClient-Server Interfacele. 
    lslmCommand Line Filtersle. 

! 1 memsdev
cEcENAME cEcA


    memsdev - Microsoft Developer Studio Add-in for MicroEmacs '02 


cEcESYNOPSIS cEcA


    cDmemsdev.dllcA 


cEcEDESCRIPTION cEcA


    cDmeMsdevcA is a Microsoft Visual Studio Add-In that allows MicroEmacs '02 to 
    be integrated as the default text editor. It will be used instead of the 
    Visual Studio built in editor when you double click on a file or press F4. 


cEcEINSTALLATION cEcA


    cD1)cA Copy mesdev.dll into the MicroEmacs directory i.e. 

        c:/Program Files/JASSPA/MicroEmacs 


    cD2)cA Edit the lslmme32.ini(8)le file in your Windows directory and identify the 
    location of the MicroEmacs executable. The executable name is used to 
    spawn MicroEmacs if it is not already running. The entry takes the form:- 

        ; Identify the location of the MicroEmacs executable so that the 
        ; Developer Studio "Add-In" can locate the executable 
        [Location] 
        exe=c:\Program Files\JASSPA\MicroEmacs\me32.exe 


    Change the cCexecA entry to match the location and name of your executable. 

    cD3)cA For MS-DEV V5.0 only; from a DOS box, register the DLL using 
    cDregsvr32.exe(1)cA i.e. 

        > cd c:/Program Files/JASSPA/MicroEmacs 
        > regsvr32 memsdev.dll 


    For MS-DEV V6.0 it is not necessary to perform this registration step. 

    cD4)cA Start Visual Studio and goto:- 

        Tools 
            Customize... 
                Add-Ins and Macro Files 


    cD5)cA Click on cCBrowsecA and point Visual Studio to your cDmemsdev.dllcA file. 

    cD6)cA Click the check box to indicate that you want to use the Add-In, and 
    close the Customize dialog box. 

    cD7)cA You should notice the MicroEmacs tool bar showing the MicroEmacs Icon. 
    This invokes a dialog that allows you to attach and detach MicroEmacs as 
    the default editor. 


cEcEUSING meMsdev cEcA


    Clicking on the MicroEmacs Tool bar shows the meMsdev configuration 
    dialog. Check the boxes when MicroEmacs edit session is required as 
    default; uncheck the boxes if you wish to revert to the built-in dialog. 

    Use Visual Studio as normal, and MicroEmacs should almost always bring 
    MicroEmacs to the foreground to edit the document. If a MicroEmacs is 
    already running then "meMsdev" will attach to an existing session and will 
    load the file. If MicroEmacs is not detected then a new version is spawned 
    off and then an attachment is made. 


cEcERUNNING A DEBUG SESSION cEcA


    cDmeMsdevcA does not currently provide any debugging capability (but we are 
    working on it !!). To start debugging it is suggested that the Editor is 
    decoupled cC(MicroEmacs Dialogue -> Uncheck Boxes)cA and work within the 
    Developer studio. 

    When you have finished debugging and wish to move back to an edit session 
    then re-enable MicroEmacs cC(MicroEmacs Dialogue -> Check Boxes)cA AND close 
    any windows that are open within the MS-Dev environment ( 
    cCWindow->Windows...->Select AllcA and cCClose All WindowscA). Then commence 
    editing again. 

    While MicroEmacs is attached, selecting any of the find file lines, 
    compilation error lines etc within the response panes will take MicroEmacs 
    to the specified line. 


cEcEBUGS cEcA


    cDmeMsdevcA works by hooks exposed by Visual Studio. Most of the functionality 
    works from the OpenDocument (look it up in VS 5) hook. So...If a document 
    is ALREADY open in Visual Studio, and you double click the file in the 
    File Browser...Emacs will NOT come to the foreground. Since the document 
    was open in the Visual Studio editor, the OpenDocument event never 
    occurred. 


cEcEACKNOWLEDGEMENTS cEcA


    cDmeMsdevcA is based on the initial work from cDVisEmacscA performed by 
    cDChristopher PaynecA cC<payneca@sagian.com>cA for GNU Emacs. This software comes 
    under the GNU General Public License, as such, meMsdev is covered by the 
    same licensing. 

    Many thanks to Christopher for putting together this technology, this 
    manual page is derived from the documentation supplied with cCVisEmacscA. 


cEcELICENSING cEcA


    meMsdev is free software; you can redistribute it and/or modify it under 
    the terms of the GNU General Public License as published by the Free 
    Software Foundation; either version 2, or (at your option) any later 
    version. 

    meMsdev is distributed in the hope that it will be useful, but WITHOUT ANY 
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
    FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
    details. 

    You should have received a copy of the GNU General Public License along 
    with GNU Emacs; see the file COPYING. If not, write to the Free Software 
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 


cEcESEE ALSO cEcA


    cCMicrosoft Developer Studio Add-In DocumentationcA 

! 2 abort-command
cEcENAME cEcA


    abort-command - Abort command 
$a


cEcESYNOPSIS cEcA


    cDabort-commandcA (cDC-gcA) 


cEcEDESCRIPTION cEcA


    Aborts the current command, when in trouble, this command will usually 
    limit the damage. If you find yourself in a position where you do not want 
    to be then this command will usually take you back to a sane state. This 
    command rings the bell and stops keyboard macros. 

    Avoid re-binding this key where possible as it is used in other places. 

    When cDabort-commandcA is invoked a warning is automatically given alerting 
    the user, this may be an audible or a visual warning depending on the 
    global state of the lslmquiet(2m)le mode. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmquiet(2m)le. 

! 2 add-color
! 2 add-color-scheme
cEcENAME cEcA


|add-color
    add-color - Create a new color 
|add-color-scheme
    add-color-scheme - Create a new color scheme 
$a


cEcESYNOPSIS cEcA


    cDadd-colorcA "cCcol-nocA" "cCredcA" "cCgreencA" "cCbluecA" 
    cCncA cDadd-color-schemecA "cCschemeNumcA" "cCforecA" "cCbackcA" "cCcurrent-forecA" "cCcurrent-backcA" 
            "cCselected-forecA" "cCselected-backcA" 
            "cCcurrent-selected-forecA" "cCcurrent-selected-backcA" 
            [ "cCfm-forecA" "cCfm-backcA" "cCfm-cur-forecA" "cCfm-cur-backcA" 
            "cCfm-sel-forecA" "cCfm-sel-backcA" 
            "cCfm-cur-sel-forecA" "cCfm-cur-sel-backcA" ] 


cEcEDESCRIPTION cEcA


    cDadd-colorcA creates a new color and inserts it into MicroEmacs '02 colors 
    table, where cCredcA, cCgreencA and cCbluecA are the color components and cCcol-nocA is 
    the MicroEmacs '02 color table number. The color table contains 256 
    entries indexed by cCcol-nocA in the range 0-255. 

    On some platforms (DOS and UNIX termcap) the number of colors is 
    physically limited by the hardware to less than 256 (typically 16), in 
    this case all 256 colors can be defined and for each created color the 
    closest system color is used. 

    By default, only color 0 (white) and 1 (black) are defined. Once created, 
    the colors may be used to create color schemes, this is the sole use of 
    colors. 

    cDadd-colorcA may be used to modify an existing cCcol-nocA index by re-assignment, 
    the existing color definition is over-written with the new color 
    definition. cDadd-color-schemecA creates a color scheme entry used by 
    lslmhilight(2)le, lslmscreen-poke(2)le, lslmosd(2)le and variables such as 
    lslm$global-scheme(5)le, lslm$buffer-scheme(5)le, lslm$ml-scheme(5)le. 

    The command takes an index number "cCschemeNumcA" and eight color values 
    (defined by cDadd-colorcA) alternating between foreground and background 
    colors. The 8 colors represent the 4 color paired states of foreground and 
    background that may appear in a text buffer. The paired states correspond 
    to current and selected lines (or permutations thereof). If an argument cCncA 
    is given to the command then cCschemeNumcA is set to a duplicate of the cCncAth 
    scheme, no other arguments are required. 

    cCschemeNumcA is the identifying index that is used to recognize the scheme. 
    By default only two color schemes are defined at initialization, they are 
    a monochrome scheme and inverse scheme with indices 0 and 1 using white as 
    foreground and black as background, selected text is inverted. When 
    defining a color scheme, if an existing cCschemeNumcA index is used then that 
    scheme is modified. 

    The next eight arguments must be given, they specify foreground and 
    background color pairs for the four different situations, as follows:- 

    Default 
        Color combination used when none of the following three are 
        applicable. 

    Current 
        Color combination used when the text is on the same line as the 
        cursor. It is also used by the lslm$mode-line-scheme(5)le for the current 
        window's mode line and for the current selection on an lslmosd(2)le dialog. 

    Selected 
        Color combination used when the text is in the current selected 
        region, but is not on the current line. Also used by cDosdcA for 
        non-current item Hot keys. 

    Current-selected 
        Color combination used when the text is on the current line and in the 
        current selected region. Also used by cDosdcA for the current item's Hot 
        key. 

    The following 8 arguments set up fonts and are optional, any missing 
    arguments are defaulted to 0. Each argument is a bitmask indicating which 
    font should be enabled, where each bit is as follows: 

        cG0x01cA Enable bold font. 
        cG0x02cA Enable italic font. 
        cG0x04cA Enable light font. 
        cG0x08cA Enable reverse font. 
        cG0x10cA Enable underlining. 

    Normally only the foreground value is used, i.e. the first, third, fifth 
    and seventh values. But lslmscreen-poke(2)le can be used to draw reversed color 
    scheme in which case the background values are used. 


cEcEEXAMPLE cEcA


    The color palette is typically created at start-up via the configuration 
    file cDschemecAcCXcAcD.emfcA. These files are not easily read as they are 
    automatically generated via the lslmscheme-editor(3)le dialog. A more readable 
    form of "cGschemed.emfcA" would be as follows:- 
sB
        ; Standard colors 
        add-color &set .white     0 200 200 200 
        add-color &set .black     1 0   0   0 
        add-color &set .red       2 200 0   0 
        add-color &set .green     3 0   200 0 
        add-color &set .yellow    4 200 200 0 
        add-color &set .blue      5 0   0   200 
        add-color &set .magenta   6 200 0   200 
        add-color &set .cyan      7 0   200 200 
        ; Light colors 
        add-color &set .lwhite    8 255 255 255 
        add-color &set .lblack    9 75  75  75 
        add-color &set .lred     10 255 0   0 
        add-color &set .lgreen   11 0   255 0 
        add-color &set .lyellow  12 255 255 0 
        add-color &set .lblue    13 0   0   255 
        add-color &set .lmagenta 14 255 0   255 
        add-color &set .lcyan    15 0   255 255 
        ; Selection color 
        add-color &set .sel-col  16 91  78  131 
        ; Set the required cursor-color 
        set-variable $cursor-color .col12 
        ; Set up the standard schemes for the text, mode line message line, scroll bar and osd. 
        add-color-scheme $global-scheme  .white .black .lwhite .black ... 
            ... .white .sel-col .lwhite .sel-col 0 8 1 9 8 0 9 1 
        add-color-scheme $ml-scheme  .white .black .lwhite .black ... 
            ... .white .sel-col .lwhite .sel-col 0 8 1 9 8 0 9 1 
        add-color-scheme $mode-line-scheme  .white .red .lwhite .lred ... 
            ... .white .red .lwhite .red 8 0 9 1 0 8 1 9 
        add-color-scheme $scroll-bar-scheme .white .lblack .lwhite .lblack ... 
            ...  .lblack .white .lblack .lwhite 8 0 9 1 0 8 1 9 
            . 
            . 

sA

cEcENOTES cEcA


    Color schemes can be created and altered using the lslmscheme-editor(3)le 
    dialog, the created color scheme can then the used from start-up by using 
    the lslmuser-setup(3)le dialog. Therefore direct use of these commands is 
    largely redundant. 

    The existence of a color or scheme index is checked as each entry is 
    submitted, therefore any color or scheme used must have been previously 
    been created, otherwise a default value is substituted. 

    Changing any existing color definitions causes all references to the color 
    from a scheme to adopt the new color. 

    Changing any existing color-scheme definitions changes the rendered color 
    of any lslmhilight(2)le etc., that was using that color-scheme. 

    A -ve color scheme value (i.e. cC-ncA) uses the previous 'cCncA'th entry that is 
    defined in the color block. i.e. if cCcurrent-forecA was specified as -2 then 
    it would inherit the cCforecA field color. 

    Not all UNIX terminals support all the above fonts. 

    On some telnet packages color is not directly supported and some of the 
    termcap display attributes such as bold and italic are represented by a 
    color (e.g. italic text is shown in green). Using this translation it is 
    possible to achieve reasonable color support on a VT100 terminal - it is a 
    little awkward but is worth while if you have to use this type of 
    connection frequently. 


cEcESEE ALSO cEcA


    lslmscheme-editor(3)le, lslmuser-setup(3)le, lslmchange-font(2)le, lslmhilight(2)le, 
    lslmscreen-poke(2)le, lslm$buffer-hilight(5)le, lslm$cursor-color(5)le, lslm$global-scheme(5)le, 
    lslm$trunc-scheme(5)le, lslm$ml-scheme(5)le, lslm$osd-scheme(5)le, lslm$mode-line-scheme(5)le, 
    lslm$scroll-bar-scheme(5)le, lslm$system(5)le. 

! 2 add-dictionary
cEcENAME cEcA


    add-dictionary - Declare existence of a spelling dictionary 
$a


cEcESYNOPSIS cEcA


    cCncA cDadd-dictionarycA "cCfilecA" 


cEcEDESCRIPTION cEcA


    cDadd-dictionarycA adds the given dictionary (specified by the given cCfilecA) to 
    the dictionary list. Note that the cCfilecA may omit the cD.edfcA extension, this 
    is automatically added. 

    The command accepts a numeric argument 'cCncA' which determines the actions to 
    be undertaken. When cCncA is omitted then the dictionary is marked for loading 
    (on demand) - this is the standard invocation used in the start up files. 

    If an argument of cD0cA is given the dictionary is created but it is not 
    marked for loading, this can be used to create an empty dictionary. 

    If an argument of cD-1cA is given the contents of the dictionary are dumped 
    into the current buffer, used for dictionary maintenance. The two main 
    uses of this command are discussed below. 


cEDictionary Loading cA


    A call to cDadd-dictionarycA with no numeric argument does not perform an 
    immediate load of the dictionary, instead the dictionary is only loaded on 
    demand, i.e. when a call to lslmspell(2)le (usually via lslmspell-word(3)le or 
    lslmspell-buffer(3)le) is made, this ensures that the start up time for 
    MicroEmacs does not become too long. When the dictionary is loaded it is 
    checked for efficiency, if found to be inefficient it is automatically 
    optimized and flagged as changed. On exiting MicroEmacs, the user is 
    prompted to save any dictionary that has be altered or optimized. 

    The spelling search order is made from the last dictionary added to the 
    first, as soon as a word is found in a dictionary the search is halted. 
    This implies that if a word has been defined incorrectly in one 
    dictionary, but correct in another, the order in which the dictionaries 
    are added determines the result. 

    The number of dictionaries allowed is unlimited but note that any words 
    added are always added to the LAST dictionary. The size of the dictionary 
    is restricted to about 16Mb, the size is NOT tested when words are added 
    and if this size is exceeded the results are undefined. However, it is 
    unlikely that this limit will be reached, the largest dictionary created 
    to date is 0.8Mb. 

    A new main dictionary may be created as follows:- 

    cD1)cA 
        Find a file containing an cDispell(1)cA compatible list of words. 

    cD2)cA 
        lslmexecute-file(2)le spellutl.emf to define macro lslmspell-add-word(3)le. 

    cD3)cA 
        Start up MicroEmacs '02 and execute the command cDadd-dictionarycA giving 
        an appropriate new dictionary name. 

    cD4)cA 
        Load up the file containing the words and execute the command 
        lslmspell-add-word(3)le with a very large argument so all the words are 
        added. 

    cD5)cA 
        Save the dictionary by either executing the command lslmsave-dictionary(2)le 
        or exiting. 


cEDictionary Dump cA


    A call to cDadd-dictionarycA with a numeric argument cCncA of -1 causes the 
    contents of the given dictionary to be dumped into the current buffer 
    (make sure you are in an empty buffer or cD*scratch*cA) where: 

        cGxxxxcA - Good word cGxxxxcA with no spell rules allowed 
        cGxxxx/abccA - Good word cGxxxxcA with spell rules cGabccA allowed 
        cGxxxx>yyyycA - Erroneous word with an auto-replace to cGyyyycA 

    The dump of the dictionary may be edited, allowing erroneous entries to be 
    removed. The macro file cGspellutl.emfcA contains macros lslmedit-dictionary(3)le 
    and lslmrestore-dictionary(3)le which enable the user to edit a dictionary. 


cEcENOTES cEcA


    MicroEmacs '02 is supplied with a dictionaries for American and British 
    English, it is strongly suggested that these dictionaries are cDNOTcA modified 
    in anyway. Ensure that the dictionary is protected by loading the base 
    dictionaries first, followed by a personal dictionary. New words added 
    during spelling will then be added to the personal dictionary rather than 
    the main dictionary. 


cEcEEXAMPLE cEcA


    The MicroEmacs '02 start-up file cDme.emfcA executes cDlanguage.emfcA which in 
    turn executes the user language setup file, for example cDamerican.emfcA, 
    which adds the main language dictionaries and rules. cDlanguage.emfcA then 
    adds the user's dictionary, this process can be simplified to:- 
sB
        ; add the main American dictionary 
        add-dictionary "lsdmenus" 

        ; reset the spell rules 
        0 add-spell-rule 
        ; Now add the American spell rules 
        -2 add-spell-rule "A" "" "" "re" ; As in enter > reenter 
        -2 add-spell-rule "I" "" "" "in" ; As in disposed > indisposed 
            . 
            . 
        ; Now add the user dictionary 
        add-dictionary $MENAME 

sA

cEcESEE ALSO cEcA


    lslmadd-spell-rule(2)le, lslmsave-dictionary(2)le, lslmspell-add-word(3)le, 
    lslmedit-dictionary(3)le, lslmspell-buffer(3)le. 

! 2 add-file-hook
cEcENAME cEcA


    add-file-hook - Declare file name context dependent configuration 
$a


cEcESYNOPSIS cEcA


    cCncA cDadd-file-hookcA "cCextensionscA" "cCfhook-namecA" 


cEcEDESCRIPTION cEcA


    cDadd-file-hookcA defines a macro binding between a file name or file type and 
    a set of macros. This binding enables file type dependent screen 
    highlighting and key bindings to be performed. For a higher level 
    introduction refer to lsfileHooks(2)lmFile Hooksle. 

    cDadd-file-hookcA operates in two different modes to establish the type of 
    file:- 

        * Content recognition, by examination of the contents of the file. 
        * File extension recognition. 

    Content recognition has the highest priority and is used in preference to 
    the file extension. 

    cDadd-file-hookcA is called multiple times to add new recognition rules. The 
    rules are interrogated in last-in-first-out (LIFO) order, hence the 
    extension added last has a greater precedence than those added first. This 
    ordering allows default rules to be over-ridden. 


cEInitialization cA


    cDadd-file-hookcA must be initialized prior to the first call, using an 
    invocation of the form:- 
sB
        0 add-file-hook 

sA
    with a numeric argument cCncA of 0, and no arguments. This invocation resets 
    the file hooks by deleting all of the installed hooks. 


cEFile Extension Recognition cA


    cDadd-file-hookcA with no numerical argument cCncA allows the extension of a file 
    (or the base file name if there is no extension) to be used to determine 
    which user defined setup macro is to be executed. The cCextensionscA argument 
    is a space separated list of cCfile endingscA (as opposed to true extensions) 
    and is usually specified with the extension separator. For example, the 
    extension "cG.doccA" may indicate that the file is a document and therefore 
    the lsindent(2m)lmindentle, lswrap(2m)lmwraple and lsjustify(2m)lmjustifyle buffer modes are required. This may be 
    performed automatically by defining a macro which adds these modes and 
    adding a file hook to automatically execute this macro whenever a file 
    "cG*.doccA" is loaded. 

    The command arguments are defined as follows:- 

    cCextensionscA 
        A space separated list of file extensions, which are to be checked, 
        this list includes the extension separator (typically dot ('cG.cA'). It 
        should be noted that the extension search is actually a comparison of 
        the tail of the string, as such files such as cCmakefilecA, which do not 
        have an extension, are specified literally. 

    cCfhook-namecA 
        The name of the file hook to execute. This is the name of the macro to 
        execute that initializes the buffer. 

    As an example:- 
sB
        define-macro fhook-doc 
            1 buffer-mode "indent" 
            1 buffer-mode "wrap" 
            1 buffer-mode "justify" 
        !emacro 

        add-file-hook ".doc" "fhook-doc" 

sA
    It is quite possible that the same macro should be executed for a text 
    file, i.e. "cG*.txtcA" this is achieved by a single cDadd-file-hookcA as the space 
    (' ') character is used as an extension separator, e.g. 
sB
        add-file-hook ".doc .txt" "fhook-doc" 

sA
    There are three special file hooks, which are cDfhook-binarycA, cDfhook-rbincA and 
    cDfhook-defaultcA, these are not predefined, but if the user defines them then 
    they are executed whenever a file is loaded in lsbinary(2m)lmbinaryle or lsrbin(2m)lmreduced binaryle 
    mode (see lslmbuffer-mode(2)le) or the extension does not match any of those 
    defined. 

    Considering the cGfhook-XXXcA prefix, the initial 'cDfcA' character must be 
    present as this is changed to a 'cDbcA' and an 'cDecA' when looking for the enter 
    (begin) buffer and exit buffer hooks. These hooks are executed whenever 
    the user swaps to or from a buffer (including creating and deleting). So 
    for the given example, if the tab size of 8 is required in a document (but 
    4 elsewhere) then this operation this is performed by defining the 
    cGbhook-XXXcA and cGehook-XXXcA macros, e.g.:- 
sB
        define-macro bhook-doc 
            set-variable $tabsize 8 
        !emacro 

        define-macro ehook-doc 
            set-variable $tabsize 4 
        !emacro 

sA
    File hooks are often used to setup the desired cCbuffer modescA, cChilightingcA, 
    cClocal key bindingscA, cCabbreviation filecA, etc. 

    Buffer hooks are usually used to set and restore conflicting global 
    variables. 


cEFile Content Recognition cA


    cDadd-file-hookcA with a non-zero numerical argument cCncA defines a macro binding 
    between the content in a file and a set of macros. This binding enables 
    file type dependent screen hi-lighting and key binding to be performed. 
    For a full description of file hooks refer to lsfileHooks(2)lmFile Hooksle, for file 
    extension dependent hooking refer to lslmadd-file-hook(2)le. 

    The content defined file hooks interrogate the contents of a file on 
    loading and search for a cCmagiccA string identifier embedded in the text 
    which uniquely identifies the file type. 

    The recognition process performs a search of the first cCncA (numerical 
    argument) non-blank lines of the file, searching for the regular 
    expression specified by the cCextensionscA argument. The sign of the numerical 
    argument cCncA is interpreted as follows:- 

        * cD-vecA - Case insensitive search 
        * cD+vecA - Case sensitive search 

    The command arguments are defined as follows:- 

    cCextensionscA 
        A regular expression string defining the text to be searched for. 

    cCfhook-namecA 
        The name of the file hook to execute. This is the name of the macro to 
        execute that will initialize the buffer. 

    The search commences from the first non-blank line in the file, if the 
    regular expression, defined by cCextensionscA is located then the file hook 
    cCfhook-namecA is invoked. This is typically used to identify files which do 
    not have file extensions i.e. UNIX shell script files. To identify a shell 
    script file which commences with:- 

        #!/bin/sh 


    The following file hook is used:- 

        cD1 add-file-hookcA "cD#!/.*shcA" "cDfhook-shellcA" 

    Note that "cG.*shcA" also matches cG/bin/cshcA, cG/usr/local/bin/zshcA etc, so care 
    should be taken to ensure that the regular expression string is 
    sufficiently well specified to recognize the file type. 

    The second class of embedded text are explicit identifiers embedded into 
    the text. The embedded strings take the form: 

        cG-*-cA cCmodecA cG-*cA 
        cG-*-cA cDMode:cA cCmodecA; ... cG-*-cA 
        cG-!-cA cCmodecA cG-!-cA 

    The cG-*-cA notation belongs to GNU Emacs, but MicroEmacs '02 recognizes the 
    construct and extracts the string correctly. The cG-!-cA notation is 
    MicroEmacs '02 specific and is provided so as not to cause conflict with 
    GNU Emacs. MicroEmacs '02 searches for either construct on the first 
    non-blank line of the file. 

    The explicit strings are defined with a negative numerical argument cCncA, 
    which identifies them as cDexplicitcA rather than cDmagiccA text strings. The 
    cCstringcA should be defined in lower case and matches a case insensitive 
    string take from the file. e.g. to define a file hook for a make file: 

        #_____________________________-!-Makefile-!-________________________________ 
        # 
        # Make file for MicroEmacs using the Microsoft MSCV 2.0/4.0 development kit. 
        # 
        # Author      : Jon Green 
        # Created     :  020197.1002 
        # Last Edited : <150297.1942> 
        # File        : makefile.w32 
        .... 


    might be defined as: 

        -1 cDadd-file-hookcA "-!-[ \t]*makefile.*-!-" fhook-make 


cEcENOTES cEcA


cEAutomatic Macro File Loading cA


    cDadd-file-hookcA performs an automatic load of a macro file if the cDfhookcA 
    macro is not present in memory. The file name of the command file 
    containing the macro is automatically derived from the cCnamecA component of 
    the cDfhookcA macro name. The cDfhook-cA part of the name is stripped off and 
    prepended with cDhkcA and suffixed with cD.emfcA. Hence, macro cDfhook-doccA would be 
    searched for in file cGhkdoc.emfcA within the MicroEmacs '02 directory. The 
    command file is automatically loaded and executed. 

    In cases where the fhook macro is not located in an equivalent hook file, 
    the file location of the macro may be explicitly defined for auto loading 
    via a lslmdefine-macro-file(2)le invocation. 

    As an example, consider the C-mode file hook, used to load cG.ccA files. The 
    loading of a C header file (cG.hcA) utilizes the same highlighting modes, but 
    it's startup sequence is slightly different when handling new files. In 
    this case the cDfhook-cmodecA for cG.ccA and cDfhook-hmodecA for cG.hcA files are located 
    in the same hook file namely cGhkcmode.emfcA. 
sB
        define-macro-file hkcmode fhook-hmode 

        add-file-hook ".c .cc .cpp .def .l .y .i .ac"   "fhook-cmode" 
        add-file-hook ".h .hpp"                         "fhook-hmode" 

sA
    In this case the lsdefine-macro-file(2)lmdefine-macro-filele has been used to inform MicroEmacs '02 
    of the location of the cDfhook-hmodecA macro thereby overriding the automatic 
    load of a file called cDhkhmode.emfcA. The cDfhook-cmodecA macro requires no such 
    definition as it is located in a hook file that matches the mode name, 
    cGhkcmode.emfcA. 


cEExtending a standard hook definition cA


    The standard file hook files cDhkcAcCXXXcAcD.emfcA should not be modified. The 
    standard file hooks may be extended with local definitions by defining a 
    file cDmycAcCXXXcAcD.emfcA, which is an extension to the hook file cDhkcAcCXXXcAcD.emfcA. This is 
    automatically executed after cDhkcAcCXXXcAcD.emfcA. Refer to sections lslanguageTemplates(2)lmLanguageln
    lnTemplatesle and lsfileHooks(2)lmFile Hooksle for details. 


cEFile Extensions cA


    The file extensions are specified as a space separated list of file name 
    endings. Back-up file endings such as tilde (cG~cA) are not classed as correct 
    file endings and are skipped by the file hook search, hence a file ending 
    "cG.c~cA" invokes the same hook function as a "cG.ccA" file. It is therefore not 
    necessary to add the backup and auto-save endings to the file hook 
    definition. 

    The extension separator, usually dot (cG.cA), is typically added to the 
    cCextensionscA list, they may be omitted with effect where a file always ends 
    in the same set of characters. A notable example is "cGmakefilecA" which 
    includes no extension, as such, MicroEmacs '02 applies the same hook 
    function to a file called cGImakefilecA as the endings are the same. 


cEBinary Files cA


    It is sometimes useful to associate file types as binary files, so that 
    they are immediately loaded in binary. In this case, both file extension 
    and content recognition methods (i.e. of a magic string) are applicable. 
    In both cases the file is bound to the well known hook cGfhook-binarycA which 
    automatically loads the file in a binary mode. 

    Note, that for the content recognition process for a binary hook, the load 
    time is doubled as the file is initially loaded in the default text mode, 
    the binary hook function forces a second load operation in binary. 


cEcESUMMARY cEcA


    cDadd-file-hookcA is summarized as follows:- 

        * Binds one or more extensions to a macro called fhook-cCxxxxcA. 
        * Extensions are typically specified with the dot (cG.cA) separator. 
        * Multiple extensions are specified as a space separated list. 
        * Binds a regular expression search string to a macro called 
          fhook-cCxxxxcA. 
        * The absolute value of the numerical argument determines the number 
          of lines in the file over which the regular expression search is 
          made. 
        * The sign of the numerical argument determines if the regular 
          expression search is case (in)sensitive. 
        * When one of the files with a known file extension, or recognized 
          content, is loaded macro cDfhook-xxxxcA is executed. 
        * cDfhook-xxxxcA, if undefined, is automatically searched for in file 
          cDhkcAcCxxxxcAcD.emfcA. 
        * When the buffer containing the known file is entered (i.e. gains 
          focus), then entry macro cDbhook-xxxxcA is executed. 
        * When the buffer containing the known file is exited (i.e. looses 
          focus), then the exit macro cDehook-xxxxcA is executed. 


cEcEEXAMPLE cEcA


    The standard set of supported file types by MicroEmacs '02, at the time of 
    writing, is defined as:- 
sB
        ; reset the file hook list 
        0 add-file-hook 
        ; Add file extension hooks. 
        ; Files loaded in binary mode do not need hook as fixed 
        add-file-hook "*help* *info* .ehf"                            fhook-ehf 
        add-file-hook "*bindings* *commands* *variables*"             fhook-lists 
        add-file-hook "*buffers*"                                     fhook-blist 
        add-file-hook "/ *directory* *files*"                         fhook-dir 
        add-file-hook "*registry*"                                    fhook-reg 
        add-file-hook "*icommand* *shell* *gdb* *dbx*"                fhook-ipipe 
        add-file-hook ".emf"                                          fhook-emf 
        add-file-hook ".doc .txt"                                     fhook-doc 
        add-file-hook ".1 .2 .3 .4 .5 .6 .7 .8 .9 .so .tni .sm"       fhook-nroff 
        add-file-hook ".c .h .def .l .y .i"                           fhook-c 
        add-file-hook ".cc .cpp .hpp .rc"                             fhook-cpp 
        add-file-hook "Makefile makefile .mak"                        fhook-make 
        add-file-hook "Imakefile imakefile"                           fhook-imake 
        add-file-hook ".sh .ksh .csh .login .cshrc .profile .tcshrc"  fhook-shell 
        add-file-hook ".bat .btm"                                     fhook-dos 
        add-file-hook ".man"                                          fhook-man 
        add-file-hook ".dmn"                                          fhook-dman 
        add-file-hook ".ini .hpj .reg .rgy"                           fhook-ini 
        add-file-hook ".htm .html"                                    fhook-html 
        add-file-hook ".htp .hts"                                     fhook-hts 
        add-file-hook ".tcl"                                          fhook-tcl 
        add-file-hook ".rul"                                          fhook-rul 
        add-file-hook ".awk .nawk .gawk"                              fhook-awk 
        add-file-hook ".p .pas"                                       fhook-pascal 
        add-file-hook ".vhdl .vhd"                                    fhook-vhdl 
        add-file-hook ".fvwm .fvwm2rc"                                fhook-fvwm 
        add-file-hook ".java .jav"                                    fhook-java 
        add-file-hook ".nsr"                                          fhook-nsr 
        add-file-hook ".erf"                                          fhook-erf 
        ; Add magic hooks 
         1 add-file-hook "^#!/.*sh"               fhook-shell ; UNIX shell files 
         1 add-file-hook "^#!/.*wish"             fhook-tcl 
         1 add-file-hook "^#!/.*awk"              fhook-awk 
         1 add-file-hook "^#VRML"                 fhook-vrml 
        -4 add-file-hook "<html>"                 fhook-html 
        -1 add-file-hook "-[*!]-[ \t]*c.*-[*!]-"         fhook-c     ; -*- C -*- 
        -1 add-file-hook "-[*!]-[ \t]*c\\+\\+.*-[*!]-"   fhook-cpp   ; -*- C++ -*- 
        -1 add-file-hook "-[*!]-[ \t]nroff.*-[*!]-"      fhook-nroff ; -*- nroff -*- 
        -1 add-file-hook "-!-[ \t]*shell.*-!-"           fhook-shell ; -!- shell -!- 
        -1 add-file-hook "-!-[ \t]*msdos.*-!-"           fhook-dos   ; -!- msdos -!- 
        -1 add-file-hook "-!-[ \t]*makefile.*-!-"        fhook-make  ; -!- makefile -!- 
        -1 add-file-hook "-!-[ \t]*document.*-!-"        fhook-doc   ; -!- document -!- 
        -1 add-file-hook "-!-[ \t]*fvwm.*-!-"            fhook-fvwm  ; -!- fvwm -!- 
        -1 add-file-hook "-!-[ \t]*erf.*-!-"             fhook-erf   ; -!- erf -!- 
        -1 add-file-hook "-!-[ \t]*fold:.*-!-"           fhook-fold  ; -!- fold:... -!- 

sA

cEcEOBSCURE INFORMATION cEcA


    This section includes some low-level information which is so obscure it is 
    not relevant to the typical user. 


cEResolving Loading Order Problems cA


    There is a potential loading order problem involving auto-loading of file 
    libraries and the setting up of cDbhookcA and cDehookcA. E.g. if the main fhook 
    function has been defined as a lslmdefine-macro-file(2)le, but the bhook or 
    ehooks have not the when a buffer is created as only the fhook is define, 
    only the fhook is set, the rest remain disabled even though the execution 
    of the macro file will define these extra hooks. 

    To solve this problem simply define the bhook/ehooks as well. Note that 
    automatically loaded hooks do not suffer from this problem as the macro 
    file is executed before the hooks are assigned, thereby ensuring the all 
    the hooks are defined. 


cEcESEE ALSO cEcA


    lsfileHooks(2)lmFile Hooksle, lslanguageTemplates(2)lmLanguage Templatesle, lslm$buffer-bhook(5)le, lslm$buffer-ehook(5)le, 
    lslm$buffer-fhook(5)le. 

! 2 osd-bind-key
! 2 osd-unbind-key
cEcENAME cEcA


|osd-bind-key
    osd-bind-key - Create key binding for OSD dialog 
|osd-unbind-key
    osd-unbind-key - Remove key binding from OSD dialog 
$a


cEcESYNOPSIS cEcA


    cDosd-bind-keycA cCncA "cCcommandcA" "cCkeycA" 
    cDosd-unbind-keycA cCncA "cCkeycA" 


cEcEDESCRIPTION cEcA


    cDosd-bind-keycA creates a local key binding for a given lsosd(2)lmosd dialogle, binding 
    the command cCcommandcA to the keyboard input cCkeycA. Only the current root 
    dialog's local bindings are used, local bindings of included dialogs or 
    other root dialogs currently displayed are ignored. 

    Osd local bindings take priority over default osd bindings, local bindings 
    created using lslmml-bind-key(2)le are also used, but any current buffer local 
    bindings created using lslmbuffer-bind-key(2)le are ignored. 


cEcENOTES cEcA


    The prefix commands cannot be rebound with this command. 

    Key response time linearly increases with each osd binding added. 

    As only the root dialog's bindings are used, creating note-book page 
    specific bindings can be awkward. Typically all required keys are bound to 
    the same command which, depending on the page that is currently being 
    displayed, checks if the key pressed is bound on the current page and if 
    so calls the required command. See lslmorganizer(3)le, defined in cGorganize.emfcA 
    for an example of this operation. 


cEcESEE ALSO cEcA


    lslmosd(2)le, lslmglobal-bind-key(2)le, lslmml-bind-key(2)le, lslmbuffer-bind-key(2)le, 
    lslmglobal-unbind-key(2)le. 

! 2 global-mode
! 3 add-global-mode
! 3 delete-global-mode
cEcENAME cEcA


|global-mode
    global-mode - Change a global buffer mode 
|add-global-mode
    add-global-mode - Set a global buffer mode 
|delete-global-mode
    delete-global-mode - Remove a global buffer mode 
$a


cEcESYNOPSIS cEcA


    cCncA cDglobal-modecA "cCmodecA" (cDesc mcA) 
    cDadd-global-modecA "cCmodecA" 
    cDdelete-global-modecA "cCmodecA" 


cEcEDESCRIPTION cEcA


    cDglobal-modecA changes the state of one of the hereditary global modes. A 
    buffer's modes are initialized to the global modes when first created. 
    This command is very useful in changing some of the default behavior such 
    as case sensitive searching (see the example below). See lslmOperating Modesle 
    for a full list and description of modes. Also see lslmbuffer-mode(2)le for a 
    full description of the use of the argument cCncA. 

    The lslmabout(2)le command gives a list of the current global and buffer modes. 

    cDadd-global-modecA and cDdelete-global-modecA are macros defined in meme3_8.emf 
    which use global-mode to add or remove a global mode. They are defined for 
    backward compatibility with MicroEMACS v3.8 and for ease of use; they are 
    simple macros, add-global-mode is defined as follows: 
sB
        define-macro add-global-mode 
            ; Has the require mode been given as an argument, if so add it 
            !force 1 global-mode @1 
            !if &not $status 
                ; No - use 1 global-mode to add a mode 
                !nma 1 global-mode 
            !endif 
        !emacro 

sA

cEcEEXAMPLE cEcA


    The following example globally disables lslmexact(2m)le and lslmmagic(2m)le modes, if 
    these lines are copied to the user setup file then are searches will be 
    simple and case insensitive by default: 
sB
        -1 global-mode "exact" 
        -1 global-mode "magic" 

sA

cEcENOTES cEcA


    Globally adding lslmbinary(2m)le, lslmcrypt(2m)le and lslmrbin(2m)le modes is strongly 
    discouraged as any file loaded would be assigned these modes. Instead use 
    the numeric argument of command lslmfind-file(2)le or commands lslmfind-bfile(3)le and 
    lslmfind-cfile(3)le. 

    lslmauto(2m)le, lslmautosv(2m)le, lslmbackup(2m)le, lslmexact(2m)le, lslmmagic(2m)le, lslmquiet(2m)le, lslmtab(2m)le 
    and lslmundo(2m)le modes are present on all platforms by default. On Windows and 
    DOS platforms lslmcrlf(2m)le is also present and on DOS lslmctrlz(2m)le is also 
    present. 


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmbuffer-mode(2)le, lslmfind-bfile(3)le, lslmfind-cfile(3)le, lslmabout(2)le. 

! 2 buffer-mode
! 2 named-buffer-mode
! 3 add-mode
! 3 delete-mode
! 3 unmark-buffer
cEcENAME cEcA


|buffer-mode
    buffer-mode - Change a local buffer mode 
|named-buffer-mode
    named-buffer-mode - Change a named buffer mode 
|add-mode
    add-mode - Set a local buffer mode 
|delete-mode
    delete-mode - Remove a local buffer mode 
|unmark-buffer
    unmark-buffer - Remove buffer change flag 
$a


cEcESYNOPSIS cEcA


    cCncA cDbuffer-modecA "cCmodecA" (cDC-x mcA) 
    cCncA cDnamed-buffer-modecA "cCbuffer-namecA" "cCmodecA" 
    cDadd-modecA "cCmodecA" 
    cDdelete-modecA "cCmodecA" 
    cDunmark-buffercA 


cEcEDESCRIPTION cEcA


    cDbuffer-modecA changes the state of a given buffer mode, affecting only the 
    current buffer. A buffer's mode affects the behavior of MicroEmacs '02. 
    The lslmabout(2)le command gives a list of the current global and buffer modes. 
    Refer to lslmOperating Modesle for a description of the buffer modes. 

    The argument cCncA when given, has the following meaning: 

        Delete    Add    toggle    Mode 

          -1       1         0     Use "mode" 
          -2       2       130     auto 
          -3       3       131     autosv 
          -4       4       132     backup 
          -5       5       133     binary 
          -6       6       134     cmode 
          -7       7       135     crlf 
          -8       8       136     crypt 
          -9       9       137     ctrlz 
          -10      10      138     del 
          -11      11      139     dir 
          -12      12      140     edit 
          -13      13      141     exact 
          -14      14      142     hide 
          -15      15      143     indent 
          -16      16      144     justify 
          -17      17      145     letter 
          -18      18      146     line 
          -19      19      147     lock 
          -20      10      148     magic 
          -21      21      149     nact 
          -22      22      150     narrow 
          -23      23      151     over 
          -24      24      152     pipe 
          -25      25      153     quiet 
          -26      26      154     rbin 
          -27      27      155     save 
          -28      28      156     tab 
          -29      29      157     time 
          -30      30      158     undo 
          -31      31      159     usr1 
          -32      32      160     usr2 
          -33      33      161     usr3 
          -34      34      162     usr4 
          -35      35      163     usr5 
          -36      36      164     usr6 
          -37      37      165     usr7 
          -38      38      166     usr8 
          -39      39      167     view 
          -40      40      168     wrap 


    Note that when omitted the default argument is 0, i.e. prompt for and 
    toggle a mode. 

    cDnamed-buffer-modecA changes the state of a given buffer mode for a given 
    buffer which may not be the current buffer. 

    cDadd-modecA and cDdelete-modecA are macros which use buffer-mode to add and 
    remove a buffer mode. cDunmark-buffercA is also a macro which removes the edit 
    flag from the current buffer. They are defined for backward compatibility 
    with MicroEMACS v3.8 and can be found in meme3_8.emf; add-mode is defined 
    as follows: 
sB
        define-macro add-mode 
            ; Has the require mode been given as an argument, if so add it 
            !force 1 buffer-mode @1 
            !if &not $status 
                ; No - use 1 buffer-mode to add a mode 
                !nma 1 buffer-mode 
            !endif 
        !emacro 

sA

cEcENOTES cEcA


    When a buffer is created it inherits the current global mode state. 


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmglobal-mode(2)le, lslmabout(2)le, lslm&bmode(4)le. 

! 2 add-next-line
cEcENAME cEcA


    add-next-line - Define the searching behavior of command output 
$a


cEcESYNOPSIS cEcA


    cCncA cDadd-next-linecA "cCbuffer-namecA" [ "cCstringcA" ] 


cEcEDESCRIPTION cEcA


    cDadd-next-linecA is used to set up the cCnext-linecA functionality which is used 
    by the lslmget-next-line(2)le command. The cCnext-linecA feature is aimed at giving 
    the user easy access to file locations which are stored in another buffer. 
    This buffer may typically be the output from the cDgrep(1)cA command or a 
    compiler (e.g. cDcc(1)cA) and needs to contain the file name and line number 
    of the required location. 

    As long as the format of the buffer is consistent and there is a maximum 
    of one location per line, the cCnext-linecA feature can be successfully 
    configured. 

    The first argument, "cCbuffer-namecA", gives the name the aforementioned 
    buffer, this is "cD*grep*cA" for the lslmgrep(3)le command etc. There is no limit on 
    the number of next-line formats, nor on the number of cDadd-next-linecA 
    strings which are given. While there is no real need to initialize each 
    new type, it is advised that the first cDadd-next-linecA is called with a 
    numerical argument of zero, e.g.: 
sB
        0 add-next-line "*grep*" 
        add-next-line "*grep*" "....." 

sA
    This tells MicroEmacs to reinitialize the type by freeing off any strings 
    currently stored, note that the "cCstringcA" argument is not used in this 
    case. Resetting the next-line type safe guards against duplicate strings 
    being added to it, a common problem if MicroEmacs is reinitialized. 

    Following is a typical output from grep: 

        foo.c: 45:      printf("hello world\n") ; 
        foo.c: 46:      printf("hello again\n") ; 


    If we replace the file name with "cG%fcA" and the line number with "cG%lcA", this 
    becomes: 

        %f: %l:      printf("hello world\n") ; 


    lsget-next-line(2)lmget-next-linele works on a left to right basis, as soon as it has enough 
    information from the line it does not need to continue. Therefore the 
    previous example can be reduced to just "cG%f: %l:cA". This is the string 
    argument that should be given for the above example, i.e.: 
sB
        add-next-line "*grep*" "%f: %l:" 

sA
    lsget-next-line(2)lmget-next-linele takes the given string and replaces the "cG%fcA" with 
    lslm$file-template(5)le and the "cG%lcA" with the lslm$line-template(5)le and then uses 
    the resultant string as a regular expression search string to find the 
    next location. Crudely these could be set to "cGfoo.ccA" and "cG45cA" respectively 
    to find the first example, but this would fail to find any other. As a 
    result the templates are usually magic search strings which will match any 
    file and line number. 

    Similarly, following is an example output of the cDgcc(1)cA compiler: 

        basic.c:522: warning: `jj' might be used uninitialized in this command 
        display.c:833: warning: implicit declaration of function `ScreenPutChar' 


    In this case the cDadd-next-linecA given needs to be: 
sB
        add-next-line "*compile*" "%f:%l:" 

sA
    If a -ve numerical argument is given to cDadd-next-linecA the given 
    'next-line' is ignored, this can be useful when some warnings are to be 
    ignored. For example a common warning from gcc is given when a variable 
    might be used uninitialized, given as follows: 

        bind.c:578: warning: `ssc' might be used uninitialized in this function 


    These warnings can be ignored using the following: 
sB
        -1 add-next-line "*compile*" ... 
            ... "%f:%l: warning: `.*' might be used uninitialized in this function" 

sA
    Some versions of cDgrep(1)cA give the file name first and then the lines on 
    the following lines. This is not a major problem as cDget-next-linecA 
    remembers the last file name. The only problem occurs when skipping some 
    parts of the list at which point the last file name parsed may not be the 
    current file. Following is an example output of such a cDgrepcA and the setup 
    required: 

        File foo.c: 
        Line 45:      printf("hello world\n") ; 
        Line 46:      printf("hello again\n") ; 


    The configuration to locate the lines is defined as: 
sB
        0 add-next-line "*grep*" 
        add-next-line "*grep*" "File %f:" 
        add-next-line "*grep*" "Line %l:" 

sA

cEcENOTES cEcA


    The reinitialize command format of this command changed in January 2001, 
    the format changed from: 
sB
        add-next-line "*grep*" "" 


cEcESEE ALSO cEcA


    lslm$file-template(5)le, lslm$line-template(5)le, cDcc(1)cA, lslmcompile(3)le, lslmget-next-line(2)le, 
    cDgrep(1)cA, lslmgrep(3)le. 

! 2 save-registry
cEcENAME cEcA


    save-registry - Write a registry definition file 
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-registrycA ["cCrootcA" "cCfilecA"] 


cEcEDESCRIPTION cEcA


    cDsave-registrycA saves a registry tree, defined by cCrootcA, to a registry file 
    cCfilecA in the lslmerf(8)le format. By default the user is prompted for the 
    registry cCrootcA to save, which must already exist. If the cCfilecA given is the 
    empty string cG""cA, the registry node cCrootcA must be a root node with an 
    associated file name stored, this file name is used. 

    The argument cCncA may be used to control the effect of the command, cCncA is a 
    bit based flag defined as follows:- 

    cD0x01cA 
        Enables prompting before saving, only used when saving all registries. 

    cD0x02cA 
        Save all changed registries except the history node which should be 
        saved using the command lslmsave-history(2)le. 


cEcENOTES cEcA


    This command is called to save all registry changes whenever MicroEmacs is 
    exited. 


cEcESEE ALSO cEcA


    lslmread-registry(2)le, lslmsave-history(2)le, lslmerf(8)le. 

! 2 command-apropos
cEcENAME cEcA


    command-apropos - List commands involving a concept 
$a


cEcESYNOPSIS cEcA


    cDcommand-aproposcA "cCstringcA" (cDC-h acA) 


cEcEDESCRIPTION cEcA


    cDcommand-aproposcA compiles a list of all commands with cCstringcA in their name, 
    also giving their current key bindings. 


cEcEEXAMPLE cEcA


    To find all of the commands with "cGcommandcA" in their name space then issue 
    the command "cGC-h a commandcA" which generates a list of commands such as:- 

        abort-command ................. "C-g" 
                                        "esc C-g" 
                                        "C-x C-g" 
        command-apropos ............... "C-h a" 
        command-complete 
        execute-named-command ......... "esc x" 
        help-command .................. "C-h C-c" 
        ipipe-shell-command ........... "esc \\" 
        list-commands ................. "C-h c" 
        pipe-shell-command ............ "esc !" 
                                        "esc @" 
                                        "C-x @" 
        shell-command 


cEcESEE ALSO cEcA


    lslmdescribe-bindings(2)le. 

! 2 forward-char
! 2 backward-char
cEcENAME cEcA


|forward-char
    forward-char - Move the cursor right 
|backward-char
    backward-char - Move the cursor left 
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-charcA (cDC-fcA) 
    cCncA cDbackward-charcA (cDC-bcA) 


cEcEDESCRIPTION cEcA


    cDbackward-charcA moves the cursor cCncA characters to the left. Move to the end 
    of the previous line if the cursor was at the beginning of the current 
    line. 

    cDforward-charcA moves the cursor cCncA characters to the right. Move to the 
    beginning of the next line if the cursor was already at the end of the 
    current line. 


cEcENOTES cEcA


    cDbackward-charcA is also bound to cDleftcA. 
    cDforward-charcA is also bound to cDrightcA. 


cEcESEE ALSO cEcA


    lslmforward-line(2)le, lslmbackward-line(2)le. 

! 2 start-kbd-macro
! 2 end-kbd-macro
cEcENAME cEcA


|start-kbd-macro
    start-kbd-macro - Start/stop recording keyboard macro 
|end-kbd-macro
    end-kbd-macro - Stop recording keyboard macro 
$a


cEcESYNOPSIS cEcA


    cDstart-kbd-macrocA (cDC-x (cA) 
    cDend-kbd-macrocA (cDC-x )cA) 


cEcEDESCRIPTION cEcA


    A keyboard macro is a short hand way to repeat a series of characters. In 
    effect, a cCrecordingcA is made of the sequence of keys that you hit while 
    defining a keyboard macro. The recording is started with cDstart-kbd-macrocA 
    and ended with cDend-kbd-macrocA. The recording is then repeated whenever you 
    execute the keyboard macro using lslmexecute-kbd-macro(2)le. 

    Since it is key-strokes that are being saved, you can freely intermix 
    commands and text to be inserted into the buffer. 

    You can save a keyboard macro for later using the lslmname-kbd-macro(2)le 
    command, which saves the keyboard macro as a named macro. Otherwise if you 
    start another keyboard macro recording session, the previously defined 
    macro is lost. So make sure that you are done with the current keyboard 
    macro before defining another one. If you have a series of commands that 
    you would like to cCrecordcA for later use, lslminsert-macro(2)le can be used to 
    insert the macro into a text file and can be reloaded using the 
    lslmexecute-file(2)le or lslmexecute-buffer(2)le commands. 

    Recording commences with cDstart-kbd-macrocA (cGC-x (cA) and terminates when an 
    cDend-kbd-macrocA (cGC-x )cA is encountered. 


cEcENOTES cEcA


    Once cDstart-kbd-macrocA has been executed, the mouse is disabled until 
    cDend-kbd-macrocA is executed. This is because the mouse events cannot be 
    successfully recorded in macros. The main menu can still be used, but only 
    via the keyboard bindings and hot-keys (note that the layout of the menu 
    may change). 


cEcESEE ALSO cEcA


    lslmexecute-kbd-macro(2)le, lslminsert-macro(2)le, lslmkbd-macro-query(2)le, 
    lslmname-kbd-macro(2)le. 

! 2 beginning-of-buffer
! 2 end-of-buffer
cEcENAME cEcA


|beginning-of-buffer
    beginning-of-buffer - Move to beginning of buffer/file 
|end-of-buffer
    end-of-buffer - Move to beginning/end of buffer/file 
$a


cEcESYNOPSIS cEcA


    cDbeginning-of-buffercA (cDesc <cA) 
    cDend-of-buffercA (cDesc >cA) 


cEcEDESCRIPTION cEcA


    cDbeginning-of-buffercA places the cursor at the beginning of the buffer/file. 

    cDend-of-buffercA places the cursor at the end of the buffer/file. 


cEcENOTES cEcA


    cDbeginning-of-buffercA is typically bound to cDhomecA. 
    cDend-of-buffercA is typically bound to cDendcA. 


cEcESEE ALSO cEcA


    lslmbeginning-of-line(2)le, lslmend-of-line(2)le. 

! 2 global-bind-key
! 2 global-unbind-key
cEcENAME cEcA


|global-bind-key
    global-bind-key - Bind a key to a named command or macro 
|global-unbind-key
    global-unbind-key - "Unbind a key from a named command or macro" 
$a


cEcESYNOPSIS cEcA


    cCncA cDglobal-bind-keycA "cCcommandcA" "cCkeycA" (cDesc kcA) 
    cCncA cDglobal-unbind-keycA "cCkeycA" (cDesc C-kcA) 


cEcEDESCRIPTION cEcA


    cDglobal-bind-keycA takes one of the named commands and binds it to a key. 
    Thereafter, whenever that key is struck, the bound command is executed. If 
    an argument cCncA is given then the bound command is executed cCncA times when the 
    key is struck. (i.e. the command is passed the numeric argument 'cCncA'). 

    cDglobal-unbind-keycA unbinds (detaches) a user entered cCkeycA sequence (i.e. cGC-x 
    C-fcA) from any command to which it may be bound. This does not work with 
    lsbuffer-bind-key(2)lmbufferle or lsml-bind-key(2)lmmessage linele key bindings, see lslmbuffer-unbind-key(2)le and 
    lslmml-unbind-key(2)le. If an argument of 0 is given to cDglobal-unbind-keycA, only 
    a single key is obtained for the user, if the character is currently bound 
    to the lsprefix(2)lmprefixle command, the prefix binding and any sub-bindings are 
    removed. cDglobal-bind-keycA calls cDglobal-unbind-keycA first if the key to be 
    bound is already bound to something else. 

    If a -ve argument is given to cDglobal-unbind-keycA then all bindings are 
    removed, cDcautioncA - removing all bindings interactively will render the 
    current MicroEmacs session unusable. This can only be used within macro 
    development where new bindings are created immediately afterwards. 

    The cDglobal-bind-keycA command, currently bound to cGesc kcA, prompts the user 
    for the named command and the key to which it is to be bound. This help 
    file gives a complete list of all built in commands, and some useful 
    macros, a complete list of all commands and macros can be obtained by 
    using the command completion (type cGesc xcA cGtabcA cGtabcA, see lslmml-bind-key(2)le) or 
    using the command lslmdescribe-bindings(2)le. 

    The mouse buttons are considered to be cCkeyscA, there is a cCkeycA for each 
    button press and release event, use lslmdescribe-key(2)le to get the binding key 
    string. 

    The non-ASCII standard keys such as the cursor keys have 'standard' key 
    names to make cross platform binding support easy. Some systems such as 
    cCtermcapcA do not have fixed key-bindings, for these key the users must use 
    the command lslmtranslate-key(2)le to convert the system key binding to the 
    standard key binding. 

    Permanent changes are done indirectly through the cGme.emfcA file. This is a 
    file that MicroEmacs '02 reads and executes (see lslmexecute-file(2)le) during 
    startup and hence results in the appearance of a permanent change in the 
    key bindings. The syntax of commands in the cGme.emfcA file is described under 
    the lsexecute-file(2)lmexecute-filele command. Of principal concern here are the two commands 
    cDglobal-bind-keycA and cDglobal-unbind-keycA. The primary difference between the 
    way parameters are passed to these commands in the cGme.emfcA file is that the 
    keys are not typed in directly (as in the cCcontrol-IcA key when you want cGC-icA) 
    but by symbolic names. Every key has a unique name which can be easily 
    obtained with the current binding by using the command lslmdescribe-key(2)le. 

    See help on lskeyNames(2)lmKey Namesle for a description of the symbolic naming system and 
    a complete list of valid key names. Also see lsBindings(2)lmBindingsle for a complete list 
    of default key bindings. 


cEcEEXAMPLE cEcA


    cDAlt PcA 
sB
        global-bind-key "func" "A-p" 

sA
    cDControl F2cA 
sB
        global-bind-key "func" "C-f3" 

sA
    cDShift Alt Left CursorcA 
sB
        global-bind-key "func" "A-S-left" 

sA
    cDControl Alt DeletecA 
sB
        global-bind-key "func" "C-A-delete" 

sA
        Note that binding cDControl-Alt-DeletecA is not recommended for MS-DOS 
        systems for obvious reasons. 


cEcENOTES cEcA


    Some ASCII keys, such as cG<CR>cA (C-m), cG<tab>cA (C-i), cG<BACKSPACE>cA (C-h) have 
    non-ASCII key bindings, namely "cDreturncA", "cDtabcA", "cDbackspacecA" etc. this is 
    to allow separate key-bindings for the real "cDC-mcA" etc. 

    Be very careful in binding and unbinding keys since you could get into 
    some very peculiar situations such as being unable to abort out of a 
    command (if you unbind CTRL-G or bind it to something else) or recover 
    from the bad binding/unbinding if you unbind lslmexecute-named-command(2)le or 
    the cDglobal-unbind-keycA command. As long as you leave yourself the 
    opportunity to do both of the last two commands, you can recover from 
    disastrous bindings/unbindings. 


cEcESEE ALSO cEcA


    lslmbuffer-bind-key(2)le, lslmbuffer-unbind-key(2)le, lslmdescribe-bindings(2)le, 
    lslmdescribe-key(2)le, lslmml-bind-key(2)le, lslmml-unbind-key(2)le, lslmtranslate-key(2)le. 

! 2 buffer-info
cEcENAME cEcA


    buffer-info - Status information on current buffer position 
$a


cEcESYNOPSIS cEcA


    cDbuffer-infocA (cDC-x =cA) 


cEcEDESCRIPTION cEcA


    cDbuffer-infocA reports on the current and total lines and characters of the 
    current buffer. It also gives the hexadecimal code of the character 
    currently under the cursor. 

    The output of the command is displayed on the message line e.g. 

        Line 1845/3955 Col 0.0 Char 78267/167172 (46%) Win Line 99/48 Col/0/0 char = 0xA 


    lslm$result(5)le is set to the same output string. 


cEcESEE ALSO cEcA


    lslm$result(5)le, lslm$mode-line(5)le, lslmabout(2)le. 

! 2 capitalize-word
! 2 lower-case-word
! 2 upper-case-word
! 2 lower-case-region
! 2 upper-case-region
cEcENAME cEcA


|capitalize-word
    capitalize-word - Capitalize word 
|lower-case-word
    lower-case-word - Lowercase word (downcase) 
|upper-case-word
    upper-case-word - Uppercase word (upcase) 
|lower-case-region
    lower-case-region -  Lowercase a region (downcase) 
|upper-case-region
    upper-case-region - Uppercase a region (upcase) 
$a


cEcESYNOPSIS cEcA


    cCncA cDcapitalize-wordcA (cDesc ccA) 
    cCncA cDlower-case-wordcA (cDesc lcA) 
    cCncA cDupper-case-wordcA (cDesc ucA) 

    cDlower-case-regioncA (cDC-x C-lcA) 
    cDupper-case-regioncA (cDC-x C-ucA) 


cEcEDESCRIPTION cEcA


    cDcapitalize-wordcA capitalizes the next cCncA words. 

    cDlower-case-wordcA changes the next cCncA words to lower case. 

    cDupper-case-wordcA changes the next cCncA words to upper case. 

    cDlower-case-regioncA changes all alphabetic characters in the marked region 
    to lower case (see lslmset-mark(2)le). 

    cDupper-case-regioncA changes all alphabetic characters in the marked region 
    to upper case 


cEcESEE ALSO cEcA


    lslmset-mark(2)le. 

! 2 change-directory
cEcENAME cEcA


    change-directory - Change the current working directory 
$a


cEcESYNOPSIS cEcA


    cDchange-directorycA "cCdir-namecA" (cDC-x C-dcA) 


cEcEDESCRIPTION cEcA


    cDchange-directorycA changes the current working directory to cCdir-namecA, on 
    certain platforms (MS-DOS) this can also change the current drive. This 
    command is largely redundant as any shell command automatically inherits 
    the directory of the current buffer's file. 


cEcESEE ALSO cEcA


    lslmchange-file-name(2)le. 

! 2 change-file-name
cEcENAME cEcA


    change-file-name - Change the file name of the current buffer 
$a


cEcESYNOPSIS cEcA


    cDchange-file-namecA "cCfile-namecA" (cDC-x ncA) 


cEcEDESCRIPTION cEcA


    cDchange-file-namecA changes the file name of the current buffer to cCfile-namecA. 
    A validity check is made on the given file name and if found to be invalid 
    (e.g. its a directory) the name is rejected. 


cEcESEE ALSO cEcA


    lslmchange-buffer-name(2)le, lslmchange-directory(2)le, lslmwrite-buffer(2)le. 

! 2 change-screen-depth
! 2 change-screen-width
cEcENAME cEcA


|change-screen-depth
    change-screen-depth - Change the number of lines of the screen 
|change-screen-width
    change-screen-width - Change the number of columns on the screen 
$a


cEcESYNOPSIS cEcA


    cCncA cDchange-screen-depthcA 
    cCncA cDchange-screen-widthcA 


cEcEDESCRIPTION cEcA


    cDchange-screen-depthcA changes the size of the screen to cCncA lines deep. It is 
    assumed that the screen is cCncA lines deep and MicroEmacs '02 draws cCncA lines 
    at the users peril. A change in depth causes all of the windows currently 
    displayed on the screen to be re-sized, the vertical position of the 
    windows is modified to match the new screen dimension, the horizontal 
    position of the windows remains unaltered. If the window is down-sized and 
    the currently displayed windows are not able to fit into the new screen 
    space then all windows are deleted with the exception of the current 
    window. 

    cDchange-screen-widthcA changes the size of the screen to cCncA characters wide. 
    It is assumed that the screen is cCncA columns wide and MicroEmacs '02 draws cCncA 
    columns at the users peril. The windows are reorganized as 
    cDchange-screen-depthcA working horizontally rather than vertically. 


cEcENOTES cEcA


    Within windowing environments such as cDX-WindowscA and cDMicrosoft WindowscA 
    these commands cause the canvas window to be re-sized to accommodate the 
    change in screen size. 

    In MS-DOS environments the physical size of the screen is determined by 
    the characteristics of the display adapter. cDchange-screen-depthcA may be 
    used to correct anomalies (usually on portables) in the displayable screen 
    area and the graphics mode. e.g. the graphics mode utilizes 50 lines, and 
    only 47 lines are viewable. In this case change the screen depth to 47 and 
    MicroEmacs '02 will not utilize the remaining lines which are not 
    viewable. 


cEcESEE ALSO cEcA


    lslm$screen-depth(5)le, lslm$screen-width(5)le. 

! 2 ml-clear
cEcENAME cEcA


    ml-clear - Clear the message line 
$a


cEcESYNOPSIS cEcA


    cDml-clearcA 


cEcEDESCRIPTION cEcA


    cDml-clearcA clears the message line during script execution. This is useful 
    so as not to leave a confusing message from the last command(s) in a 
    script. 

    Callback macros which may interrupt the user at any point in time are 
    handled by cDml-clearcA. The callback macro for instance may interrupt the 
    user while entering a new file name, and any lslmml-write(2)le erases the 
    message-line which may currently be in use. MicroEmacs '02 stores the line 
    and when lslmml-clear(2)le is invoked, instead of clearing the message line the 
    current input line is restored. 


cEcESEE ALSO cEcA


    lslmcreate-callback(2)le, lslmml-write(2)le. 

! 2 compare-windows
! 3 compare-windows-exact
cEcENAME cEcA


|compare-windows
    compare-windows - Compare buffer windows, ignore whitespace. 
|compare-windows-exact
    compare-windows-exact - Compare buffer windows, with whitespace. 
$a


cEcESYNOPSIS cEcA


    cCncA cDcompare-windowscA 
    cDcompare-windows-exactcA 


cEcEDESCRIPTION cEcA


    cDcompare-windowscA compares the textural content of ALL the current windows 
    from their current cursor position. These commands are generally used to 
    locate the next difference in the windows displayed. Returns cGTRUEcA if the 
    buffers of the windows do not differ from the current position to the end 
    of the file (inclusive), else returns cGFALSEcA setting the cursor of each 
    buffer to the first point of difference. 

    The default mode of operation ignores white-space, a numeric argument cCncA of 
    zero (0) then an exact white-space match is performed. 

    cDcompare-windows-exactcA is a macro short cut for cC0 compare-windowscA, forcing 
    a white space comparison. 


cEcESEE ALSO cEcA


    lslmdiff(3)le, lslmdiff-changes(3)le, lslmgdiff(3)le. 

! 2 set-scroll-with-mouse
cEcENAME cEcA


    set-scroll-with-mouse - Scroll the window with the mouse 
$a


cEcESYNOPSIS cEcA


    cCncA cDset-scroll-with-mousecA 


cEcEDESCRIPTION cEcA


    The cDset-scroll-with-mousecA command controls the scrolling of a window by 
    the mouse. This is a two stage process, the first stage locks the cursor 
    to the mouse, the second stage scrolls the screen. 

    The first stage (locking) is performed when the mouse is located on the 
    scroll-box (typically when the left button is depressed i.e. 
    cDpick-mouse-1cA). cDset-scroll-with-mousecA is invoked with an argument cCncA, this 
    causes the mouse position to be recorded ready for a scroll. Depending on 
    the scroll method, the blank lines present at the end of the buffer are 
    scrolled off the screen. 

    Subsequent calls to the cDset-scroll-with-mousecA are made with no argument, 
    the window is scrolled by the relative displacement of the mouse from it's 
    locked position, motion is limited at the end of the scrolling region. 
    Scrolling is proportional to the buffer length. The command is typically 
    bound to cDmove-mouse-1cA which results in an update whenever the mouse is 
    moved by the user. 

    When the button is released cDdrop-mouse-1cA then the scrolling is stopped by 
    unbinding cDmove-mouse-1cA, thereby breaking the binding between the mouse 
    moving and the scroll command. 

    The scrolling utilizes fractional mouse positional information (i.e. units 
    smaller than a character cell), if available, resulting in a smoother 
    scrolling motion. 


cEcEEXAMPLE cEcA


    The following example shows how the command is used. 
sB
        0 define-macro mouse-scroll-pick 
            1 set-scroll-with-mouse         ; Lock mouse position to scroller 
            global-bind-key set-scroll-with-mouse "mouse-move-1" 
        !emacro 

        0 define-macro mouse-scroll-drop 
            global-unbind-key "mouse-move-1" 
        !emacro 

        global-bind-key mouse-scroll-pick "mouse-pick-1" 
        global-bind-key mouse-scroll-drop "mouse-drop-1" 

sA
    When the left button is 'picked', cDmouse-scroll-pickcA lock the cursor to the 
    mouse and binds mouse movement to cDset-scroll-with-mousecA so that whenever 
    the mouse is moved the cursor will be repositioned appropriately. When the 
    button is 'dropped', the mouse movement is unbound so that the cursor will 
    no longer be locked to the mouse. 


cEcESEE ALSO cEcA


    lslm$mouse-pos(5)le, lslm$scroll-bar(5)le, lslmset-cursor-to-mouse(2)le. 

! 2 copy-region
cEcENAME cEcA


    copy-region - Copy a region of the buffer 
$a


cEcESYNOPSIS cEcA


    cDcopy-regioncA (cDesc wcA) 


cEcEDESCRIPTION cEcA


    cDcopy-regioncA copies all the characters between the cursor and the mark set 
    with the lslmset-mark(2)le command into the kill buffer (so they can later be 
    lsyank(2)lmyankedle elsewhere). 

    If the last command also entered text into the kill buffer (or the lslm@cl(4)le 
    variable is set to one of these commands) the cDcopy-regioncA text is appended 
    to the last kill. 


cEcEUSAGE cEcA


    To copy text from one place to another, using the cDcopy-regioncA command, the 
    following operations are performed: 

        * Move to the beginning of the text you want to copy. 
        * Set the mark there with the lsset-mark(2)lmset-markle (cDesc-spacecA) command. 
        * Move the point (cursor) to the end of the text. 
        * Use cDcopy-regioncA to copy the region you just defined. The text will 
          be saved in the kill buffer. (If you accidentally delete the text 
          use lsyank(2)lmyankle (cDC-ycA) immediately or lsundo(2)lmundole (cDC-x ucA) to restore the text). 
        * Move the point to the place you want the text to appear. 
        * Use the lsyank(2)lmyankle (cDC-ycA) command to copy the text from the kill buffer to 
          the current point. 

    Repeat the last two steps to insert further copies of the same text. 


cEcENOTES cEcA


    Windowing systems such as X-Windows and Microsoft Windows utilize a global 
    windowing kill buffer allowing data to be moved between windowing 
    applications (cCcut buffercA and cCclipboardcA, respectively). Within these 
    environments MicroEmacs '02 automatically interacts with the windowing 
    systems kill buffer, the last MicroEmacs '02 cDcopy-regioncA entry is 
    immediately available for a paste operation into another windowing 
    application. 


cEcESEE ALSO cEcA


    lslmexchange-point-and-mark(2)le, lslmkill-region(2)le, lslmset-mark(2)le, lslmyank(2)le. 

! 2 count-words
cEcENAME cEcA


    count-words - Count the number of words in a region 
$a


cEcESYNOPSIS cEcA


    cDcount-wordscA (cDesc C-ccA) 


cEcEDESCRIPTION cEcA


    cDcount-wordscA Counts the number of words between the lslmset-mark(2)le position 
    and the current cursor position. The command also gives statistics on the 
    number of characters and the average characters per word. The output 
    appears on the message line in a format such as:- 

        cG54 Words, 345 Chars, 8 LinescA 

    lslm$result(5)le is set to the same output string. 


cEcESEE ALSO cEcA


    lslm$result(5)le, lslmbuffer-info(2)le, lslmset-mark(2)le. 

! 2 create-callback
cEcENAME cEcA


    create-callback - Create a timer callback 
$a


cEcESYNOPSIS cEcA


    cCncA cDcreate-callbackcA "cCcommandcA" 


cEcEDESCRIPTION cEcA


    cDcreate-callbackcA creates a timer based callback command. The given cCcommandcA 
    is called back in cCncA milliseconds time. This can be used by the user to 
    monitor system events (such as incoming mail). The command is called only 
    once, but if the command creates a callback of itself a loop is created. 

    If a -ve argument cCncA is given any pending callback for cCcommandcA is 
    cancelled. 


cEcEEXAMPLE cEcA


    The following example creates a callback that is invoked every 10 minutes. 
sB
        define-macro Example-callback 
            ml-write "It was 10 minutes since you last saw me!" 
            600000 create-callback Example-callback 
        !emacro 
        Example-callback 

sA

cEcENOTES cEcA


    A call-back cannot interrupt while MicroEmacs is active, instead the 
    call-back is delayed until MicroEmacs becomes inactive. MicroEmacs is 
    considered to be inactive when it is waiting for user input, this could be 
    during the execution of another macro. If a command or macro requires no 
    user input then once execution has started, it cannot be interrupted by a 
    call-back macro. 

    The resolution of the clock is platform dependent, some platforms limit 
    the minimum timer period to 10 milliseconds. 

    MicroEmacs does not guarantee to service the callbacks within any set time 
    constraints, the resultant callback intervals may be of a slightly 
    different duration than requested. 

    When a callback macro is executed, the key given by lslm@cck(4)le is "cGcallbackcA. 
    If the current buffer has a lslm$buffer-input(5)le command set, this command 
    will be called instead of the callback command with cD@cccA and cD@cckcA set 
    appropriately. It is the responsibility of the input macro to deal with 
    the callback. 


cEcESEE ALSO cEcA


    lslm$auto-time(5)le, lslmdefine-macro(2)le. 

! 2 list-registry
cEcENAME cEcA


    list-registry - Display the registry in a buffer 
$a


cEcESYNOPSIS cEcA


    cDlist-registrycA 


cEcEDESCRIPTION cEcA


    cDlist-registrycA lists the contents of the registry in the a buffer in a 
    hierarchical format. The key name and any associated string is shown as a 
    hierarchical tree. 

    The registry listing is generated in the buffer "cG*registry*cA". 


cEcESEE ALSO cEcA


    lslmread-registry(2)le, lslmerf(8)le. 

! 2 beginning-of-line
! 2 end-of-line
cEcENAME cEcA


|beginning-of-line
    beginning-of-line - Move to beginning of line 
|end-of-line
    end-of-line - Move to end of line 
$a


cEcESYNOPSIS cEcA


    cDbeginning-of-linecA (cDC-acA) 
    cDend-of-linecA (cDC-ecA) 


cEcEDESCRIPTION cEcA


    cDbeginning-of-linecA places the cursor at the beginning of the line. 

    cDend-of-linecA places the cursor at the end of the line. 


cEcESEE ALSO cEcA


    lslmbeginning-of-buffer(2)le, lslmend-of-buffer(2)le. 

! 2 change-font
cEcENAME cEcA


    change-font - Change the screen font 
$a


cEcESYNOPSIS cEcA


    cC[X-Windows]cA 
    cDchange-fontcA "cCfontNamecA" 

    cC[IBM-PC / MS-DOS]cA 
    cDchange-fontcA "cCmode-nocA" "cCspeccA" 

    cC[Microsoft Windows]cA 
    cCncA cDchange-fontcA "cCnamecA" cCcharSetcA cCweightcA cCwidthcA cCheightcA 


cEcEDESCRIPTION cEcA


    cDchange-fontcA is a platform specific command which allows the displayable 
    font to be modified. The selection of font is determined by the monitor 
    resolution and the capabilities of the graphics adapter. 

    This command is available on all systems except termcap. While MS-DOS does 
    not support the concept of different fonts, it does (or at least the 
    graphics card does) support the concept of changing screen resolution, 
    which has the effect of changing the font. Each platform takes different 
    arguments and are considered independently, as follows: 


cEX-Windows cA


    The X-Windows UNIX environments accept a single argument which is a fully 
    qualified font name. Simply give the font X name and the font will change 
    if it is available. The window size changes to attempt to retain the same 
    number of rows and columns so ensure that when changing to a larger font 
    then there is enough room (or a way) to resize a window which is larger 
    than the actual screen. 

    The X font string describes the attributes of the font in terms of it's 
    size name etc. as follows:- 

    -cCfoundrycA-cCfamilycA-cCweightcA-cCslantcA-cCwidthcA--cCpixelscA-cCpointcA-cChrescA-cCvrescA-cCspacecA-cCavcA-cCsetcA 

    Where 

    cCfoundrycA 
        The type of foundry that digitized and supplied the font. 

    cCfamilycA 
        Font Family. 

    cCweightcA 
        Modifies the appearance of the font, the cCweightcA is usually cDmediumcA or 
        cDboldcA. 

    cCslantcA 
        Determines the orientation of the font. cCslantcA is usually cDrcAoman 
        (upright), cDicAtalic or cDocAblique. 

    cCwidthcA 
        Describes the proportionate width of the font. Typical widths include 
        cDnormalcA, cDcondensedcA, cDnarrowcA, cDdoublecA. 

    cCpixelscA 
        Pixel size of the font 

    cCpointcA 
        The resolution of the font in tenths of a cDdpicA (i.e. dpi*10) 

    cChrescA 
        Horizontal resolution of the font in dpi. 

    cCvrescA 
        Vertical resolution of the font in dpi. 

    cCspacecA 
        The spacing of the font. Typical spacing values include cDmcAonospaced 
        (i.e. fixed width), cDpcAroportional and cDccAharacter cell. 

    cCavcA 
        Mean width of all font characters, measured in tenths of a pixel. 

    cCsetcA 
        Character set - character set standards e.g. cDiso8859-1cA. 

    The default font used by MicroEmacs '02 is 

        -*-fixed-medium-r-normal--15-*-*-*-c-90-iso8859-1 


    A good font to try is: 
sB
        change-font "-misc-fixed-medium-r-normal--13-*-*-*-c-80-iso8859-1" 

sA
    The font may also be changed in your cD.XdefaultscA file by inserting the 
    line:- 

        MicroEmacs.font "-misc-fixed-medium-r-normal--13-*-*-*-c-80-iso8859-1" 


cEIBM-PC / MS-DOS cA


    MS-DOS may only change the screen resolution, the standard screen 
    resolution is either 80 columns by 25 rows or 80 by 50. A more advanced 
    graphics card can typically support up to 132 by 60, MicroEmacs in theory 
    has no limit but it has only been tested up to this size. 

    The main problem with MS-DOS machines is that there is no standard and 
    this is no exception. The graphics mode needed to get a 132 by 60 screen 
    (if available) varies from one card to the next so MicroEmacs '02 needs to 
    know the graphic mode number your card uses to get your required screen 
    resolution. 

    MicroEmacs '02 can also attempt a little bit of magic to double the number 
    of rows on the screen for a given screen resolution. This is how 50 lines 
    are obtained from the standard 25 line mode 3. If the value of "cCspeccA" is 
    non-zero then this is attempted, to the authors knowledge this will either 
    work or not depending on the direction of the wind and no harm will befall 
    the users equipment. However the author also quickly disclaims anything 
    and everything, the user uses this at their own peril, like everything 
    else. 

    MicroEmacs '02 attempts to determine the new screen width and depth 
    itself, in case this fails the commands lslmchange-screen-width(2)le and 
    lslmchange-screen-depth(2)le may be used to correct the problem. 

    Following are the standard MS-DOS text modes: 
sB
        change-font "2" "0"       ; Simple monochrome or EGA monitor, 80 by 25. 
        change-font "3" "0"       ; Simple EGA/VGA monitor, again 80 by 25. 
        change-font "3" "1"       ; Simple EGA/VGA monitor using spec, 80 by 50. 

sA
    Most Trident cards support the following text mode: 
sB
        change-font "86" "0"      ; Sweet 132 by 60 

sA
    A Diamond Stealth supports the following mode: 
sB
        change-font "85" "1"      ; Nice 132 by 50 

sA
    Cirrus video cards (1MB) seem to support: 
sB
        change-font "84" "1"      ; PT-526 (132x50) 

sA
    Time to start digging out your graphics card manual! 


cEMicrosoft Windows cA


    The Microsoft Windows environments utilize font files to drive the 
    display. When cDchange-fontcA is invoked with no arguments, or a -ve argument 
    then a font dialog is presented to the user to allow the font to be 
    selected. The current font is not changed if a -ve argument is given, in 
    both cases the variable lslm$result(5)le is set the the user selected font. The 
    format of the returned string is "cGOWwwwwhhhhhFontNamecA", where:- 

    cDOcA 
        The type of character set (0 for OEM and 1 for ANSI). 

    cDWcA 
        The font weight (0 - 9). 

    cDwwwwcA 
        The font width. 

    cDhhhhcA 
        The font height. 

    cDFontNamecA 
        The font name. 

    If a +ve argument is specified with cDchange-fontcA then the arguments are 
    explicitly entered, arguments are defined as follows:- 

    cCfontcA 
        The name of the font - maximum of 32 characters. Select Fixed mono 
        fonts only. Proportional fonts may be specified but the cursor will 
        not align with the characters on the screen. 

        An empty name ("") may be specified resulting in the selection of the 
        default system OEM font. No other arguments are required when 
        specified. 

        Note that cDCourier NewcA is not actually a fixed mono font as might be 
        expected. 

    cCcharSetcA 
        The type of character set required, this is an integer value of:- 

            cG  0cA - ANSI or Western (True Type etc) 
            cG161cA - Greek 
            cG162cA - Turkish 
            cG204cA - Russian 
            cG255cA - OEM (or bitmapped) 

    cCweightcA 
        The weight of the font. The values are defined as:- 

            cG0cA - Don't care (Automatically selected). 
            cG1cA - Thin 
            cG2cA - Extra Light 
            cG3cA - Light 
            cG4cA - Normal 
            cG5cA - Medium 
            cG6cA - Semi-Bold 
            cG7cA - Bold 
            cG8cA - Extra-Bold 
            cG9cA - Heavy 

        Note that you may request a weight and it is not honored. Typically 4 
        and 7 are honored by most font definitions. 4 is typically used. 

    cCwidthcA 
        The width of the font. Specifies the average width, in logical units, 
        of characters in the requested font. If this value is zero, the font 
        mapper chooses a "closest match" value. The "closest match" value is 
        determined by comparing the absolute values of the difference between 
        the current device's aspect ratio and the digitized aspect ratio of 
        available fonts. 

        Note that if the width is specified as zero then the height should be 
        specified and the width will be automatically selected. 

    cCheightcA 
        The height of the font. Specifies the desired height, in logical 
        units, of the requested font's character cell or character. (The 
        character height value is the character cell height value minus the 
        internal-leading value.) If this value is greater than zero, the font 
        mapper matches it against available character cell height values; if 
        this value is zero, the font mapper uses a default height value when 
        it searches for a match; if this value is less than zero, the font 
        mapper matches it against available character height values. 

        Note: as with the weight the width and height may not be honored if 
        the font cannot support the specified width/height in which case the 
        closest matching height is automatically selected 


cENotes on the Standard Windows Configuration cA


    For releases prior to '99, the cDTerminalcA font is the standard MS-DOS font 
    used for the MS-DOS window. This is an OEM fixed width character set which 
    contains all of the conventional symbols found in the DOS shell. 

    Releases of MicroEmacs post '99 may utilise any of the windows fonts, 
    typically cGCourier NewcA or cGLucida ConsolecA are used, these provide the best 
    screen rendering of characters. cGLucida ConsolecA is slightly better with a 
    smaller font size as this allows a 'cG1cA' (one) and 'cGlcA' (lower case L) to be 
    distinguished. 

    The cDTerminalcA fonts are the same as shown in the DOS window the last 2 
    arguments are the width x height, the terminal equivalents (Bit Mapped) 
    are commented here. 

    cD7x12cA 
        Regular weight seems to offer the best resolution for 14/15" monitors. 

    cD6x8cA 
        Regular weight is more suitable for 17-21" monitors which offer better 
        resolutions. 

    The best options for the fonts are defined as follows:- 
sB
        ;Standard Terminal Fonts - standard weight 
        ;change-font "Terminal" 0 4  4  6 
        change-font "Terminal" 0 4  6  8 
        ;change-font "Terminal" 0 4  8  8 
        ;change-font "Terminal" 0 4  5 12 
        ;change-font "Terminal" 0 4  7 12 
        ;change-font "Terminal" 0 4  8 12 
        ;change-font "Terminal" 0 4 12 16 
        ;change-font "Terminal" 0 4 10 18 

        ;Standard Terminal Fonts - heavy weight 
        ;change-font "Terminal" 0 7  4  6 
        ;change-font "Terminal" 0 7  6  8 
        ;change-font "Terminal" 0 7  8  8 
        ;change-font "Terminal" 0 7  5 12 
        ;change-font "Terminal" 0 7  7 12 
        ;change-font "Terminal" 0 7  8 12 
        ;change-font "Terminal" 0 7 12 16 
        ;change-font "Terminal" 0 7 10 18 

sA
    The "cDCourier NewcA" font is not actually a fixed mono font as might be 
    expected. 


cEcESEE ALSO cEcA


    lslmchange-screen-width(2)le, lslmchange-screen-depth(2)le, lslm$result(5)le, lslmuser-setup(3)le. 

! 2 prefix
cEcENAME cEcA


    prefix - Key prefix command 
|prefix2
    prefix2 - Control(2) prefix 
|prefix3
    prefix3 - Control(3) prefix 
|prefix4
    prefix4 - Control(4) prefix 
$a


cEcESYNOPSIS cEcA


    cCncA cDprefixcA 

    Default prefix bindings: 

    cDprefix 1cA (cDesccA) 
    cDprefix 2cA (cDC-xcA) 
    cDprefix 3cA (cDC-hcA) 
    cDprefix 4cA (cDC-ccA) 


cEcEDESCRIPTION cEcA


    cDprefixcA sets up to 8 prefix key sequences, allowing two stoke key bindings. 
    The command does not do anything, it is used to create double barrel key 
    bindings such as such as lslmgoto-line(2)le (cDesc gcA). This binding may be 
    redefined, redefining ALL meta bindings. If the meta bindings are not 
    required the command should first be unbound using the 
    lslmglobal-unbind-key(2)le. 

    The prefix key can only be defined using the lslmglobal-bind-key(2)le, passing 
    the command the prefix number required, for example: 
sB
        1 global-bind-key "prefix" "esc " 
        2 global-bind-key "prefix" "C-x" 

sA
    Binds the first prefix to the Escape key and the second prefix to 
    Control-x. 

    The first prefix key (cDprefix 1cA) differs from the other prefixes since it 
    permits entry of the numeric argument at the message line, e.g. "cGesc 1 0 
    C-fcA" will move forward 10 characters. 


cEcENOTES cEcA


    Invocating this command via lslmexecute-named-command(2)le or by a macro has no 
    effect. It can be bound to only one key sequence which must be a single 
    key stroke such as cDC-x cAetc. Re-binding the command to another key will not 
    only unbind the new key but also the current cDprefix ?cA key bindings. 


cEcESEE ALSO cEcA


    lslmglobal-bind-key(2)le, lslmglobal-unbind-key(2)le. 

! 2 define-macro
cEcENAME cEcA


    define-macro - Define a new macro 
$a


cEcESYNOPSIS cEcA


    cCncA cDdefine-macrocA cCmacro-namecA 
        cCMacro bodycA 
    cD!emacrocA 


cEcEDESCRIPTION cEcA


    cDdefine-macrocA starts the definition of an macro named cCmacro-namecA, only used 
    within macro files or buffers. After the above header line, the body of 
    the macro is added, one command or expression on a line. The macro 
    definition is completed by the ls!emacro(4)lm!emacrole directive. 

    The numeric argument cCncA, specified as zero, defines the macro as private 
    such that it does not appear on a command completion list. A zero argument 
    is generally used on helper macro's that form part of a larger macro. If 
    the argument is omitted, or non-zero, then the macro appears in the 
    command completion list. 

    See lslmexecute-file(2)le for a complete definition and examples of the 
    MicroEmacs '02 macro language. 

    Once the macro has been defined, it becomes indistinguishable from a 
    standard MicroEmacs '02 command, i.e. lslmexecute-named-command(2)le (cGesc xcA) can 
    be used to execute the macro and lslmglobal-bind-key(2)le can be used to 
    globally bind the command to a key combination. 

    There are no restrictions on the number of macros that may be defined, 
    provided that the name space is managed properly. Consideration must be 
    given as to when any additional macros that are created are loaded into 
    MicroEmacs '02. We usually like start-up to be rapid and macros are loaded 
    as and when requested by the user, or by the buffer hooks as new files are 
    loaded (see lslmadd-file-hook(2)le and lslmdefine-macro-file(2)le). 

    User defined macros may be documented with on-line help by including a 
    lslmdefine-help(2)le construct within the macro file. 


cEcEEXAMPLE cEcA


    The following are two standard macros provided with MicroEmacs '02. The 
    first is a macro called cDcleancA, this strips trailing white space from the 
    ends of lines in a file and removes blank lines from the end of the file. 
sB
        define-macro clean 
            ; 
            ; Prepare to clean up file. 
            ; Remember line & magic mode 
            set-variable #l0 $window-line 
            set-variable #l1 &not &bmod magic 
            !if #l1 
                1 buffer-mode "magic" 
            !endif 
            ; 
            ; Get rid of trailing white space on EOL 
            beginning-of-buffer 
            replace-string "[\t ]+$" "\\0" 
            beginning-of-buffer 
            replace-string "[ ]+\t" "\t" 
            ; 
            ; Strip trailing blank lines. 
            end-of-buffer 
            backward-line 
            !while &and &gre $window-line 1 &sequal @wc "\n" 
                kill-line 
                backward-line 
            !done 
            ; 
            ; Clean up - restore buffer modes etc. 
            ; Move back to starting line & restore original magic mode 
            !force goto-line #l0 
            !if #l1 
                -1 buffer-mode "magic" 
            !endif 
            screen-update 
            ml-write "Cleaned up file." 
        !emacro 

sA
    The second example converts all of the cG<tab>cA characters in the file to 
    their cG<SPACE>cA character equivalent. 
sB
        ; 
        ; tabs-to-spaces. 
        ; Convert all of the tabs to spaces. 
        define-macro tabs-to-spaces 
            ; Remember line 
            set-variable #l0 $window-line 
            beginning-of-buffer 
            !force search-forward "\t" 
            !while $status 
                set-variable #l1 $window-acol 
                backward-delete-char 
                &sub #l1 $window-acol insert-space 
                !force search-forward "\t" 
            !done 
            goto-line #l0 
            screen-update 
            ml-write "[Converted tabs]" 
        !emacro 

sA
    Both of these commands are available from the command line, they are 
    indistinguishable from the built in commands. 

    Macros may also be nested, as shown in the next example, this macro 
    contains a cDdefine-macrocA within itself, when executed the macro creates 
    another macro dynamically - dynamic macros are generally given a prefix of 
    cD%cA and are highlighted differently in lslmdescribe-bindings(2)le. 

    The following example is taken from the lslmalarm(3)le macro, executing cDalarmcA 
    the user is prompted for a message, and the time interval before the alarm 
    expires in hours and minutes. It then creates a new macro with a callback 
    so that the new macro will be called at the correct time. 
sB
        !if &seq %alarm-numb "ERROR" 
            set-variable %alarm-numb 0 
            set-variable %osd-alarm &pinc %osd 1 
        !endif 

        define-macro alarm 
            set-variable %alarm-numb &add %alarm-numb 1 
            set-variable #l0 &cat "%alarm-" %alarm-numb 
            !force set-variable #l2 @3 
            !if &not $status 
                set-variable &ind #l0 @ml "Message" 
                set-variable #l1 @ml "Hours" 
                set-variable #l2 @ml "Minutes" 
            !else 
                set-variable &ind #l0 @1 
                set-variable #l1 @2 
            !endif 
            set-variable #l1 &mul 60000 &add &mul 60 #l1 #l2 
            define-macro #l0 
                !bell 
                set-variable #l0 &add &len &ind @0 10 
                osd %osd-alarm 0 "bat" 9 3 
                osd %osd-alarm 1 "" 
                osd %osd-alarm 2 "c" "ALARM" 
                osd %osd-alarm 3 "" 
                osd %osd-alarm 4 "" &ind @0 
                osd %osd-alarm 5 "" 
                osd %osd-alarm 6 "Bcf" " OK " f void 
                %osd-alarm osd 
            !emacro 
            #l1 create-callback #l0 
        !emacro 

sA

cEcESEE ALSO cEcA


    Refer to lslm!return(4)le and lslm!abort(4)le for details macro termination. 

    lslm!emacro(4)le, lslmadd-file-hook(2)le, lslmdefine-macro-file(2)le, lslmdefine-help(2)le, 
    lslmdescribe-bindings(2)le, lslmexecute-file(2)le, lslmexecute-named-command(2)le, 
    lslmglobal-bind-key(2)le, lslminsert-macro(2)le, lslmstart-kbd-macro(2)le. 

! 2 delete-blank-lines
cEcENAME cEcA


    delete-blank-lines - Delete blank lines about cursor 
$a


cEcESYNOPSIS cEcA


    cDdelete-blank-linescA (cDC-x C-ocA) 


cEcEDESCRIPTION cEcA


    cDdelete-blank-linescA deletes all the blank lines before and after the 
    current cursor position. Note that the deleted lines are not added to a 
    kill buffer. 


cEcESEE ALSO cEcA


    lslmdelete-indentation(3)le, lslmclean(3)le, lslmkill-line(2)le. 

! 2 delete-buffer
cEcENAME cEcA


    delete-buffer - Delete a buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-buffercA "cCbuffer-namecA" (cDC-x kcA) 


cEcEDESCRIPTION cEcA


    cDdelete-buffercA disposes of buffer cCbuffer-namecA in the editor and reclaim the 
    memory. This does not delete the file that the buffer was read from. 

    If the buffer has been edited and its name does not start with a 'cD*cA' then 
    the user is prompted as to whether the changes should be discarded. Also 
    if the buffer has an active process running in it then confirmation is 
    sort from the user before the process is killed. 

    The argument cCncA can be used to change the default behavior of delete-buffer 
    described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Enables loss of work checks (default). These include a check that the 
        buffer has not been modified, if so the user is prompted. Also if a 
        process is running then user must confirm that the process can be 
        killed. If this flag is not supplied then the buffer is killed without 
        any user prompts (useful in macros). 


cEcESEE ALSO cEcA


    lslmnext-buffer(2)le. 

! 2 directory-tree
cEcENAME cEcA


    directory-tree - Draw the file directory tree 
$a


cEcESYNOPSIS cEcA


    cCncA cDdirectory-treecA ["cCdirectorycA"] 


cEcEDESCRIPTION cEcA


    cDdirectory-treecA creates or manipulates a view of the file systems directory 
    structure. The command is quite complex to use directly so is largely used 
    but macros such as lslmfile-browser(3)le. 

    The argument cCncA is a bit based flag which is used to control the command, 
    where the bits have the following meaning:- 

    cD0x01cA 
        If set, the focal directory of the command is set by the given 
        "cCdirectorycA" argument. Otherwise the argument is not required and the 
        command must be executed within the "cC*directory*cA" buffer; the current 
        line sets the focal directory. 

    cD0x02cA 
        Specifies that the current line in resultant "cC*directory*cA" window 
        should be set to the focal directory. If this bit is not set then the 
        current line will be the last selected directory, or if none have been 
        selected, the first line in the buffer. 

    cD0x04cA 
        Specifies that any evaluations required during the commands operation 
        should be performed. Without this flag an open operation on a 
        directory which has not previously been evaluated will not be perform 
        an evaluation and the results will likely be incomplete. 

    cD0x08cA 
        Specifies that the current focal directory should be opened. This 
        means that sub-directories within the current focal directory will 
        also be drawn in the directory tree. 

    cD0x10cA 
        Specifies that the current focal directory should be closed. This 
        means that sub-directories within the current focal directory will not 
        be drawn in the directory tree. 

    cD0x20cA 
        Specifies that the current focal directory's open state should be 
        toggled. This means that if the sub-directories are currently hidden 
        they will now be drawn and vice-versa. 

    cD0x40cA 
        When specified any directory opened will be re-evaluated, ensuring the 
        accuracy of the information. 

    cD0x80cA 
        Enables a recursive behavior, for example if this flag was specified 
        with the open then not only will the focal directory be opened, but 
        all of it's children, and their children etc. Note that if the 
        Evaluation flag is not specified then only the already evaluated 
        directories can be opened. 

    directory-tree creates a new buffer "cC*directory*cA" and draws the known 
    directory tree. Every drawn directory is preceded by a character flag 
    giving the user an indication of the directory state, where: 

    cD?cA 
        Directory has not been evaluated. 

    cD-cA 
        Directory has been evaluated and is visible. 

    cD+cA 
        Directory has been evaluated but is currently hidden. 

    Directories which have been evaluated and found to have no children use 
    the '-' lslm$box-chars(5)le instead of a '-' character. 

    On UNIX platforms, if a directory is a symbolic link to another directory, 
    the link name is given after the directory name. 


cEcEEXAMPLE cEcA


    The best example of the use of directory-tree is lslmfile-browser(3)le which can 
    be found in hkdirlst.emf. 


cEcESEE ALSO cEcA


    lslmfile-browser(3)le, lslm$box-chars(5)le. 

! 2 indent
cEcENAME cEcA


    indent - Manage the auto-indentation methods 
$a


cEcESYNOPSIS cEcA


    cC0cA cDindentcA "cCind-nocA" "cCflagscA" "cClook-backcA" 

    cDindentcA "cCind-nocA" "cCtypecA" "cCtokencA" [ "cCclosecA" [ "cCignorecA" ]] [ "cCindentcA" ] 


cEcEDESCRIPTION cEcA


    The cDindentcA command creates and manages the auto-indenting methods, the 
    process of creating a new indentation method is best described in lslanguageTemplates(2)lmFileln
    lnLanguage Templatesle. The command takes various forms as defined by the 
    arguments. Each of the argument configurations is defined as follows:- 


cEIndentation Method Creation cA


    cC0cA cDindentcA "cCind-nocA" "cCflagscA" "cClook-backcA" 

    With an argument of cG0cA, cDindentcA creates a new indentation method with the 
    integer handle cCind-nocA. The indentation method is assigned to a buffer by 
    setting lslm$buffer-indent(5)le to cCind-nocA. cCind-nocA cannot be 0 as setting 
    cD$buffer-indentcA to zero disables indentation. If the indentation method 
    with the same cCind-nocA already exists, then the existing method is deleted 
    and a new method may be created. 

    cCflagscA Sets the indent bit flags where:- 

    cG0x01cA 
        Indent method is case insensitive. Note that cDindentcA tokens must be 
        specified in lower case. 

    cClook-backcA specifies the maximum number of lines, prior to the current 
    line, considered when calculating the indentation of a line, i.e. if there 
    are cClook-backcA number of lines between the line to be indented and the 
    previous non-blank line then the current indentation is lost. 

    If cClook-backcA is set to 0 then the indentation is effectively disabled as 
    the current indentation can never be found. The value may be specified in 
    the range 0-255, a value of 10 is typically sufficient. 


cEIndentation Rule Creation cA


    cDindentcA "cCind-nocA" "cCtypecA" "cCtokencA" [ "cCclosecA" [ "cCignorecA" ]] [ "cCindentcA" ] 

    With the default argument of cG1cA, cDindentcA creates a new rule for the 
    indentation method cCind-nocA which must have previously been defined and 
    initialized. 

    The indentation of a line in a buffer, which is using an indentation 
    method, is affected by the token types matched on the line (cCtypecA cGfcA, cGocA, cGscA) 
    and the current indentation (if line is not of type cGfcA). 

    The current indentation is determined by searching the previous lines 
    (look-back) for the indentation of the last indented line. This may not 
    simply be the indentation of the last non-blank line, the exact 
    indentation is determined by searching for tokens in the line and 
    assessing their effect on the indentation of the current line. 

    The format of the regex valid in the "cCtokencA" and "cCclosecA" arguments are the 
    same as at used by hilight token creation, see lslmhilight(2)le for more 
    information. 

    The indent tokens may be assigned one of the following types, using the 
    cCtypecA argument. If the type is specified in upper case then the token must 
    be surrounded by non-alpha-numeric characters: 

    cDFixedcA (cCtypecA = 'cGfcA' or 'cGFcA') 
        A line containing a fixed indent token will be indented to the given 
        cCindentcA column from the left-hand edge. cCindentcA is the only argument 
        specified. e.g. MicroEmacs macro cG!gotocA labels:- 
sB
            indent .hilight.emf f "*" 0 

sA
        producing 

                ..... 
            *label 
                ..... 


        The fixed token must be the first non-white character on the line, the 
        rest of the line is ignored. The indentation of the previous line has 
        no effect. 

    cDIndent-from-next-line-onwardcA (cCtypecA = 'cGncA' or 'cGNcA') 
        The indentation changes by cCindentcA from the next line onwards from the 
        current line. cCindentcA is the only argument specified. e.g. MicroEmacs 
        macro cG!ifcA:- 
sB
            indent .hilight.emf n "!if" 4 

sA
        Keeps the indentation of the cG!ifcA line the same as the previous 
        indentation, change the indentation on the following lines by an extra 
        4 characters, to produce: 

            .... 
            !if 
                .... 


    cDIndent-from-current-line-onwardcA (cCtypecA = 'cGocA' or 'cGOcA') 
        Increment the current and following lines indentation by cCindentcA. 
        cCindentcA is the only argument specified. e.g. MicroEmacs macro cG!endifcA 
sB
            indent .hilight.emf o "!endif" -4 

sA
        decrement the indent of the cG!endifcA line and following lines by 4 
        spaces producing: 

                .... 
            !endif 
            .... 


    cDIndent-singlecA (cCtypecA = 'cGscA' or 'cGScA') 
        Changes the indentation of the current line ONLY by cCindentcA. cCindentcA is 
        the only argument specified. e.g. MicroEmacs macro cG!elifcA:- 
sB
            indent .hilight.emf o "!elif" -4 

sA
        decrements the indentation of the cG!elifcA line by 4 characters, but 
        restores the previous indentation after the current line, producing: 

                .... 
            !elif 
                .... 


    cDBracketcA (cCtypecA = 'cGbcA' or 'cGBcA') 
        A bracket should be used when a starting token pairs with a closing 
        token which may span multiple lines. i.e. the opening and closing 
        braces of a programming language. Note that the opening and closing 
        tokens must be different otherwise they cannot be differentiated. A 
        bracket has two main effects: 

        When the previous line has an unmatched open bracket 
            In this situation the current line is indented to the right of the 
            mismatched bracket. 

        When the previous line has an unmatched close bracket 
            In this situation the matching open bracket is hunted for in 
            previous lines until either the cClook-backcA limit (See cDIndentation 
            Method CreationcA) is exhausted or the bracket is matched, in which 
            case the indent of that line is used. 

        For a bracket the only other argument given is the cCclosecA. e.g. tcl's 
        'cG(cA' and 'cG)cA' brackets 
sB
            indent .hilight.tcl b "(" ")" 

sA
        Which produces: 

            .... 
            .... (.... 
                  .... 
                  ....) 
            .... 


    cDContinuecA (cCtypecA = 'cGccA' or 'cGCcA') 
        Indicates that when cCtokencA is found on the current line, the next line 
        is a continuation of the current line. The indentation of the next 
        line is the indentation of the first continuation line plus the given 
        cCindentcA. cCindentcA is the only argument specified. e.g. tcl's '\' 
sB
            indent .hilight.tcl c "\\" 10 

sA
        A simple example is 

            .... 
            12345678901234567890      \ 
                     .... 
            .... 


        When used in conjunction with brackets, the following effect is 
        observed: 

            .... 
            12345678901234567890      \ 
                      ....(....       \ 
                           ....)      \ 
                      ....            \ 
                      .... 
            .... 


        This shows why the first continuation line (the cG123456...cA line) must 
        be located and used as the base line from which the indentation is 
        derived; again the cClook-backcA limits the search for this line. 

    cDExclusioncA (cCtypecA = 'cGecA' or 'cGEcA') 
        Used to exclude text between start cCtokencA and cCclosecA token from the 
        indentation calculation, typically used for quotes. The cCignorecA 
        argument is also specified (see lslmhilight(2)le cGtype 0x004cA type bracket) 
        e.g. MicroEmacs macro quotes:- 
sB
            indent .hilight.emf e "\"" "\"" "\\" 

sA
        e.g. tcl's quotes 
sB
            indent .hilight.tcl e "\"" "\"" "\\" 

sA
        producing:- 

            .... 
            ".... ignore { ... \" ... ignore another { token ... " 
            .... 


    cDIgnorecA (cCtypecA = 'cGicA' or 'cGIcA') 
        Text to the right of a line containing cCtokencA is to be ignored; 
        typically used for comments. e.g. MicroEmacs macro 'cG;cA' comment:- 
sB
            indent .hilight.emf i ";" 

sA
        Or tcl's 'cG#cA' comment 
sB
            indent .hilight.tcl i "#" 

sA
        producing 

            .... 
            # ... ignore this { indent token 
            .... 


cEcEEXAMPLE cEcA


    Examples of indentation method creations can be found in macro files 
    cGhkemf.emfcA, cGhktcl.emfcA and cGhkvrml.emfcA. The following example is taken from 
    cGhkemf.emfcA:- 
sB
        !if &sequal .hilight.emf "ERROR" 
            set-variable .hilight.emf &pinc .hilight.next 1 
        !endif 

        ... 

        0 indent  .hilight.emf 0 10 
        indent .hilight.emf N "define-macro" 4 
        indent .hilight.emf n "!if" 4 
        indent .hilight.emf s "!eli" -4 
        indent .hilight.emf s "!els" -4 
        indent .hilight.emf o "!end" -4 
        indent .hilight.emf n "!whi" 4 
        indent .hilight.emf o "!don" -4 
        indent .hilight.emf n "!rep" 4 
        indent .hilight.emf o "!until" -4 
        indent .hilight.emf o "!ema" -4 
        indent .hilight.emf e "\"" "\"" "\\" 
        indent .hilight.emf i ";" 
        indent .hilight.emf f "*" 0 

sA

cEcESEE ALSO cEcA


    lslanguageTemplates(2)lmFile Language Templatesle, lslm$buffer-indent(5)le, lslmadd-file-hook(2)le, lslmhilight(2)le. 

! 2 forward-delete-char
! 2 backward-delete-char
cEcENAME cEcA


|forward-delete-char
    forward-delete-char - Delete next character at the cursor position 
|backward-delete-char
    backward-delete-char - Delete previous character at the cursor position 
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-delete-charcA (cDC-dcA) 
    cCncA cDbackward-delete-charcA (cDbackspacecA) 


cEcEDESCRIPTION cEcA


    cDforward-delete-charcA deletes the next cCncA characters from the current cursor 
    position. If the cursor is at the end of a line, the next line is joined 
    on the end of the current line. If an argument is given or lslmletter(2m)le mode 
    is enabled then the character is added to the kill buffer, otherwise the 
    kill buffer is unaltered. 

    cDbackward-delete-charcA deletes the next cCncA characters immediately to the left 
    of the cursor (e.g. more conventionally backspace). If the cursor is at 
    the beginning of a line, this will join the current line on the end of the 
    previous one. If an argument is given or lsglobal-bind-key(2)lmletter modele is enabled then the 
    character is added to the kill buffer, otherwise the kill buffer is 
    unaltered. 


cEcENOTES cEcA


    cDforward-delete-charcA is also bound to cDdeletecA and cDS-deletecA. 

    cDbackward-delete-charcA is also bound to cDS-backspacecA. 


cEcESEE ALSO cEcA


    lslmbackward-kill-word(2)le, lslmforward-kill-word(2)le, lslmletter(2m)le. 

! 2 forward-kill-word
! 2 backward-kill-word
cEcENAME cEcA


|forward-kill-word
    forward-kill-word - Delete next word at the cursor position 
|backward-kill-word
    backward-kill-word - Delete previous word at the cursor position 
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-kill-wordcA (cDesc dcA) 
    cCncA cDbackward-kill-wordcA (cDesc backspacecA) 


cEcEDESCRIPTION cEcA


    cDforward-kill-wordcA deletes the next cCncA words starting at the current cursor 
    position, the deleted text is added to the kill buffer. See 
    lslmforward-word(2)le for a description of word boundaries. If the argument cCncA is 
    cG0cA the command has no effect. If a -ve argument is specified, +cCncA words are 
    deleted and the text is not added to the kill buffer. 

    cDbackward-kill-wordcA deletes the previous cCncA words before the cursor, the 
    deleted text is added to the kill buffer. The numeric argument has the 
    same effect as with cDforward-kill-wordcA. 


cEcENOTES cEcA


    cDbackward-kill-wordcA is also bound to cDesc backspacecA. 

    The -ve argument is typically used from macro scripts where the kill 
    buffer is more precisely controlled. 


cEcESEE ALSO cEcA


    lslmbackward-delete-char(2)le, lslmforward-delete-char(2)le, lslmforward-word(2)le, lslmyank(2)le. 

! 2 delete-window
! 2 delete-other-windows
cEcENAME cEcA


|delete-window
    delete-window - Delete the current window 
|delete-other-windows
    delete-other-windows - Delete other windows 
$a


cEcESYNOPSIS cEcA


    cDdelete-windowcA (cDC-x 0cA) 
    cDdelete-other-windowscA (cDC-x 1cA) 


cEcEDESCRIPTION cEcA


    cDdelete-windowcA attempts to delete the current window (remove window from 
    the screen), retrieving the lines for use in the window adjacent to it. 

    The window deletion policy is determined by the formation of the windows 
    displayed on the screen. The bias is for the cCpreviouscA window (above) the 
    current window to be merged when split vertically, and for the left window 
    to be merged when split horizontally. 

    cDdelete-other-windowscA deletes all of the other windows, the current window 
    becomes the only window, using the entire available screen area. 


cEcESEE ALSO cEcA


    lslmset-position(2)le, lslmgrow-window-vertically(2)le, lslmresize-window-vertically(2)le, 
    lslmsplit-window-horizontally(2)le, lslmsplit-window-vertically(2)le. 

! 2 backward-delete-tab
cEcENAME cEcA


    backward-delete-tab - Delete white space to previous tab-stop 
$a


cEcESYNOPSIS cEcA


    cDbackward-delete-tabcA (cDS-tabcA) 


cEcEDESCRIPTION cEcA


    cDbackward-delete-tabcA deletes all white characters left of the cursor back 
    to the previous tab stop or non-white space, the deleted text is not added 
    to the kill buffer. 


cEcESEE ALSO cEcA


    lslmtab(2)le, lslm$tabsize(5)le, lslm$tabwidth(5)le. 

! 2 describe-bindings
cEcENAME cEcA


    describe-bindings - Show current command/key binding 
$a


cEcESYNOPSIS cEcA


    cDdescribe-bindingscA (cDC-h bcA) 


cEcEDESCRIPTION cEcA


    cDdescribe-bindingscA pops up a window with a list of all the named commands, 
    and the keys currently bound to them. Each entry is formatted as: 

        cDkeyCodecA cG...........cA cDcommandcA 

    cDdescribe-bindingscA is buffer context sensitive and shows the bindings for 
    the currently active buffer (i.e. the buffer that is active when the 
    command is invoked). The resultant command list is divided into three 
    sections as follows: 

    cDBuffer BindingscA 
        The bindings for the active buffer when cDdescribe-bindingscA was invoked. 
        These are the buffer bindings set by lslmbuffer-bind-key(2)le. 

    cDMl BindingscA 
        The message line bindings as set by lslmml-bind-key(2)le. 

    cDGlobal BindingscA 
        Global binding of keys as set by lslmglobal-bind-key(2)le. 


cEcEEXAMPLE cEcA


    The following is an example of the displayed output from 
    cDdescribe-bindingscA. This was invoked while editing buffer cDm2fun038.2cA which 
    is the cDNroffcA file for this manual page; the local bindings for the buffer 
    are all Nroff related. 

        Buffer [m2cmd038.2] bindings: 

            "C-c C-s" ..................... nroff-size 
            "C-c C-r" ..................... nroff-roman 
            "C-c C-b" ..................... nroff-bold 
            "C-c C-i" ..................... nroff-italic 
            "C-c C-c" ..................... nroff-mono 
            "C-c C-o" ..................... nroff-para 
            "esc o" ....................... nroff-para 
            "esc q" ....................... nroff-para 
            "C-c b" ....................... nroff-bold-block 
            "C-c i" ....................... nroff-italic-block 
            "C-c C-h" ..................... nroff-swap-hilight 
            "C-c &" ....................... nroff-add-padding 
            "C-x &" ....................... nroff-remove-padding 
            "C-c C-p" ..................... nroff-prev 
            "C-mouse-drop-1" .............. nroff-tag 

        Ml bindings: 

            "esc esc" ..................... tab 

        Global bindings: 

            "C-a" ......................... beginning-of-line 
            "C-b" ......................... backward-char 
            "C-c" ......................... 4 prefix 
            "C-d" ......................... forward-delete-char 
            "C-e" ......................... end-of-line 
            "C-f" ......................... forward-char 
            "C-g" ......................... abort-command 
            "C-h" ......................... 3 prefix 
            "C-i" ......................... insert-tab 
            "C-k" ......................... kill-line 
            "C-l" ......................... recenter 
            "C-m" ......................... newline 
            "C-n" ......................... forward-line 
            "C-o" ......................... insert-newline 
            "C-p" ......................... backward-line 
            "C-q" ......................... quote-char 
            "C-r" ......................... isearch-backward 
            "C-s" ......................... isearch-forward 
            "C-t" ......................... transpose-chars 
            "C-u" ......................... universal-argument 
            "C-v" ......................... scroll-down 
            "C-w" ......................... kill-region 
            "C-x" ......................... 2 prefix 
            "C-y" ......................... yank 
            "C-z" ......................... scroll-up 
            "C-_" ......................... undo 
            "A-e" ......................... file-browser 
            "A-r" ......................... replace-all-string 
            "esc C-c" ..................... count-words 
            "esc C-f" ..................... goto-matching-fence 
            "esc C-g" ..................... abort-command 
            "esc C-i" ..................... goto-matching-fence 
            "esc C-k" ..................... global-unbind-key 
            "esc C-n" ..................... change-buffer-name 
            "esc C-r" ..................... query-replace-string 
            "esc C-v" ..................... scroll-next-window-down 
            "esc C-w" ..................... kill-paragraph 
            "esc C-z" ..................... scroll-next-window-up 
            "esc space" ................... set-mark 
            "esc !" ....................... pipe-shell-command 
            "esc $" ....................... spell-word 
            "esc ." ....................... set-mark 
            "esc /" ....................... execute-file 
            "esc <" ....................... beginning-of-buffer 
            "esc >" ....................... end-of-buffer 
            "esc ?" ....................... help 
            "esc @" ....................... pipe-shell-command 
            "esc [" ....................... backward-paragraph 
            "esc \\" ...................... ipipe-shell-command 
            "esc ]" ....................... forward-paragraph 
            "esc ^" ....................... delete-indentation 
            "esc b" ....................... backward-word 
            "esc c" ....................... compile 
            "esc d" ....................... forward-kill-word 
            "esc e" ....................... set-encryption-key 
            "esc f" ....................... forward-word 
            "esc g" ....................... goto-line 
            "esc i" ....................... tab 
            "esc k" ....................... global-bind-key 
            "esc l" ....................... lower-case-word 
            "esc m" ....................... global-mode 
            "esc n" ....................... forward-paragraph 
            "esc o" ....................... fill-paragraph 
            "esc p" ....................... backward-paragraph 
            "esc q" ....................... fill-paragraph 
            "esc r" ....................... replace-string 
            "esc t" ....................... find-tag 
            "esc u" ....................... upper-case-word 
            "esc v" ....................... scroll-up 
            "esc w" ....................... copy-region 
            "esc x" ....................... execute-named-command 
            "esc y" ....................... reyank 
            "esc z" ....................... quick-exit 
            "esc ~" ....................... -30 buffer-mode 
            "esc A-r" ..................... query-replace-all-string 
            "C-x C-a" ..................... set-alpha-mark 
            "C-x C-b" ..................... list-buffers 
            "C-x C-c" ..................... save-buffers-exit-emacs 
            "C-x C-d" ..................... change-directory 
            "C-x C-e" ..................... execute-kbd-macro 
            "C-x C-f" ..................... find-file 
            "C-x C-g" ..................... abort-command 
            "C-x C-h" ..................... hunt-backward 
            "C-x C-i" ..................... insert-file 
            "C-x C-l" ..................... lower-case-region 
            "C-x C-o" ..................... delete-blank-lines 
            "C-x C-q" ..................... rcs-file 
            "C-x C-r" ..................... read-file 
            "C-x C-s" ..................... save-buffer 
            "C-x C-t" ..................... transpose-lines 
            "C-x C-u" ..................... upper-case-region 
            "C-x C-v" ..................... view-file 
            "C-x C-w" ..................... write-buffer 
            "C-x C-x" ..................... exchange-point-and-mark 
            "C-x C-y" ..................... insert-file-name 
            "C-x C-z" ..................... shrink-window-vertically 
            "C-x #" ....................... filter-buffer 
            "C-x (" ....................... start-kbd-macro 
            "C-x )" ....................... end-kbd-macro 
            "C-x /" ....................... isearch-forward 
            "C-x 0" ....................... delete-window 
            "C-x 1" ....................... delete-other-windows 
            "C-x 2" ....................... split-window-vertically 
            "C-x 3" ....................... next-window-find-buffer 
            "C-x 4" ....................... next-window-find-file 
            "C-x 5" ....................... split-window-horizontally 
            "C-x 9" ....................... find-bfile 
            "C-x <" ....................... scroll-left 
            "C-x =" ....................... buffer-info 
            "C-x >" ....................... scroll-right 
            "C-x ?" ....................... describe-key 
            "C-x @" ....................... pipe-shell-command 
            "C-x [" ....................... scroll-up 
            "C-x ]" ....................... scroll-down 
            "C-x ^" ....................... grow-window-vertically 
            "C-x `" ....................... get-next-line 
            "C-x a" ....................... goto-alpha-mark 
            "C-x b" ....................... find-buffer 
            "C-x c" ....................... shell 
            "C-x e" ....................... execute-kbd-macro 
            "C-x h" ....................... hunt-forward 
            "C-x k" ....................... delete-buffer 
            "C-x m" ....................... buffer-mode 
            "C-x n" ....................... change-file-name 
            "C-x o" ....................... next-window 
            "C-x p" ....................... previous-window 
            "C-x q" ....................... kbd-macro-query 
            "C-x r" ....................... search-backward 
            "C-x s" ....................... search-forward 
            "C-x u" ....................... undo 
            "C-x v" ....................... set-variable 
            "C-x w" ....................... resize-window-vertically 
            "C-x x" ....................... next-buffer 
            "C-x z" ....................... grow-window-vertically 
            "C-x {" ....................... shrink-window-horizontally 
            "C-x }" ....................... grow-window-horizontally 
            "C-h C-c" ..................... help-command 
            "C-h C-i" ..................... help-item 
            "C-h C-v" ..................... help-variable 
            "C-h a" ....................... command-apropos 
            "C-h b" ....................... describe-bindings 
            "C-h c" ....................... list-commands 
            "C-h d" ....................... describe-variable 
            "C-h k" ....................... describe-key 
            "C-h v" ....................... list-variables 
            "backspace" ................... backward-delete-char 
            "delete" ...................... forward-delete-char 
            "down" ........................ forward-line 
            "end" ......................... end-of-buffer 
            "esc" ......................... 1 prefix 
            "f1" .......................... menu 
            "home" ........................ beginning-of-buffer 
            "insert" ...................... 141 buffer-mode 
            "left" ........................ backward-char 
            "mouse-drop-1" ................ mouse-drop-left 
            "mouse-drop-2" ................ yank 
            "mouse-drop-3" ................ menu 
            "mouse-pick-1" ................ mouse-pick-left 
            "mouse-pick-2" ................ void 
            "mouse-pick-3" ................ void 
            "page-down" ................... scroll-down 
            "page-up" ..................... scroll-up 
            "redraw" ...................... screen-update 
            "return" ...................... newline 
            "right" ....................... forward-char 
            "tab" ......................... tab 
            "up" .......................... backward-line 
            "S-backspace" ................. backward-delete-char 
            "S-delete" .................... forward-delete-char 
            "S-tab" ....................... backward-delete-tab 
            "C-down" ...................... 5 forward-line 
            "C-left" ...................... backward-word 
            "C-mouse-drop-1" .............. mouse-control-drop-left 
            "C-mouse-pick-1" .............. set-cursor-to-mouse 
            "C-page-down" ................. scroll-next-window-down 
            "C-page-up" ................... scroll-next-window-up 
            "C-right" ..................... forward-word 
            "C-up" ........................ 5 backward-line 
            "A-down" ...................... 1 scroll-down 
            "A-left" ...................... 1 scroll-left 
            "A-right" ..................... 1 scroll-right 
            "A-up" ........................ 1 scroll-up 
            "esc backspace" ............... backward-kill-word 
            "esc esc" ..................... expand-abbrev 
            "C-c g" ....................... grep 


    Note that both internal commands and macro commands are shown in the list. 


cEcESEE ALSO cEcA


    lslmbuffer-bind-key(2)le, lslmcommand-apropos(2)le, lslmdescribe-key(2)le, 
    lslmdescribe-variable(2)le, lslmglobal-bind-key(2)le, lslmlist-commands(2)le, 
    lslmml-bind-key(2)le. 

! 2 describe-key
cEcENAME cEcA


    describe-key - Report keyboard key name and binding 
$a


cEcESYNOPSIS cEcA


    cDdescribe-keycA (cDC-x ?cA) 


cEcEDESCRIPTION cEcA


    cDdescribe-keycA allows a key to be typed and it will report the name of the 
    command bound to that key (if any) and the internal key-code. This command 
    is useful when trying to locate the identity of keyboard keys for binding. 


cEcENOTES cEcA


    cDdescribe-keycA is also bound to cDC-h kcA. 


cEcESEE ALSO cEcA


    lslmcommand-apropos(2)le, lslmglobal-bind-key(2)le, lslmdescribe-bindings(2)le, 
    lslmdescribe-variable(2)le. 

! 2 describe-variable
cEcENAME cEcA


    describe-variable - Describe current setting of a variable 
$a


cEcESYNOPSIS cEcA


    cDdescribe-variablecA (cDC-h vcA) 


cEcEDESCRIPTION cEcA


    cDdescribe-variablecA describes the current setting of the given variable (cD%cA, 
    cD:cA and cD$cA variables), returning cGERRORcA if the variable is undefined. If a cG$cA 
    variable is not found then it is tested for an environment variable, i.e. 
sB
        describe-variable $PATH 

sA
    returns your environment cG$PATHcA setting. This is the easiest and best way 
    of determining the current platform from within a Macro file. 

    The returned value of any undefined variable is the string cGERRORcA. 


cEcENOTES cEcA


    Completion is enabled on the command line for variable names. 


cEcESEE ALSO cEcA


    lslmdescribe-key(2)le, lslmhelp-variable(2)le, lslmset-variable(2)le. 

! 2 delete-dictionary
cEcENAME cEcA


    delete-dictionary - Remove a spelling dictionary from memory 
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-dictionarycA ["cCdictionarycA"] 


cEcEDESCRIPTION cEcA


    cDdelete-dictionarycA removes the given cCdictionarycA from memory, where cCncA is a 
    bitwise flag determining the removal mode, defined as follows:- 

    cD0x01cA 
        Prompt the user before loosing any changes (except to the ignore 
        dictionary). 

    cD0x02cA 
        Delete all the dictionaries other than the ignore dictionary. 

    cD0x04cA 
        Delete the ignore dictionary. 

    If the argument does not have bit 0x02 or 0x04 set, which specify the 
    dictionaries to be deleted, the user is prompted for the "cCdictionarycA". The 
    default argument is 1. 


cEcENOTES cEcA


    The ignore dictionary is a temporary dictionary that exists in memory for 
    duration of the MicroEmacs session; the dictionary holds words that have 
    been ignored during any previous spell checks (see lslmspell(2)le). All of the 
    words that have been ignored may be discarded with:- 
sB
        4 delete-dictionary 

sA
    i.e. cDesc 4 esc x delete-dictionarycA. 


cEcESEE ALSO cEcA


    lslmspell-buffer(3)le, lslmadd-dictionary(2)le, lslmsave-dictionary(2)le, lslmspell(2)le. 

! 2 get-registry
! 2 set-registry
cEcENAME cEcA


|get-registry
    get-registry - Retrieve a node value from the registry. 
|set-registry
    set-registry - Modify a node value in the registry. 
$a


cEcESYNOPSIS cEcA


    cDget-registrycA "cCrootcA" "cCsubkeycA" 
    cDset-registrycA "cCrootcA" cC"subkeycA" cC"valuecA" 


cEcEDESCRIPTION cEcA


    cDget-registrycA retrieves the value of a node defined by cCrootcA/cCsubkeycA from the 
    registry into the variable lslm$result(5)le. 

    The node name is specified in two components, typically required when 
    iterating over a registry tree, where the cCrootcA component is static and the 
    cCsubkeycA is dynamic, cCsubkeycA may be specified as the null string (cG""cA) if an 
    absolute registry path is specified. 

    cDset-registrycA adds (or modifies) a new value to the registry. cCrootcA is the 
    root of the new entry and MUST exist or the call fails. cCsubkeycA is the node 
    name (or path) if the path does not exist then it is created. cCvaluecA is the 
    value to assign to the node. 


cEcEDIAGNOSTICS cEcA


    cDget-registrycA fails if the node does not exist, otherwise the registry 
    string is returned in lslm$result(5)le. 

    cDset-registrycA fails if the cCrootcA node does not exist. 


cEcEEXAMPLE cEcA


    The following call 
sB
        set-registry "/history" "foo/win32/printer" "foo-bar" 

sA
    constructs a registry hierarchy of the form:- 

        "history" { 
          "foo" { 
            "win32" { 
              "printer"="foo-bar"; 
            } 
          } 
        } 


    The value of the registry node may be retrieved using:- 
sB
        get-registry "/history" "foo/win32/printer" 

sA
    which would return "cGfoo-barcA". 


cEcESEE ALSO cEcA


    lslmfind-registry(2)le, lslmlist-registry(2)le, lslmread-registry(2)le, lslm&reg(4)le, lslmerf(8)le. 

! 2 exchange-point-and-mark
cEcENAME cEcA


    exchange-point-and-mark - Exchange the cursor and marked position 
$a


cEcESYNOPSIS cEcA


    cDexchange-point-and-markcA (cDC-x C-xcA) 


cEcEDESCRIPTION cEcA


    cDexchange-point-and-markcA moves the cursor to the current marked position 
    (see lslmset-mark(2)le) in the current window and moves the mark to where the 
    cursor was. This is very useful in finding where a mark was, or in 
    returning to a position previously marked. 


cEcESEE ALSO cEcA


    lslmset-mark(2)le, lslmcopy-region(2)le. 

! 2 execute-buffer
! 2 execute-line
cEcENAME cEcA


|execute-buffer
    execute-buffer - Execute script lines from a buffer 
|execute-line
    execute-line - Execute a script line from the command line 
$a


cEcESYNOPSIS cEcA


    cDexecute-buffercA "cCbuffer-namecA" 
    cDexecute-linecA ["cCcommand-linecA"] 


cEcEDESCRIPTION cEcA


    cDexecute-buffercA executes script lines in the named buffer cCbuffer-namecA. If 
    the buffer is off screen and an error occurs during execution, the cursor 
    is left on the line causing the error. 

    cDexecute-linecA executes a in script line entered from the command line. 
    Typically this is used in macros. 


cEcESEE ALSO cEcA


    lslmexecute-file(2)le, lslmexecute-string(2)le, lslmexecute-named-command(2)le. 

! 2 execute-file
cEcENAME cEcA


    execute-file - Execute script lines from a file 
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-filecA "cCfilecA" (cDesc /cA) 


cEcEDESCRIPTION cEcA


    cDexecute-filecA executes script lines from the given cCfilecA cCncA times in 
    succession, this is the normal way to execute a MicroEmacs '02 script. The 
    command prompts for a file name, and will then search for <cCfilecA>[.emf] in 
    the search path. If the file is found then the file is loaded and the 
    buffer is executed cCncA times. 


cEcESEE ALSO cEcA


    lslmexecute-buffer(2)le, lslmexecute-line(2)le, lslmexecute-named-command(2)le, 
    lslmexecute-string(2)le. 

! 2 execute-kbd-macro
cEcENAME cEcA


    execute-kbd-macro - Execute a keyboard macro 
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-kbd-macrocA (cDC-x ecA) 


cEcEDESCRIPTION cEcA


    cDexecute-kbd-macrocA executes a keyboard macro. The entire sequence of 
    recorded key-strokes is repeated starting at the current point. The result 
    is exactly as if you were retyping the sequence all over again. A numeric 
    argument cCncA prefixing the cDexecute-kbd-macrocA command repeats the stored 
    key-strokes cCncA times. 

    Keyboard macros are recored with lslmstart-kbd-macro(2)le; recording is 
    terminated with lslmend-kbd-macro(2)le. 


cEcESEE ALSO cEcA


    lslmend-kbd-macro(2)le, lslmkbd-macro-query(2)le, lslmname-kbd-macro(2)le, 
    lslmstart-kbd-macro(2)le. 

! 2 execute-named-command
cEcENAME cEcA


    execute-named-command - Execute a named command 
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-named-commandcA "cCcommand-stringcA" esc x 


cEcEDESCRIPTION cEcA


    cDexecute-named-commandcA command prompts the user for the name of a command 
    to execute and then executes the command cCncA times. MicroEmacs '02 offers 
    command completion and history facilities, see lslmml-bind-key(2)le. 


cEcESEE ALSO cEcA


    lslmexecute-buffer(2)le, lslmdescribe-bindings(2)le, lslmml-bind-key(2)le. 

! 2 execute-string
cEcENAME cEcA


    execute-string - Execute a string as a command 
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-stringcA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cDexecute-stringcA executes the given cCstringcA cCncA times as if it is being typed. 
    This is the writable format of a keyboard macro, it can be placed in any 
    cDemfcA file. Any characters may form the cCstringcA (unprintables as cG\xXXcA) and 
    key-strokes that are bound to a command will execute that command. This 
    command is used by macros to store user defined keyboard macros. 


cEcEEXAMPLE cEcA


    The following example uses keyboard strokes with cDexecute-stringcA in a macro 
    to format cDnroff(1)cA text located between cG.cA commands: 
sB
        define-macro nroff-para 
            beginning-of-line 
            !if &not &sequal @wc "." 
                1 buffer-mode "magic" 
                execute-string "\CXS^\\.\CM\CB\CM\CX\CH\CN\CM" 
                -1 fill-paragraph 
                execute-string "\CD\CX\CH\CN\CD\CXH\CB" 
            !endif 
            forward-line 
        !emacro 

sA
    cDexecute-stringcA has the advantage that execution is very fast as the amount 
    of parsing and decoding to be performed is limited. The disadvantage is 
    that you cannot quickly discern which operations are being performed !! 


cEcENOTES cEcA


    Try to avoid using named key, such as "cGupcA" and "cGreturncA", as the keyboard 
    macro equivalent is not readable and is likely to change in future 
    releases. 

    For this reason the following special abbreviations may be used 

    cD\EcA 
        The "cDescapecA" key. 

    cD\NcA 
        The "cDreturncA" key. 

    cD\TcA 
        The "cDtabcA" key. 

    cD\bcA 
        The backspace character (0x08). 

    cD\dcA 
        The delete character (0x7f). 

    cD\ecA 
        The escape character (0x1b). 

    cD\fcA 
        The form-feed character (0x0c). 

    cD\ncA 
        The carriage-return character (0x0a). 

    cD\rcA 
        The line-feed character (0x0d). 


cEcESEE ALSO cEcA


    lslmbuffer-abbrev-file(2)le, lslmglobal-abbrev-file(2)le, lslminsert-macro(2)le, 
    lslmname-kbd-macro(2)le, lslmstart-kbd-macro(2)le. 

! 2 exit-emacs
cEcENAME cEcA


    exit-emacs - Exit MicroEmacs 
$a


cEcESYNOPSIS cEcA


    cCncA cDexit-emacscA 


cEcEDESCRIPTION cEcA


    Exit MicroEmacs '02 back to the operating system. If no argument cCncA is 
    given and there are any unwritten, changed buffers, the editor prompts the 
    user to discard changes. If an argument is specified then MicroEmacs '02 
    exits immediately. 


cEcENOTES cEcA


    All buffers with a name starting with a 'cG*cA' are assumed to be system 
    buffers (i.e. cD*scratch*cA) and are not saved. 


cEcESEE ALSO cEcA


    lslmquick-exit(2)le, lslmsave-buffers-exit-emacs(2)le. 

! 2 insert-file-name
cEcENAME cEcA


    insert-file-name - Insert filename into current buffer 
$a


cEcESYNOPSIS cEcA


    cDinsert-file-namecA (cDC-x C-ycA) 


cEcEDESCRIPTION cEcA


    cDinsert-file-namecA inserts the current buffer's file name into the current 
    buffer or, if entering text on the message line then enters the file name 
    into the message line buffer. 


cEcESEE ALSO cEcA


    lslminsert-file(2)le, lslmyank(2)le. 

! 2 expand-abbrev
cEcENAME cEcA


    expand-abbrev - Expand an abbreviation 
$a


cEcESYNOPSIS cEcA


    cDexpand-abbrevcA 


cEcEDESCRIPTION cEcA


    cDexpand-abbrevcA expands an abbreviation to an alternate form. The 
    abbreviation must be an alpha-numeric string and the cursor must be one 
    position to the right of the abbreviation (which must not be 
    alpha-numeric) when this command is called. If the abbreviation is found, 
    it is deleted and the alternate form is inserted leaving the cursor at the 
    end of the insertion unless cG\pcA is used. If not found, a space is inserted. 


cEcESEE ALSO cEcA


    lslmbuffer-abbrev-file(2)le, lslmglobal-abbrev-file(2)le, lslmexpand-abbrev-handle(3)le, 
    lslmeaf(8)le. 

! 2 fill-paragraph
cEcENAME cEcA


    fill-paragraph - Format a paragraph 
$a


cEcESYNOPSIS cEcA


    cCncA cDfill-paragraphcA (cDesc ocA) 


cEcEDESCRIPTION cEcA


    cDfill-paragraphcA this takes all the text in the current paragraph (as 
    defined by surrounding blank lines, or a leading indent) and attempts to 
    fill it from the left margin to the current fill column as defined by 
    lslm$fill-col(5)le. When an argument cCncA is supplied cCncA paragraphs are filled. If cCncA 
    is positive then MicroEmacs '02 performs indented filling (i.e. 
    indentation for a bullet mark etc). If cCncA is negative then indented filling 
    is disabled. If no argument cCncA is supplied then the paragraph is filled and 
    the cCpointcA and cCmarkcA positions are retained. This allows paragraphs to be 
    filled, whilst in the middle of the paragraph and the word position is 
    maintained. 

    If cDjustify modecA is enabled the variable lslm$fill-mode(5)le determines how the 
    paragraph is filled (i.e. cCleftcA, cCrightcA, cCbothcA or cCcentercA). The variable 
    lslm$fill-eos-len(5)le determines the trailing space used after a period (cG.cA) 
    character (the trailing characters are specified by lslm$fill-eos(5)le), 
    typically defined as 2. 

    A set of characters defined by lslm$fill-bullet(5)le enable bullet markers to be 
    placed in the text at the beginning of the paragraph causing the left 
    margin to be moved to the right of the bullet. The search depth for fill 
    to locate a bullet character is defined by lslm$fill-bullet-len(5)le. When the 
    paragraph is formatted and one of the bullet characters is encountered 
    then the user is prompted as to whether the paragraph should be indented 
    following the marker or not. The point of indentation is shown with a cG<<<<cA 
    marker. 

    Filling is automatically disabled on paragraphs which start with 
    characters in the lslm$fill-ignore(5)le set. 

    The simple text formatting is generally used for mail messages, ASCII text 
    README files etc. 


cEcEEXAMPLE cEcA


    The following examples show how the text is formatted with indented 
    filling enabled and both justification enabled:- 

        This  is  regular  text  that  is on the 
        margin 

            This is a regular  paragraph that is 
            offset  from  the  margin.  Note how 
            MicroEmacs '02 retains the indent. 

            * With  the  introduction  of one of 
              the  special  characters,  in this 
              case a  bullet,  a  format  of the 
              paragraph  offsets  the text  from 
              the bullet. 

            1) Numbered  lists   are  the  same. 
               Note that the  paragraphs are all 
               separated with a blank line. 

            1. Numbered  lists  ending  with   a 
               period. 

            label - Or labeled lists, separated 
                    with a dash. 

            >  '>' might be an ignore 
            >  character so it skips the paragraph 
            > 
            >          it is up to the user to 
            >   format these. 


cEcESEE ALSO cEcA


    lslm$fill-bullet(5)le, lslm$fill-bullet-len(5)le, lslm$fill-col(5)le, lslm$fill-eos(5)le, 
    lslm$fill-eos-len(5)le, lslm$fill-ignore(5)le, lslm$fill-mode(5)le, lslmifill-paragraph(3)le, 
    lslmparagraph-to-line(3)le. 

! 2 filter-buffer
cEcENAME cEcA


    filter-buffer - Filter the current buffer through an O/S command 
$a


cEcESYNOPSIS cEcA


    cDfilter-buffercA (cDC-x #cA) 


cEcEDESCRIPTION cEcA


    cDfilter-buffercA executes one operating system command, using the contents of 
    the current buffer as input, sending the results back to the same buffer, 
    replacing the original text. 

    This would typically be used in conjunction with cDsort(1)cA, cDawk(1)cA or cDsed(1)cA 
    to translate the contents of the buffer. 


cEcESEE ALSO cEcA


    lslmpipe-shell-command(2)le. 

! 2 find-file
cEcENAME cEcA


    find-file - Load a file 
$a


cEcESYNOPSIS cEcA


    cCncA cDfind-filecA "cCfile-namecA" (cDC-x C-fcA) 


cEcEDESCRIPTION cEcA


    cDfind-filecA finds the named file cCfile-namecA. If it is already in a buffer, 
    make that buffer active in the current window, otherwise attempt to create 
    a new buffer and read the file into it. 

    The numeric argument cCncA can be used to modify the default behaviour of the 
    command, where the bits are defined as follows: 

    cD0x01cA 
        If the file does not exist and this bit is not set the command fails 
        at this point. If the file does not exist and this bit is set (or no 
        argument is specified as the default argument is cG1cA) then a new empty 
        buffer is created with the given file name, saving the buffer 
        subsequently creates a new file. 

    cD0x02cA 
        If this bit is set the file will be loaded with lslmbinary(2m)le mode 
        enabled. See help on cDbinarycA mode for more information on editing 
        binary data files. 

    cD0x04cA 
        If this bit is set the file will be loaded with lslmcrypt(2m)le mode 
        enabled. See help on cDcryptcA mode for more information on editing 
        encrypted files. 

    cD0x08cA 
        If this bit is set the file will be loaded with lslmrbin(2m)le mode enabled. 
        See help on cDrbincA mode for more information on efficient editing of 
        binary data files. 

    Text files are usually thought of as named collections of text residing on 
    disk (or some other storage medium). In MicroEmacs '02 the disk based 
    versions of files come into play only when reading into or writing out 
    buffers. The link between the physical file and the buffer is through the 
    associated file name. 

    MicroEmacs '02 permits full file names, i.e. you can specify: 

        disk:\directories\filename.extension 


    or (UNIX) 

        /directories/filename.extension 


    If the disk and directories are not specified, the current buffers disk/ 
    directory is used. Several points should be noted in respect to the 
    methods that MicroEmacs utilizes in the handling of files:- 

        * Without explicitly saving the buffer(s) to file, all edits would be 
          lost upon leaving MicroEmacs - you are asked to confirm whenever you 
          are about to lose edits. 

        * MicroEmacs has a mechanism for "protecting" your disk-based files 
          from overwriting when it saves files. When instructed to save a 
          file, it proceeds to dump the file to disk, making a backup of the 
          existing file when lslmbackup(2m)le mode is enabled. 

        * Auto-saving files can be performed on edited buffers by setting the 
          lslm$auto-time(5)le variable. The file is saved in the same place with a 
          'cG#cA' appended to the file name. This can be used directly by the user 
          or in the unlikely event of MicroEmacs crashing (or system crash), 
          the files are automatically recovered next time it is edited. 

    If you do not wish to perform any edits but merely browse the file(s), add 
    the lslmview(2m)le mode to the buffer or ask for the file to be read in for 
    lsview-file(2)lmviewingle only. 


cERCS Support cA


    If the file does not exist and the variable lslm$rcs-file(5)le is set then the 
    existence of the RCS file is tested. If the rcs file exists then it will 
    be checked out using a command-line created from the variable 
    lslm$rcs-co-com(5)le. If the check-out is successful then this file is loaded. 

    This raw interface for supporting file revision control systems has been 
    adapted to support SCCS and Visual Source Safe see help on variable 
    cD$rcs-filecA for more information and examples. 


cEHTTP Support cA


    MicroEmacs supports http file loading, this is available by default on 
    UNIX systems but must be compiled in on win32 platforms (socket libraries 
    not available on all win95 machines so cannot be compiled in by default). 
    When available a http file can be loaded by simply executing cDfind-filecA and 
    giving the http file name, i.e. "cGhttp://user:password@address:port/filecA". 
    Only thecG http://cA, cGaddresscA and cG/filecA components are mandatory, the rest can 
    usually be omitted. e.g.: 

        find-file "http://members.xoom.com/jasspa/index.html" 


    See help page on lslm%http-proxy-addr(5)le for information on HTTP proxy server 
    support. 


cEFTP support cA


    MicroEmacs supports ftp file loading, this is identical to http except the 
    prefix cGftp://cA is used as opposed tocG http://cA. The user name and password 
    defaults to cCguestcA in the absence of both these fields. If the user name is 
    supplied but not the password the password will be prompted for; this can 
    be useful as the password will not be stored or written to the history 
    file. Connection is by default on port 21. 

        find-file "ftp://<me>:<password>@members.xoom.com/jasspa/index.html" 


    See also lslmftp(3)le. 

    The progress of the FTP transfer, and the FTP commands issued, may be 
    viewed in the cG*ftp-console*cA buffer. This is popped up depending on the 
    setting of the lslm%ftp-flags(5)le variable. 


cEcENOTES cEcA


    The base name part (i.e. not the path) of cGfile-namecA can contain wild-card 
    characters compatible with most file systems, namely:- 

    cD?cA 
        Match any character. 

    cD[abc]cA 
        Match character only if it is cCacA, cCbcA or cCccA. 

    cD[a-d]cA 
        Match character only if it is cCacA, cCbcA, cCccA or cCdcA. 

    cD[^abc]cA 
        Match character only if it is not cCacA, cCbcA or cCccA. 

    cD*cA 
        Match any number of characters. 

    If the name matches more than one file, a buffer will be created for each 
    matching file. Note that these are not the same wild-card characters used 
    by lsRegularExpressions(2)lmregexle. 

    For cCftpcA and cChttpcA then a ftp console window is opened up to show the 
    progress of the transfer (when configured), this is described in lslmftp(3)le. 


cEcESEE ALSO cEcA


    lslmauto(2m)le, lslmbinary(2m)le, lslmcrypt(2m)le, lslmrbin(2m)le, lslmtime(2m)le, lslmview(2m)le, 
    lslmbuffer-mode(2)le, lslmfind-bfile(3)le, lslmftp(3)le, lslm$rcs-file(5)le, lslm%ftp-flags(5)le, 
    lslm%http-flags(5)le, lslm%http-proxy-addr(5)le, lslmnext-window-find-file(2)le, 
    lslmread-file(2)le, lslmsave-buffer(2)le, lslmview-file(2)le, lslmwrite-buffer(2)le, lslmfile-op(2)le, 
    lslmfile-attrib(3)le. 

! 2 find-tag
cEcENAME cEcA


    find-tag - Find tag, auto-load file and move to tag position 
$a


cEcESYNOPSIS cEcA


    cCncA cDfind-tagcA "cCstringcA" (cDesc tcA) 


cEcEDESCRIPTION cEcA


    cDfind-tagcA finds the current or given tag (cCstringcA) in a cDtagscA file and goes 
    to the given point, loading the file if necessary. The tag is either the 
    current word under the cursor or a user supplied word if the cursor is not 
    in a word. The buffer containing the tag is popped up in another window 
    and the cursor moved to the tag in the new window. 

    A cDtagscA file is usually created by an external program (e.g. cDctags(1)cA) 
    which stores word references (or tags) and the name of the file containing 
    the tag, with a search string to go to its local. It is an indexing system 
    which is often used in programming. 

    The argument cCncA can be used to change the default behavior of find-tag 
    described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Use popup-window to display the tag in a different window (default) 
        when this flag is not given the current window is used to display the 
        tag. 

    cD0x02cA 
        Disable the use of the current cursor position to determine the tag. 
        Instead the tag must always be supplied through "cCstringcA". 

    cD0x04cA 
        Find the next definition of the last tag (multiple tag support). This 
        feature can only be used if multiple tag support is enabled (see flag 
        'cDmcA' of variable lslm%tag-option(5)le) and cDfind-tagcA has already been 
        successfully executed. In this situation the last invocation of 
        find-tag defines the current tag and executing again with an argument 
        of cG4cA will jump to the next definition of the current tag or return the 
        message "cG[No more "<current>" tags]cA". 

        The next tag is typically bound to cGM-C-tcA. 

    The cDtagscA file is, by default, assumed to reside in the current directory 
    of the currently viewed file. The user variable lslm%tag-option(5)le may be 
    specified with a value of 'cGrcA' (recursive) and 'cGccA' (continue) flags, which 
    ascends the directory tree from the current directory and attempts to 
    locate a cCrecursivelycA generated tags file at a higher directory level. 
    Recursive tag files are generally easier to maintain where project source 
    files are located in a number of project sub-directories, and enable the 
    whole of the project tree to be taggable. 

    Two user variables must be defined before cDfind-tagcA will execute, if either 
    lslm%tag-file(5)le or lslm%tag-template(5)le are not defined the error message "cD[tags 
    not setup]cA" is signaled. 


cEcENOTES cEcA


    A cDtagscA file may be generated by MicroEmacs '02 from the menu (cCTools->XX 
    Tools->Create Tags FilecA). Alternatively a cDtagscA file may be generated by 
    the cDctags(1)cA utility. This is typically standard on UNIX platforms. For 
    Windows and DOS platforms then the cDExuberant CtagscA is recommended, this is 
    available from:- 

       cG http://darren.hiebert.comcA 

    A MicroEmacs '02 compatible tags file may be generated using the command 
    line "cGctags -N --format=1 ."cA cataloging the current directory. To generate 
    cDtagscA for a directory tree then use "cGctags -NR -format=1 .cA". Refer to the 
    cDExuberant CtagscA documentation for a more detailed description of the 
    utility. 


cEcESEE ALSO cEcA


    lslm%tag-file(5)le, lslm%tag-option(5)le, lslm%tag-template(5)le, lslmgenerate-tags-file(3)le, 
    cDctags(1)cA. 

! 2 get-next-line
cEcENAME cEcA


    get-next-line - Find the next command line 
$a


cEcESYNOPSIS cEcA


    cDget-next-linecA (cDC-x `cA) 


cEcEDESCRIPTION cEcA


    cDget-next-linecA is typically used in conjunction with the lslmcompile(3)le and 
    lslmgrep(3)le commands to enable the user to step through errors/locations one 
    by one. The command looks for lines in the form defined by 
    lslmadd-next-line(2)le in the order of definition. If a match is found the 
    command attempts to find the next error or warning found from the current 
    location (See lslmcompile(3)le). If the buffer was not found then the next 
    buffer set is searched for, and if found then the next expression from the 
    cursor is automatically located. The command fails if none of the buffers 
    exist, or the end of the buffer is reached. 


cEcESEE ALSO cEcA


    lslm$file-template(5)le, lslm$line-template(5)le. lslmadd-next-line(2)le, lslmcompile(3)le, 
    lslmgrep(3)le. 

! 2 goto-alpha-mark
cEcENAME cEcA


    goto-alpha-mark - Move the cursor to a alpha marked location 
$a


cEcESYNOPSIS cEcA


    cDgoto-alpha-markcA "cC?cA" (cDC-x acA) 


cEcEDESCRIPTION cEcA


    cDgoto-alpha-markcA prompts user for an alpha character and sets the cursor 
    position to the preset location. Alpha marks are specified on a per buffer 
    basis, thus the current buffer is not changed, merely the current location 
    in the buffer. The alpha mark must already be defined using 
    lslmset-alpha-mark(2)le. This functionality is useful for rapidly returning back 
    to locations in large files. 


cEcESEE ALSO cEcA


    lslmset-alpha-mark(2)le. 

! 2 goto-line
cEcENAME cEcA


    goto-line - Move the cursor to specified line 
$a


cEcESYNOPSIS cEcA


    cCncA cDgoto-linecA (cDesc gcA) 
    cDgoto-linecA "cCnumcA" 


cEcEDESCRIPTION cEcA


    cDgoto-linecA moves the cursor to the specified line in the buffer. The user 
    is prompted for the new line number on the command line, which may be 
    entered as a relative displacement ([cG+cA|cG-cA]cCnumbercA) from the current 
    position, or as an absolute line number (cCnumbercA). If the number is 
    preceded by cG+cA or cG-cA then this is treated as a relative displacement from 
    the current line, otherwise it is an absolute line number. 

    If a +ve argument cCncA is supplied, cDgoto-linecA moves to this line, e.g. to 
    move the cursor to line 240: 
sB
        240 goto-line 

sA
    A special case of cDgoto-linecA is operative if an argument of cG0cA is supplied, 
    argument "cCnumcA" must also be given as above except cDgoto-linecA treats the 
    line number or displacement as an absolute move, i.e. includes cCnarrowed 
    outcA sections when calculating the new position. If the new line lies 
    within a narrowed out section (i.e. a section that has been hidden and is 
    not visible on the screen) the narrow is automatically expanded. See 
    lslmnarrow-buffer(2)le for more information on narrowing. 

    Supplying a -ve argument to goto-line results in an error. 


cEcENOTES cEcA


    After successfully calling goto-line, variable lslm$window-line(5)le is set to 
    the required line number. 


cEcESEE ALSO cEcA


    lslmgoto-alpha-mark(2)le, lslmgoto-matching-fence(2)le, lslmnarrow-buffer(2)le, 
    lslm$window-line(5)le. 

! 2 goto-matching-fence
cEcENAME cEcA


    goto-matching-fence - Move the cursor to specified line 
$a


cEcESYNOPSIS cEcA


    cDgoto-matching-fencecA (cDesc C-fcA) 


cEcEDESCRIPTION cEcA


    cDgoto-matching-fencecA moves the cursor to the opposing fence character of 
    the character currently under the cursor. The set of fence characters 
    include cG[]cA, cG{}cA and cG()cA. i.e. if the character under the cursor is `cG{cA' then 
    cDgoto-matching-fencecA moves the cursor to the opening fence `cG}cA', and visa 
    versa. 

    cDgoto-matching-fencecA can also be used to move the cursor to matching C/C++ 
    cG#ifcA, cG#elifcA, cG#elsecA and cG#endifcA constructs, cycling through them in the given 
    order. 

    When the lslmfence(2m)le buffer mode is enabled the matching open fence is 
    automatically displayed when the closing fence is typed. The length of 
    time the matching fence is displayed for can be controlled by the 
    lslm$fmatchdelay(5)le variable. 


cEcESEE ALSO cEcA


    lslmfence(2m)le, lslm$fmatchdelay(5)le, lslmgoto-line(2)le. 

! 2 list-commands
cEcENAME cEcA


    list-commands - List available commands 
$a


cEcESYNOPSIS cEcA


    cDlist-commandscA (cDC-h ccA) 


cEcEDESCRIPTION cEcA


    cDlist-commandscA constructs a list of all known built in commands and macros 
    that are currently defined by MicroEmacs '02 and presents a list of those 
    commands in the buffer "cD*commands*cA". Each entry is formatted as:- 

        cDcommand ......................... keyCodecA 

    Where multiple keys are bound to the same command, then each of the 
    cCkeyCodecA's is shown. 

    cDlist-commandscA is similar to lslmdescribe-bindings(2)le except that the commands 
    are presented in alphabetical order (as opposed to key binding order). 


cEcEEXAMPLE cEcA


    The following is an example of the output of cDlist-commandscA:- 

        backward-char ................. "C-b" 
                                        "left" 
        backward-delete-char .......... "backspace" 
                                        "S-backspace" 
        backward-delete-tab ........... "S-tab" 
        backward-kill-word ............ "esc backspace" 
        backward-line ................. "C-p" 
                                        "up" 
                                        "C-up" 
        backward-paragraph ............ "esc [" 
                                        "esc p" 
        backward-word ................. "esc b" 
                                        "C-left" 
        beginning-of-buffer ........... "esc <" 
                                        "home" 
        beginning-of-line ............. "C-a" 
        buffer-bind-key 
        buffer-info ................... "C-x =" 
        buffer-mode ................... "esc ~" 
                                        "C-x m" 
                                        "insert" 
        buffer-unbind-key 
        : 
        : 


cEcESEE ALSO cEcA


    lslmdescribe-bindings(2)le, lslmlist-variables(2)le. 

! 2 grow-window-vertically
! 2 shrink-window-vertically
! 2 resize-window-vertically
cEcENAME cEcA


|grow-window-vertically
    grow-window-vertically - Enlarge the current window (relative change) 
|shrink-window-vertically
    shrink-window-vertically - Shrink the current window (relative change) 
|resize-window-vertically
    resize-window-vertically - Resize the current window (absolute change) 
$a


cEcESYNOPSIS cEcA


    cCncA cDgrow-window-verticallycA (cDC-x zcA) 
    cCncA cDshrink-window-verticallycA (cDC-x C-zcA) 
    cCncA cDresize-window-verticallycA (cDC-x wcA) 


cEcEDESCRIPTION cEcA


    cDgrow-window-verticallycA enlarges the current window by cCncA number of lines (1 
    by default). If cCncA is negative then the window is shrunk. 

    cDshrink-window-verticallycA shrinks the current window by cCncA number of lines 
    (1 by default). If cCncA is negative then the window is enlarged. 

    cDresize-window-verticallycA change the size of the current window to cCncA lines, 
    if possible. i.e. resize window is not a relative displacement. 

    Growth is performed by consuming space from the next vertical window below 
    the current window, except at the bottom of the screen where the previous 
    window is consumed. 


cEcESEE ALSO cEcA


    lslmgrow-window-horizontally(2)le, lslmresize-all-windows(2)le, 
    lslmsplit-window-vertically(2)le. 

! 2 tab
cEcENAME cEcA


    tab - Handle the tab key 
$a


cEcESYNOPSIS cEcA


    cCncA cDtabcA (cDtabcA) 


cEcEDESCRIPTION cEcA


    cDtabcA manages the cGtabcA key, typically inserts cCncA tabs. The effect of the 
    command is determined by: 

    cD$buffer-indentcA 
        If lslm$buffer-indent(5)le, is non-zero then the effect of tab is defined by 
        the setting of bit cG0x1000cA of variable lslm$system(5)le, typically it resets 
        the current line indentation or inserts a tab. 

    cDcmodecA 
        If cmode is enabled then the effect of tab is defined by the setting 
        of bit cG0x1000cA of variable lslm$system(5)le, typically it resets the current 
        line indentation or inserts a tab. 

    cDtabcA 
        If a tab is to be inserted and this mode is enabled then multiple 
        spaces are used instead of tab characters, see lslmtab(2m)le mode. 


cEcESEE ALSO cEcA


    lslmcmode(2m)le, lslm$buffer-indent(5)le, lslmtab(2m)le, lslmbackward-delete-tab(2)le, 
    lslminsert-tab(2)le, lslmnormal-tab(3)le, lslm$tabsize(5)le, lslm$tabwidth(5)le. 

! 2 help
! 2 help-command
! 2 help-variable
! 2 help-item
cEcENAME cEcA


|help
    help - Help; high level introduction to help 
|help-command
    help-command - Help; command information 
|help-variable
    help-variable - Help; variable information 
|help-item
    help-item - Help; item information 
$a


cEcESYNOPSIS cEcA


    cCncA cDhelpcA (cDesc ?cA) 
    cDhelp-commandcA "cCcommandcA" (cDC-h C-ccA) 
    cDhelp-variablecA "cCvariablecA" (cDC-h C-vcA) 
    cDhelp-itemcA "cCitemcA" (cDC-h C-icA) 


cEcEDESCRIPTION cEcA


    The help commands provide a quick on-line help facility within MicroEmacs 
    '02 without invoking a third party documentation system (e.g. a browser 
    such as cDNetscape(1)cA or cDwinhelp(1)cA). 

    The on-line help is assisted by a set of macros which enable key words 
    within the help buffers to be located by either tagging (cGesc tcA) or by 
    selection with the left mouse button. The tag mechanism supports command 
    completion. 

    cDhelpcA provides general help on the philosophy and functionality of 
    MicroEmacs '02, if an argument cCncA of 0 is given to the command it changes 
    the current buffer to the internal help buffer, typically named "cG*on-line 
    help*cA". This is a lshide(2m)lmhiddenle system buffer used to store all the on-line help 
    and can be used for a variety of things. Note that access to this buffer 
    must be via the cDhelpcA command, not cDfind-buffercA and the help command will 
    also ensure the system help file is loaded first. 

    cDhelp-commandcA describes the purpose of the given cCcommandcA. 

    cDhelp-variablecA Describes the purpose of the given cCvariablecA, similar to 
    cDhelp-commandcA, only for variables. 

    cDhelp-itemcA Describes the purpose of any given item, where item could be a 
    command, variable or any aspect of MicroEmacs '02. 


cEcEFILES cEcA


    The help files are ASCII text files located in the MicroEmacs '02 home 
    directory. The files are defined as follows:- 

    cGme.ehfcA - Help text file. 
    cGhkehf.emfcA - Help macros. 


cEcESEE ALSO cEcA


    lslmosd-help(3)le, lslmcommand-apropos(2)le, lslmdescribe-bindings(2)le, lslmdescribe-key(2)le, 
    lslmlist-commands(2)le, lslmlist-variables(2)le. 

! 2 osd
cEcENAME cEcA


    osd - Manage the On-Screen Display 
$a


cEcESYNOPSIS cEcA


    cDosdcA 
    cC-1cA cDosdcA 
    cC-2cA cDosdcA 
    cCncA cDosdcA 
    cD-1cA cDosdcA cCncA 
    cDosdcA cD-1cA cCflagcA 
    cDosdcA cCncA cD0cA cCflagscA ["cCschemecA"] ["cCx-poscA" "cCy-poscA"] ["cCmin-widthcA" "cCmin-depthcA" 
    "cCmax-widcA" "cCmax-depcA"] ["cCdefaultcA"] [["cCtitle-bar-schemecA"] ["cCTextcA"]] 
    ["cCresize-commandcA"] ["cCcontrol-commandcA"] ["cCinit-commandcA"] 
    cDosdcA cCncA cCicA cCflagscA ["cCtab-nocA"] ["cCitem-schemecA"] ["cCwidthcA" "cCdepthcA"] ["cCtextcA"] 
    ["cCargumentcA" "cCcommandcA"] 


cEcEDESCRIPTION cEcA


    The cDosdcA command manages the On-Screen Display, menu and dialogs. The 
    command takes various forms as defined by the arguments. Each of the 
    argument configurations is defined as follows:- 


cEMain Menu-Bar Status cA


    cDosdcA cD-1cA cCflagcA 

    This invocation determines the state of the top main menu bar. The state 
    is set by the argument cCflagcA defined as:- 

            cG 1cA - enable. 
            cG 0cA - disable. 
            cG-1cA - disable and destroy. 


cEDialog Creation and Redefinition cA


    cDosdcA cCncA cD0cA cCflagscA ["cCschemecA"] ["cCx-poscA" "cCy-poscA"] ["cCmin-widthcA" "cCmin-depthcA" 
    "cCmax-widcA" "cCmax-depcA"] ["cCdefaultcA"] [["cCtitle-bar-schemecA"] ["cCTextcA"]] 
    ["cCresize-commandcA"] ["cCcontrol-commandcA"] ["cCinit-commandcA"] 

    This invocation creates or resets the base properties of dialog cCncA. The 
    cCflagscA argument determines the arguments and are defined as follows: 

        cDAcA 
            Defines dialog as an alpha type dialog, items are added according 
            to their string text value. Alpha dialogs may not have separator 
            or child items. 

        cDicA 
            Used with the cDAcA flag, sets the alpha ordering to be case 
            insensitive. 

        cDGcA 
            Create a Grid dialog. Every item in the dialog is given a single 
            character boarder around it. If one of the dialogs items is also 
            given a 'cDGcA' flag, the boarder is drawn as a box around it, 
            otherwise spaces are used. 

        cDNcA 
            Create a Note-Book (or tabs) dialog. The dialog can only contain 
            one dialog inclusion item ('cDIcA') and Note-Book pages ('cDPcA'). Pages 
            added before the Inclusion item (page item number is lass than the 
            inclusion page item number) will be drawn at the top of the 
            note-book, those added after will be drawn at the bottom. 

        cDbcA 
            Draw boarder, draws a boarder around the outside of the dialog. 
            See also cCflagcA cDtcA (title) as flag effects the boarder. 

        cDacA 
            Defines the absolute start-up position of the dialog in the 
            arguments cCx-poscA and cCy-poscA, which are the column and row positions 
            respectively of the dialog from the top left-hand corner of the 
            display. The arguments must be specified. e.g. the main menu is 
            defined with an absolute position of (0,0). If the dialog can not 
            be fully drawn on the screen at the given position it will be 
            moved to a position which shows the most. 

        cDocA 
            Specifies an offset to the dialog position calculated by 
            MicroEmacs in the arguments cCx-poscA and cCy-poscA, which are the column 
            and row offsets. This flag is ignored when flag cDacA is also 
            specified. If the dialog can not be fully drawn on the screen at 
            the new position it will be moved to a position which shows the 
            most. 

        cDscA 
            Sets the size of the dialog. cDosdcA automatically resizes a dialog to 
            fit the contents, this flag should be considered as a size hint 
            for cDosdcA, and is not guaranteed to be honored. If the dialog has a 
            boarder (flag cDbcA) the size given should include the boarder size. 

            The arguments, cCmin-widthcA, cCmin-depthcA, cCmax-widthcA and cCmax-depthcA must 
            be specified, as 

            cD+vecA 
                The actual size of the dialog, minimum and maximum sizes. 

            cD0cA 
                cCmincA value should be specified as desired window size, cCmaxcA may 
                be 0 which specifies the screen size. 

            cD-vecA 
                cCmincA defines the maximum size. cCmaxcA is unlimited. 

            The following table shows possible combination of the sing 
            parameters and their effect:- 

            cCmincA=0, cCmaxcA=0 
                Default setting, makes dialog as small as possible, with a 
                maximum size of the screen. 

            cCmincA=0, cCmaxcA=50 
                Make dialog as small as possible with a max of 50 characters. 

            cCmincA=50, cCmaxcA=0 
                Make dialog as small as possible, but make it at least 50 
                characters big and no larger than the screen. 

            cCmincA=30, cCmaxcA=-1 
                Make dialog at least 30 characters big with no upper limit, 
                very useful for dialogs being used as scrolled children. 

            cCmincA=-1, cCmaxcA=50 
                Make dialog 50 characters big. 

            cCmincA=-1, cCmaxcA=0 
                Make dialog the same size as the screen. 

            cCmincA=-1, cCmaxcA=-1 
                Make dialog as big as possible (do not do this unless you have 
                a large amount of memory to throw away). 

        cDScA 
            Sets the main dialog scheme, The default scheme when not specified 
            is lslm$osd-scheme(5)le See macro file cGfileopen.emfcA for an example. 

        cDdcA 
            Sets default item to select to "cCdefaultcA". This item is selected 
            when the dialog is first opened, if this item is an automatically 
            opened sub-menu then the child menu will also be opened. 

        cDtcA 
            Title bar is present - draws the title bar. The cCtextcA argument is 
            optional Also see flags cDHcA, cDccA and cDrcA. 

        cDHcA 
            Defines the title bar color scheme if flag cDtcA is specified. If cCtcA is 
            absent the option is ignored. 

        cDccA 
            Centers the title bar text if specified. Option cDtcA must be 
            specified, otherwise the option is ignored. 

        cDrcA 
            Right justifies the title bar text if specified. Option cDtcA must be 
            specified, otherwise the option is ignored. 

        cDRcA 
            Defines the dialog as re-sizable. The cCresize-commandcA argument must 
            be specified and the command should resize the dialog to the sizes 
            given in lslm$result(5)le in the format "cGwwwwddddcA", where cGwcA is width and 
            cGdcA the depth. If the cCresize-commandcA is aborted then that resize 
            operation is abandoned. 

        cDMcA 
            Identifies the dialog as the main menu dialog. 

        cDCcA 
            Binds a command to the dialog, which is automatically executed 
            when the dialog is opened. When the dialog with a cDCcA attribute is 
            opened, it is rendered on the screen and then a command, defined 
            by cCcontrol-commandcA is invoked, when the command completes the 
            dialog is closed. 

            The command dialog is typically used to create status messages. 
            e.g. a "cGBusy - Please WaitcA" dialog box, such a dialog may be 
            implemented when saving the current buffer then create the simple 
            dialog and sent the cCcontrol-commandcA to lslmsave-buffer(2)le. The dialog 
            would be defined as:- 
sB
                osd 200 0 "btcHC" %osd-title-scheme "Saving Buffer" save-buffer 
                osd 200 1 "" 
                osd 200 2 "" "Busy - Please Wait" 
                osd 200 3 "" 
                200 osd 

sA
            If the dialog has buttons which need to become active then control 
            can be returned to cDosdcA by calling cDosdcA with no arguments, e.g. in 
            the above example the dialog can be made to stay on the screen 
            until the user selects cGokaycA by: 
sB
                define-macro test-osd 
                    save-buffer 
                    osd 200 2 "" "Save Complete" 
                    osd 200 4 "BcfH" %osd-ebtt-scheme "  &Okay  " f void 
                    osd 
                !emacro 

                osd 200 0 "btcHC" %osd-title-scheme "Saving Buffer" test-osd 
                osd 200 1 "" 
                osd 200 2 "" "Busy - Please Wait" 
                osd 200 3 "" 
                osd 200 4 "BcfHS" %osd-dbtt-scheme "  Okay  " 

                200 osd 

sA
            The above mechanism is how lslmspell-buffer(3)le operates. 

        cDkcA 
            Disables hot-keys for the dialog. All text strings are copied 
            literally. This is useful for dialogs like the tags child dialog 
            as many tags have 'cG&cA's in them. 

        cDBcA 
            Makes the mouse right Button have the same behaviour as the left, 
            by default the right mouse button simply closes the dialog. This 
            is useful for some dialogs which are opened using the right mouse 
            button. 

        cDfcA 
            Automatically uses the first letter of an item's test as the hot 
            key. Unlike the normal hot keys, the letter is not hi-lighted and 
            when typed by the user the item is only selected, not executed. 
            This flag also disables the normal hot-keys for the dialog, so all 
            text strings are copied literally. 

        cDncA 
            Disables '\n' characters in text fields leading to multi lines. By 
            default a text item of "Hello\nWorld" will create an item 5 by 2 
            characters big. 

        If "cCinit-commandcA" is given then this function is always called just 
        prior to the dialog being displayed so it can be used to configure the 
        dialog. 


cEDialog Destruction cA


    cD-1cA cDosdcA cCncA 

    This invocation destructs a dialog cCncA. The dialog is only destroyed if it 
    is not currently being displayed. 


cEDialog Item Creation and Redefinition cA


    cDosdcA cCncA cCicA cCflagscA ["cCtab-nocA"] ["cCitem-schemecA"] ["cCwidthcA" "cCdepthcA"] ["cCtextcA"] 
    ["cCargumentcA" "cCcommandcA"] 

    This invocation type adds a new item cCicA to a dialog cCncA, the operation of the 
    invocation is controlled by the cCflagscA as follows:- 

        cDDcA 
            Disable item cCicA, the item is ignored and is not rendered in the 
            dialog. 

        cDIcA 
            Include dialog "cCargumentcA" into this dialog. If "cCcommandcA" is 
            specified then it is called prior to the child being constructed 
            and can be used to define the child. This is similar to the cDMcAs 
            command. See also flag cDbcA. 

        cDPcA 
            Item is a Note-Book page, the item must have text and have an 
            argument which is the osd dialog to be show when the page is 
            activated. 

        cDMcA 
            Item is a sub-menu, The argument "cCargumentcA" specifies the 
            sub-menus osd dialog number. A "cCcommandcA" may also be specified 
            which is executed first, this can actually re-define the item and 
            set the dialog number, e.g. 
sB
                ; To start with the dialog number is unknown 
                osd 1 1 "M" f submenu-setup 

                define-macro submenu-setup 
                    osd 200 0 .... 
                    .... 
                    ; Now the sub-menu number is known redefine parent item, 
                    ; note the setup  command  is not given as we have now set 
                    ; it up! 
                    osd 1 1 "M" 200 
                !emacro 

sA
            See also options cDmcA, cDncA, cDecA, cDscA, cDwcA and cDdcA. 

        cDmcA 
            Sub-menu must be manually opened, using hot-key, the return key or 
            the left mouse button. 

        cDncA, cDecA, cDscA, cDwcA 
            Specify where a sub-menu is to be placed relative to the parent 
            item. The letter indicates the direction as points on a compass, 
            North, East, South and West, respectively. The default when 
            omitted is East. 

        cDdcA 
            Display sub-menu type, i.e. "cG..cA" for auto opening and "cG >cA" for a 
            manual opening sub-menu. 

        cD-cA 
            Fill a non-defined chars with 'cG-cA's instead of 'cG cA's, used to draw 
            the lines across menus, typically with no text given, e.g. 
sB
                osd 200 5 "-" 

sA
            But could also be specified as: 
sB
                osd 200 5 "-c" "Lined" 

sA
        cDCcA 
            Item is a check-box. The setting of the check-box is evaluated 
            when the dialog is first drawn, re-draw and whenever any item is 
            executed. A "cCcommandcA" must be specified which must both return the 
            current setting when the given argument (of 1) is given (!abort if 
            false, !return if true) and change the value if the argument value 
            is negated. The text string must also be specified, the first 6 
            characters are used in the drawing of the check box. The format 
            can be shown as follows:- 

                String\State       Off         On 
                "123456"            "12356"     "12456" 
                " (-+)^"            " (-)"      " (+)" 
                "^[ *] "            "[ ] "      "[*] " 
                "^^NY^^"            "N"         "Y" 
                "^^^^^^"            ""          "" 


            Note that no character is rendered when a 'cG^cA' character is used. 
            See also cDpcA for prepending the check-box. 

        cDpcA 
            Prepend the check-box box. By default a check box is drawn as: 

                "Check box12?56" 


            This option changes it to: 

                "12?56Check box" 


        cDxcA 
            When the item is executed do not exit the dialog. Often used with 
            Check-boxes. 

        cDicA 
            The command given is a command line string which is executed in a 
            similar fashion to lslmexecute-line(2)le. Note that if an argument is 
            required it is usually specified in the string, i.e. 
sB
                osd "i" "text" 5 "1000 ml-write @#" 

sA
            writes the argument (i.e. 5) for 1 second. 
sB
                osd "i" "text" 5 "my-command" 

sA
            in this case cCmy-commandcA will not be given an argument, 
sB
                osd "i" "text" 5 "10 my-command" 

sA
            in this case cCmy-commandcA will be given an argument of 10, 
sB
                osd "i" "text" 5 "@# my-command" 

sA
            in this case cCmy-commandcA will be given an argument of 5. 

        cDhcA 
            Horizontally add the next item, e.g. 
sB
                osd "h" "1st on line " 
                osd ""  "2nd on line" 

sA
            Will produce "cG1st on line 2nd on linecA". If there is not enough 
            room on a single dialog line to display all the horizontally added 
            items then the line is split and as many lines as needed are used. 

        cDccA 
            Center the text for the item in the middle of the dialog. 

        cDrcA 
            Right hand justify the text for the item. 

        cDtcA 
            Set the items tab order in the dialog. 

        cDbcA 
            Child inclusion is a scroll box type. By default a child inclusion 
            simply draws the whole child dialog at the position. If this flag 
            is specified then arguments "cCwidthcA" and "cCdepthcA" must also be 
            supplied and a window displaying "cCwidthcA" by "cCdepthcA" of the child 
            is created. The size of this item will be "cCwidthcA"+1+cCsscA by 
            "cCdepthcA"+1+cCsscA where cCsscA is the scroll bar size which is 1 or 2 
            depending on the setting of lslm$scroll-bar(5)le. It is up to the user 
            to ensure that the child dialog being displayed is at least 
            "cCwidthcA" by "cCdepthcA" characters in size, if this is not true then 
            the effect is undefined, (a crash dump is not out of the 
            question). 

        cDfcA 
            Fix the item size to the given "cCsizecA", by default an item is 
            expanded to the width of the dialog. 

        cDEcA 
            Item is an entry box type. Use a string of cG#cA's to set the position 
            and size of the entry text box. Similar to Check-boxes, the 
            command given must both return and set the value depending on 
            value of the argument given. The value must be returned in 
            lslm$result(5)le if the given argument (or 1 for 'cGfcA') is given, and the 
            value must be set (usually using lslm@ml(4)le or lslm@mc(4)le) if the argument 
            is negated. The absolute value of the argument is maintained. 
sB
                set-variable %entry-value "Hello world" 

                define-macro my-entry-set 
                    !if &equ @# -1 
                        set-variable %entry-value @ml "" %entry-value 
                    !else 
                        set-variable $result %entry-value 
                    !endif 
                !emacro 

                osd 200 1  "S" " &Enter text" 2 
                osd 200 2  "ExHf" %osd-entry-scheme "########" 1 my-entry-set 

sA
        cDBcA 
            Item is a Button type. Add the last 2 characters of 
            lslm$window-chars(5)le to the text string given, one on each side, i.e. 
            if the last two chars are "[]" then: 
sB
                osd "B" " Okay " 

sA
            will be drawn as "cG[ Okay ]cA". See also flag cDTcA. 

        cDTcA 
            Item is a repeat type, this is typically used with buttons, 
            altering their execution behavior. By default an item is only 
            executed when the left mouse button is released while over the 
            item. However when this flag is specified the item is executed as 
            soon as the left mouse button is pressed and is repeatedly 
            executed until the button is release or the mouse moves off the 
            item. The delay between repeated executions is determined by the 
            variables lslm$delay-time(5)le and lslm$repeat-time(5)le. 

        cDScA 
            Item is a separator type. This is not often required as any item 
            without anything to execute is automatically set to be a 
            separator. Occasionally a mouse-insensitive item which can be 
            executed is required, typically a text string with a hot key, e.g. 
sB
                osd 200 1  "S" " &Enter text" 2 
                osd 200 2  "ExHf" %osd-entry-scheme "########" 1 my-entry-set 

sA
            will be drawn as "cG[ Okay ]cA" 

            Item 1 will have a hot-key which executes item 2 (as no command is 
            given), but it will not hi-light if the mouse is placed over it. 

        cDRcA 
            Redraw dialog. Forces a redraw of the dialog when the item is 
            executed. This is not usually required as cDosdcA generally works out 
            for itself whether a redraw is needed, however, sometimes it does 
            not, most notably when the item sets a variable that is displayed 
            by another item as an entry, e.g. 
sB
                set-variable %entry-value "Hello world" 

                define-macro my-entry-set 
                    !if &equ @# -1 
                        set-variable %entry-value @ml "" %entry-value 
                    !else 
                        set-variable $result %entry-value 
                    !endif 
                !emacro 

                osd 200 1  "S" " &Enter text" 2 
                osd 200 2  "ExHf" %osd-entry-scheme "########" 1 my-entry-set 
                osd 200 3  "BxHcfiR" %osd-ebtt-scheme  " &Reset " f "set-variable %entry-value\"\"" 

sA
            If item 3 did not have flag cDRcA set when executed, cDosdcA would not 
            realize that the change to value cG%entry-valuecA affects the display 
            and the button would not appear to operate. 

        cDHcA 
            Sets the item color scheme. Note that for scrolled child items 
            this only sets the scroll-box color scheme, the dialog scheme is 
            used for the rest of the boarder. 

        cDGcA 
            This flag is only applicable in grid dialogs (see flag cDGcA in dialog 
            creation). The current item will be drawn with a box around it 
            using lslm$box-chars(5)le. 

        cDzcA 
            Sets the item size, arguments "cCwidthcA" and "cCdepthcA" must be given. 

        cDNcA 
            This flag only has an effect on entry item types, it selects 
            'New-line' style text entry which allows the user to enter 
            multiple line of text using the return key and to end the input 
            using the tab key. 

        Note that for a non-sub-menu item type, if an argument is given with 
        no command then it is assumed that the number given is the item number 
        to be executed, see flag cDScA for an example. 


cEDialog Exacution cA


    cCncA cDosdcA 

    This invocation with a single positive numeric argument executes the cCncAth 
    dialog. 


cEReturning Command Control cA


    cDosdcA 

    An invocation of cDosdcA with no arguments returns control back to the cDosdcA 
    from a cCcontrol-commandcA. Refer to the cDCcA flag in the create/reset dialog 
    property for information and an example. 


cECurrent Dialog Redraw cA


    cC-1cA cDosdcA 

    Calling osd with an argument of -1 forces the complete redrawing of 
    current dialog and any sub-dialogs. This is very useful when the execution 
    of one item may effect the appearance of another. 


cERedraw All Active Dialogs cA


    cC-2cA cDosdcA 

    Calling osd with an argument of -2 forces the complete redrawing of all 
    currently active osd dialogs. This is better than calling lslmscreen-update(2)le 
    when only the osd dialogs need updating as it suffers less from 
    flickering. 


cEcEEXAMPLE cEcA


    Refer to cGosd.emfcA, cGuserstp.emfcA, cGsearch.emfcA, cGspell.emfcA and cGorganize.emfcA for 
    examples of the OSD. 


cEcESEE ALSO cEcA


    lslm$osd-scheme(5)le, lslm$result(5)le, lslm$scroll-bar(5)le. lslm$window-chars(5)le. 

! 2 show-cursor
cEcENAME cEcA


    show-cursor - Change the visibility of the cursor 
$a


cEcESYNOPSIS cEcA


    cCncA cDshow-cursorcA 


cEcEDESCRIPTION cEcA


    cDshow-cursorcA hides the cursor if a negative argument is given and restores 
    it if a positive or no argument is given. Note that this is not supported 
    on all platforms. 

    cDshow-cursorcA internally performs a counting operation, if the cursor is 
    hidden cCmcA times then it must also be shown cCmcA times before the cursor 
    becomes visible again, giving no argument will restore the count ensuring 
    it is visible. 

! 2 narrow-buffer
cEcENAME cEcA


    narrow-buffer - Hide buffer lines 
$a


cEcESYNOPSIS cEcA


    cCncA cDnarrow-buffercA 


cEcEDESCRIPTION cEcA


    The effect of cDnarrow-buffercA depends on the argument given, defined as 
    follows:- 

    1 
        Removes all narrows in the current buffer (Default). 

    2 
        Removes the current line's narrow. 

    3 
        Narrow to region. Hides all but the lines of test in the current 
        buffer from the lsset-mark(2)lmmarkle position to the current cursor position, 
        effectively 'narrowing' the buffer to the remaining text. 

    4 
        Narrow out region. Hides the lines of test in the current buffer from 
        the lsset-mark(2)lmmarkle position to the current cursor position, opposite to argument 
        cD3cA. 

    When a narrow is created the buffer mode lslmnarrow(2m)le is automatically set, 
    when the last is removed this mode is deleted. 

    For example, if the buffer contains the following text: 

        1 Richmond 
        2 Lafayette 
        3 Bloomington 
        4 Indianapolis 
        5 Gary 
        6 


    If the mark is on line 2 and the current point is on line 4, executing:- 

        4 narrow-buffer 


    Creates one narrow, narrowing out line 2 and 3. Line 4 becomes the narrow 
    anchor line, when the narrow is removed lines 2 and 3 will be inserted 
    before line 4. The buffer will become:- 

        1 Richmond 
        4 Indianapolis 
        5 Gary 


    If instead the following was executed:- 

        3 narrow-buffer 


    Two narrows are created, the first narrowing out line 4 and 5 (line 6, the 
    last line, being the anchor line) the second narrowing out line 1 (line 2 
    being the anchor line). The buffer will become:- 

        2 Lafayette 
        3 Bloomington 
        6 


    Executing cDnarrow-buffercA with an argument of cD2cA will only work on the anchor 
    lines, namely 4 in the first example and 2 and 6 in the second. 


cEcENOTES cEcA


    Alpha mark set by lslmset-alpha-mark(2)le in text which is subsequently narrowed 
    out will automatically remove the narrow if the user returns to the mark 
    using lslmgoto-alpha-mark(2)le. 

    lslmget-next-line(2)le operates on the unnarrowed buffer and will remove any 
    narrows hiding the 'next' line. 


cEcEEXAMPLE cEcA


    lslmc-hash-eval(3)le macro defined in cmacros.emf uses narrow-buffer to hide 
    regions of source code which has been #defined out, improving readability. 

    lslmvm(3)le defined in vm.emf uses narrow-buffer with appropriate arguments to 
    lslmappend-buffer(2)le and lslmwrite-buffer(2)le to write out only parts of the 
    current buffer. 


cEcESEE ALSO cEcA


    lslmnarrow(2m)le, lslmset-mark(2)le, lslmset-alpha-mark(2)le, lslmget-next-line(2)le, 
    lslmc-hash-eval(3)le, lslmvm(3)le. 

! 2 hilight
cEcENAME cEcA


    hilight - Manage the buffer hilighting schemes 
$a


cEcESYNOPSIS cEcA


    cC0cA cDhilightcA "cChil-nocA" "cCflagscA" [ "cCnolcA" ] [ "cCbuffer-schemecA" [ "cCtrunc-schemecA" ] 
    ] 

    cDhilightcA "cChil-nocA" "cCtypecA" "cCtokencA" [ ["cCrtokencA"] 
        [ ( [ "cCclosecA" ["cCrclosecA"] "cCignorecA" ] ) | 
            ( ["cCcontinuecA"] ) | 
            ( ["cCb-hil-nocA"] ) ] 
        "cCschemeNumcA" 
    cDhilightcA "cChil-nocA" "cC0x200cA" "cCtokencA" 
    cDhilightcA "cChil-nocA" "cC0x400cA" "cCfrom-colcA" "cCto-colcA" "cCschemeNumcA" 

    cC-1cA cDhilightcA "cChil-nocA" "cCtypecA" "cCtokencA" 


cEcEDESCRIPTION cEcA


    The cDhilightcA command creates and manages the buffer hilighting, the process 
    of creating a new hilighting scheme is best described in lslanguageTemplates(2)lmFile Languageln
    lnTemplatesle. The command takes various forms as defined by the arguments. 
    Each of the argument configurations is defined as follows:- 


cEHilight Scheme Creation cA


    cC0cA cDhilightcA "cChil-nocA" "cCflagscA" [ "cCnolcA" ] [ "cCbuffer-schemecA" [ "cCtrunc-schemecA" ] 
    ] 

    With an argument of cG0cA, cDhilightcA initializes or re-initializes the hilight 
    scheme cChil-nocA (1-255). Every buffer has a hilight scheme, the default is 0 
    which means no hi-lighting and only the lslm$global-scheme(5)le etc. are used. 
    The hilighting scheme must be defined before use and is used to specify 
    how the buffer is to be hilighted. MicroEmacs '02 supports the following 
    hilighting concepts:- 

        * cDhilight stringcA, a user specified string is hilighted in any color 
          scheme. 
        * cDTokenscA, same as a hilight string except that the string must be 
          enclosed in non alpha-numeric characters. 
        * cDStart-of-line hilightscA, the start of the hilight must be the first 
          non-white character of the line. 
        * cDEnd-of-Line hilightscA, the hilight starts from the current position 
          and continues until the end of the line. Optionally, the hilight may 
          continue onto the next line if the current line ends in a given 
          string. A bracket may also be searched for within the line. 
        * cDBracket hilightcA, hi-lights from the current position until the 
          closing bracket token is found. 
        * cDReplace string cA, allows the hilight string to be replaced with a 
          different user specified string. (i.e. the displayed representation 
          is different from the buffer contents) 

    Terminals that cannot display color directly may still be able to take 
    advantage of the hi-lighting. A terminal that has fonts (i.e. cCTermcapcA) can 
    use them in the same way using the lslmadd-color-scheme(2)le command. The 
    hi-light scheme is also used in printing (see lslmprint-buffer(2)le). If your 
    terminal cannot display color in any way, it is recommended that 
    hi-lighting is disabled (except when printing) as it does take CPU time. 

    The "cChil-nocA" argument specifies which hi-lighting scheme is being 
    initialized. Once a hilighting scheme has been initialized, hi-light 
    tokens can be added to it and it can be used by setting the current 
    buffer's lslm$buffer-hilight(5)le variable to "cChil-nocA". The "cCflagscA" argument is 
    a bit based flag setting global hi-light characteristics, where:- 

    cD0x01cA 
        The hi-light scheme is case insensitive, i.e. the following tokens 
        become equivalent:- 

            cGhousecA == cGHOUSEcA == cGhOuSecA 

        When the hilight scheme is attributed as case insensitive then the 
        tokens must cDallcA be specified in cDlowercA case. 

    cD0x02cA 
        Set a hi-light look-back. During the process of determining the window 
        hilighting then the hilight process has to determine whether the top 
        of the window starts in a hi-light bracket or not. The look-back 
        command tries looking "cCnolcA" lines backwards for an open bracket. If an 
        open bracket is found then the top of the window is assumed to start 
        with that bracket, else it is assumed that the top of the window is 
        not in a bracket. For example, in `C', a comment starts with "cG/*cA" and 
        ends with "cG*/cA" so if the hilight was initialized with 
sB
            0 hilight 1 2 10 $global-scheme 

sA
        of the following, only the first would begin hi-lighted which is 
        correct (assuming the "cG/*cA" is 10 or less lines away). 

             /* ........         /*.........           ......... 
                ........           .........*/         ......... 
            ----------------    ---------------     --------------- top of 
                ........*/         .........           .........    window 


    The optional argument "cCbuffer-schemecA" specifies the default scheme to use 
    if there is no specific hi-light, when omitted the value of 
    lslm$global-scheme(5)le is used. The cCbuffer-schemecA is a reference to a set of 
    foreground and background color pairs previously defined with 
    lslmadd-color-scheme(2)le. The last argument "cCtrunc-schemecA" is also optional and 
    specifies the line truncation scheme, when omitted the value of 
    lslm$trunc-scheme(5)le is used. 

    The hi-lighting scheme required is based on the type of file being edited 
    and so is usually directly related to the file extension, thus it can be 
    automatically set using file hooks (see lslmadd-file-hook(2)le). 


cEHilight Scheme Token Creation cA


    cDhilightcA "cChil-nocA" "cCtypecA" "cCtokencA" [ ["cCrtokencA"] 
        [ ( [ "cCclosecA" ["cCrclosecA"] "cCignorecA" ] ) | 
            ( ["cCcontinuecA" ["cCrcontinuecA"] ] ) | 
            ( ["cCb-hil-nocA"] ) ] 
        "cCschemeNumcA" 
    cDhilightcA "cChil-nocA" "cC0x200cA" "cCtokencA" 
    cDhilightcA "cChil-nocA" "cC0x400cA" "cCfrom-colcA" "cCto-colcA" "cCschemeNumcA" 

    With the default argument of cG1cA, cDhilightcA creates a hilight token to be used 
    in hilight color scheme identified by "cChil-nocA" (1-255) (see the section on 
    cDHilight Scheme CreationcA for a overview of hi-lighting). The second 
    argument "cCtypecA" specifies the token type and must always be specified, it 
    determines which other arguments required. 

    Typically the last argument, cCschemeNumcA, is also required. This identifies 
    the color scheme to use when hilighting the token, defining the 
    foreground, background and selection color schemes. This is an index 
    generated from lslmadd-color-scheme(2)le. If the cCschemeNumcA argument is omitted 
    the default hilght color scheme is used. 

    The token "cDtypecA" is a bit based flag of which 0, 1 or more of the bits may 
    be set, the effect of the bits are defined as follows: 

    cD0x001cA 
        The "cCtokencA" must be surrounded by non-word characters (word characters 
        are typically the alpha-numeric characters), e.g. the following 
        defines "cGifcA" as a token: 
sB
            hilight 1 1 "if" .scheme.keyword 

sA
        this hilights the 'if' in "cG if cA" but not in "cGaifacA". 

    cD0x002cA 
        Color this to the end of the line, often used for comments etc. For 
        example in MicroEmacs macro language a 'cG;cA' character signifies the 
        rest of the line as a comment, hilighting is defined as follows: 
sB
            ; this is a comment line 
            hilight 1 2 ";" .scheme.comment 

sA
    cD0x004cA 
        This is a bracket token, the closing bracket string "cCclosecA" and an 
        ignore character "cCignorecA" must also be supplied. The ignore character 
        indicates that when found it should ignore the next character; this 
        prevents an early end on bracket miss-match. For example, in C a 'cG"cA' 
        character can be inserted into a string by 'protecting' it with a 'cG\cA' 
        character, such as "cCthis is a string with a \" in itcA". In this example 
        the ignore character should be 'cC\cA' so the mid string 'cG"cA' is correctly 
        ignored, as follows: 
sB
            hilight 1 4 "\"" "\"" "\\" .scheme.string 

sA
        An empty value, "", effectively disables the ignore feature. If 
        replacing bit cG0x040cA is set the replacement close bracket "cCrclosecA" must 
        be supplied. 

    cD0x008cA 
        The token has a continuation string, usually used with 0x02 but cannot 
        be used with token types cG0x004cA and cG0x080cA. The argument "cCcontinuecA" must 
        be supplied and if the replacing bit cG0x040cA is set the replacement 
        continue string "cCrcontinuecA" must also be supplied. The best example of 
        its use can again be found in C; macros defined using the cG#definecA 
        pre-processor construct may be constructed on single or multiple 
        lines. The macro continues onto another line if the current line ends 
        with a backslash 'cG\cA' character, e.g.: 

            #define a_single_line_macro() printf("hello world\n") 

            #define a_four_lined_macro()          \ 
            do {                                  \ 
                printf("hello world\n") ;         \ 
            } while(0) 


        This can be correctly hilighted with the pre-processor scheme using: 
sB
            ; use to-end-of-line (2) and continuation (8), i.e. 2+8=10 
            hilight 1 10 "#" "\\" .scheme.prepro 

sA
    cD0x010cA 

        If this is an end of line token (cG0x002cA) then 
            The rest of the line is checked for any valid brackets. 

        Else if this is a bracket token (cG0x004cA) then 
            This is still searched for after an end of line token is found. 

        Else 
            Ignored 

        This feature enables the searching and hilighting of specific brackets 
        contained within a to-end-of-line scheme. For example, consider the 
        following C code: 

            #define My_Token 0x01  /* This is a multi-lined comment 
                                    * describing My_Token */ 


        With the 'cG#cA' pre-processor hilight (see bit 0x08 above) the #define 
        line would all be hilighted with the pre-process scheme, the comment 
        would be missed causing incorrect hilighting of the next line. Instead 
        this feature may be used by both the pre-processor and comment hilight 
        tokens to correctly hilight the above example: 
sB
            hilight 1 26 "#" "\\" .scheme.prepro 
            hilight 1 20 "/\\*" "*/" "" .scheme.comment 

sA
    cD0x020cA 
        This token must be the first non-white character of the line. 

    cD0x040cA 
        The token (and closing bracket tokens) are to be replaced by the given 
        replacement strings. This is often utilized when displaying formated 
        text such as MicroEmacs on-line help lslmehf(8)le pages, the output from 
        UNIX cDman(1)cA etc. In MicroEmacs help pages, the start of bold text is 
        delimited with the character sequence "cG\C[cDcA" and ends with the 
        character sequence "cG\C[cAcA", e.g. 

            "the word \C[cDbold\C[cA is in \C[cDbold\C[cA" 


        Obviously the hilight delimiters should not appear so the character 
        sequence may be correctly drawn using a bracket token, starting with 
        "cG\C[cDcA" and ending with "cG\C[cAcA", replacing both with an empty string: 
sB
            hilight 1 0x44 "\C[cD" "" "\C[cA" "" "" .scheme.bold 

sA
    cD0x080cA 
        This is a branch token. When this token is found, the token (or the 
        replace string) is colored using the given color cCschemeNumcA and then 
        the current hilighting scheme is changed to "cCb-hil-nocA" (which MUST be 
        defined by the time it is first used). The "cCb-hil-nocA" hi-light scheme 
        should also contain a branch token which branches back to "cChil-nocA" or 
        "cG0cA" (which branches to lslm$buffer-hilight(5)le). A branch does not have to 
        branch back to "cChil-nocA", it may branch to any other hi-light scheme. 
        The branches are not stacked and there is no limit on the nesting. 

    cD0x100cA 
        The token must be at the start of the line. 

    cD0x200cA 
        This is an invalid token in its own right, which is used for 
        optimizing a hi-lighting scheme. 

        This has the second highest precedence (see cD0x400cA) and all other bits 
        are ignored. Only the first 3 arguments are required. For example, if 
        there are 11 tokens starting with "cGdelete-cA" as with the hi-lighting of 
        this buffer, then adding the token "cGdelete-cA", while invalid in its own 
        right, means that "cGdelete-cA" is only checked for once. This also 
        reduces the size of the internal hilighting tables so if the message 
        "cDTable fullcA" appears, the hilighting scheme should be reduced by 
        removal of the common components. 

    cD0x400cA 
        This is a column hilighting token, which allows absolute columns 
        within a window to be hilighted (irrespective of the contents). This 
        bit takes precedence over all other bits and all other bits are 
        ignored. Column highlighting is a different concept to token in that 
        it requires a "cCfrom-colcA" and a "cCto-colcA" column positions and a line 
        will be hilighted in the given scheme between these two columns. 

    cD0x800cA 
        The flag is used with bracket tokens (cG0x04cA) and indicates that the 
        bracket is typically contained on a single line. This information is 
        used by MicroEmacs in trying to avoid hilighting anomalies caused when 
        the start and end tokens of the bracket are the same (e.g. a string's 
        start and end token is 'cG"cA'). Problems arise when the bracket starts on 
        one line and closes on a later line, even with a large look-back, 
        eventually the start bracket will become too far back and only the end 
        bracket is found. But as this is the same as the open token it is 
        mistaken for an open bracket and the strings become out of synch. This 
        test can reset this if further down the file an open and close bracket 
        is found on the same line. For this to have any effect, the hilighting 
        scheme must use look-back (flag cG0x02cA of cDHilight CreationcA). 

    Note that cG0x004cA, cG0x008cA and cG0x080cA are mutually exclusive and more than 1 
    should not be set in any one hilight token, if 2 or more are set the 
    effect is undefined. Other than this there is no restrictions placed on 
    the types of token used, although strange combinations like cG0x006cA may lead 
    to unexpected results -- hopefully not a core dump, but not guaranteed ! 

    The token and close token of brackets may contain a limited subset of 
    regular expression tokens as follows:- 

    cD^cA 
        When specified as the first character of the token, the token must be 
        at the start of the line. 

    cD$cA 
        The token must be at the end of the line, must be the last character. 

    cD\{cA 
        Indicates the start of the hilighted part of the token, only one may 
        be used per token. This token use is different from regex. 

    cD\}cA 
        Indicates the end of the hilighted part of the token, only one may be 
        used per token. The rest of the token must be matched for it to be 
        used but is not considered part of the token, i.e. hilighting 
        continues on the character immediately after the "cC\}cA", not at the end 
        of the token. Similar to the cD\<cA token, the length of the rest of the 
        token must be fixed. This token use is different from regex. 

    cD\(.\)cA 
        Groups are supported in hilighting, but they must only enclose a 
        single character, closures ('*', '?' and '+') must come after the 
        closure, i.e. use "\(.\)*", not "\(.*\)". Alternatives ("cG\|cA") are not 
        supported. 

    cD.cA 
        Matches any character. 

    cD[...]cA 
        Matches a single buffer character to a range of characters, for 
        example to hilight MicroEmacs register variables (i.e. cG#g0cA-cG#g9cA, 
        cG#p0cA-cG#p9cA, cG#l0cA-cG#l9cA) the following regex string may be used: 
sB
            hilight 1 1 "#[gpl][0-9]" 

sA
        This matches a token which starts with a 'cG#cA', followed by a 'cGgcA', 'cGpcA' 
        or 'cGlcA' character and ends with a numerical digit. If the user required 
        the replacement (bit 0x40) of the "cG#cA" to "#register" to aid 
        readability, the replacement string some now needs to know whether the 
        second character was a 'cGgcA', 'cGpcA' or 'cGlcA' and which digit. Up to 9 groups 
        ("cG\(.\)cA") can be use to store a store a single search character, which 
        can be used later in the search string and in the replacement string 
        by using the form "\cG#cA", where cG#cA is the range test number counting from 
        the left, e.g. for the given example use: 
sB
            hilight 1 65 "#\\([gpl]\\)\\([0-9]\\)" "#register\\1\\2" 

sA
        The content of the brackets (cD[cA...cD]cA) include a set of special short 
        cuts and regular expression syntax definitions as follows:- 

        cG[abc]cA 
            A list of characters. 

        cG[a-z]cA 
            A range of characters. 

        cG[-.0-9]cA 
            A combination of character lists and ranges. 

        cG[[:space:]]cA 
            A white space character. See lslmset-char-mask(2)le for a full 
            description on MicroEmacs character range support. 

        cG[[:digit:]]cA 
            A digit, 0-9. 

        cG[[:xdigit:]]cA 
            A hexadecimal digit, 0-9, a-f, A-F. 

        cG[[:lower:]]cA 
            A lower case letter, by default a-z. 

        cG[[:upper:]]cA 
            An upper case letter, by default A-Z. 

        cG[[:alpha:]]cA 
            A lower or upper case letter. 

        cG[[:alnum:]]cA 
            A lower or upper case letter or a digit. 

        cG[[:sword:]]cA 
            A spell word character. 

        cD[^...]cA 
            Matches all characters except the given range of characters, e.g. 
            "cG[^[:space:]]cA". 

        cG\#cA 
            The same character which matched the #th group token. This 
            functionality is best explained using UNIX cDman(1)cA output as an 
            example, to create a bold character 'cDXcA' it produces "cGX\CHXcA" where 
            cG\CHcA is a backspace character thereby overstriking the first 'cGXcA' 
            with another creating a bold character. This can be checked for 
            and simulated in MicroEmacs using the following: 
sB
                hilight 1 64 "\\(.\\)\CH\\1" "\\1" .scheme.bold 

sA
        The use of "cG\1cA" in the search string ensures that the second character 
        is the same as the first. This is replace by a single character drawn 
        in the bold scheme. 

    cD?cA cD+cA cD*cA 
        Matches 0 or 1, 1 or more and 0 or more of the previous character or 
        character range respectively. 

    Following is a list of hilighting regular expression restrictions: 

        The number of characters to the left of a cD\{cA and to the right of a cD\}cA 
        token must be fixed, i.e. the 'cD?cA', 'cD+cA' and 'cD*cA' tokens cannot be used 
        before this token. Consider the hilighting of a C function name 
        defined to be a token at the start of a line followed by 0 or more 
        spaces followed by a '('. The following hilight token looks valid but 
        the variable space match is incorrect as it is to the right of the cD\}cA: 
sB
            hilight 1 0 "^\\w+\\}\\s-*(" .scheme.function 

sA
        Instead either the space match must be include in the function token 
        hilighting (which may cause problems, particularly if printing with 
        underlining) or by fixing the number of spaces as follows: 
sB
            ; include the spaces in the function hilighting 
            hilight 1 0 "^\\w+\\s-*\\}(" .scheme.function 
            ; or fix the number of spaces to 0, 1 ... 
            hilight .hilight.c    0 "^\\w+\\}(" .scheme.function 
            hilight .hilight.c    0 "^\\w+\}\\s-(" .scheme.function 

sA
        The cD+cA and cD*cA tokens match the longest string and do not narrow, e.g. 
        consider the hilighting of a C goto label which takes the form of an 
        alpha-numerical name at the start of a line followed by a ':' 
        character. The token "cG^.*:cA" cannot be used as cG.cA will also match and 
        move past the ending ':', ending only at the end of the line. As no 
        narrowing is performed the final 'cG:cA' in the token will not match and 
        the label will not be hilighted. Instead a character range which 
        excludes a ':' character must be used, e.g. "cD^[^:]*:cA". 

        A group should not be followed by a cD?cA or cD*cA closure, it should either 
        be a fixed single character or followed by a cD+cA closure (in which case 
        the last matching character is stored). 

    Following is a list of hilight type bit / token regex equivalents: 

    cD0x01cA 
        "cG[^word]\{????\}[^word]cA" 

    cD0x02cA 
        "cG????.*cA" 

    cD0x20cA 
        "cG^\s-*\{????cA" - (note that this is strictly incorrect as the cG\s-*cA is 
        to the left of the cG\{cA, it is correctly handled for the ease of use). 

    cD0x100cA 
        "cG^????cA" 


cEHilight Scheme Token Deletion cA


    cC-1cA cDhilightcA "cChil-nocA" "cCtypecA" "cCtokencA" With a -ve argument cDhilightcA deletes the 
    given "cCtokencA" from a hi-light color scheme identified by "cChil-nocA". The 
    token "cCtypecA" must also be specified to distinguish between normal and 
    column token types. 


cEcEEXAMPLE cEcA


cEExample 1 cA


    Hilighting a MicroEmacs character given in hex form, checking its validity 
    (i.e. "cG\x??cA" where cG?cA is a hex digit): 
sB
        hilight 1 0 "\\x[[:xdigit:]][[:xdigit:]]" .hilight.variable 

sA
    Hilighting a C style variable length hex number (i.e. "cG0x???cA"): 
sB
        hilight 1 1 "0[xX][[:xdigit:]]+" .hilight.variable 

sA

cEExample 2 cA


    Replacing a quoted character with just the character (i.e. cG'x'cA -> cGxcA) 
sB
        hilight 1 64 "'\\(.\\)'" "\\1" %magenta 

sA

cEExample 3 cA


    The following example uses the branch hilighting feature to hilight each 
    window line a different color to its neighbors by cycle through 3 
    different color schemes: 
sB
        0 hilight .hilight.line1 0                        $global-scheme 
          hilight .hilight.line1 0x80 "\\n" .hilight.line2 .scheme.no1 
        0 hilight .hilight.line2 0                        .scheme.no1 
          hilight .hilight.line2 0x80 "\\n" .hilight.line3 .scheme.no2 
        0 hilight .hilight.line3 0                        .scheme.no2 
          hilight .hilight.line3 0x80 "\\n" .hilight.line1 $global-scheme 

sA

cEExample 4 cA


    Simulate the hilighting from the output of a UNIX man page (taken from 
    hkman.emf): 
sB
        0 hilight  .hilight.man 0                                $global-scheme 
        ; ignore 
        hilight .hilight.man 64 ".\CH" ""                        $global-scheme 
        ; normal underline/italic 
        hilight .hilight.man 64 "_\CH\\(.\\)\\}[^\CH]" "\\1"     .scheme.italic 
        hilight .hilight.man 64 "\\(.\\)\CH_\\}[^\CH]" "\\1"     .scheme.italic 
        ; bold - first is for nroff -man 
        hilight .hilight.man 64 "\\(.\\)\CH\\1\\}[^\CH]" "\\1"   .scheme.bold 
        hilight .hilight.man 64 "_\CH_\CH_\CH_\\}[^\CH]" "_"     .scheme.header 
        hilight .hilight.man 64 "\\(.\\)\CH\\1\CH\\1\CH\\1\\}[^\CH]" "\\1" .scheme.header 
        ; bold underline 
        hilight .hilight.man 64 "_\CH_\CH_\CH_\CH_\\}[^\CH]" "_" .scheme.italic 
        hilight .hilight.man 64 "_\CH\\(.\\)\CH\\1\CH\\1\CH\\1\\}[^\CH]" "\\1" .scheme.italic 

sA
    This replaces the complex nroff character string with a single hi-lighted 
    character (don't believe me, try it!). 


cEcENOTES cEcA


    MicroEmacs hilight was written with speed and flexibility in mind, as a 
    result the user is assumed to know what they are doing, if not the effects 
    can be fatal. 


cEcESEE ALSO cEcA


    lslanguageTemplates(2)lmFile Language Templatesle, lslm$buffer-hilight(5)le, lslmadd-file-hook(2)le, 
    lslmadd-color-scheme(2)le, lslmprint-scheme(2)le, lslmindent(2)le, lslm$system(5)le, 
    lslmprint-buffer(2)le. 

! 2 hunt-forward
! 2 hunt-backward
cEcENAME cEcA


|hunt-forward
    hunt-forward - Resume previous search in forward direction 
|hunt-backward
    hunt-backward - Resume previous search in backward direction 
$a


cEcESYNOPSIS cEcA


    cCncA cDhunt-forwardcA (cDC-x hcA) 
    cCncA cDhunt-backwardcA (cDC-x C-hcA) 


cEcEDESCRIPTION cEcA


    cDhunt-forwardcA repeats the last search with the last search string in a 
    forwards direction, from the current cursor position. lslmmagic(2m)le and 
    lslmexact(2m)le modes are operational. 

    cDhunt-backwardcA repeats the last search with the last search string in a 
    backwards direction, as per cDhunt-forwardcA. 

    The numeric argument cCncA is interpreted as follows:- 

    cDn > 0cA 
        The cCncAth occurrence of the pattern is located. 

    cDn < 0cA 
        The first occurrence of the pattern is located in the next cCncA lines. 


cEcEDIAGNOSTICS cEcA


    The command returns a status of cGFALSEcA if no previous search string has 
    been established, or if the pattern could not be located (or cCncAth pattern 
    where cCncA occurrences are requested). If the pattern is found within the 
    given search criteria the return status is cGTRUEcA. 


cEcESEE ALSO cEcA


    lslmexact(2m)le, lslmisearch-forward(2)le, lslmmagic(2m)le, lslmsearch-backward(2)le, 
    lslmsearch-forward(2)le, 
    lsRegularExpressions(2)lmRegular Expressionsle 

! 2 shell
cEcENAME cEcA


    shell - Create a new command processor or shell 
$a


cEcESYNOPSIS cEcA


    cDshellcA (cDC-x ccA) 


cEcEDESCRIPTION cEcA


    cDshell-commandcA creates a new command processor or shell. Upon exiting the 
    shell, MicroEmacs '02 redraws its screen and continues editing. The 
    exceptions to this are as follows: 

    cDX-WindowscA 
        A new cDxtermcA is spawned off and editing control is returned to 
        MicroEmacs '02 once the cDxtermcA has initialized. 

    cDMicrosoft WindowscA 
        A new MS-DOS shell is created and control is returned to MicroEmacs 
        '02 once the DOS console window has initialized. The shell created is 
        determined by the MS-DOS environment variable cGCOMSPECcA, this may be a 
        replacement shell e.g. cG4DOScA. 


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmpipe-shell-command(2)le, lslmsuspend-emacs(2)le. 

! 2 find-registry
cEcENAME cEcA


    find-registry - Index search of a registry sub-tree. 


cEcESYNOPSIS cEcA


    cDfind-registrycA "cCrootcA" "cCsubkeycA" cCindexcA 


cEcEDESCRIPTION cEcA


    cDfind-registrycA performs an indexed search of a registry sub-tree allowing 
    the caller to determine the names of the children that exist as sub-nodes 
    of the specified node. cCrootcA and cCsub-keycA form the root whose children are 
    to be determined, cCsubkeycA may be specified as the null-string (cG""cA) if an 
    absolute registry path is specified. cCindexcA is a value from cG0..ncA and 
    identifies the index number of the child node. The name of the child node 
    is returned in lslm$result(5)le if one exists, otherwise an error status is 
    returned. 


cEcEEXAMPLE cEcA


    The following example comes from cGaddrbook.emfcA and shows how cDfind-registrycA 
    is used to iterate through entries in the address book. Note that 
    cDfind-registrycA is used with lslm!force(4)le and the lslm$status(5)le of the call is 
    tested to determine if the invocation succeeded. 
sB
        !force find-registry "/AddressBook" "Names" #l0 
        !if $status 
            set-variable #l1 $result 
            76 insert-string "_" 
            2 newline 
            insert-string &spr "Section: %s" #l1 
            newline 
            ; Iterate through all of the entries. 
            set-variable #l2 0 

            !repeat 
                !force #l2 ab-buffer 
                !if $status 
                    set-variable #l2 &add #l2 1 
                !endif 
            !until &not $status 
            set-variable #l0 &add #l0 1 
            !goto next 
        !endif 

sA

cEcESEE ALSO cEcA


    lslmget-registry(2)le, lslmlist-registry(2)le, lslmread-registry(2)le, lslmset-registry(2)le, 
    lslmerf(8)le. 

! 2 insert-file
cEcENAME cEcA


    insert-file - Insert file into current buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-filecA "cCfile-namecA" (cDC-x C-icA) 


cEcEDESCRIPTION cEcA


    cDinsert-filecA inserts the named file cCfile-namecA cCncA times into the current 
    buffer at the beginning of the current line. The buffer mark is set to the 
    start of the insertion and the cursor is moved to the end. 


cEcESEE ALSO cEcA


    lslmset-mark(2)le, lslmfind-file(2)le, lslminsert-file-name(2)le, lslmview-file(2)le. 

! 2 insert-macro
cEcENAME cEcA


    insert-macro - Insert keyboard macro into buffer 
$a


cEcESYNOPSIS cEcA


    cDinsert-macrocA "cCcommandcA" 


cEcEDESCRIPTION cEcA


    cDinsert-macrocA inserts the named cCcommandcA into the current buffer in the 
    MicroEmacs '02 macro language, thus enables it to be saved, re-load and 
    therefore re-used at a later date. This is often used in conjunction with 
    lslmstart-kbd-macro(2)le, lslmend-kbd-macro(2)le and lslmname-kbd-macro(2)le. The given 
    cCcommandcA must have been defined either by a keyboard macro or in MicroEmacs 
    '02 macro code. 


cEcENOTES cEcA


    The cDinsert-macrocA provides a good method of identifying unknown low level 
    key codes. Simply record the unknown key as a macro and insert the macro 
    into the scratch buffer. The low level key code appears within the string. 


cEcESEE ALSO cEcA


    lslmstart-kbd-macro(2)le, lslmname-kbd-macro(2)le, lslmdefine-macro(2)le, lslmexecute-file(2)le. 

! 2 insert-space
cEcENAME cEcA


    insert-space - Insert space(s) into current buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-spacecA 


cEcEDESCRIPTION cEcA


    cDinsert-spacecA inserts cCncA spaces at the current cursor position, moving the 
    cursor position. 


cEcESEE ALSO cEcA


    lslminsert-string(2)le, lslminsert-tab(2)le, lslminsert-newline(2)le. 

! 2 insert-string
cEcENAME cEcA


    insert-string - Insert character string into current buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-stringcA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cDinsert-stringcA inserts a string cCncA times into the current buffer, moving the 
    cursor position. 

    cDinsert-stringcA allows text to be built in a buffer without reading it from 
    a file. Some special escape characters are interpreted in the cCstringcA, as 
    follows: 

        cG\ncA - Enters a new line 
        cG\tcA - A tab character 
        cG\bcA - Backspace 
        cG\fcA - Form-feed 
        cG\\cA - Literal backslash character 'cG\cA' 
        cG\xXXcA - Hexadecimal value of character ASCII value 


cEcESEE ALSO cEcA


    lslminsert-file(2)le, lslminsert-newline(2)le, lslminsert-space(2)le, lslminsert-tab(2)le, 
    lslmnewline(2)le. 

! 2 ipipe-shell-command
! 2 ipipe-kill
! 2 ipipe-write
cEcENAME cEcA


|ipipe-shell-command
    ipipe-shell-command - Incremental pipe (non-suspending system call) 
|ipipe-kill
    ipipe-kill - Kill a incremental pipe 
|ipipe-write
    ipipe-write - Write a string to an incremental pipe 
$a


cEcESYNOPSIS cEcA


    cCncA cDipipe-shell-commandcA "cCcommandcA" ["cCbuffer-namecA"] (cDesc \cA) 
    cCncA cDipipe-writecA "cCstringcA" 
    cCncA cDipipe-killcA 


cEcEPLATFORM cEcA


    UNIX - cCirixcA, cChpuxcA, cCsunoscA, cCfreebsdcA, cClinuxcA. 

    Windows NT - cCwin32cA. 


cEcEDESCRIPTION cEcA


    cDipipe-shell-commandcA executes the given system command cCcommandcA, opening up 
    a cD*icommand*cA buffer into which the results of the command execution are 
    displayed. Unlike the lslmpipe-shell-command(2)le, the user may continue editing 
    during command execution. The command may be terminated by deleting the 
    buffer or issuing a cDipipe-killcA command. 

    The argument cCncA can be used to change the default behavior of 
    pipe-shell-command described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Enables the use of the default buffer name cD*icommand*cA (default). If 
        this bit is clear the user must supply a buffer name. This enables 
        another command to be started without effecting any other command 
        buffer. 

    cD0x02cA 
        Hides the output buffer, default action pops up a window and displays 
        the output buffer in the new window. 

    cD0x04cA 
        Disable the use of the command-line processor to launch the program 
        (win32 versions only). By default the "cDcommandcA" is launched by 
        executing the command: 

            %COMSPEC% /c command 


        Where cG%COMSPEC%cA is typically command.com. If this bit is set, the 
        "cDcommandcA" is launched directly. 

    cD0x08cA 
        Detach the launched process from MicroEmacs (win32 versions only). By 
        default the command is launched as a child process of MicroEmacs with 
        a new console. With this bit set the process is completely detached 
        from MicroEmacs instead. 

    cD0x10cA 
        Disable the command name mangling (win32 versions only). By default 
        any 'cG/cA' characters found in the command name (the first argument only) 
        are converted to 'cG\cA' characters to make it Windows compliant. 

    cD0x20cA 
        Displays the new process window, by default this window is hidden. 

    Many other macro commands (see lslmcompile(3)le, lslmgrep(3)leetc.) use this command. 

    cDipipe-writecA writes a string cCstringcA to an open ipipe, cCncA times. 

    cDipipe-killcA terminates an open ipipe, this is automatically called when the 
    ipipe buffer is deleted using lslmdelete-buffer(2)le or when MicroEmacs is 
    exited.. The numeric argument cCncA can be used to change the signal 
    generated, where cCncA can take the following values: 

    cD1cA 
        Sends a Terminate process signal, literally a cGSIGKILLcA signal on unix 
        or a cGWM_CLOSEcA on windows platforms. This is the default signal and is 
        typically bound to cGC-c C-kcA. 

    cD2cA 
        Sends an interrupt signal, writes a Ctrl-C to the <stdin> pipe on unix 
        or sends Ctrl-C key events on windows platforms. This is typically 
        bound to cGC-c C-ccA. 


cEcENOTES cEcA


    On UNIX platforms the TERM environment variable of the new process can be 
    set by setting the user variable cD%ipipe-termcA to the required value, e.g.: 

            set-variable %ipipe-term "TERM=vt100-nam" 


    Ipipe shells support a large sub-set of vt100 terminal commands, notable 
    exceptions are color and font support and the support of auto-margins. 
    Using the terminal type "cGvt100-namcA" disables the use of auto-margins, 
    providing better support. 

    On platforms which do not support cDipipe-shell-commandcA, such as MS-DOS, 
    executing cDipipe-shell-commandcA automatically invokes lspipe-shell-command(2)lmpipe-shell-commandle, 
    hence macros may safely use ipipes without explicitly checking the 
    platform type. cDipipe-shell-commandcA does not run reliably on Windows 3.11 
    and Windows 95; Windows NT does support ipipes. 

    While the pipe command is running, mode lslmpipe(2m)le is enabled. Modes 
    lslmlock(2m)le and lslmwrap(2m)le effect the output behavior of an 
    cDipipe-shell-commandcA. 


cEcEEXAMPLE cEcA


    The following example is the lslmgrep(3)le command macro which utilizes the 
    cDipipe-shell-commandcA, diverting the output to a buffer called cD*grep*cA. 
sB
        define-macro grep 
            !if &seq %grep-com "ERROR" 
                set-variable %grep-com "grep " 
            !endif 
            !force set-variable #l0 @1 
            !if &not $status 
                set-variable #l0 @ml00 %grep-com 
            !endif 
            !if @? 
                1 pipe-shell-command &cat %grep-com #l0 "*grep*" @mna 
            !else 
                1 ipipe-shell-command &cat %grep-com #l0 "*grep*" @mna 
            !endif 
        !emacro 

sA
    Note that if an argument is passed to cDgrepcA then it uses pipe-shell-command 
    instead. This is useful if another command is using cDgrepcA which must finish 
    before the calling command can continue, see lslmreplace-all-string(3)le for an 
    example. 


cEcEBUGS cEcA


    On MicroSoft Windows platforms, cDipipe-shell-commandcA spawns the shell (e.g. 
    cGcommand.comcA) with the appropriate command line to make it execute the 
    given command. If the command to be run detaches from the shell and 
    creates its own window, for example cGme.execA, cDipipe-killcA will only kill the 
    shell, it will not kill the actual process, i.e. the cGme.execA. 

    On MicroSoft Windows platforms cDipipe-shell-commandcA does not work on 
    Novell's Intranet Client v2.2 networked drives, version 2.5 does appear to 
    work. 


cEcESEE ALSO cEcA


    lslm$buffer-ipipe(5)le, lslmcompile(3)le, lslmgrep(3)le, lslmpipe-shell-command(2)le, 
    lslmreplace-all-string(3)le, lslmshell-command(2)le, lslmpipe(2m)le, lslmlock(2m)le, lslmwrap(2m)le. 

! 2 isearch-forward
! 2 isearch-backward
cEcENAME cEcA


|isearch-forward
    isearch-forward - Search forward incrementally (interactive) 
|isearch-backward
    isearch-backward - Search backwards incrementally (interactive) 
$a


cEcESYNOPSIS cEcA


    cDisearch-forwardcA (cDC-scA) 
    cDisearch-backwardcA (cDC-rcA) 


cEcEDESCRIPTION cEcA


    cDisearch-forwardcA provides an interactive search in the forward direction. 
    This command is similar to lslmsearch-forward(2)le, but it processes the search 
    as each character of the input string is typed in. This allows the user to 
    only use as many key-strokes as are needed to uniquely specify the string 
    being searched. 

    The follow keys can be used at the start of an incremental search only: 

        cGC-scA - Search for last string. 
        cGC-mcA - Perform a search-forward instead. 
        cGesc pcA, 
        cGesc ncA - Scroll through history list etc (See lslmml-bind-key(2)le). 

    Several control characters are active while isearching: 

    cDC-scA or cDC-x cA
        Skip to the next occurrence of the current string 

    cDC-rcA 
        Skip to the last occurrence of the current string 

    cDC-hcA 
        Back up to the last match (possibly deleting the last character on the 
        search string) 

    cDC-wcA 
        Insert the next word into the search string. 

    cDC-gcA 
        Abort the search, return to start. 

    cDesc cAor cDC-mcA 
        End the search, stay here 

    cDisearch-backwardcA is the same as cDisearch-forwardcA, but it searches in the 
    reverse direction. 

    For both commands when the end of the buffer is reached, an alarm is 
    raised (bell etc.) a further search request (cGC-scA) causes the search to 
    commence from the start of the buffer. 


cEcENOTES cEcA


    The lslmml-bind-key(2)le bindings are used. 

    The incremental search supports buffer modes lslmexact(2m)le and lslmmagic(2m)le. 


cEcEBUGS cEcA


    Due to the dynamic nature of active lslmipipe-shell-command(2)le buffers the 
    search history cannot be stored in the same way (list of fixed locations). 
    As a result the search history is stored as a list of searches which are 
    not guaranteed to be consistent. 


cEcESEE ALSO cEcA


    lslmexact(2m)le, lslmhunt-forward(2)le, lslmmagic(2m)le, lslmml-bind-key(2)le, lslmsearch-forward(2)le. 
    lsRegularExpressions(2)lmRegular Expressionsle 

! 2 kbd-macro-query
cEcENAME cEcA


    kbd-macro-query - Query termination of keyboard macro 
$a


cEcESYNOPSIS cEcA


    cC[Definition]cA 
    cDkbd-macro-querycA (cDC-x qcA) 

    cC[Execution]cA 
    cDkbd-macro-querycA "cDycA"|"cDncA"|"cDC-gcA" 


cEcEDESCRIPTION cEcA


    cDkbd-macro-querycA queries the termination state of keyboard macro recording. 
    If the command is executed during a keyboard macro definition, at that 
    point during its execution the user is prompted as to whether to continue 
    the macro execution. A reply of "cDycA" continues the execution as normal, "cDncA" 
    stops execution at that point once, if executing the macro cCncA times the 
    macro will still executed a further cCn-1cA times. If the "cGC-gcA" abort command 
    is entered then all keyboard macro execution is aborted, regardless of the 
    number of repetitions. 


cEcESEE ALSO cEcA


    lslmstart-kbd-macro(2)le, lslmexecute-kbd-macro(2)le. 

! 2 kill-paragraph
cEcENAME cEcA


    kill-paragraph - Delete a paragraph 
$a


cEcESYNOPSIS cEcA


    cCncA cDkill-paragraphcA 


cEcEDESCRIPTION cEcA


    cDkill-paragraphcA deletes the next cCncA paragraphs, if cCncA is +ve then the 
    paragraph the cursor is currently in and the next cCncA-1 paragraphs are 
    killed. If cCncA is -ve then the current paragraph and the previous cCncA-1 
    paragraphs are killed. If cCncA is zero the command simply returns. The 
    default value for cCncA is 1. 


cEcEDIAGNOSTICS cEcA


    The following errors can be generated, in each case the command returns a 
    FALSE status: 

    cD[end of buffer]cA 
        The given argument cCncA was greater that the number of remaining 
        paragraphs, all the remaining paragraphs are still removed. 

    cD[top of buffer]cA 
        A negative argument cCncA was given requesting more paragraphs to be 
        killed then are present before the cursor. All the paragraphs before 
        the cursor are still removed. 


cEcENOTES cEcA


    A paragraph is terminated by a blank line. All text residing between two 
    blank lines is considered to be a paragraph - regardless of the text 
    layout. 

    The distinction between killed text and deleted text is that text which is 
    killed is placed into the yank buffer so that it can be pasted into any 
    buffer using lslmyank(2)le. 


cEcESEE ALSO cEcA


    lslmbackward-paragraph(2)le, lslmforward-paragraph(2)le, lslmkill-region(2)le. 

! 2 kill-region
cEcENAME cEcA


    kill-region - Delete all characters in the marked region 
$a


cEcESYNOPSIS cEcA


    cCncA cDkill-regioncA (cDC-wcA) 


cEcEDESCRIPTION cEcA


    cDkill-regioncA deletes all characters from the cursor to the mark set with 
    the lslmset-mark(2)le command. The characters removed are copied into the kill 
    buffer and may be extracted using lslmyank(2)le. If a numeric argument of cG0cA is 
    given the command has no effect. If a -ve argument is given the characters 
    are not placed in the kill buffer, therefore the text is effectively lost 
    (this does not effect the lslmundo(2)le operation). 

    The mark position may be ahead or behind the current cursor position. 


cEcEUSAGE cEcA


    To move text from one place to another: 

        * Move to the beginning of the text you want to move. 
        * Set the mark there with the lsset-mark(2)lmset-markle (cDesc spacecA) command. 
        * Move the point (cursor) to the end of the text. 
        * Use the cDkill-regioncA command to delete the region you just defined. 
          The text will be saved in the kill buffer. 
        * Move the point to the place you want the text to appear. 
        * Use the lsyank(2)lmyankle (cDC-ycA) command to copy the text from the kill buffer to 
          the current point. 

    Repeat the last two steps to insert further copies of the same text. 


cEcENOTES cEcA


    If a region is accidentally removed then lsyank(2)lmyankle the text back immediately or 
    use lslmundo(2)le. 

    Windowing systems such as X-Windows and Microsoft Windows utilize a global 
    windowing kill buffer allowing data to be moved between windowing 
    applications (cCcut buffercA and cCclipboardcA, respectively). Within these 
    environments MicroEmacs '02 automatically interacts with the windowing 
    systems kill buffer, the last MicroEmacs '02 cDkill-regioncA entry is 
    immediately available for a paste operation into another windowing 
    application. 


cEcESEE ALSO cEcA


    lslmcopy-region(2)le, lslmkill-rectangle(2)le, lslmreyank(2)le, lslmset-mark(2)le, lslmundo(2)le, 
    lslmyank(2)le. 

! 2 kill-line
cEcENAME cEcA


    kill-line - Delete all characters to the end of the line 
$a


cEcESYNOPSIS cEcA


    cCncA cDkill-linecA (cDC-kcA) 


cEcEDESCRIPTION cEcA


    cDkill-linecA, when used with no argument cCncA, deletes all text from the cursor 
    to the end of a line, the end of line character is also deleted if the 
    cursor is in the first column and the lslmline(2m)le mode is disabled. The 
    deleted text is placed in the kill buffer, see lslmyank(2)le for more 
    information on the kill buffer. When used on a blank line, it always 
    deletes it. 

    If a +ve argument cCncA is supplied the specified number of lines is deleted, 
    the setting of the cDlinecA mode is ignore. If cCncA is cG0cA the command has no 
    effect. If a -ve argument is given, +cCncA lines are deleted but the text is 
    NOT added to the kill buffer. 


cEcENOTES cEcA


    If a line is accidentally removed then lsyank(2)lmyankle the text back immediately or 
    use lslmundo(2)le. 

    The -ve argument is typically used in macro scripts where the yank buffer 
    is more precisely controlled by the script. 


cEcESEE ALSO cEcA


    lslmkill-region(2)le, lslmline(2m)le, lslmundo(2)le, lslmyank(2)le, lslmforward-kill-word(2)le. 

! 2 list-buffers
cEcENAME cEcA


    list-buffers - List all buffers and show their status 
$a


cEcESYNOPSIS cEcA


    cDlist-bufferscA (cDC-x C-bcA) 


cEcEDESCRIPTION cEcA


    cDlist-bufferscA splits the current window and in one half brings up a list of 
    all the buffers currently existing in the editor. The active modes, change 
    flag, and active flag for each buffer is displayed. (The change flag is a 
    cD*cA character if the buffer has been changed and not written out. The active 
    flag is not an cD@cA if the file had been specified on the command line, but 
    has not been read in yet since nothing has switched to that buffer.) 

    The buffer list has some special command keys associated with it which 
    allow the state of the buffers to be edited from the buffer list, the 
    editing allows buffers to be killed and saved to disk. The key codes are 
    defined as follows:- 

    cD1cA - Switch to buffer 
        Switch to that buffer and make it the only buffer. 

    cD2cA - Move to buffer 
        Switch the buffer list window to that buffer. 

    cDDcA - delete buffer 
        Flag buffer for deletion. A buffer scheduled for deletion is marked 
        with a 'cDDcA' in first column. The delete status is enacted by the 'cDXcA' 
        command, or may be removed with the 'cDUcA' command. 

    cDScA - save buffer 
        Flag buffer for saving. A buffer scheduled from saving is marked with 
        a 'cDScA' in the second column. Note that a buffer may be marked for 
        saving and deletion, the save operation is performed before the 
        delete. 

    cDUcA - unmark buffer 
        Unmark the 'cDDcA' and 'cDScA' flags on current line. 

    cDXcA - execute 
        Execute all the 'cDDcA' and 'cDScA' flags currently set. The cDScAave is enacted 
        first. 

    For all but 'cDXcA', the buffer selected is the buffer noted on the current 
    cursor line. These keys are not remappable. 


cEcESEE ALSO cEcA


    lslmlist-variables(2)le, lslmlist-commands(2)le, lslmsplit-window-horizontally(2)le. 

! 2 buffer-bind-key
! 2 buffer-unbind-key
cEcENAME cEcA


|buffer-bind-key
    buffer-bind-key - Create local key binding for current buffer 
|buffer-unbind-key
    buffer-unbind-key - Remove local key binding for current buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDbuffer-bind-keycA "cCcommandcA" "cCkeycA" 
    cCncA cDbuffer-unbind-keycA "cCkeycA" 


cEcEDESCRIPTION cEcA


    cDbuffer-bind-keycA creates a key binding local to the current buffer, binding 
    the command cCcommandcA to the keyboard input cCkeycA. This command is 
    particularly useful in conjunction with file loading hooks (see 
    lslmadd-file-hook(2)le) allowing local key bindings dependent upon the context 
    of the buffer. 

    The message line input is not effected by the current buffers local 
    bindings. 

    cDbuffer-unbind-keycA unbinds a user created local key binding, this command 
    effects only the current buffer. If a -ve argument is given to 
    cDbuffer-unbind-keycA then all the current buffer's bindings are removed. 


cEcENOTES cEcA


    The prefix commands cannot be rebound with this command. 

    Key response time linearly increases with each local binding added. 


cEcESEE ALSO cEcA


    lslmglobal-bind-key(2)le, lslmml-bind-key(2)le, lslmosd-bind-key(2)le, lslmglobal-unbind-key(2)le. 

! 2 ml-bind-key
! 2 ml-unbind-key
cEcENAME cEcA


|ml-bind-key
    ml-bind-key - Create key binding for message line 
|ml-unbind-key
    ml-unbind-key - Remove key binding from message line 
$a


cEcESYNOPSIS cEcA


    cCncA cDml-bind-keycA "cCcommandcA" "cCkeycA" 
    cCncA cDml-unbind-keycA "cCkeycA" 


cEcEDESCRIPTION cEcA


    cDml-bind-keycA creates a key binding local to the message line input buffer. 
    There are several commands that can be used in message line input, each 
    command is associated with a main buffer editing command and inherits all 
    that commands global bindings, i.e. moving forward 1 character is 
    associated with the command lslmforward-char(2)le and thus inherits the binding 
    cGC-fcA (as well as any other like the right cursor key). The following is a 
    list of available commands, what they do and their associated commands 


cECursor Movement cA


        * move backwards 1 character, command: lsforward-char(2)lmbackward-charle (cDC-bcA) 
        * move forwards 1 character, command: lsforward-char(2)lmforward-charle (cDC-fcA) 
        * move backwards 1 word, command: lsforward-word(2)lmbackward-wordle 
        * move forwards 1 word, command: lsforward-word(2)lmforward-wordle 
        * move to the beginning of buffer, command: lsbeginning-of-line(2)lmbeginning-of-linele (cDC-acA) 
        * move to the end of buffer, command: lsbeginning-of-line(2)lmend-of-linele (cDC-ecA) 


cEInput cA


        * Quote a character, command: lsquote-char(2)lmquote-charle (cDC-qcA) 
        * Yank kill buffer into message line, command: lsyank(2)lmyankle (cDC-ycA) 
        * insert current buffers current line into the buffer, command: 
          lsinsert-newline(2)lminsert-newlinele (cDC-ocA) 
        * insert current buffers file name into the buffer, command: 
          lsinsert-file-name(2)lminsert-file-namele (cDC-x C-ycA). 
        * insert current buffers buffer name into the buffer, command: lsreyank(2)lmreyankle 
          (cDesc ycA) 


cEDeletion cA


        * delete backward 1 character, command: lsforward-delete-char(2)lmbackward-delete-charle (cDC-hcA) 
        * delete forward 1 character, command: lsforward-delete-char(2)lmforward-delete-charle 
        * kill text from current position to end of line, command: lskill-line(2)lmkill-linele 
          (cDC-kcA). 
        * erase whole line, command lskill-region(2)lmkill-regionle (cDC-wcA). Note that in 
          incremental searches this is used to add the current word to the 
          search string. 


cEHistory cA


    MicroEmacs '02 stores the last 20 entries of each kind (command, buffer, 
    file, search and general which is also saved in the history file so the 
    state of the history is retained when next loaded. The following commands 
    can be used to manipulate the history. 

        * next history list entry (loop through history), command: 
          lsforward-paragraph(2)lmforward-paragraphle (cDesc ncA) 
        * previous history list entry, command: lsforward-paragraph(2)lmforward-paragraphle (cDesc pcA) 


cECompletion cA


    When entering a command, file, buffer or a mode name MicroEmacs '02 
    creates a list of possible completions the following operations can be 
    performed on this list. 

        * expand. This completes the given input until the first ambiguous 
          character, command: a space (' ') or lstab(2)lmtable (cDC-icA). 
        * expand to the previous completion (loops through the completion 
          list, command: lsforward-line(2)lmbackward-linele (cDC-pcA) 
        * expand to the next completion (loops through the completion list, 
          command: lsforward-line(2)lmforward-linele (cDC-ncA) 
        * create a listing of all completions, command: a double expansion, 
          i.e. 2 spaces or lstab(2)lmtabsle. The first expands and the second creates the 
          list. 
        * page up the completion list buffer, lsscroll-down(2)lmscroll-uple (cDC-zcA) 
        * page down the completion list buffer, lsscroll-down(2)lmscroll-downle (cDC-vcA) 


cEMiscellaneous cA


        * abort input, returning failure to the input, lsabort-command(2)lmabort-commandle (cDC-gcA) 
        * re-fresh the message line, command: lsrecenter(2)lmrecenterle (cDC-lcA) 
        * finish input, command lsnewline(2)lmnewlinele (cDC-mcA, return) 
        * transpose previous character with current character, command: 
          lstranspose-chars(2)lmtranspose-charsle (cDC-tcA) 
        * capitalize the next word, command: lscapitalize-word(2)lmcapitalize-wordle (cDesc ccA) 
        * Turn the whole of the next word to lower case letters, command: 
          lscapitalize-word(2)lmupper-case-wordle (cDesc ucA) 
        * Turn the whole of the next word to upper case letters, command: 
          lscapitalize-word(2)lmlower-case-wordle (cDesc lcA) 

    cDml-unbind-keycA unbinds a user created message line key binding, this 
    command effects only the message line key bindings. If a -ve argument is 
    given to cDml-unbind-keycA then all message line bindings are removed. 


cEcEEXAMPLE cEcA


    If expansion was required on the cDesc esccA key binding then use the 
    following:- 
sB
        ml-bind-key tab esc esc  

sA

cEcENOTES cEcA


    The prefix commands cannot be rebound with this command. 

    Command key response time will linearly increase with each local binding. 


cEcESEE ALSO cEcA


    lslmglobal-bind-key(2)le, lslmbuffer-bind-key(2)le, lslmdescribe-bindings(2)le, 
    lslmosd-bind-key(2)le, lslmglobal-unbind-key(2)le. 

! 2 list-variables
cEcENAME cEcA


    list-variables - List defined variables 
$a


cEcESYNOPSIS cEcA


    cDlist-variablescA (cDC-h vcA) 


cEcEDESCRIPTION cEcA


    cDlist-variablescA pops up a window with a list of all register, buffer, user 
    and global variables with their current setting. The variables are shown 
    for the current buffer from which the command was invoked 

    cDlist-variablescA provides a good alternative to lslmdescribe-variable(2)le where 
    the value of multiple variables is to be interrogated. 

    The output is displayed in four sections:- 

    cDRegister variablescA 
        The current settings of the global register variables ('cD#cA' prefix). 

    cDBuffer VariablescA 
        The current setting of the buffer variables ('cD:cA' prefix). This 
        variables relate to the current buffer from which the command was 
        invoked. 

    cDSystem VariablescA 
        The current settings of the system variables ('cD$cA' prefix). 

    cDGlobal VariablescA 
        The current setting of the global variables ('cD%cA' prefix). 


cEcEEXAMPLE cEcA


    An example output from cDlist-variablescA is shown below:- 

        Register variables: 

            #g0 ........................... "29" 
            #g1 ........................... "" 
            #g2 ........................... "ERROR" 
            : 
            : 
            #g8 ........................... "ERROR" 
            #g9 ........................... "ERROR" 

        Buffer [m2cmd086.2] variables: 


        System variables: 

            $auto-time .................... "300" 
            $buffer-bhook ................. "bhook-nroff" 
            $buffer-bname ................. "m2cmd086.2" 
            $buffer-ehook ................. "ehook-nroff" 
            $buffer-fhook ................. "fhook-nroff" 
            $buffer-fmod .................. "040" 
            $buffer-fname ................. "d:/emacs/doc/m2cmd086.2" 
            $buffer-hilight ............... "3" 
            : 
            : 
            $window-width ................. "80" 
            $window-x-scroll .............. "0" 
            $window-xcl-scroll ............ "0" 
            $window-y-scroll .............. "52" 

        Global variables: 

            %black ........................ "0" 
            %blue ......................... "4" 
            %compile-com .................. "nmake " 
            %cyan ......................... "6" 
            %green ........................ "2" 
            %grep-com ..................... "grep -n " 
            : 
            : 
            %usr1mode ..................... "off" 
            %white ........................ "7" 
            %yellow ....................... "3" 


cEcESEE ALSO cEcA


    lslmdescribe-variable(2)le, lslmlist-commands(2)le. 

! 2 scroll-down
! 2 scroll-up
cEcENAME cEcA


|scroll-down
    scroll-down - Move the window down (scrolling) 
|scroll-up
    scroll-up - Move the window up (scrolling) 
$a


cEcESYNOPSIS cEcA


    cCncA cDscroll-downcA (cDC-ncA) 
    cCncA cDscroll-upcA (cDC-pcA) 


cEcEDESCRIPTION cEcA


    cDscroll-downcA moves the window in the current buffer down by cCncA lines, the 
    default when cCncA is omitted is 1 windows worth of lines i.e. a next page 
    operation. A -ve value of cCncA causes the window to move up. 

    cDscroll-upcA moves the window in the current buffer up by cCncA lines, default 
    when cCncA is omitted is 1 windows worth of lines, i.e. a previous page 
    operation. A -ve value of cCncA causes the window to move down. 


cEcESEE ALSO cEcA


    lslmscroll-left(2)le, lslmscroll-right(2)le, lslm$window-y-scroll(5)le. 

! 2 change-buffer-name
cEcENAME cEcA


    change-buffer-name - Change name of current buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDchange-buffer-namecA "cCbuffer-namecA" (cDesc C-ncA) 


cEcEDESCRIPTION cEcA


    cDchange-buffer-namecA changes the name of the current buffer to cCbuffer-namecA. 
    Buffer names must be unique as they act as the identity handle. By default 
    the buffer name is derived from the buffer's file name excluding the path. 
    This can lead to conflicts, when editing files with the same name and 
    different paths, in which case a counter is appended to the end of the 
    buffer name to make the name unique. For example: 

        File Name               Buffer Name 

        /etc/file.c             file.c 
        /tmp/file.c             file.c<1> 


    By default, or an argument is given with bit 1 set, cDchange-buffer-namecA 
    will fail if a buffer with the given name already exists. This behavior 
    can be changed by giving an argument with the first bit cleared, e.g. 0, 
    in which case if a buffer with that name already exists then a counter as 
    appended. 


cEcESEE ALSO cEcA


    lslm$buffer-fname(5)le, lslmchange-file-name(2)le. lslmdelete-buffer(2)le. 

! 2 name-kbd-macro
cEcENAME cEcA


    name-kbd-macro - Assign a name to the last keyboard macro 
$a


cEcESYNOPSIS cEcA


    cDname-kbd-macrocA "cCcommandcA" 


cEcEDESCRIPTION cEcA


    cDname-kbd-macrocA labels the last defined keyboard macro with the given 
    cCcommandcA name. The command name must be either unique or the name of an 
    existing macro. A keyboard macro is deleted when another keyboard macro is 
    defined, but when named, it is preserved. A named keyboard macro can also 
    be bound to its own command key sequence, and may be inserted into a 
    buffer enabling it to be saved and thus re-loaded and re-used at a later 
    date. 


cEcESEE ALSO cEcA


    lslmexecute-file(2)le, lslmexecute-kbd-macro(2)le, lslmglobal-bind-key(2)le, 
    lslminsert-macro(2)le, lslmstart-kbd-macro(2)le. 

! 2 newline
cEcENAME cEcA


    newline - Insert a new line 
$a


cEcESYNOPSIS cEcA


    cCncA cDnewlinecA (cDreturncA) 


cEcEDESCRIPTION cEcA


    cDnewlinecA inserts cCncA new lines into the text, move the cursor down to the 
    beginning of the next physical line, carrying any text that was after it 
    with it. The next line may automatically be indented depending on the 
    current buffer mode, see lslmcmode(2m)le, lslmindent(2m)le, and lslmwrap(2m)le. 


cEcESEE ALSO cEcA


    lslmcmode(2m)le, lslmindent(2m)le, lslmwrap(2m)le, lslmbuffer-mode(2)le. 

! 2 next-buffer
! 2 find-buffer
cEcENAME cEcA


|next-buffer
    next-buffer - Switch to the next buffer 
|find-buffer
    find-buffer - Switch to the next buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDnext-buffercA (cDC-x xcA) 
    cCncA cDfind-buffercA "cCbuffer-namecA" (cDC-x bcA) 


cEcEDESCRIPTION cEcA


    cDnext-buffercA switches to the cCncAth next buffer in the buffer list in the 
    current window, the default cCncA is cG1cA, if cCncA is negative then the cG0-cAcCncAth 
    previous buffer is selected. If cG0cA or a number greater than the number of 
    buffers is specified then the command fails. 

    cDfind-buffercA switches to buffer "cCbuffer-namecA" in the current window. If the 
    buffer does not exist and a zero argument cCncA is supplied then the command 
    fails. If the buffer does not exist but no argument or a +ve argument cCncA is 
    specified then a new buffer is created, at which point the file-hook is 
    evaluated. 

    If a -ve argument cCncA is given to cDfind-buffercA then the buffer will be 
    hidden. Any window displaying "cCbuffer-namecA" will find another buffer to 
    display. This functionality is often used with the lslmhide(2m)le buffer mode. 

    If the current buffer has an cC$buffer-ehookcA command set then this command 
    is executed before the new buffer is switched in. If the new buffer has a 
    $cCbuffer-bhookcA command set then this command is automatically executed 
    after the new buffer is switched in but before control returns to the 
    user. 


cEcESEE ALSO cEcA


    lslmnext-window-find-buffer(2)le, lslmhide(2m)le. 

! 2 forward-line
! 2 backward-line
cEcENAME cEcA


|forward-line
    forward-line - Move the cursor to the next line 
|backward-line
    backward-line - Move the cursor to the previous line 
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-linecA (cDC-ncA) 
    cCncA cDbackward-linecA (cDC-pcA) 


cEcEDESCRIPTION cEcA


    cDforward-linecA moves the cursor down cCncA lines, default 1. If the line is not 
    on the current screen then display the next page and move to the line. 

    cDbackward-linecA moves the cursor up cCncA lines, if the line is not on the 
    current screen then display the previous page and move to the line. 

    For both invocations a negative value reverses the sense of movement as 
    expected. 


cEcESEE ALSO cEcA


    lslmbackward-word(2)le, lslmforward-word(2)le, lslmscroll-down(2)le, lslmscroll-up(2)le. 

! 2 define-help
cEcENAME cEcA


    define-help - Define help information 
$a


cEcESYNOPSIS cEcA


    cDdefine-helpcA "cCstringcA" ["cCsectioncA"] 

        cCFree form textcA 

    cD!ehelpcA 


cEcEDESCRIPTION cEcA


    cDdefine-helpcA provides a mechanism to define help information for commands 
    and variables within macro files. The command allows user defined macros 
    to be documented with help information that is accessible from the command 
    line via the normal help commands such as lslmhelp-item(2)le. 

    The help information is typically embedded in the macro file with the 
    macro command that it is documenting. When the macro file is loaded then 
    the help information is loaded and integrated into the existing help 
    database. 

    cCstringcA is the name of the item that is being defined, cCsectioncA defines what 
    section the item belongs to. Following is a table of standard MicroEmacs 
    '02 sections: 

        cG1 cAMicroEmacs command line arguments. 
        cG2 cABuilt-in commands. 
        cG2mcA MicroEmacs buffer modes. 
        cG3 cAMacro commands. 
        cG4 cAMacro language commands. 
        cG5 cAMicroEmacs variables. 
        cG8 cAMicroEmacs file formats. 

    When cCsectioncA is omitted is defaults to the general section which is 
    usually used for the higher level help pages. 

    Text following the cDdefine-helpcA line contains the help information, this is 
    a free form text area that is reproduced when the help information is 
    requested. The end of the text area is delimited by a cD!ehelpcA construct. 
    The help text is usually displayed using a special lshilight(2)lmhilighting schemele to 
    control the colors and hyper-text links to other help pages. As a result 
    the text may contain escape ('cG^[cA') key sequences, see lslmehf(8)le for more 
    information on the format. 


cEcEEXAMPLE cEcA


    The following example is a define-help representation for the 
    lslmparagraph-to-line(3)le macro. 
sB
        define-help "paragraph-to-line" "3" 

        ^[cENAME^[cA 

             paragraph-to-line - Convert a paragraph to a single line 
        $a 


        ^[cESYNOPSIS^[cA 

             n paragraph-to-line 


        ^[cEDESCRIPTION^[cA 

             paragraph-to-line  reduces  each of the  next n  paragraphs  of text to a 
             single  line.  This  is  used to  prepare  a  document  to go into a word 
             processor environment where end of line marks represent paragraph marks. 


        ^[cENOTES^[cA 

             This command is a macro defined in format.emf. 


        ^[cESEE ALSO^[cA 

             ^[ls^[lm^[cGfill-paragraph(2)^[cA^[le. 

        !emacro 

sA

cEcESEE ALSO cEcA


    lslmehf(8)le, lslmhelp-item(2)le, lslmdefine-macro(2)le, lslmhelp-command(2)le, lslmhelp-variable(2)le. 

! 2 forward-paragraph
! 2 backward-paragraph
cEcENAME cEcA


|forward-paragraph
    forward-paragraph - Move the cursor to the next paragraph 
|backward-paragraph
    backward-paragraph - Move the cursor to the previous paragraph 
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-paragraphcA (cDesc ncA) 
    cCncA cDbackward-paragraphcA (cDesc pcA) 


cEcEDESCRIPTION cEcA


    cDforward-paragraphcA puts the cursor at the end of the cCncAth paragraph after 
    the cursor, default is 1. 

    cDbackward-paragraphcA puts the cursor at the beginning of the cCncAth paragraph 
    before the cursor, default is 1. 


cEcEDIAGNOSTICS cEcA


    The following errors can be generated, in each case the command returns a 
    FALSE status: 

    cD[end of buffer]cA 
        When moving forwards, the given argument cCncA was greater that the number 
        of remaining paragraphs, the cursor is left at the end of the buffer. 

    cD[top of buffer]cA 
        When moving backwards, the given argument cCncA was greater than the 
        number of paragraphs before the cursor, the cursor is left at the 
        beginning of the buffer. 


cEcENOTES cEcA


        * For both invocations a negative value reverses the sense of movement 
          as expected. 
        * A paragraph break is defined as a blank line. 


cEcESEE ALSO cEcA


    lslmbackward-line(2)le, lslmforward-line(2)le, lslmscroll-down(2)le, lslmscroll-up(2)le. 

! 2 next-window
! 2 previous-window
cEcENAME cEcA


|next-window
    next-window - Move the cursor to the next window 
|previous-window
    previous-window - Move the cursor to the previous window 
$a


cEcESYNOPSIS cEcA


    cCncA cDnext-windowcA (cDC-x ocA) 
    cCncA cDprevious-windowcA (cDC-x pcA) 


cEcEDESCRIPTION cEcA


    cDnext-windowcA makes the next window down the current window. A +ve argument 
    cCncA, makes the cCncAth window from the top current, where 1 is the first window. 
    A -ve argument cCncA specifies the cCnthcA window from the bottom current. An 
    argument cCncA of 0, makes the next window down current, if this is the last 
    window then the command fails. 

    cDprevious-windowcA makes the next window up the current window. A +ve 
    argument cCncA, this makes the cCncAth window from the bottom the current window. 
    A -ve argument cCncA makes the cCnthcA window from the top current. An argument cCncA 
    of zero makes the previous window current, if this is the first window 
    then the command fails. 

    When no argument is supplied then the next (or previous) window becomes 
    the current window. Wrapping occurs from bottom to top on cDnext-windowcA, and 
    top to bottom on cDprevious-windowcA. 


cEcENOTES cEcA


    The cCn=0cA argument is typically used to traverse the window list from top to 
    bottom, where the cGFALSEcA status may be trapped and used as an indicator 
    that end of the windows list has been reached. 


cEcESEE ALSO cEcA


    lslmnext-window-find-buffer(2)le, lslmnext-window-find-file(2)le, lslmset-position(2)le, 
    lslmgoto-position(2)le. 

! 2 forward-word
! 2 backward-word
cEcENAME cEcA


|forward-word
    forward-word - Move the cursor to the next word 
|backward-word
    backward-word - Move the cursor to the previous word 
$a


cEcESYNOPSIS cEcA


    cCncA cDforward-wordcA (cDesc fcA) 
    cCncA cDbackward-wordcA (cDesc bcA) 


cEcEDESCRIPTION cEcA


    cDforward-wordcA places the cursor at the end of the cCncAth word from the current 
    position; the default is 1. 

    cDbackward-wordcA places the cursor at the beginning of the cCncAth previous word, 
    default 1. 


cEcENOTES cEcA


    Words are distinguished by non-alphanumeric characters and need not be 
    white space such as spaces and tabs. 

    A character is considered to be part of a word if it is in the 
    lslm$buffer-mask(5)le character set. The default setting for cD$buffer-maskcA is 
    "cGluhcA" which gives a word character set of the alphanumeric characters, 
    i.e. cG0cA-cG9cA, cGAcA-cGZcA, cGacA-cGzcA, this may be changed by setting the cD$buffer-maskcA 
    variable. The character sets (including 4 user character sets cG1cA-cG4cA) may be 
    altered by using the command lslmset-char-mask(2)le. 


cEcESEE ALSO cEcA


    lslmbackward-line(2)le, lslmbackward-paragraph(2)le, lslmforward-line(2)le, 
    lslmforward-paragraph(2)le, lslocaleSupport(2)lmLocale Supportle, lslm$buffer-mask(5)le, lslmset-char-mask(2)le. 

! 2 insert-newline
cEcENAME cEcA


    insert-newline - Move the cursor to the next word 
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-newlinecA (cDC-ocA) 


cEcEDESCRIPTION cEcA


    cDinsert-newlinecA inserts cCncA new lines at the current cursor position, but 
    does not move the cursor. Any text following the cursor is moved to the 
    newly created line. 


cEcESEE ALSO cEcA


    lslmnewline(2)le. 

! 2 pipe-shell-command
! 5 $ME_PIPE_STDERR
cEcENAME cEcA


    pipe-shell-command - Execute a single operating system command 
    $ME_PIPE_STDERR - Command line diversion to stderr symbol 
$a


cEcESYNOPSIS cEcA


|pipe-shell-command
    cCncA cDpipe-shell-commandcA "cCcommandcA" ["cCbuffer-namecA"] (cDesc @cA) 
|$ME_PIPE_STDERR
    cC[MS-DOS and Win32s Only]cA 
|$ME_PIPE_STDERR
    cD$ME_PIPE_STDERRcA "cCstringcA"; Default is undefined. 


cEcEDESCRIPTION cEcA


    cDpipe-shell-commandcA executes one operating system command cCcommandcA and pipes 
    the resulting output into a buffer with the name of cD*command*cA. 

    The argument cCncA can be used to change the default behavior of 
    pipe-shell-command described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Enables the use of the default buffer name cD*command*cA (default). If 
        this bit is clear the user must supply a buffer name. This enables 
        another command to be started without effecting any other command 
        buffer. 

    cD0x02cA 
        Hides the output buffer, default action pops up a window and displays 
        the output buffer in the new window. 

    cD0x04cA 
        Disable the use of the command-line processor to launch the program 
        (win32 versions only). By default the "cDcommandcA" is launched by 
        executing the command: 

            %COMSPEC% /c command 


        Where cG%COMSPEC%cA is typically command.com. If this bit is set, the 
        "cDcommandcA" is launched directly. 

    cD0x08cA 
        Detach the launched process from MicroEmacs (win32 versions only). By 
        default the command is launched as a child process of MicroEmacs with 
        a new console. With this bit set the process is completely detached 
        from MicroEmacs instead. 

    cD0x10cA 
        Disable the command name mangling (win32 versions only). By default 
        any 'cG/cA' characters found in the command name (the first argument only) 
        are converted to 'cG\cA' characters to make it Windows compliant. 


cEcENOTES cEcA


    On MS-DOS and cCWin32scA the standard shell cDcommand.com(1)cA does not support 
    the piping of cCstderrcA to a file. Other shells, such as cD4Dos.com(1)cA, do, 
    using the command-line argument "cG>&cA". If the environment variable 
    "cGME_PIPE_STDERRcA" is defined (the value is not used) then MicroEmacs 
    assumes that the current shell supports piping of stderr. 


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmshell-command(2)le. 

! 2 screen-poke
cEcENAME cEcA


    screen-poke - Immediate write string to the screen 
$a


cEcESYNOPSIS cEcA


    cCncA cDscreen-pokecA cCrowcA cCcolumncA cCcolorSchemecA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cDscreen-pokecA writes a cCstringcA to the screen at position (cCrowcA, cCcolumncA) using 
    the given color scheme. The screen coordinates are defined with (0,0) at 
    the top left of the screen. 

    cDscreen-pokecA by-passes the conventional buffer update and writes directly 
    to the screen buffer. The command has no effect on buffers already showing 
    on the screen and is erased on the next screen update. The cCstringcA is 
    clipped to the screen area hence the caller need not continually check on 
    the size of the client area. 

    The numeric argument cCncA is a bitwise flag which has the following meaning 
    cG0x01cA Don't mark the poke area for update. 
    cG0x02cA Don't flush poke to screen. 
    cG0x04cA colorScheme is an array of values, one for each letter. 
    cG0xf0cA colorScheme pair offset to use. 

    If the cD0x01cA flag is absent then the parts of the screen over written by 
    cDscreen-pokecA are marked and refreshed on the next cDscreen-updatecA operation, 
    thereby erasing the poked information. If the flag is present the poked 
    information remains on the screen until a forced refresh is performed 
    (i.e. cD1 screen-updatecA) or the window information under the poked screen 
    data is modified. 

    In macros using many consecutive screen-pokes (e.g. lslmPatience(3)le to display 
    a pack of cards) most pokes use the 'No flush' flag to improve performance 
    and look on some platforms. 

    The use of cDscreen-pokecA has largely been reduced to games such as lslmMetris(3)le 
    since the introduction of lslmosd(2)le to create dialogs. 


cEcENOTES cEcA


    Some platforms do not allow all character values to be poked, illegal 
    characters are replaced with a 'cG.cA'. 


cEcESEE ALSO cEcA


    lslmosd(2)le, lslmscreen-update(2)le, lslmMahjongg(3)le, lslmMetris(3)le. 

! 2 popup-window
cEcENAME cEcA


    popup-window - Pop-up a window on the screen 
$a


cEcESYNOPSIS cEcA


    cCncA cDpopup-windowcA "cCnamecA" 


cEcEDESCRIPTION cEcA


    cDpopup-windowcA manages the display of a new window on the screen. If only 
    one window exists then it will be split else the current window will 
    changed to one of the other existing visible windows. If the given buffer 
    name "cCnamecA" is not null ("") then the buffer is created, if it does not 
    exist, and swapped in. 

    If an argument cCncA of zero is given then the command only succeeds if the 
    given buffer is already being displayed in an existing window, this window 
    is made current. If an non-zero argument is given to the command and the 
    given buffer is not visible then a window displaying a system buffer is 
    chosen in preference. A system buffer is one who's name starts with a 'cG*cA' 
    character, e.g. "cG*help*cA". window used to display 


cEcESEE ALSO cEcA


    lslmfind-buffer(2)le. 

! 2 print-buffer
! 2 print-region
cEcENAME cEcA


|print-buffer
    print-buffer - Print buffer, with formatting 
|print-region
    print-region - Print region, with formatting 
$a


cEcESYNOPSIS cEcA


    cCncA cDprint-buffercA 
    cCncA cDprint-regioncA 


cEcEDESCRIPTION cEcA


    cDprint-buffercA and cDprint-regioncA print the current buffer or region, 
    respectively, using high-lighting where appropriate. The hilighting 
    assigned to a buffer is defined by the variable lslm$buffer-hilight(5)le the 
    print scheme is defined with lslmprint-scheme(2)le, the lslmscheme-editor(3)le should 
    be used to create printer schemes. 

    The printing is typically configured using lslmprint-setup(3)le, which can be 
    found in the main menu under cDFile->Printer SetupcA. 

    The numerical argument cCncA is generally used for macro development, it 
    changes the default behaviour of these commands as follows: 

    cD-2cA 
        Configures the printer and, on win32 platforms, opens a Windows 
        printing dialog box enabling the user to configure the printer, font 
        and page layout. The configuration is stored in the "cG/printcA" registry. 

    cD-1cA 
        Configures the printer, the configuration is stored in the "cG/printcA" 
        registry. 

cDcA
        Configures the printer and, on win32 platforms, opens a Windows 
        printing dialog box enabling the user to configure the printer, font 
        and page layout. The required printing is then performed. 

cDcA
        Configures the printer and performs the required printing. 


cEPrinting Process cA


    When either of these commands are executed the macro file cGprint.emfcA is 
    executed to configure the printer (in a same vain as cGme.emfcA is executed to 
    configure MicroEmacs for general usage). After the macro file has been 
    executed the "cG/printcA" registry must contain the information required for 
    printing. Following is a list of registry entries and their use: 

    cDflagscA (cCintegercA) 
        The setup flags, defined as a bit mask as follows:- 

        cG0x0fcA - Destination of the printer output. 
            cG0x00cA - Buffer only. 
            cG0x01cA - Internal queue. 
            cG0x02cA - To file only. 
            cG0x03cA - To file and command line. 
        cG0x01cA - Bit set, header enabled. 
        cG0x20cA - Bit set, footer 
        cG0x04cA - Bit set, enable line numbers. 
        cG0x08cA - Bit set, Enable truncated line character (typically \). 

    cDpaper-xcA (cCintegercA) 
        Paper page width in character cells. 

    cDpaper-ycA (cCintegercA) 
        Paper page depth in character cells. 

    cDpage-xcA (cCintegercA) 
        The logical page width in character cells. 

    cDpage-ycA (cCintegercA) 
        The logical paper depth in character cells. 

    cDspecifier-xcA (cCintegercA) 
        Windows only. 

    cDspecifier-ycA (cCintegercA) 
        Windows only. 

    cDfont-facecA (cCstringcA) 
        The name of the font face (Windows only). 

    cDrowscA (cCintegercA) 
        Number rows per output page. 

    cDcolscA (cCintegercA) 
        Number of columns per output page. 

    cDmtopcA (cCintegercA) 
        The size of the top margin in character cells (i.e. where printing may 
        commence). 

    cDmbottomcA (cCintegercA) 
        The size of the bottom margin in character cells (i.e. where printing 
        stops). 

    cDmleftcA (cCintegercA) 
        The number of characters of space forming the left magin of the 
        physical page. 

    cDmrightcA (cCintegercA) 
        The number of characters of space forming the right magin of the 
        physical page. 

    cDheadercA (cCstringcA) 
        The ASCII text string for the header line. 

    cDfootercA (cCstringcA) 
        The ASCII text string for the footer line. 

    cDportcA (cCstringcA) 
        Printer port identity. 

    cDbuffercA (cCstringcA) 
        The name of the destination buffer. 

    cDfilecA (cCstringcA) 
        The name of the destination file. 

    cDstripcA (cCintegercA) 
        If cCintegercA value strip spaces from eol. 

    cDdevicecA (cCstringcA) 
        The ASCII name of the device (i.e. cG/dev/lpcA). 

    cDeofcA (cCstringcA) 
        The printer codes for the end of the file, may be the empty string if 
        not reqired. 

    cDeolcA (cCstringcA) 
        The printer codes for the end of line character. 

    cDeopcA (cCstringcA) 
        The printer codes for the end of a page. 

    cDsofcA (cCstringcA) 
        The printer codes for the start of a file, may be the empty string if 
        not required. 

    cDsolcA (cCstringcA) 
        The printer codes for the start of a line. 

    cDsopcA (cCstringcA) 
        The printer codes for the start of a page. 

    cDscontcA (cCstringcA) 
        The printer codes for a start of row continuation. 

    cDecontcA (cCstringcA) 
        The printer codes for the end of row continuation. 

    cDhsepcA (cCstringcA) 
        The horizonal logical page separator character. 

    cDvsepcA (cCstringcA) 
        The vertical logical page separator character. 

    cDwsepcA (cCstringcA) 
        The depth in character cells of the vertical logical page separator. 

    cDxsepcA (cCstringcA) 
        The width in character cells of the logical horizontal separator. 

    cDbg-colorcA (cCintegercA) 
        The background colour number. 

    cDcommand-linecA (cCstringcA) 
        The command line to perform a print operation. 


cEPrinting Under Microsoft Windows Environments cA


    Printing under Microsoft Windows Environments automatically invokes a 
    dialog box to assign and configure the printer page characteristics. The 
    dialog box allows the printer to be selected, enables line numbering, 
    headers and footers. 

    The dialog allows the user to select the font size, by defining the number 
    of characters that appear on a logical page, and the number of logical 
    pages that appear on a physical page. Selecting the logical and physical 
    page characteristics determine the size of the font. For dense pages with 
    a small typeface then a point size of 6 is appropriate. For clarity, a 
    larger typeface of 10 or 12 points is advised. 


cEcENOTES cEcA


    The last printer configuration selected by the user is held in the 
    registry file "cGprint.erfcA" which is loaded into the cC/print-historycA registry 
    section. This feature is implemented in the macro file cGprint.emfcA. 


cEcEBUGS cEcA


    Landscape printing under Microsoft Windows environments is temperamental. 

    Font selection under Microsoft Windows environments does not always 
    determine the most appropriate font size. 

    The printer interface does not support native postscript generation. (In 
    progress). 


cEcESEE ALSO cEcA


    lslmprint-setup(3)le, lslmscheme-editor(3)le, lslmprint-scheme(2)le, lslmhilight(2)le, 
    lslmprintall(3f)le, lslm$buffer-hilight(5)le. 

! 2 query-replace-string
cEcENAME cEcA


    query-replace-string - Search and replace a string - with query 
$a


cEcESYNOPSIS cEcA


    cDquery-replace-stringcA (cDesc C-rcA) 


cEcEDESCRIPTION cEcA


    cDquery-replace-stringcA operates like the lslmreplace-string(2)le command. 
    replacing one string with another. However, it allows you to step through 
    each string and ask you if you wish to make the replacement. The user is 
    prompted for a replacement response as follows:- 

    cDYcA 
        Make the replacement and continue on to the next string. 

    cDNcA 
        Do not make the replacement, and continue. 

    cD!cA 
        Replace the rest of the strings without asking. 

    cD^GcA 
        Stop the command. 

    cD.cA 
        Go back to place the command started 

    cDucA 
        Undo last replacement. 

    cDlcA 
        Last replacement, do next and stop. 

    cD?cA 
        Help - get a list of options. 


cEcESEE ALSO cEcA


    Refer to lslmsearch-forward(2)le for a description of the magic mode search 
    characters. 

    lslmreplace-string(2)le. 
    lsRegularExpressions(2)lmRegular Expressionsle 

! 2 quick-exit
! 2 save-buffers-exit-emacs
cEcENAME cEcA


|quick-exit
    quick-exit - Exit the editor writing changes 
|save-buffers-exit-emacs
    save-buffers-exit-emacs - Exit the editor prompt user to write changes 
$a


cEcESYNOPSIS cEcA


    cDquick-exitcA (cDesc zcA) 
    cDsave-buffers-exit-emacscA (cDC-x C-ccA) 


cEcEDESCRIPTION cEcA


    cDquick-exitcA writes out all changed buffers to the files they were read 
    from, saves all changed dictionaries, killing any running commands and 
    exits the editor. 

    cDsave-buffers-exit-emacscA operates a cDquick-exitcA only prompts the user before 
    saving any files. 


cEcENOTES cEcA


    All buffers with a name starting with a 'cD*cA' are assumed to be system 
    buffer (i.e. cD*scratch*cA) and are not saved. 


cEcESEE ALSO cEcA


    lslmexit-emacs(2)le, lslmsave-buffer(2)le. 

! 2 quote-char
cEcENAME cEcA


    quote-char - Insert literal character 
$a


cEcESYNOPSIS cEcA


    cCncA cDquote-charcA "cCkeycA" (cDC-qcA) 


cEcEDESCRIPTION cEcA


    cDquote-charcA inserts the next typed character cCncA times, default is 1, 
    ignoring the fact that it may be a command character. cDquote-charcA obeys the 
    current buffer setting of lslmover(2m)le mode. 


cEcESEE ALSO cEcA


    lslminsert-string(2)le, lssymbol(3)lmSymbol(3)le. 

! 2 rcs-file
cEcENAME cEcA


    rcs-file - Handle Revision Control System (RCS) files 
$a


cEcESYNOPSIS cEcA


    cCncA cDrcs-filecA (cDC-x C-qcA) 


cEcEDESCRIPTION cEcA


    MicroEmacs '02 RCS support command. The action of this command depends on 
    the current buffer lslmview(2m)le mode state, the argument cCncA, and the existence 
    of an RCS file. 

    cDview-mode ON; RCS file does not existcA 
        Removes buffer view mode to enable the user to edit the file. 

    cDview-mode ON; RCS file existscA 
        MicroEmacs attempts to check out the file using the command line given 
        by the variable lslm$rcs-cou-com(5)le (co unlock). The file is then reloaded 
        and the view mode status re-evaluated. 

    cDview-mode OFF; RCS file does not existcA 
        MicroEmacs attempts to check-in the file into RCS for the first time 
        using the command-line given by the variable lslm$rcs-cif-com(5)le (ci 
        first). The file is then reload. 

    cDview-mode OFF; RCS file existscA 
        MicroEmacs attempts to check-in the file into RCS using the 
        command-line given by the variable lslm$rcs-ci-com(5)le. The file is then 
        reload. 

    cD-ve argument givencA 
        MicroEmacs attempts to unedit any changes made to the file using the 
        command-line given by the variable lslm$rcs-ue-com(5)le. The file is then 
        reload. 


cEcESEE ALSO cEcA


    cDrcs(1)cA. lslm$rcs-file(5)le, lslmbuffer-mode(2)le, lslmfind-file(2)le, lslmview(2m)le. 

! 2 read-file
cEcENAME cEcA


    read-file - Find and load file replacing current buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDread-filecA "cCfile-namecA" (cDC-x C-rcA) 


cEcEDESCRIPTION cEcA


    cDread-filecA operates like lslmfind-file(2)le, this command either finds the file 
    in a buffer, or creates a new buffer and reads the file in. The command 
    destroys the current buffer before the new buffer is created making this 
    command ideal to use when the wrong file was entered on a lslmfind-file(2)le. 
    This command is also useful for re-loading files that have changed on 
    disk. 

    The numeric argument cCncA can be used to modify the default behaviour of the 
    command, where the bits are defined as follows: 

    cD0x01cA 
        If the file does not exist and this bit is not set the command fails 
        at this point. If the file does not exist and this bit is set (or no 
        argument is specified as the default argument is cG1cA) then a new empty 
        buffer is created with the given file name, saving the buffer 
        subsequently creates a new file. 

    cD0x02cA 
        If this bit is set the file will be loaded with lslmbinary(2m)le mode 
        enabled. See help on cDbinarycA mode for more information on editing 
        binary data files. 

    cD0x04cA 
        If this bit is set the file will be loaded with lslmcrypt(2m)le mode 
        enabled. See help on cDcryptcA mode for more information on editing 
        encrypted files. 

    cD0x08cA 
        If this bit is set the file will be loaded with lslmrbin(2m)le mode enabled. 
        See help on cDrbincA mode for more information on efficient editing of 
        binary data files. 


cEcESEE ALSO cEcA


    lslmreread-file(3)le, lslmfind-file(2)le, lslmview-file(2)le, lslmbinary(2m)le, lslmcrypt(2m)le, 
    lslmrbin(2m)le. 

! 2 read-history
cEcENAME cEcA


    read-history - Read in session history information 
$a


cEcESYNOPSIS cEcA


    cCncA cDread-historycA [ "cChist-filecA" ] 


cEcEDESCRIPTION cEcA


    cDread-historycA reads in a MicroEmacs '02 history file, setting the current 
    history information. If argument cDncA is not given then the given "cChist-filecA" 
    is simply read in. If a non-zero argument is specified then default 
    history is set to the given file-name and the file is read. If an argument 
    of zero is given then the default history is re-read. Information read in 
    (and saved) from the history file includes:- 

        * Searching and replacing history. 
        * Buffer name history. 
        * Command name history. 
        * File name history. 
        * General (all the rest) history. 
        * Buffer and file list with line numbers. 

    MicroEmacs '02's environment may be retained almost intact by the use of 
    the default history and using the cD-ccA (continue) command-line option to 
    re-load all files that were being edited in a previous session. 


cEcENOTES cEcA


    When running multiple MicroEmacs '02 sessions on the same work-station (or 
    different workstations sharing the same home directory), the default 
    history is saved when MicroEmacs '02 exits. As a result the last 
    MicroEmacs '02 sessions that terminates writes the history information 
    used next time. 

    The history information is saved in a registry format file (see lslmerf(8)le). 
    Reference should be made to the notes included in lslmerf(8)le as to how the 
    history file may be edited and effected in the same MicroEmacs '02 
    session. 


cEcESEE ALSO cEcA


    lslmerf(8)le, lslmsave-history(2)le. 

! 2 recenter
cEcENAME cEcA


    recenter - Recenter the window (refresh the screen) 
$a


cEcESYNOPSIS cEcA


    cCncA cDrecentercA (cDC-lcA) 


cEcEDESCRIPTION cEcA


    cDrecentercA scrolls the current window so that the cursor position is at the 
    center of the window and redraws the whole screen. If cCncA is given then 
    scrolls the window so that the cursor is cCncA lines from the top if cCncA is 
    positive or from the bottom if negative. 

    cDrecentercA is typically used to refresh the screen if it is out of date 
    (i.e. needs to be redrawn). 


cEcESEE ALSO cEcA


    lslmscreen-update(2)le. 

! 2 replace-string
cEcENAME cEcA


    replace-string - Replace string with new string 
$a


cEcESYNOPSIS cEcA


    cCncA cDreplace-stringcA (cDesc rcA) 


cEcEDESCRIPTION cEcA


    cDreplace-stringcA replaces all occurrences of one string with another string. 
    The replacement starts at the current location of the cursor and goes to 
    the end of the current buffer. 

    A numeric argument positive cCncA limits the number of strings replaced to cCncA. 
    A negative argument cCncA limits the number of lines in which the replacement 
    may take place, e.g. a value of -15 restricts the replacement of the 
    string to the next 15 lines from the current cursor position. 


cEcESEE ALSO cEcA


    See lslmOperating Modesle for a description of the lslmmagic(2m)le and lslmexact(2m)le modes 
    which change the search space. 

    lslmbuffer-mode(2)le, lslmquery-replace-string(2)le, lslmsearch-forward(2)le. 
    lsRegularExpressions(2)lmRegular Expressionsle 

! 2 set-position
! 2 goto-position
! 2 set-window
! 2 goto-window
cEcENAME cEcA


|set-position
    set-position - Store the current position 
|goto-position
    goto-position - Restore a stored position 
$a


cEcESYNOPSIS cEcA


    cCncA cDset-positioncA "cClabelcA" 
    cCncA cDgoto-positioncA "cClabelcA" 


cEcEDESCRIPTION cEcA


    cDset-positioncA stores current window, buffer, cursor and mark position 
    information against the given 'cGlabelcA' (a single alpha-numeric character). 
    cDgoto-positioncA takes the positional information stored against the given 
    'cGlabelcA' and restores the window, buffer and cursor positions from those 
    previously cDsetcA. 

    A call to cDset-positioncA with the same label over-writes the previous stored 
    information, a call to cDgoto-positioncA does not alter the information and 
    may be restored multiple times. 

    The numerical argument to cDset-positioncA is used to define the information 
    that is stored in the position item. The argument is intrepreted as a 
    bitmask, flagging what information is to be stored. The bit mask is 
    defined as follows: 

    cG0x001cA 
        Store the current window. 

    cG0x002cA 
        Store the current window's horizonal scroll (value of 
        lslm$window-x-scroll(5)le). 

    cG0x004cA 
        Store the current window's current line horizonal scroll (value of 
        lslm$window-xcl-scroll(5)le). 

    cG0x008cA 
        Store the current window's vertical scroll (value of 
        lslm$window-y-scroll(5)le). 

    cG0x010cA 
        Store the current buffer. 

    cG0x020cA 
        Store the current window's current line using an lsset-alpha-mark(2)lmalpha markle. 

    cG0x040cA 
        Store the current window's current line number (value of 
        lslm$window-line(5)le). 

    cG0x080cA 
        Store the current window's current column offset (value of 
        lslm$window-col(5)le). 

    cG0x100cA 
        Store the current window's mark line using an lsset-alpha-mark(2)lmalpha markle. 

    cG0x200cA 
        Store the current window's mark line number (value of lslm$window-line(5)le 
        when mark was set). 

    cG0x400cA 
        Store the current window's mark column offset (value of lslm$window-col(5)le 
        when mark was set). 

    When cCncA is not specified, the default value is cG0x0bfcA, i.e. store all 
    information required to return to the window, buffer and cursor position. 

    The argument supplied to cDgoto-positioncA similarly interpreted as a bitmask, 
    restoring the positional information. When the numerical argument cCncA is 
    omitted the same default is used when omitted on the store. On restoring a 
    position, information stored during the call to cDset-positioncA which is not 
    requested in corresponding cDgotocA is ignored, similarly information 
    requested in a cDgotocA which was not stored in the cDsetcA is also ignored. 


cEcEEXAMPLE cEcA


    The following example shows the typical use of these commands: 
sB
        set-position "a" 
            . 
            . 
        goto-position "a" 

sA
    The following example stores the current position at the start of a macro 
    sequence, if cGmy-commandcA is not successful (cD$statuscA equals 0) the original 
    position is restored: 
sB
        set-position "\x80" 
        !force my-command 
        !if &equ $status 0 
            ; command failed, return to the original position 
            goto-position "\x80" 
        !endif 

sA
    Note 'cG\x80cA' is interpreted as the character with the ASCII value of 0x80 
    which is a non-alphanumeric character, this is permitted in macros to 
    avoid using alphanumerics. 

    The following example shows how the current position can be restored after 
    re-reading a file: 
sB
        0xce set-position 
        read-file $buffer-fname @mna 
        ; a numeric argument of 0xce is not 
        ; required as this is the default 
        goto-position 

sA

cEcENOTES cEcA


    The position item may store and restore the current line by using an alpha 
    mark or the line number. The restrore strategy will determine what is 
    required, as follows:- 

    The main benefit from using an alpha mark is that the position is 
    maintained even when the buffer is edited, for example if the position is 
    stored at line 10 and a line is subsequently inserted at the top of the 
    buffer, if the line number was used then it would return back to the 10th 
    line which is the old 9th line whereas if an alpha mark were used it would 
    correctly return to the 11th line, as expected. 

    The disadvantage of using an alpha mark is that it is only associated with 
    that buffer. In some cases a position may need to be restored in another 
    buffer (e.g. when re-reading a buffer the original buffer may be deleted 
    first), in this situation the buffer line number must be used. 

    Commands cDset-windowcA and cDgoto-windowcA, which simple stored and returned to 
    the current window, were replaced by set-position and goto-position in 
    August 2000. The following macro implementations can be used as a 
    replacement: 
sB
        define-macro set-window 
            1 set-position "\x80" 
        !emacro 

        define-macro goto-window 
            goto-position "\x80" 
        !emacro 

sA

cEcESEE ALSO cEcA


    lslmset-alpha-mark(2)le, lslmfind-buffer(2)le, lslm$window-x-scroll(5)le, 
    lslm$window-xcl-scroll(5)le, lslm$window-y-scroll(5)le, lslm$window-line(5)le, 
    lslm$window-col(5)le. 

! 2 reyank
cEcENAME cEcA


    reyank - Restore next yank buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDreyankcA (cDesc ycA) 


cEcEDESCRIPTION cEcA


    Every region killed goes onto a stack, with the most recent at the top. 
    Immediately after yanking text out into the current buffer using lslmyank(2)le, 
    the user may cDreyankcA which deletes the region just yanked and replaces it 
    with cCncA insertions of the next region on the kill stack. Another call to 
    reyank deletes that region and replaces it with the next in the stack etc. 

    The last 15 kills are stored. 


cEcESEE ALSO cEcA


    lslmcopy-region(2)le, lslmkill-region(2)le, lslmset-mark(2)le, lslmyank(2)le. 

! 2 save-dictionary
cEcENAME cEcA


    save-dictionary - Save changed spelling dictionaries 
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-dictionarycA ["cCdictionarycA"] 


cEcEDESCRIPTION cEcA


    cDsave-dictionarycA may be used to save one, or all changed, dictionaries back 
    to disk. By default cDsave-dictionarycA prompts for a single dictionary, which 
    is then saved. If the dictionary to be saved has been created within the 
    session (rather than read from disk) the user is always prompted to save 
    and enter a full dictionary file name (pathname) to save to. If the 
    dictionary was not created then the user is only prompted to save if, 

        * a non-zero argument is supplied 
        * and the users history registry node "cC/history/spell/autosavecA" does 
          not exist or its value is zero. 

    Otherwise the dictionary is automatically saved. 

    The argument cCncA may be used to control the effect of the command, cCncA is a 
    bit based flag defined as follows:- 

    cD0x01cA 
        Enables prompting before saving, only used when saving all 
        dictionaries. 

    cD0x02cA 
        Save all changed dictionaries. 


cEcENOTES cEcA


    This command is called to save all dictionary changes whenever MicroEmacs 
    is exited. 

    The dictionary auto-save registry value can be changed via the 
    lslmuser-setup(3)le dialog. 


cEcESEE ALSO cEcA


    lslmadd-dictionary(2)le, lslmdelete-dictionary(2)le, lslmspell(2)le. 

! 2 save-buffer
cEcENAME cEcA


    save-buffer - Save contents of changed buffer to file 
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-buffercA (cDC-x C-scA) 


cEcEDESCRIPTION cEcA


    cDsave-buffercA saves the contents of the current buffer if the contents have 
    been changed, writing the buffer back to the file it was read from. 

    On saving the file, if lslmtime(2m)le mode is enabled then the ls$timestamp(5)lmtime stamp stringle 
    is searched for in the file and modified if located, to reflect the 
    modification date and time. 

    If lslmbackup(2m)le mode is enabled then a backup copy of the file existing is 
    created and the contents of the buffer are written to the file. Any 
    ls$auto-time(5)lmautomatic savele copies of the file are deleted. 

    If the buffer contains a lslmnarrow(2m)le it will automatically be removed 
    before saving so that the whole buffer is saved and restored when saving 
    is complete 

    If lslmauto(2m)le mode is enabled the the file is written out in the style 
    indicated by modes lslmcrlf(2m)le and lslmctrlz(2m)le. Otherwise the file is written 
    out in the style on the current platform. 

    The argument cCncA can be used to change the default behavior of save-buffer 
    described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Enables validity checks (default). These include check that the buffer 
        has been modified, if not an error occurs. Also the time stamp of the 
        file to be written is checked, if the file systems file exists and is 
        newer the confirmation of writing is requested from the user. If this 
        flag is not supplied then the buffer is written whenever possible and 
        without any prompts to the user. 

    cD0x02cA 
        Disables the expansion of any narrows (see lslmnarrow-buffer(2)le) before 
        saving the buffer. 


cEcENOTES cEcA


        * lslmundo(2)le information is discarded when the file is saved. 
        * Refer to lslm$auto-time(5)le for a description of the file extensions used 
          by MicroEmacs '02 for backup and temporary files. 
        * Buffers may also be saved via the lslmlist-buffers(2)le command. 


cEcESEE ALSO cEcA


    lslm$auto-time(5)le, lslm$timestamp(5)le, lslmbuffer-mode(2)le, lslmfind-file(2)le, 
    lslmnarrow-buffer(2)le, lslmsave-some-buffers(2)le, lslmundo(2)le, lslmbackup(2m)le, lslmtime(2m)le, 
    lslmundo(2m)le, lslmnarrow(2m)le, lslmauto(2m)le, lslmcrlf(2m)le, lslmctrlz(2m)le, lslmwrite-buffer(2)le, 
    lslmappend-buffer(2)le. 

! 2 delete-registry
cEcENAME cEcA


    delete-registry - Delete a registry tree 


cEcESYNOPSIS cEcA


    cDdelete-registrycA "cCrootcA" 


cEcEDESCRIPTION cEcA


    cDdelete-registrycA deletes a registry node cCrootcA from the registry, any 
    children belonging to the node are also deleted. 


cEcEDIAGNOSTICS cEcA


    cDdelete-registrycA fails if cCrootcA does not exist. 


cEcESEE ALSO cEcA


    lslmget-registry(2)le, lslmlist-registry(2)le, lslmread-registry(2)le, lslmset-registry(2)le, 
    lslmerf(8)le. 

! 2 scroll-next-window-down
! 2 scroll-next-window-up
cEcENAME cEcA


|scroll-next-window-down
    scroll-next-window-down - Scroll next window down 
|scroll-next-window-up
    scroll-next-window-up - Scroll next window up 
$a


cEcESYNOPSIS cEcA


    cCncA cDscroll-next-window-downcA (cDesc C-vcA) 
    cCncA cDscroll-next-window-upcA (cDesc C-zcA) 


cEcEDESCRIPTION cEcA


    cDscroll-next-window-downcA scrolls the next window down cCncA lines, if cCncA is 
    omitted then the next window is scrolled by cCwindowcA number of lines (i.e. 
    next screen page). 

    cDscroll-next-window-upcA scrolls the next window up cCncA lines, as 
    cDscroll-next-window-downcA. 

    These commands are useful in macros to control other windows. 


cEcESEE ALSO cEcA


    lslmscroll-up(2)le, lslmscroll-down(2)le. 

! 2 search-forward
! 2 search-backward
cEcENAME cEcA


|search-forward
    search-forward - Search for a string in the forward direction 
|search-backward
    search-backward - Search for a string in the backward direction 
$a


cEcESYNOPSIS cEcA


    cCncA cDsearch-forwardcA "cCstringcA" (cDC-x scA) 
    cCncA cDsearch-backwardcA "cCstringcA" (cDC-x rcA) 


cEcEDESCRIPTION cEcA


    cDsearch-forwardcA searches for a string from the current cursor position to 
    the end of the file. The string is typed on the bottom line of the screen, 
    and terminated with the cG<ESC>cA key. Special characters can be typed in by 
    preceding them with a cG^QcA. A single cG^QcA indicates a null string. On 
    successive searches, hitting cG<ESC>cA alone causes the last search string to 
    be reused. 

    Searching is affected by lslmmagic(2m)le mode, which allows regular expression 
    pattern matching, and lslmexact(2m)le mode which makes the search case 
    sensitive. 

    The numeric argument cCncA is interpreted as follows:- 

    cDn > 0cA 
        The cCncAth occurrence of the cCstringcA is located. 

    cDn < 0cA 
        The first occurrence of the cCstringcA is located in the next cCncA lines. 

    cDsearch-backwardcA searches backwards in the file. In all other ways it is 
    like cDsearch-forwardcA. 


cEcEDIAGNOSTICS cEcA


    The command returns a status of cGFALSEcA if the cCstringcA could not be located 
    (or cCncAth cCstringcA where cCncA occurrences are requested). If the cCstringcA is found 
    within the given search criteria the return status is cGTRUEcA. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmexact(2m)le, lslmhunt-backward(2)le, lslmhunt-forward(2)le, 
    lslmisearch-forward(2)le, lslmmagic(2m)le, lslmreplace-string(2)le. 
    lsRegularExpressions(2)lmRegular Expressionsle 

! 2 global-abbrev-file
! 2 buffer-abbrev-file
cEcENAME cEcA


    global-abbrev-file, buffer-abbrev-file - Set abbreviation file(s). 
$a


cEcESYNOPSIS cEcA


|global-abbrev-file
    cCncA cDglobal-abbrev-filecA "cCabbrev-filecA" 
|buffer-abbrev-file
    cCncA cDbuffer-abbrev-filecA "cCabbrev-filecA" 


cEcEDESCRIPTION cEcA


    The abbreviation files allow the user to define a set of short-cut 
    expansion text, whereby a short sequence of chararacters are associated 
    with a longer text segment. When the short sequence is entered, the user 
    may elect to maually expand the sequnce with the associated replacement 
    text. Provision for cursor positioning may be made in the replacement 
    text. 

    cDbuffer-abbrev-filecA sets the current buffer's abbreviation file (limit of 
    one abbreviation file per buffer). cDbuffer-abbrev-filecA does the minimal 
    amount of work to increase speed at load-up. The first use of 
    lslmexpand-abbrev(2)le attempts to load the abbreviation file at which point 
    errors may be reported. 

    An argument cCncA of zero, forces the buffer abbreviation file to be uncached, 
    such that the next abbreviation that is expanded forces a re-load of the 
    abbreviation file. This is typically only used when an abbreviation file 
    is being constructed and tested. 

    cDglobal-abbrev-filecA assigns a global set of abbreviations accross ALL 
    buffers, such that the abbreviation is available regardless of the current 
    buffer type. The global abbreviation file has a lower presidence than the 
    cDbuffer-abbrev-filecA, hence the currently assigned cDbuffer-abbrev-filecA is 
    searched before the cDglobal-abbrev-filecA. 

    Similarly for cDglobal-abbrev-filecA, an argument of zero forces the global 
    abbreviation file to be uncached and re-loaded on the next use. 

    An abbreviation is a string which is expanded to an alternate form, e.g. 

        cDe.g.cA -> cDfor examplecA 
    or 
        cDPIcA -> cD3.1415926536cA 
    etc. 

    An abbreviation file is an ordinary text file with a strict format, it is 
    loaded only once at the first call to lslmexpand-abbrev(2)le, from then on it 
    reminds buffered. An abbreviation file has an abbreviation per line, they 
    cannot use multiple lines. This is not a draw back as the expansion string 
    is executed using lslmexecute-string(2)le so any MicroEmacs '02 command may also 
    be called. 

    For example the following expansion string inserts the string "cG!continuecA" 
    and a newline:- 

        "cG!abort\rcA" 

    Note that 'cG\rcA' is used instead of 'cG\ncA' as cDC-mcA is bound to lslmnewline(2)le and 
    not cDC-jcA. The expansion string can also make use of a few useful 
    abbreviations:- 

        cD\pcA 
            Mark the current position (expanded to "cGC-x C-a PcA") 

        cD\PcA 
            Move cursor to the marked position (expanded to "cGC-x a PcA") 

    See help on lslmexecute-string(2)le for more useful abbreviations. 


cEcEEXAMPLE cEcA


    The abbreviation must be on the left hand side followed by at least 1 
    space, the expansion string must then be on the same line in quotes. So 
    for the given examples, the abbreviation file would be: 

        | 
        |e.g. "for example" 
        |PI   "3.1415926536" 
        | 


    The following abbreviation could be used for a C cCif-elsecA statement. 

        | 
        |if "if(\p)\r{\r\r}\relse\r{\r\r}\r\P" 
        | 


    This is particularly useful for email address, e.g. 

        | 
        |JA "\"JASSPA\" <support@jasspa.com>" 
        | 


    The following example is MicroEmacs '02 C-Mode abbreviation file for 
    constructing C files. Remember cD\pcA is where the cursor is positioned 
    following the expansion. 

        #i "#include <\p>\r\P" 
        #d "#define " 
        if "if(\p)\r{\r\r}\r\P" 
        ef "else if(\p)\r{\r\r}\r\P" 
        el "else\r{\r\p\r}\r\P" 
        wh "while(\p)\r{\r\r}\r\P" 
        sw "switch(\p)\r{\rcase :\rdefault:\r}\r\P" 


cEcENOTES cEcA


    Abbreviation files are given the extension cD.eafcA in the MicroEmacs '02 home 
    directory. 

    One of the easiest ways to create more complex abbreviations is to record 
    a keyboard macro, name it and then insert the resultant macro. See notes 
    on commands lslmstart-kbd-macro(2)le, lslmname-kbd-macro(2)le and lslminsert-macro(2)le. 

    Try to avoid using named key, such as "cGupcA" and "cGreturncA", as the keyboard 
    macro equivalent is not readable and is likely to change in future 
    releases. 


cEcEFILES cEcA


    cDc.eafcA - C-Mode abbreviation file. cDemf.eafcA - Macro code abbreviation file. 


cEcESEE ALSO cEcA


    lslmexecute-string(2)le, lslmexpand-abbrev(2)le, lslminsert-macro(2)le, lslmiso-accents-mode(3)le, 
    lslmname-kbd-macro(2)le, lslmstart-kbd-macro(2)le, lslmeaf(8)le. 

! 2 set-alpha-mark
cEcENAME cEcA


    set-alpha-mark - Place an alphabetic marker in the buffer 
$a


cEcESYNOPSIS cEcA


    cDset-alpha-markcA "cC?cA" (cDC-x C-acA) 


cEcEDESCRIPTION cEcA


    cDset-alpha-markcA places an alpha mark at the current location in the buffer 
    which can be returned to from anywhere in the buffer using the command 
    lslmgoto-alpha-mark(2)le. The user is prompted for a mark name which can be any 
    alphabetic character. the mark is destroyed if the line is deleted. 


cEcESEE ALSO cEcA


    lslmgoto-alpha-mark(2)le. 

! 2 set-cursor-to-mouse
cEcENAME cEcA


    set-cursor-to-mouse - Move the cursor to the current mouse position 
$a


cEcESYNOPSIS cEcA


    cCncA cDset-cursor-to-mousecA 


cEcEDESCRIPTION cEcA


    cDset-cursor-to-mousecA sets the current window and cursor position to the 
    location of the mouse on it's last event (button press or release). This 
    command may change the current window. If the line on which the mouse was 
    located was the message line then the no action is taken, if the line was 
    a window mode line the that window is made the current window but the 
    cursor location within the window remains the same. This is usually used 
    in user defined macros that control the functionality of the mouse. 

    An argument cCncA determines if the command is permitted to change windows, 
    when omitted a window change is permitted on cDset-cursor-to-mousecA. When 
    specified, the mouse is not permitted to change windows and returns an 
    error condition in lslm$mouse-pos(5)le indicating that the mouse is not within 
    the current window. 

    Invocation of this command sets the variable lslm$mouse-pos(5)le which 
    determines where the mouse is within the window. Interrogation of the 
    variable following the command may be used to determine if the mouse is 
    located on one of the more specialized window or screen regions. 

    When writing macros to cut and paste using the mouse, care should be taken 
    to ensure that the window at the button release is the same is at the 
    button press. If this is not undertaken, undesired effects could result. 
    The use of lslmset-position(2)le and lslmgoto-position(2)le are most usefully used 
    with this command to restore existing window context. 


cEcESEE ALSO cEcA


    lslm$mouse-pos(5)le, lslm$mouse-x(5)le, lslm$mouse-y(5)le, lslm$window-mode-line(5)le, 
    lslm$window-scroll-bar(5)le, lslmset-scroll-with-mouse(2)le, lslmset-position(2)le, 
    lslmgoto-position(2)le. 

! 2 set-encryption-key
cEcENAME cEcA


    set-encryption-key - Define the encryption key 
$a


cEcESYNOPSIS cEcA


    cDset-encryption-keycA (cDesc ecA) 


cEcEDESCRIPTION cEcA


    cDset-encryption-keycA sets the encryption key for files loaded or saved with 
    lslmcrypt(2m)le mode enabled. This must be performed for each file, key is not 
    entered into the history. The key can be set for each file on the command 
    line using the cD-kcA flag. When saving a buffer in encryption mode the key 
    will be prompted for if not already set. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmcrypt(2m)le, lslmfind-file(2)le, lslmfind-cfile(3)le. 

! 2 set-mark
cEcENAME cEcA


    set-mark - Set starting point of region 
$a


cEcESYNOPSIS cEcA


    cDset-markcA (cDesc spacecA) 


cEcEDESCRIPTION cEcA


    cDset-markcA is used to delimit the beginning of a marked region. Many 
    commands are effective for a region of text. A region is defined as the 
    text between the mark and the current cursor position. To delete a section 
    of text, for example, one moves the cursor to the beginning of the text to 
    be deleted, issues the cDset-markcA command by typing cDesc spacecA, moves the 
    cursor to the end of the text to be deleted, and then deletes it by using 
    the lslmkill-region(2)le (cDC-wcA) command. Only one mark can be set in one window 
    or one buffer at a time, and MicroEmacs '02 will try to remember a mark 
    set in an off screen buffer when it is called back on screen. 

    A region is a block of text to be acted upon by some MicroEmacs '02 
    commands. It is demarcated by the cDPOINTcA on one end and the cDMARKcA at the 
    other. The point is the primary location identifier where most of the 
    action takes place and is always between two characters. The point is 
    indicated by the cursor position in that it is just behind the cursor. The 
    point is also significant in that it defines one end of the region. The 
    mark, on the other hand, is invisible, and is used to demarcate the other 
    end of the region and is set through cDset-markcA. 


cEcESEE ALSO cEcA


    lslmcopy-region(2)le, lslmexchange-point-and-mark(2)le, lslmkill-region(2)le. lslmreyank(2)le, 
    lslmyank(2)le, 

! 2 set-variable
! 2 unset-variable
cEcENAME cEcA


|set-variable
    set-variable - Assign a new value to a variable 
|unset-variable
    unset-variable - Delete a variable 
$a


cEcESYNOPSIS cEcA


    cDset-variablecA "cCvariablecA" "cCvaluecA" (cDC-x vcA) 
    cDunset-variablecA "cCvariablecA" 


cEcEDESCRIPTION cEcA


    cDset-variablecA sets the given register (cD#cA name), system (cD$cA name), global (cD%cA 
    name), buffer (cD:cA name) or command (cD.cA name) variable to the given value, 
    erasing its current value. The returned value of an undefined variable is 
    the string "cGERRORcA", this maybe used to determine whether a variable has 
    been set. 

    cDunset-variablecA unsets the given variable so that it no longer exists. The 
    variable must be a global (cD%cA), buffer (cD:cA) or command (cD.cA) variable, system 
    (cD$cA) variables cannot be unset. 

    The cCvaluecA may be quoted or unquoted, if there are any white space 
    characters, or characters open to other interpretation (e.g. cD@wccA) in cCvaluecA 
    then quotes should be used. 

    cCvaluecA may contain control characters which are delimited by a back slash 
    (cD\cA) which include:- 

        cG\ncA newline 
        cG\tcA tab 
        cG\\cA backslash 

    Confusion sometimes arises in macros with the back slash, as the back 
    slashes are dereferenced when set. Commands such as lslmreplace-string(2)le 
    where the command itself utilizes back slashes. In this case the number of 
    back slashes should be doubled as the variable contents under go two 
    stages of dereferencing. 


cEcESEE ALSO cEcA


    lslmdescribe-variable(2)le, lslmlist-variables(2)le, lslm&set(4)le. 

    lsVariables(4)lmVariablesle 
    lslmIntroduction to Variable Functionsle 
    lsVariables(4)lmRegister Variablesle 

! 2 append-buffer
cEcENAME cEcA


    append-buffer - Write contents of buffer to end of named file 
$a


cEcESYNOPSIS cEcA


    cCncA cDappend-buffercA "cCfile-namecA" 


cEcEDESCRIPTION cEcA


    cDappend-buffercA is used to write the contents of the current buffer into an 
    EXISTING file. Use lslmsave-buffer(2)le if the buffer is to over-write the 
    existing file already associated with the buffer. Use lslmwrite-buffer(2)le if 
    the buffer is to be written out to a new file, or to replace an existing 
    file. 

    cDappend-buffercA writes the contents of the current buffer to the named file 
    cCfile-namecA. But unlike lslmwrite-buffer(2)le the action of the write does not 
    change the attributes associated with the file (if it exists), it also 
    does not effect the stats of the current buffer. 

    On writing the file, append-buffer ignores the lslmtime(2m)le and lslmbackup(2m)le 
    mode settings. The current buffer will not be time stamped and a backup 
    will not be created for "cCfile-namecA". If the buffer contains a lslmnarrow(2m)le 
    it will automatically be removed before saving so that the whole buffer is 
    saved and restored when saving is complete 

    The argument cCncA is a bit based flag, where:- 

    cD0x01cA 
        Enables validity checks (default). These include a check that the 
        given file already exist, if not confirmation of writing is requested 
        from the user. Without this flag the command will always succeed 
        wherever possible. If "cCfile-namecA" does not exist the buffer is written 
        out in a similar fashion to using the command lslmwrite-buffer(2)le. 

    cD0x02cA 
        Disables the expansion of any narrows (see lslmnarrow-buffer(2)le) before 
        appending the buffer. 

    cD0x04cA 
        Truncate the existing file before writing out the contents of the 
        buffer. This means that the file will consist solely of the contents 
        of the buffer, but it will still have the file attributes of the 
        original file. 

    If cCncA is not specified then the default argument of 1 is used. 


cEcEEXAMPLE cEcA


    The following example appends the current buffer onto the end of a file, 
    creating the file if it does not exists 
sB
        append-buffer "things_to_do.txt" 

sA
    The following example truncates the users email file while maintaining the 
    file attributes. This is taken from lslmvm(3)le where it is used to remove the 
    current mail from the system mail box. 

        find-buffer "*vm-empty-buffer" 
        -1 buffer-mode "ctrlz" 
        5 append-buffer %vm-mail-src 
        delete-buffer $buffer-bname 


    Note that the macro ensures that lslmctrlz(2m)le mode is removed. If it was 
    enabled then the file written would not be empty. 


cEcESEE ALSO cEcA


    lslmwrite-buffer(2)le, lslmsave-buffer(2)le. 

! 2 sort-lines
cEcENAME cEcA


    sort-lines - Alphabetically sort lines 
$a


cEcESYNOPSIS cEcA


    cCncA cDsort-linescA 


cEcEDESCRIPTION cEcA


    cDsort-linescA alphabetically sorts lines of text in the current buffer from 
    the lsset-mark(2)lmmarkle position to the current cursor position. If the buffer mode 
    lslmexact(2m)le is enabled then the sort is case sensitive, otherwise the sort 
    is case insensitive. By default the text is compared from left to right 
    from column 0 (the left hand edge), if a positive argument cCncA is given then 
    the text is compared left to right from the cCncAth column, any lines shorter 
    than cCncA characters are moved to the top and sorted from column 0. 

    If a negative argument cCncA is given then the text is sorted in reverse 
    order. The comparison starts at column cG-1-ncA, i.e. an argument of -1 sorts 
    in reverse order from column 0. 


cEcEEXAMPLE cEcA


    The following table gives the results of cDsort-linescA for different exact 
    modes and values of cCncA. 

        ___________________________________________________________ 

                 Original        Sorted Lines 
        ___________________________________________________________ 

          exact     -      n      n      y      y      n      n 
            n       -      -      1      -      1      -1     -2 
        ___________________________________________________________ 

                    B      a2     B      Aa     B      CA     Aa 
                    CA     Aa     c      B      c      c      CA 
                    b1     B      b1     CA     b1     b1     a2 
                    Aa     b1     a2     a2     a2     B      b1 
                    c      c      CA     b1     CA     Aa     c 
                    a2     CA     Aa     c      Aa     a2     B 
        ___________________________________________________________ 


cEcENOTES cEcA


    Typically MicroEmacs is executed with lslmexact(2m)le mode enabled, the macro 
    command cDsort-lines-ignore-casecA provides a command to sort lines case 
    insensitively while cDexactcA mode is enabled. The macro is defined as 
    follows:- 
sB
        define-macro sort-lines-ignore-case 
            set-variable #l0 &bmod exact 
            -1 buffer-mode "exact" 
            !if @? 
                @# sort-lines 
            !else 
                sort-lines 
            !endif 
            &cond #l0 1 -1 buffer-mode "exact" 
        !emacro 

sA
    lslmsort-lines-ignore-case(3)le is a macro defined in format.emf. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmexact(2m)le, lslmsort-lines-ignore-case(3)le, lslmtranspose-lines(2)le, 
    lslmuniq(3)le. 

! 2 spell
cEcENAME cEcA


    spell - Spell checker service provider 
$a


cEcESYNOPSIS cEcA


    cCncA cDspellcA ["cCwordcA"] ["cCrulescA"] ["cCcorrectioncA"] ["cCrulecA"] 


cEcEDESCRIPTION cEcA


    cDspellcA is a low level command which provides spell checking capabilities 
    for MicroEmacs '02, it is not designed to be used directly. The action of 
    cDspellcA depends on the argument given, which is a bitwise flag defined as 
    follows:- 

    cD0x001cA 
        If set then gets the input word from the user, i.e. "cCwordcA" must be 
        supplied. Otherwise the word input is taken from the current buffer. 

    cD0x002cA 
        If set then keeps getting words from the current buffer until either 
        the end of the buffer is reached or an error is found. If the end of 
        the buffer is reached then the command succeeds setting lslm$result(5)le to 
        the value "cCFcA". This bit is ignored if bit 0x001 is set. cDspellcA sets the 
        current show-region to enclose the problematical word and the command 
        lslmshow-region(2)le can be used to move around the word. 

    cD0x004cA 
        Adds the given word to a dictionary determined by the state of bit 
        0x008. If the word is flagged as erroneous (see bit 0x010) then a 
        "cCcorrectioncA" word must be supplied, otherwise a list of "cCrulescA" which 
        can be applied to the word must be given, this list can be empty. Note 
        that if the word is not flagged as erroneous and it already exists in 
        the dictionary, the word is not removed, instead a combined rule list 
        is created. 

    cD0x008cA 
        When set flags that word additions (bit 0x004) and deletions (bit 
        0x200) should be made to the ignore dictionary. Otherwise word 
        additions are made the last added dictionary and deletions are made to 
        all main dictionaries. 

    cD0x010cA 
        When set flags that the given word is erroneous, used solely by word 
        additions to create auto-corrections. 

    cD0x020cA 
        Returns a 'cC|cA' separated guest guess list for the given word in 
        cD$resultcA. 

    cD0x040cA 
        If bit cD0x100cA is also set a complete list of valid words derivable from 
        the given word are inserted into the current buffer. Otherwise spell 
        returns lslm$result(5)le set to the derivative word created when the given 
        "cCrulecA" is applied to "cCwordcA". The rule applied is the first found of 
        the given rule letter with a matching base ending (see 
        lslmadd-spell-rule(2)le). The word need not exist as not tests for the 
        legality of the resultant word is used, for example in American, 
        executing 

        65 spell "spelling" "V" 


        returns "cGspellingivecA" in cD$resultcA. Returns the empty string if no rule 
        could be applied. 

    cD0x080cA 
        Used with bit 0x002 to enable double word checking. 

    cD0x100cA 
        Return information in cD$resultcA about the given word, or the word which 
        is used to derive the given word. The information consists of the 
        spell status, the word as stored in the dictionary, and either the 
        list of valid rules, or the correction word. See also bit cD0x040cA. 

    cD0x200cA 
        Delete the given word from a dictionary determined by bit 0x008 

    If none of the main functions are used (bits 0x004, 0x020, 0x040 & 0x200) 
    then the status flag is returned in the first column of cD$resultcA. These are 
    defined as follows:- 

    cDAcA 
        Auto-replace. The word was found and flagged as erroneous. The 
        correction word is given in cD$resultcA, either next to the flag, or if 
        bit 0x100 is set then after the 'cC>cA' character. 

    cDDcA 
        Double word. Indicates that the first problem found is a double 
        occurrence of the same word one after the other. 

    cDEcA 
        Erroneous. The word was not found, so is Erroneous 

    cDNcA 
        Not a word. The current word found contains no alphabetic characters 
        so is not deemed to be a word, e.g. 3.141593. 

    cDOcA 
        Okay. The word was found and is not an erroneous word. 


cEcESEE ALSO cEcA


    lslmadd-dictionary(2)le, lslmadd-spell-rule(2)le, lslmdelete-dictionary(2)le, 
    lslmsave-dictionary(2)le, lslmshow-region(2)le, lslmspell-buffer(3)le, lslmspell-word(3)le, lslocaleSupport(2)lmLocaleln
    lnSupportle. 

! 2 next-window-find-buffer
cEcENAME cEcA


    next-window-find-buffer - Split the current window and show new buffer 
$a


cEcESYNOPSIS cEcA


    cDnext-window-find-buffercA "cCbuffercA" (cDC-x 3cA) 


cEcEDESCRIPTION cEcA


    cDnext-window-find-buffercA splits the current window into two near equal 
    windows, and swaps the current windows buffer to the given cCbuffercA. It is 
    effectively a lslmsplit-window-vertically(2)le command followed by a 
    lslmfind-buffer(2)le. When there is insufficient space in the current window to 
    perform the split, then the current window is replaced. The requested 
    cCbuffercA is always displayed, if the buffer does not already exist it is 
    created. 


cEcESEE ALSO cEcA


    lslmfind-buffer(2)le, lslmsplit-window-vertically(2)le, lslmnext-window-find-file(2)le. 

! 2 next-window-find-file
cEcENAME cEcA


    next-window-find-file - Split the current window and find file 
$a


cEcESYNOPSIS cEcA


    cDnext-window-find-filecA "cCfilecA" (cDC-x 4cA) 


cEcEDESCRIPTION cEcA


    cDnext-window-find-filecA splits the current window into two near equal 
    windows, and loads the given cCfilecA into the current window. It is 
    effectively a lslmsplit-window-vertically(2)le command followed by a 
    lslmfind-file(2)le. 

    When there is insufficient space in the current window to perform the 
    split, then the current window is replaced. The requested cCfilecA is always 
    displayed, if the file does not already exist it is effectively created 
    within MicroEmacs (although it will not exist on the disk until a save 
    operation is performed). 

    The numeric argument cCncA can be used to modify the default behaviour of the 
    command, where the bits are defined as follows: 

    cD0x01cA 
        If the file does not exist and this bit is not set the command fails 
        at this point. If the file does not exist and this bit is set (or no 
        argument is specified as the default argument is cG1cA) then a new empty 
        buffer is created with the given file name, saving the buffer 
        subsequently creates a new file. 

    cD0x02cA 
        If this bit is set the file will be loaded with lslmbinary(2m)le mode 
        enabled. See help on cDbinarycA mode for more information on editing 
        binary data files. 

    cD0x04cA 
        If this bit is set the file will be loaded with lslmcrypt(2m)le mode 
        enabled. See help on cDcryptcA mode for more information on editing 
        encrypted files. 

    cD0x08cA 
        If this bit is set the file will be loaded with lslmrbin(2m)le mode enabled. 
        See help on cDrbincA mode for more information on efficient editing of 
        binary data files. 


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmnext-window-find-buffer(2)le, lslmsplit-window-vertically(2)le, 
    lslmbinary(2m)le, lslmcrypt(2m)le, lslmrbin(2m)le. 

! 2 split-window-vertically
cEcENAME cEcA


    split-window-vertically - Split the current window into two 
$a


cEcESYNOPSIS cEcA


    cCncA cDsplit-window-verticallycA (cDC-x 2cA) 


cEcEDESCRIPTION cEcA


    cDsplit-window-verticallycA splits the current window vertically into two near 
    equal windows, each displaying the buffer displayed by the original 
    window. A numeric argument cCncA of 1 forces the upper window to be the new 
    current window (default), and an argument of 2 forces the lower window to 
    be the new current window. 


cEcESEE ALSO cEcA


    lslmgrow-window-vertically(2)le, lslmnext-window-find-buffer(2)le, 
    lslmnext-window-find-file(2)le, lslmresize-window-vertically(2)le, 
    lslmsplit-window-horizontally(2)le. 

! 2 print-color
! 2 print-scheme
cEcENAME cEcA


|print-color
    print-color - Create a new printer color 
|print-scheme
    print-scheme - Create a new printer color and font scheme 
$a


cEcESYNOPSIS cEcA


    cCncA cDprint-colorcA "cCcol-nocA" "cCredcA" "cCgreencA" "cCbluecA" 
    cCncA cDprint-schemecA "cCschemeNumcA" "cCforecA" "cCbackcA" "cCfont-maskcA" 


cEcEDESCRIPTION cEcA


    cDprint-colorcA and cDprint-schemecA are similar to lslmadd-color(2)le and 
    lslmadd-color-scheme(2)le except they configure MicroEmacs's printer scheme. 

    cDprint-colorcA creates a new printer color and inserts it into the printer 
    color table, where cCredcA, cCgreencA and cCbluecA are the color components and cCcol-nocA 
    is the printer color index. The printer color table contains 256 entries 
    indexed by cCcol-nocA in the range 0-255. cDprint-colorcA may also be used to 
    modify an existing cCcol-nocA index by re-assignment, the existing color 
    definition is over-written with the new color definition. 

    An argument cCncA of 0 to cDprint-colorcA resets the printer color table, removing 
    all currently defined colors. 

    cDprint-schemecA creates a new printer scheme. A printer scheme maps the 
    lslmhilight(2)le buffer's text into a print scheme. For example key words could 
    be printed in cCboldcA or in cCbluecA etc. cDprint-schemecA arguments comprise an 
    identifying index number "cCschemeNumcA", two color values, "cCforecA" and "cCbackcA" 
    (defined by cDprint-colorcA) and a font setting "cCfont-maskcA". The cCfont-maskcA is 
    a bit mask where each bit is defined as follows: 

        cG0x01cA Enable bold font. 
        cG0x02cA Enable italic font. 
        cG0x04cA Enable light font. 
        cG0x08cA Enable reverse font. 
        cG0x10cA Enable underlining. 

    An argument cCncA of 0 to cDprint-schemecA resets the printer scheme table, 
    removing all currently defined printer schemes. 


cEcENOTES cEcA


    Printer schemes may be created and altered using the lslmscheme-editor(3)le 
    dialog, the created printer scheme may then be used directly in the 
    lslmprint-setup(3)le dialog. Therefore direct use of these commands is largely 
    redundant. 


cEcESEE ALSO cEcA


    lslmscheme-editor(3)le, lslmprint-setup(3)le, lslmprint-buffer(2)le, lslmhilight(2)le, 
    lslm$buffer-hilight(5)le. 

! 2 suspend-emacs
cEcENAME cEcA


    suspend-emacs - Suspend editor and place in background 
$a


cEcESYNOPSIS cEcA


    cDsuspend-emacscA 


cEcEPLATFORM cEcA


    Supported on UNIX platforms - cCirixcA, cChpuxcA, cCsunoscA, cCfreebsdcA or cClinuxcA. 


cEcEDESCRIPTION cEcA


    cDsuspend-emacscA suspends the editing processor and puts it into the 
    background. The "cCfgcA" command restarts MicroEmacs '02. 


cEcESEE ALSO cEcA


    lslmshell(2)le. 

! 2 shell-command
cEcENAME cEcA


    shell-command - Perform an operating system command 
$a


cEcESYNOPSIS cEcA


    cDshell-commandcA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cDshell-commandcA performs an operating system call with the given cCstringcA as 
    its argument. The command only fails if the shell-command call returns -1. 
    The lslm$result(5)le variable is set the return value and can be used to test 
    the result. 


cEcESEE ALSO cEcA


    lslm$result(5)le, lslmipipe-shell-command(2)le, lslmpipe-shell-command(2)le, 
    lslmsuspend-emacs(2)le. 

! 2 show-region
cEcENAME cEcA


    show-region - Show the current copy region 
$a


cEcESYNOPSIS cEcA


    cCncA cDshow-regioncA 


cEcEDESCRIPTION cEcA


    cDshow-regioncA manipulates the currently defined region, it can be used to 
    inquire the state of the current region, if any. It can also be used to 
    define a region, enable and disable the region hilighting, as well as move 
    the cursor to the start or end of the region. 

    Region hilighting occurs between the cCmarkcA (see lslmset-mark(2)le) and cCpointcA 
    (current cursor) positions within the current buffer. A region is defined 
    when text is copied to the kill buffer, by using any of the kill commands 
    such as lslmkill-region(2)le, or lslmcopy-region(2)le. However, the kill region is 
    only visible after a lslmcopy-region(2)le or a lslmyank(2)le operation. A hilight 
    region is also created on a successful search using commands like 
    lslmsearch-forward(2)le, the region encloses the search matching string. 
    lsspell(2)lmSpell(2)le also creates a hilight region around the current spell word. The 
    user can also define their own region using the numeric argument to 
    cDshow-regioncA. 

    The argument cCncA supplied to the command indicates the require functionality 
    and can take the following values:- 

        cG-3cA - Set the start position of the region. 
        cG-2cA - Move the cursor the  Mark position. 
        cG-1cA - Disable the hilighting of the current region. 
        cG 0cA - Return the current status of the region in 
        lslm$result(5)le. 
        cG 1cA - Enable the hilighting of the current region. 
        cG 2cA - Move the cursor the  Dot position. 
        cG 3cA - Set the end position of the region. 
        cG 4cA - Reactivate the current region. 

    Where an argument of 0 is used to return the current state the value of 
    $result is a bit based flag where:- 

    cD0x01cA 
        Indicates a region is currently active (visible). 

    cD0x02cA 
        Indicates a region has been fixed (may not visible). 

    cD0x04cA 
        Indicates the region is in the current buffer. 

    cD0x08cA 
        Indicates the cursor is in the current region. 

    The color of the selection hilight is defined by lslmadd-color-scheme(2)le and 
    is determined by lslm$buffer-scheme(5)le, lslm$global-scheme(5)le or 
    lslm$buffer-hilight(5)le. 


cEcEDIAGNOSTICS cEcA


    The following errors can be generated, in each case the command returns a 
    FALSE status: 

    cD[No current region]cA 
        There is no current defined region on which to operate. 

    cD[Current region not in this buffer]cA 
        An argument of 2 or -2 was used and the defined region isn't in the 
        current window so the cursor can not be moved to it. 


cEcENOTES cEcA


    If no argument is given to the command it hilights the current region, 
    similar to an argument of 1. But the properties of the hilight, namely how 
    long it will be hilighted for, are inherited from the setting of 
    lslm$show-region(5)le, whereas if an argument of 1 is passed in then the 
    hilighting is set to be kept until the region becomes invalid (i.e. as if 
    lslm$show-region(5)le is set to 3). 


cEcESEE ALSO cEcA


    lslm$show-region(5)le, lslm$buffer-hilight(5)le, lslm$buffer-scheme(5)le, lslm$global-scheme(5)le, 
    lslmadd-color-scheme(2)le, lslmcopy-region(2)le, lslmyank(2)le, lslmsearch-forward(2)le, lslmspell(2)le, 
    lslmset-mark(2)le. 

! 2 translate-key
cEcENAME cEcA


    translate-key - Translate key 
$a


cEcESYNOPSIS cEcA


    cCncA cDtranslate-keycA [ "cCfromcA" ["cCtocA"] ] 


cEcEDESCRIPTION cEcA


    cDtranslate-keycA may be used to convert any given input key sequence to 
    another single key. cDtranslate-keycA operates at a very low level, before 
    MicroEmacs attempts to evaluate keyboard bindings, so it may be used to 
    solve a variety of keyboard problems such as special language characters 
    and UNIX termcap key sequence bindings (see below). 

    If a +ve numeric argument cCncA is given it is used to set the time in 
    milliseconds MicroEmacs waits for another key to be pressed before 
    continuing, the default time use when no argument is supplied is 250ms. 

    If a numeric argument cCncA of -1 is specified then the "cCtocA" argument is not 
    required and the "cCfromcA" character sequence is removed from the translate 
    key table. 

    If a numeric argument cCncA of 0 is specified then no arguments are required; 
    the current translation table is dumped to buffer "cC*tcap-keys*cA". Following 
    is a sample output:- 

            "C-h" ......................... "backspace" 
            "C-[" ......................... "esc" 
            "C-[ [ 1 ~" ................... "delete" 
            "C-[ [ 1 1 ~" ................. "f1" 
            "C-[ [ 1 2 ~" ................. "f2" 
            "C-[ [ 1 3 ~" ................. "f3" 
            "C-[ [ 1 4 ~" ................. "f4" 
            "C-[ [ B" ..................... "down" 
            "C-[ [ 4 ~" ................... "end" 
            "C-[ [ 2 ~" ................... "insert" 
            "C-[ [ 3 ~" ................... "home" 
            "C-[ [ D" ..................... "left" 
            "C-[ [ 6 ~" ................... "page-down" 
            "C-[ [ 5 ~" ................... "page-up" 
            "C-[ [ C" ..................... "right" 
            "C-[ [ A" ..................... "up" 
            "C-[ [ V" ..................... "page-up" 
            "C-[ [ U" ..................... "page-down" 
            "C-m" ......................... "return" 
            "C-i" ......................... "tab" 
            "\x7F" ........................ "backspace" 


cEFOREIGN KEYBOARDS cA


    Foreign keyboards (non-US/UK) use a variety of key sequences, not 
    recognized by MicroEmacs, to expand the keyboard character range to cope 
    with accented characters. For example, on a German keyboard 'cGAltGr-mcA' 
    (recognized as 'cGA-C-mcA') is used to insert a Greek mu (or micro sign). On a 
    Belgian keyboard 'cGAltGr-9cA' inserts a '{' character. 

    Many foreign keyboards are already directly supported by MicroEmacs and 
    the keyboard specifics of a country have been understood and resolved. In 
    these cases the cDKeyboardcA configuration in lslmuser-setup(3)le may be used for 
    the country location. 

    If MicroEmacs does not support your keyboard, cDtranslate-keycA may be used to 
    fix any key input problems. For the aforementioned examples the following 
    cDtranslate-keycA commands would be required: 
sB
        ; translate AltGr-m to a Greek mu (char 0xb5) 
        translate-key "A-C-m" "\xB5" 
        ; translate AltGr-9 to a '{' 
        translate-key "A-C-9" "{" 

sA
    The problem is complicated further on Microsoft Window's platforms by the 
    simultaneous generation of 2 keys for some Alt-Gr key combinations (this 
    is a side effect of endeavoring to capture all key combinations in this 
    environment). For the Belgian keyboard example, on Win32 platforms an 
    'cGAltGr-9cA' generates an 'cGA-C-9cA' key first followed immediately by an 
    'cGA-C-{cA'. As both keys are generated in quick succession this is unexpected 
    and confusing. 

    When the key is first pressed on a poorly configured system the error 
    "cC[Key not bound "A-C-{"]cA" is given even when using the command 
    lslmdescribe-key(2)le as the key described will be 'cGA-C-9cA' and then the 'cGA-C-{cA' 
    key is generated and interpreted creating the error message. 

    The variable lslm$recent-keys(5)le can be used to diagnose this problem and to 
    obtain the 2 keys generated; alternatively use the macro below: 
sB
        define-macro report-2-keys 
            ml-write "Press key 1" 
            set-variable #l0 @cgk 
            ml-write "Press key 2" 
            set-variable #l1 @cgk 
            ml-write &spr "[The following keys where pressed: \"%s\" \"%s\"]" #l0 #l1 
        !emacro 

sA
    When executed the user is prompted for the first key; press the required 
    key sequence (in this case 'cGAltGr-9cA'), if you are not prompted for the 
    second key and the result is immediately returned then the key you pressed 
    has generated 2 keys, both of which will be given in the print out, i.e.: 

        "[The following keys where pressed: "A-C-9" "A-C-{"]" 


    The translate-key required to fix this type of problem would be: 
sB
        translate-key "A-C-9 A-C-{" "{" 

sA
    If your keyboard is not directly supported by MicroEmacs, please submit 
    the keyboard name and platform with a working translate-key configuration 
    to lsMicroEmacs '02 - Contact InformationlmJASSPAle as a cDBUGcA. 


cEUNIX TERMCAP cA


    cDtranslate-keycA may also be used to interpret non-standard key sequences for 
    UNIX termcap platforms to standard MicroEmacs keys. Non-standard keys, 
    such as the cursor keys, have system dependent key sequences. The output 
    from these keys usually take the form: 

        cG^[[XcA or cG^[[DXcA or cG^[[DDXcA or cG^[[DDDcA 

    where cD^[cA is the escape key (27), cDDcA is a digit and cDXcA is any character. 
    These keys may be bound to the standard keys, for example the typical 
    output of the cursor keys may be translated as follows:- 

        cG^[[AcA = cDupcA, cG^[[BcA = cDdowncA, cG^[[CcA = cDrightcA and cG^[[DcA = cDleftcA 

    The "cCfromcA" string is specified as this key sequence and the "cCtocA" string is 
    simply the key it is to be bound to, see lslmglobal-bind-key(2)le for a guide to 
    the string format. For the above example the following set of translations 
    are required:- 
sB
        translate-key "esc [ A" "up" 
        translate-key "esc [ B" "down" 
        translate-key "esc [ C" "right" 
        translate-key "esc [ D" "left" 

sA
    Note that MicroEmacs interprets cG\ecA as an escape key. More obscure keys 
    tend to be very platform specific, following are some examples: 
sB
        translate-key "esc [ 2 ~" "insert" 
        translate-key "esc [ 5 ~" "page-up" 
        translate-key "esc [ 5 ^" "C-page-up" 

sA

cEcEEXAMPLE cEcA


    Using the +ve numeric argument it is possible to reduce the delay and 
    there by increase usability is some features. For instance, in the Mouse 
    configuration of cDuser-setupcA there is an option to 'Simulate 3 Buttons' 
    which translates a rapid left and right button press into a middle button 
    press. This is implemented using cDtranslate-keycA as follows: 
sB
        10 translate-key "mouse-pick-1 mouse-pick-3" "mouse-pick-2" 
        10 translate-key "mouse-pick-3 mouse-pick-1" "mouse-pick-2" 
        10 translate-key "mouse-drop-1 mouse-drop-3" "mouse-drop-2" 
        10 translate-key "mouse-drop-3 mouse-drop-1" "mouse-drop-2" 

sA
    When a cGmouse-pick-1cA key is generated MicroEmacs must wait to see if a 
    cGmouse-pick-3cA key is next and therefore translate both to a single 
    cGmouse-pick-2cA key. This wait time is usually a quarter of a second but this 
    makes the left button unusable for dragging regions etc as the delay is 
    too long. By giving a argument of 10ms the delay is long enough for a 
    simultaneous left and right button press but short enough for the left 
    button to still be usable on its own. 

    The +ve numeric argument can be very useful for delaying MicroEmacs as 
    well, for example, the character string "cG'ecA" can be converted to e-accute 
    using lslmiso-accents-expand(3)le. This could be performed automatically using 
    translate-key as follows: 
sB
        1000 translate-key "' e" "\xE9" 

sA
    The larger 1 second delay give the user enough time to type the 'cGecA' after 
    the 'cG'cA' character. 


cEcENOTES cEcA


    The concept of standardized key-bindings is very important for cross 
    platform use and maintenance. 

    Refer to lslmglobal-bind-key(2)le for a list of standard bindings. 

    One of the easiest ways of obtaining a key sequence is to run cDsh(1)cA which 
    does not attempt to interpret these keys so when a key is pressed 
    (followed by cG<RETURN>cA) the following type of error message is usually 
    generated:- 

        sh: ^[[2~:  not found. 


    where cG^[[2~cA is the required key sequence. Another method of obtaining 
    these key sequences is to start MicroEmacs '02, use lslmstart-kbd-macro(2)le to 
    start a macro definition, press the required keys and then use 
    lslmend-kbd-macro(2)le followed by lslmname-kbd-macro(2)le and lslminsert-macro(2)le to 
    display the keys pressed. 

    The key sequences generated for these keys are dependent on the machine 
    displaying MicroEmacs '02 as opposed to the machine running it. Often they 
    are the same machine, but when they are not there is no easy method of 
    determining the displaying machine and therefore correctly configuring 
    MicroEmacs '02. 

    A better way of obtaining this cross platform consistency is to create an 
    XTerm app-defaults setup file with the correct VT100 key translations, 
    e.g. the setup file could contain the following 

        *vt100.translations: #override \ 
         Shift<Key>Tab:  string("\033[Z") \n\ 
         <Key>BackSpace:  string("\177") \n\ 
         <Key>Delete:  string("\033[1~") \n\ 
         <Key>Insert:  string("\033[2~") \n\ 
         <Key>Home:  string("\033[3~") \n\ 
         <Key>End:  string("\033[4~") \n\ 
         <Key>Prior:  string("\033[5~") \n\ 
         <Key>Next:  string("\033[6~") \n\ 
         Ctrl<Key>Up:  string("\033Oa") \n\ 
         Ctrl<Key>Down:  string("\033Ob") \n\ 
         Ctrl<Key>Right:  string("\033Oc") \n\ 
         Ctrl<Key>Left:  string("\033Od") \n\ 
         Shift<Key>Up:  string("\033[a") \n\ 
         Shift<Key>Down:  string("\033[b") \n\ 
         Shift<Key>Right: string("\033[c") \n\ 
         Shift<Key>Left:  string("\033[d") \n 


    By using the environment variable cCXUSERFILESEARCHPATHcA to ensure that this 
    configuration file is found instead of the system one (found in 
    cG/usr/lib/X11/app-defaultscA), the key sequences will then be the same across 
    all platforms. See manual page on cDxterm(1)cA for more information. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmdescribe-key(2)le, lslmglobal-bind-key(2)le, lslmstart-kbd-macro(2)le, 
    cDxterm(1)cA, cDsh(1)cA. 

! 2 set-char-mask
cEcENAME cEcA


    set-char-mask - Set character word mask 
$a


cEcESYNOPSIS cEcA


    cCncA cDset-char-maskcA "cCflagscA" ["cCvaluecA"] 


cEcEDESCRIPTION cEcA


    cDset-char-maskcA returns or modifies the setting of MicroEmacs internal 
    character tables. The argument cCncA defines the action to be taken, as 
    follows:- 

    cD-1cA 
        Removes characters from the given set. 

    cD0cA 
        Returns characters in the given set in lslm$result(5)le. 

    cD1cA 
        Adds characters to the given set. 

    The first argument "cCflagscA" determines the required character set as 
    follows:- 

    cDdcA 
        Is Displayable. Characters in this set can be directly displayed to 
        the screen (as a single character) when occurring in a buffer. When a 
        character not in this set is to be displayed it is performed using 
        more than one character. Characters in the range 1-31 are displayed as 
        "cG^?cA" where cG?cA is the ASCII character plus 64, (e.g. 0x01 -> 65, i.e. 
        "cG^AcA") otherwise the character is displayed in the form "cG\xhhcA" where cGhhcA 
        is the hex form of the ASCII value. One notable exception is the tab 
        character (0x09), by default this character is not displayable, 
        instead it is displayed as a sequence of one or more spaces up to the 
        next tab stop. 

    cDpcA 
        Is Pokable. Similar to cDdcA, characters in this set can be poked to the 
        screen when using lslmscreen-poke(2)le. When found in a binary file the 
        character is displayed in the right hand column. Unlike cDdcA, any 
        character outside this set will be displayed as a single period 'cG.cA', 
        indicating that it cannot be displayed. 

    cDPcA 
        Is Printable. Similar to cDdcA, characters in this set may be printed as a 
        single character when using lslmprint-buffer(2)le or lslmprint-region(2)le. Any 
        character not in this set is printed in a similar fashion to cDdcA. 

    cDMcA 
        Character font Map. Internally MicroEmacs uses ISO-8859-1 (Latin 1) to 
        configure alphabetic classes and the spell-checker, however the system 
        font being by the native platform may not be the same, for example a 
        small 'e' acute is character 0xe9 in ISO-8859-1 but character 0x82 in 
        Windows OEM fonts. To change the characteristics of the 'e' acute 
        character (such as making it an alphabetic character), the ISO-8859-1 
        character should always be used, but a correct mapping of ISO-8859-1 
        to the display font (such as Windows OEM) must also be supplied. 

        Unlike other sets, this set cannot be incrementally altered, any calls 
        to alter this set leads to the resetting of all the character tables 
        so the character mapping must be performed first and in a single call. 
        No other set may be altered in the same call. When setting, the 
        "cCvaluecA" must supply pairs of characters, an ISO-8859-1 character 
        followed by its system font equivalent. 

    cDLcA 
        ISO-8859-1 (Latin 1) character map list. This set cannot be altered 
        using this flag, character mappings must be set up using flag cDMcA. The 
        order of the characters in the returned cD$resultcA string is the same as 
        the order for flag cDUcA. 

    cDUcA 
        User font character map list. This set cannot be altered using this 
        flag, character mappings must be set up using flag cDMcA. The order of the 
        characters in cD$resultcA when returned is the same as the order for flag 
        cDLcA. 

    cDacA 
        Is Alphabetic letter. Characters in this set are alphabetical 
        characters, used by many MicroEmacs commands such as lslmforward-word(2)le. 
        When setting, the "cCvaluecA" must specify pairs of ISO-8859-1 (Latin 1) 
        characters, an Upper-case character followed by its lower-case 
        equivalent. This enables commands such as lslmlower-case-word(2)le to 
        operate correctly regardless of the font and language being used. Some 
        fonts may not have all the characters available for rendering, for 
        instance PC Code page 437 does not have an upper-case 'e' grave. In 
        this case an ordinary 'E' should be used as a sensible replacement, 
        i.e. "E`e" (where `e is an 'e' grave). However, this will lead to all 
        upper-case 'E's to map to a lower-case 'e' grave in a case changing 
        operation, this may be corrected by adding a further mapping of 'E' to 
        'e' to over-ride the 'e' grave mapping, i.e. "E`eEe". This technique 
        does fail when changing the case more than once, when all lower case 
        'e' graves will be lost. 

        Note that the returned character list will pair all lower-case 
        characters with their upper-case equivalent letters first. 

    cDlcA 
        Is Lower case letter. This set cannot be altered using this flag, 
        alterations to the alphabetic set must be performed using flag cDacA. 
        Characters in this set are all the lower-case letters, typically the 
        characters 'cGacA' to 'cGzcA'. The order may not be the same as returned by 
        flag cDucA. 

    cDucA 
        Is Upper case letter. This set cannot be altered using this flag, 
        alterations to the alphabetic set must be performed using flag cDacA. 
        Characters in this set are all the upper-case letters, typically the 
        characters 'cGAcA' to 'cGZcA'. The order may not be the same as returned by 

    cDhcA 
        Is Hex-decimal Digit. The set is rarely used as it is invariably the 
        digits 'cG0cA' to 'cG9cA' and the letters 'cGacA' to 'cGfcA' in upper and lower case. 
        It is often used in the setting of lslm$buffer-mask(5)le. 

    cDAcA 
        Is Alpha-numeric. This set cannot be altered using this flag, 
        alterations to the alphabetic set must be performed using flag cDacA. 
        Characters in this set are either alphabetic characters or the digits 
        0-9. 

    cDscA 
        Is Spell extended word character. The characters in this set are 
        recognized by the spell checker as characters which may be considered 
        part of a word, for example the period 'cG.cA's in e.g. or the hyphen 'cG-cA' 
        in hyphenated-words. Typically this set contains the characters 'cG'cA', 
        'cG-cA' and 'cG.cA'. 

    cD1cA, cD2cA, cD3cA & cD4cA 
        Is in Word. These user definable sets are used to add characters to a 
        buffer's word character set, affecting the operation of commands like 
        lslmforward-word(2)le. Many different file types operate better with a 
        different word character set, e.g. it is preferable to include the 'cG_cA' 
        character when editing C files. See variable lslm$buffer-mask(5)le. 

    Unless stated otherwise, multiple flags may be specified at the same time 
    returning a combined character set or setting multiple properties for the 
    given "cCvaluecA" characters. 


cEcEEXAMPLE cEcA


    For many UNIX XTerm fonts the best characters to use for lslm$box-chars(5)le 
    (used in drawing lslmosd(2)le dialogs) lie in the range 0x0B to 0x19. For 
    example the vertical bar is 'cG\x19cA', the top left hand corner is 'cG\x0DcA' 
    etc. These characters are by default set to be not displayable or pokable 
    which renders them useless. They can be made displayable and pokable as 
    follows:- 
sB
        set-char-mask "dp" "\x19\x0D\x0C\x0E\x0B\x18\x15\x0F\x16\x17\x12" 

sA
    MicroEmacs variables have either 'cG$cA', 'cG#cA', 'cG%cA', 'cG:cA' or a 'cG.cA' character 
    prepended to their name, they may also contain a 'cG-cA' character in the body 
    of their name. It is preferable for these characters to be part of the 
    variable 'word' so commands like lslmforward-kill-word(2)le can work correctly. 
    This may be achieved by adding these characters to user set cD2cA and setting 
    the cDbuffer-maskcA variable to include set cD2cA, as follows: 
sB
        set-char-mask "2" "$#%:.-" 

        define-macro fhook-emf 
            set-variable $buffer-mask "luh2" 
            . 
            . 
        !emacro 

sA
    For the examples below only the following subset of characters will be 
    used:- 

        Character               ISO-8859-1    Windows OEM    PC Page 437 

        Capital A (A)           A             A              A 
        Capital A grave (`A)    \xC0          \xB7           No equivalent 
        Capital A acute ('A)    \xC1          \x90           No equivalent 
        Small a (a)             a             a              a 
        Small A grave (`a)      \xE0          \x85           \x85 
        Small A acute ('a)      \xE1          \xA0           \xA0 


    As the spell checker only operates in ISO-8859-1 (Latin 1), the character 
    font mapping (flag cDMcA) must be correctly setup for spell checking to 
    operate correctly. For ISO-8859-1 (ISO) this is an empty string as the 
    default mapping is correct, but for both Windows OEM (OEM) and PC Code 
    Page 437 (PC-437) the mappings should be set as follows:- 
sB
        ; OEM font mapping setup 
        set-char-mask "M" "\xC0\xB7\xC1\x90\xE0\x85\xE1\xA0" 
        ; PC-437 font mapping setup 
        set-char-mask "M" "\xC0A\xC1AAA\xE0\x85\xE1\xA0" 

sA
    As all the characters in ISO have equivalents in OEM, the mapping for OEM 
    is a simple ISO to OEM character list. However the missing capital cDAcA's in 
    PC-437 cause problems, for the command lslmcharset-iso-to-user(3)le it is 
    preferable for a mapping of cD`AcA to be given, otherwise the document being 
    converted may remain unreadable. Therefore a mapping of cD`AcA to cDAcA is given 
    to alleviate this problem, similarly cD'AcA is also mapped to cDAcA. 

    This leads to a similar problem with the conversion of PC-437 back to ISO 
    (the operation of command lslmcharset-user-to-iso(3)le). If only the mapping of 
    "cG\xC0A\xC1AcA" was given, the last mapping (cD'AcA to cDAcA) would also be the back 
    conversion for cDAcA, i.e. ALL cDAcA's would be converted back to cD'AcA's. To solve 
    this problem, a further seemingly pointless mapping of cDAcA to cDAcA is given to 
    correct the back conversion. 

    For languages which use these characters, the alphabetic character set 
    must be extended to include these characters for letter based commands 
    like lslmforward-word(2)le and lslmupper-case-word(2)le to operate correctly. The 
    addition of extra letters must achieve two goals, firstly to define 
    whether a character is a letter, enabling commands like cDforward-wordcA to 
    work correctly. The second is to provide an upper case to lower case 
    character mapping, enabling commands like cDupper-case-wordcA to work 
    correctly. This is achieved with a single call to cDset-char-maskcA using the 
    cDacA flag as follows:- 
sB
        set-char-mask "a" "\xC0\xE0\xC1\xE1" 

sA
    Note that this flag always expects a ISO-8859-1 character, this allows the 
    same map character list to be used regardless of the font set being used, 
    i.e. the above line can be used for ISO, OEM and PC-437 fonts. But it does 
    mean that the ISO to user font character mapping (flag cDMcA) must already 
    have been performed. 

    Similar problems are encountered with the cDMcA flag with font PC-437. This 
    problem is not immediately obvious because the mapping is given in ISO, 
    but when this is converted to PC-437, the mapping string becomes 
    "cGA\x85A\xA0cA". As can be seen, cDAcA is mapped last to cD'acA so an upper to lower 
    character operation will convert a cDAcA to cD'acA. A similar solution is used, a 
    further mapping of cDAcA to cDacA is given to correct the default case mapping for 
    both cDAcA and cDacA, i.e. the following line should always be used instead:- 
sB
        set-char-mask "a" "\xC0\xE0\xC1\xE1Aa" 

sA

cEcESEE ALSO cEcA


    lslmforward-word(2)le, lslm$buffer-mask(5)le, lslmscreen-poke(2)le, lslmspell(2)le, lslm$tabwidth(5)le. 

! 2 transpose-chars
! 2 transpose-lines
cEcENAME cEcA


|transpose-chars
    transpose-chars - Exchange (swap) adjacent characters 
|transpose-lines
    transpose-lines - Exchange (swap) adjacent lines 
$a


cEcESYNOPSIS cEcA


    cDtranspose-charscA (cDC-tcA) 
    cCncA cDtranspose-linescA (cDC-x C-tcA) 


cEcEDESCRIPTION cEcA


    cDtranspose-charscA exchanges (swaps) the current character under the cursor 
    with the previous character. cDtranspose-characterscA does not operate in 
    column 0 (since there is no previous character). If the cursor is at the 
    end of a line when the command is initiated then the cursor is moved to 
    the previous character and the operation performed from the new position. 

    cDtranspose-linescA swaps the next line for the current line and moves to the 
    next line, effectively retaining the same text position. Repeating this cCncA 
    times moves the current line cCncA lines down. 


cEcEEXAMPLE cEcA


    cDtranspose-charactercA performs the following operations (cursor at cD^cA):- 

        abcde  => acbde         [Middle of line] 
          ^         ^ 

        abcde  => abced         [End of line] 
             ^         ^ 


cEcESEE ALSO cEcA


    lslmsort-lines(2)le. 

! 2 undo
cEcENAME cEcA


    undo - Undo the last edit 
$a


cEcESYNOPSIS cEcA


    cCncA cDundocA (cDC-x ucA) 


cEcEDESCRIPTION cEcA


    cDundocA removes the last cCncA edits made to the current buffer. The lslmundo(2m)le 
    buffer mode must be enabled for this command to operate. 

    The undo information is retained up until the next save operation, at 
    which point the undo information is discarded. When editing large files 
    with gross changes then it is advisable to either disable undo mode, or 
    save frequently to flush the undo buffer, thereby keeping MicroEmacs '02 
    memory requirements reasonable (most UNIX users have restrictions on the 
    amount of memory that may be consumed by a single process. Windows is 
    restricted by the amount of virtual memory (or swap space)). 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmsave-buffer(2)le, lslmundo(2m)le. 

! 2 universal-argument
cEcENAME cEcA


    universal-argument - Set the command argument count 
$a


cEcESYNOPSIS cEcA


    cDuniversal-argumentcA (cDC-ucA) 


cEcEDESCRIPTION cEcA


    cDuniversal-argumentcA sets the argument number passed to a command to 4^cCncA (4 
    to the power of cCncA) where cCncA is the number of calls to cDuniversal-argumentcA, 
    e.g. the key sequence "cGC-uC-ncA" moves down 4 lines, "cGC-uC-uC-uC-ncA" moves 
    down 4*4*4 = 64 lines. 

    After invoking the cDuniversal-commandcA a 'cC-cA' character can be pressed to 
    negate the argument value, and an alternative numeric argument can be 
    entered using the 'cC0cA' to 'cC9cA' keys. 

    Invoking this command via lslmexecute-named-command(2)le or by a macro has no 
    effect. The command should be treated as a command key prefix (like 
    lslmprefix(2)le) in that it may be bound to only one key sequence which must be 
    a single key stroke. Re-binding this command to another key unbinds the 
    new key and also the current cDuniversal-argumentcA key. 

    The cDprefix 1cA key (by default bound to cGesccA) may also be used to enter a 
    numeric argument at the message line, e.g. "cGesc 1 0 C-fcA" will move forward 
    10 characters. 


cEcESEE ALSO cEcA


    lslmprefix(2)le. 

! 2 add-spell-rule
cEcENAME cEcA


    add-spell-rule - Add a new spelling rule to the dictionary 
$a


cEcESYNOPSIS cEcA


    cCncA cDadd-spell-rulecA [ "cCrule-lettercA" "cCbase-endingcA" "cCremovecA" "cCderive-endingcA" ] 


cEcEDESCRIPTION cEcA


    cDadd-spell-rulecA adds a new spelling rule to the speller. The rules 
    effectively define the prefix and suffix character replacements of words, 
    which is given an alphabetical identifier used within the speller , in 
    conjunction with the language dictionary. The letter conventions are 
    defined by the cDFree Software FoundationcA GNU cDispell(1)cA package. 

    cDadd-spell-rulecA is used in the MicroEmacs '02 dictionary initialization 
    files called cC<language>cAr.emf, e.g. cGamericar.erfcA, cGbritishr.erfcA supplied in 
    the MicroEmacs macros directory. 

    The command takes a single numeric argument cCncA to control the addition of a 
    rule to the speller, as follows:- 

    cG0cA cDadd-spell-rulecA 
        Removes all existing rules and re-initializes. This is, by convention, 
        explicitly called before instantiating a new set of rules. 

    cG-1cA cDadd-spell-rulecA "cCrule-lettercA" "cCbase-endingcA" "" "cCderiv-endingcA" 

    cG-2cA cDadd-spell-rulecA "cCrule-lettercA" "cCbase-endingcA" "" "cCderiv-endingcA" 
        Adds a prefix rule, an argument of -1 indicates that this prefix rule 
        cannot be used with a suffix rule. An argument of -2 indicates it can 
        be matched with any suffix rule which can be used with a prefix rule 
        (e.g. argument of 2). 

        "cCrule-lettercA" is any character in the range cGAcA-cGzcA except 'cG_cA', all rules 
        of the given letter must be a prefix rule of the same type (i.e. same 
        argument). The start of a base word must match the given "cCbase-endingcA" 
        regular expression string for the rule to be applied, the "cCremovecA" 
        string must be empty for a prefix and the "cCderiv-endingcA" is the prefix 
        string. Example, for the American language;- 

        cG-2 add-spell-rule "I" "" "" "in"cA ; As in disposed > indisposed 

        A prefix rule of type 'cGIcA' can be applied to any base word which has 
        rule 'cGIcA' enabled, and it prefixes "cGincA" to the word. 

    cG1cA cDadd-spell-rulecA "cCrule-lettercA" "cCbase-endingcA" "cCremovecA" "cCderiv-endingcA" 

    cG2cA cDadd-spell-rulecA "cCrule-lettercA" "cCbase-endingcA" "cCremovecA" "cCderiv-endingcA" 
        Add suffix rules. An argument of 1 indicates that this prefix rule 
        cannot be used with a prefix rule. An argument of 2 indicates it can 
        be matched with any prefix rule which can be used with a suffix rule 
        (i.e. argument of -2). 

        "cCrule-lettercA" is any character in the range cGAcA-cGzcA, all rules of the 
        given letter must be a suffix rule of the same type (i.e. same 
        argument). The end of a base word must match the given "cCbase-endingcA" 
        regular expression string for the rule to be applied, the "cCremovecA" 
        string must be a fixed string and the "cCderiv-endingcA" must also be a 
        fixed string which is appended to the base-word after "cCremovecA" has 
        been removed. Example, for the American language;- 
sB
            2 add-spell-rule "N" "e" "e" "ion"     ; As in create > creation 
            2 add-spell-rule "N" "y" "y" "ication" ; As in multiply > multiplication 
            2 add-spell-rule "N" "[^ey]" "" "en"   ; As in fall > fallen 

sA
        A suffix rule of type 'cGNcA' can be applied to any base word which has 
        rule 'cGNcA' enabled, and it can be used with prefixes, e.g. with rule;- 
sB
            -2 add-spell-rule "A" "" "" "re"       ; As in enter > reenter 

sA
        to derive "cCrecreationcA" from "cCcreatecA". A rule which cannot be used with 
        prefixes, i.e.: 
sB
            1 add-spell-rule "V" "e" "e" "ive"     ; As in create > creative 
            1 add-spell-rule "V" "[^e]" "" "ive"   ; As in prevent > preventive 

sA
        While some prefix words are legal, such as "cCrecreativecA" but some are 
        not, such as "cCcollectcA" where "cCrecollectcA" is correct, so is 
        "cCcollectivecA" but "cCrecollectivecA" is not. 


cESPECIAL RULES cA


    Following are special forms of add-spell-rule used for tuning the spell 
    support, note that an argument can not be given:- 

    cDadd-spell-rulecA "cC-cA" "<cCycA|cCncA>" 

        Enables and disables the acceptance of hyphens joining correct words. 
        By default the phrase "cGout-of-datecA" would be accepted in American even 
        though the phrase does not exist in the American dictionary. This is 
        because the three words making up the phrase are correct and by 
        default hyphens joining words are allowed. Some Latin language such as 
        Spanish do not use this concept so this feature can be disable. 

    cDadd-spell-rulecA "cC#cA" "cCscorecA" 

        Sets the maximum allowed error score when creating a spelling guess 
        list. When comparing a dictionary word with the user supplied word, 
        cDspellcA checks for differences, each difference or error is scored in 
        the range of 20 to 27 points, once the maximum allowed score has been 
        exceeded the word is ignored. The default guess error score is 60, 
        allowing for 2 errors. 

    cDadd-spell-rulecA "cC*cA" "cCregexcA" 

        Adds a correct word in the form of a lsRegularExpressions(2)lmregexle if a word being spell 
        checked is completely matched by the cDregexcA the word is deemed to be 
        correct. For example, the following rule can be used to make the 
        spell-checker allow all hex numbers: 
sB
        add-spell-rule "*" "0[xX][[:xdigit:]]+" 

sA
    This will completely match the words "cG0x0cA", "cG0xffcA" etc but not "cG0x00zcA" as 
    the whole word is not matched, only the first 4 letters. 


cEcENOTES cEcA


    The format of the dictionary is a list of base words with each word having 
    a list of rules which can be applied to that word. Therefore the list of 
    words and the rules used for them are linked e.g. 

        aback 
        abaft 
        abandon/DGRS 
        abandonment/S 
        abase/DGRS 
        abasement/S 
        abash/DGS 
        abashed/U 
        abate/DGRS 


    where the "cG/...cA" is the valid list of rules for that word. 

    The '_' character is used to separate different rule lists for a single 
    word. 

    The format of the dictionary word list and the rule list is compatible 
    with cDispell(1)cA. 


cEcESEE ALSO cEcA


    lslmadd-dictionary(2)le, lslmspell(2)le lslmspell-buffer(3)le, lslmspell-word(3)le, cDispell(1)cA. 

! 2 screen-update
cEcENAME cEcA


    screen-update - Force screen update 
$a


cEcESYNOPSIS cEcA


    cCncA cDscreen-updatecA (cDredrawcA) 


cEcEDESCRIPTION cEcA


    cDscreen-updatecA updates the current screen, usually used in macros. The 
    argument cCncA can be used to change the behaviour of this command as follows: 

    cG-vecA 
        Disables the next -cCncA screen updates, i.e. if cCncA is cG-1cA then the next 
        time the screen needs to be redrawn nothing will happen. 

    cG0cA 
        Resets the screen update disable count to zero, useful to remember 
        when the the disable feature has been used incorrectly. 

    cG1cA 
        Full screen update (default), the screen is completely cleared and 
        redrawn (as if garbled). 

    cG2cA 
        Partial screen update, only the parts of the screen which require 
        updating are redrawn. 

    cG3cA 
        No screen redraw, only window variables are up-dated. This feature is 
        provided for macros which manipulate the screen view and need to know 
        where the cursor is in the window without redrawing the screen (which 
        may cause unwanted flickering). Note that as the screen is not redrawn 
        not all variables may have the correct value, for example the frame 
        store variable lslm@fs(4)le could be out of date. 


cEcEEXAMPLES cEcA


    The following macro demonstrates the problems encountered when trying to 
    use screen variables in macros after the current position has changed. The 
    first value printed is the starting cursor Y position and the next value 
    should be one less than the first value due to the call to 
    lslmbackward-line(2)le. But it is the same as the first because the screen (and 
    its variables) have not been updated. The subsequent call to screen-update 
    ensures that the third value is the correct one although by giving it an 
    argument of 3 the screen is not visibly updated thus avoiding any annoying 
    screen flicker: 
sB
        define-macro test-screen-update 
            set-variable #l0 $cursor-y 
            backward-line 
            set-variable #l1 $cursor-y 
            3 screen-update 
            set-variable #l2 $cursor-y 
            forward-line 
            ml-write &spr "%d %d %d" #l0 #l1 #l2 
        !emacro 

sA

cEcENOTES cEcA


    Every time the screen requires updating, MicroEmacs executes the cCredrawcA 
    key, it is similar in mechanism to the user pressing cCC-lcA to refresh the 
    screen. The user can therefore re-bind the cCredrawcA key to another command 
    or macro, thereby allowing the user complete control of what is displayed. 
    For example if cCredrawcA was bound to lslmvoid(2)le the screen would not be 
    up-dated (cDNotecA: this is difficult to get out of and may require MicroEmacs 
    to be killed). 

    This feature is often exploited by macros which take control of the input 
    and output, such macros include lslmgdiff(3)le, lslmMetris(3)le, and lslmMahjongg(3)le. 


cEcESEE ALSO cEcA


    lslmrecenter(2)le, lslmscreen-poke(2)le. 

! 2 view-file
cEcENAME cEcA


    view-file - Load a file read only 
$a


cEcESYNOPSIS cEcA


    cCncA cDview-filecA "cCfile-namecA" (cDC-x C-vcA) 


cEcEDESCRIPTION cEcA


    cDview-filecA is like lslmfind-file(2)le, and either finds the file in a buffer, or 
    creates a new buffer and reads the file in. A new file is left in lslmview(2m)le 
    mode if the file was found (i.e. cannot be edited). 

    The numeric argument cCncA can be used to modify the default behaviour of the 
    command, where the bits are defined as follows: 

    cD0x01cA 
        If the file does not exist and this bit is not set the command fails 
        at this point. If the file does not exist and this bit is set (or no 
        argument is specified as the default argument is cG1cA) then a new empty 
        buffer is created with the given file name, saving the buffer 
        subsequently creates a new file. 

    cD0x02cA 
        If this bit is set the file will be loaded with lslmbinary(2m)le mode 
        enabled. See help on cDbinarycA mode for more information on editing 
        binary data files. 

    cD0x04cA 
        If this bit is set the file will be loaded with lslmcrypt(2m)le mode 
        enabled. See help on cDcryptcA mode for more information on editing 
        encrypted files. 

    cD0x08cA 
        If this bit is set the file will be loaded with lslmrbin(2m)le mode enabled. 
        See help on cDrbincA mode for more information on efficient editing of 
        binary data files. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmfind-file(2)le, lslmread-file(2)le, lslmview(2m)le, lslmbinary(2m)le, 
    lslmcrypt(2m)le, lslmrbin(2m)le. 

! 2 void
cEcENAME cEcA


    void - Null command 
$a


cEcESYNOPSIS cEcA


    cCncA cDvoidcA 


cEcEDESCRIPTION cEcA


    cDvoidcA does nothing except return cGFALSEcA if the given argument cCncA is zero, 
    cGTRUEcA otherwise. Used to bind any frequently miss hit keys to something 
    harmless. 


cEcESEE ALSO cEcA


    lslmglobal-bind-key(2)le. 

! 2 wrap-word
cEcENAME cEcA


    wrap-word - Wrap word onto next line 
$a


cEcESYNOPSIS cEcA


    cDwrap-wordcA 


cEcEDESCRIPTION cEcA


    cDwrap-wordcA wraps the current word onto the next line, justifying the 
    current line if the lslmjustify(2m)le mode is enabled. The justification method 
    is defined by lslm$fill-mode(5)le. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmfill-paragraph(2)le, lslm$fill-mode(5)le, lslmjustify(2m)le. 

! 2 write-buffer
cEcENAME cEcA


    write-buffer - Write contents of buffer to named (new) file 
$a


cEcESYNOPSIS cEcA


    cCncA cDwrite-buffercA "cCfile-namecA" (cDC-x C-wcA) 


cEcEDESCRIPTION cEcA


    cDwrite-buffercA is used to write the contents of the buffer to a NEW file, 
    use lslmsave-buffer(2)le if the buffer is to be written to the existing file 
    already associated with the buffer. 

    cDwrite-buffercA writes the contents of the current buffer to the named file 
    cCfile-namecA. The action of the write also changes the file name associated 
    with the current buffer to the new file name. 

    Unlike lslmappend-buffer(2)le, cDwrite-buffercA always replaces an existing file and 
    the new file inherits the buffers file characteristics instead of the old 
    file's. 

    On writing the file, if lslmtime(2m)le mode is enabled then the ls$timestamp(5)lmtime stampln
    lnstringle is searched for in the file and modified if located, to reflect the 
    modification date and time. 

    If the buffer contains a lslmnarrow(2m)le it will automatically be removed 
    before saving so that the whole buffer is saved and restored when saving 
    is complete 

    If lslmbackup(2m)le mode is enabled and the buffer is associated with a 
    different file (compared with cCfile-namecA) then any ls$auto-time(5)lmautomatic savele copies of 
    the file associated with the cCbuffercA are deleted. 

    The argument cCncA can be used to change the default behavior of write-buffer 
    described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Enables validity checks (default). These include a check that the 
        proposed file does not already exist, if so confirmation of writing is 
        requested from the user. Also MicroEmacs '02 checks all other current 
        buffers for one with the proposed file name, if found, again 
        confirmation is requested. Without this flag the command will always 
        succeed wherever possible. 

    cD0x02cA 
        Disables the expansion of any narrows (see lslmnarrow-buffer(2)le) before 
        saving the buffer. 


cEcENOTES cEcA


    lslmundo(2)le information is discarded when the file is written. 


cEcESEE ALSO cEcA


    lslm$auto-time(5)le, lslmbackup(2m)le, lslmtime(2m)le, lslmbuffer-mode(2)le, lslmfile-attrib(3)le, 
    lslmchange-file-name(2)le, lslmsave-buffer(2)le, lslmappend-buffer(2)le. 

! 2 save-history
cEcENAME cEcA


    save-history - Write history information to history file 
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-historycA "cChist-filecA" 


cEcEDESCRIPTION cEcA


    cDsave-historycA writes out MicroEmacs '02's current history information into 
    the given history file. 

    The command lslmread-history(2)le can set a default history file in which case 
    the history is automatically written out to this file if an argument of 
    zero is given; the user is not prompted for a file. MicroEmacs '02 
    automatically tries to write the default history whenever it is exited. 


cEcENOTES cEcA


    The history information is saved in a registry format file (see lslmerf(8)le). 
    Reference should be made to the notes included in lslmerf(8)le as to how the 
    history file may be edited and effected in the same MicroEmacs '02 
    session. 


cEcESEE ALSO cEcA


    lslmerf(8)le, lslmread-history(2)le. 

! 2 ml-write
cEcENAME cEcA


    ml-write - Write message on message line 
$a


cEcESYNOPSIS cEcA


    cCncA cDml-writecA "cCmessagecA" 


cEcEDESCRIPTION cEcA


    cDml-writecA writes the given cCmessagecA to the message line. If a positive 
    argument cCncA is given then there will be an cCncA millisecond uninterruptible 
    delay, giving the user time to see the message. 

    A call to cDml-writecA from a callback macro can erase a message line which is 
    currently being used (to enter a buffer name say). A call to lslmml-clear(2)le 
    restores the previous message-line. 


cEcEEXAMPLE cEcA


    The following call displays a message on the message-line with a fixed 2 
    second pause: 
sB
        2000 ml-write "Hello World!" 

sA

cEcESEE ALSO cEcA


    lslmml-clear(2)le, lslmcommand-wait(2)le, lslmcreate-callback(2)le. 

! 2 yank
cEcENAME cEcA


    yank - Paste (copy) kill buffer contents into buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDyankcA (cDC-ycA) 


cEcEDESCRIPTION cEcA


    When a non negative argument is supplied to cDyankcA, the command copies the 
    contents of the kill buffer cCncA times into the current buffer at the current 
    cursor position. This does not clear the kill buffer, and therefore may be 
    used to make multiple copies of a section of text. On windowing systems 
    which support clip-boards, such as windows and X-terms, MicroEmacs will 
    also cut to and paste from the global clip-board. 

    If cCyankcA is IMMEDIATELY followed by a lslmreyank(2)le then the cCyankedcA text is 
    replaced by text of the next entry in the kill ring. (another cDreyankcA 
    replaces the text with the previous reyank text and so on). 

    If an -ve argument is given, cDyankcA removes the last 0-cCncA items from the kill 
    ring. 

    Text is inserted into the kill buffer by one of the following commands:- 

        lslmbackward-kill-word(2)le, lslmcopy-region(2)le, lslmforward-kill-word(2)le, 
        lslmkill-line(2)le, lslmkill-paragraph(2)le, lslmkill-region(2)le, 
        lslmforward-delete-char(2)le, lslmbackward-delete-char(2)le. 

    All the above commands (except cDcopy-regioncA) cut text out of the buffer, 
    the last 2 commands require the lslmletter(2m)le mode enabled to add the text to 
    the kill buffer. If any of these commands are executed immediately after 
    any other (including itself) or the lslm@cl(4)le variable is set to one of these 
    command, the new kill text is appended to the last kill buffer text. 


cEcENOTES cEcA


    Windowing systems such as X-Windows and Microsoft Windows utilize a global 
    windowing kill buffer allowing data to be moved between windowing 
    applications (cCcut buffercA and cCclipboardcA, respectively). Within these 
    environments MicroEmacs '02 automatically interacts with the windowing 
    systems kill buffer, the last MicroEmacs '02 kill buffer entry is 
    immediately available for a cCpastecA operation into another application 
    (regardless of how it was inserted into the kill buffer). Conversely, data 
    placed in the windowing kill buffer is available to MicroEmacs '02, via 
    cDyankcA, until a new item has been inserted into the kill buffer (the data 
    may still be available via lslmreyank(2)le). 


cEcEEXAMPLE cEcA


    The following example is a basic macro code implementation of the 
    lslmtranspose-lines(2)le command, 
sB
        beginning-of-line 
        kill-line 
        forward-line 
        yank 
        -1 yank 
        backward-line 

sA
    Note that similar to cDtranspose-linescA it does not leave the moved line in 
    the kill buffer, effectively tidying up after itself. 


cEcESEE ALSO cEcA


    lslmyank-rectangle(2)le, lslmcopy-region(2)le, lslmkill-region(2)le, lslmletter(2m)le, lslmreyank(2)le, 
    lslm@y(4)le, lslm@cc(4)le. 

! 2 define-macro-file
cEcENAME cEcA


    define-macro-file - Define macro file location 
$a


cEcESYNOPSIS cEcA


    cDdefine-macro-filecA "cCfile-namecA" ["cCmacro-namecA" "cCmacro2-namecA" ...] 


cEcEDESCRIPTION cEcA


    Macros are loaded as late as possible using an on-demand mechanism, this 
    speeds up the load time of MicroEmacs '02, it also keeps the startup file 
    clean since macros are not defined within the start-up file. Only when the 
    user first executes a macro defined via cDdefine-macro-filecA is the file 
    loaded, the macro becomes defined and is executed. Subsequent calls to the 
    macro will not reload the file as the macro will now be fully defined. 

    cDdefine-macro-filecA binds macros (cCmacro-namecA ...) to a file name 
    (cCfile-namecA). This operation informs MicroEmacs '02 which file should be 
    loaded when cCmacro-namecA is first executed. The cCmacro-namecA arguments may be 
    omitted if the file contains only one exported macro which has the same 
    name as cCfile-namecA. 

    Alternatively the macro file may contain many macros all of which can be 
    defined by a single call to cDdefine-macro-filecA, listing all macros on the 
    same line after the cCfile-namecA. If a cCmacro-namecA is given then the default 
    macro cCfile-namecA is not created, if a macro of that name does exist it must 
    be added to the cCmacro-namecA list. 


cEcEEXAMPLE cEcA


    The following definitions are found in the cGme.emfcA start-up file:- 
sB
        0 define-macro-file utils ascii-time regex-forward regex-backward 
        define-macro-file format clean sort-lines-ignore-case tabs-to-spaces ... 
        define-macro-file cvs cvs cvs-state cvs-update cvs-commit cvs-log ... 
        define-macro-file abbrev expand-abbrev-handle spell-complete-word ... 
        define-macro-file misc symbol check-line-length alarm time 
        define-macro-file search replace-all-string query-replace-all-string 
        define-macro-file tools compile grep rgrep which diff diff-changes 
        define-macro-file hkdirlst file-browser file-browser-close 
        define-macro-file comment comment-line uncomment-line comment-to-end-of-line 
        define-macro-file spell spell-word spell-buffer spell-edit-word find-word 
        define-macro-file games Metris Patience Triangle Mahjongg Match-It 
        define-macro-file buffstp buffer-setup buffer-help buffer-tool 
        define-macro-file fattrib file-attrib 
        define-macro-file osd osd-main 
        define-macro-file gdiff 
        define-macro-file calc 
        define-macro-file draw 

sA
    Hilighting a number of entries as examples; macro file cDcalccA is defined 
    with no macro definition, the macro is assumed to be cDcalccA. The file 
    cDtools.emfcA contains multiple macros cDcompilecA, cDgrepcA, cDdiffcA and cDdiff-changescA; 
    all can be defined by a single cDdefine-macro-filecA entry. 


cEcENOTES cEcA


        * Macro files are searched for in the current directory and along the 
          lslm$search-path(5)le. 
        * The macro file is not loaded unless a binding has been defined using 
          cDdefine-macro-filecA. 
        * Any other macros that exist in the cCfile-namecA macro file become 
          defined when the entry point macro is loaded and are available for 
          use. This is potentially useful as a single cCentrycA macro may be 
          defined using cDdefine-macro-filecA, when invoked other helper macros 
          become available. 


cEcESEE ALSO cEcA


    lslmadd-file-hook(2)le, lslmdefine-macro(2)le, lslm$search-path(5)le, lslmstart-up(3)le. 

! 2 about
cEcENAME cEcA


    about - Information About MicroEmacs '02 
$a


cEcESYNOPSIS cEcA


    cDaboutcA 


cEcEDESCRIPTION cEcA


    cDaboutcA displays information about the current MicroEmacs '02 editing 
    session and includes the following information:- 

        * Version number and date information for MicroEmacs '02. 
        * Global status information including the number of active buffers and 
          global mode status information. 
        * Current buffer status information; buffer modes and buffer size 
          information. 


cEcEEXAMPLE cEcA


    The following is an example output from cDaboutcA. 

        MicroEmacs '98 - Date 1/1/98 

        Global Status: 
          # buffers : 21 

          Modes on  : auto backup crlf exact magic quiet tab undo 
          Modes off : binary cmode crypt ctrlz del dir edit hide indent 
                      justify letter line lock nact narrow over pipe rbin 
                      save time usr1 usr2 usr3 usr4 usr5 usr6 usr7 usr8 
                      view wrap 

        Current Buffer Status: 
          Buffer    : m2cmd148.2 
          File name : c:/emacsdoc/m2cmd148.2 

          Lines     : Total     34, Current     27 
          Characters: Total    759, Current    683 

          Modes on  : auto backup edit exact indent justify magic quiet 
                      tab time undo wrap 
          Modes off : binary cmode crlf crypt ctrlz del dir hide letter 
                      line lock nact narrow over pipe save rbin usr1 usr2 
                      usr3 usr4 usr5 usr6 usr7 usr8 view 


cEcESEE ALSO cEcA


    lslmdescribe-bindings(2)le, lslmlist-buffers(2)le. 

! 2 scroll-left
! 2 scroll-right
cEcENAME cEcA


|scroll-left
    scroll-left - Move the window left (scrolling) 
|scroll-right
    scroll-right - Move the window right (scrolling) 
$a


cEcESYNOPSIS cEcA


    cCncA cDscroll-leftcA (cDC-x <cA) 
    cCncA cDscroll-rightcA (cDC-x >cA) 


cEcEDESCRIPTION cEcA


    cDscroll-leftcA moves the window in current buffer left by 1 screen width. If 
    an argument cCncA is supplied then the resolution of movement is specified in 
    characters relative to the current displacement. Moving the window in the 
    current buffer left by cCncA characters (that is if the current left-hand 
    margin of the screen is column 0, the left hand margin becomes column cCncA). 

    cDscroll-rightcA moves the window in current buffer right by 1 screen width. 
    If an argument cCncA is supplied then the resolution of movement is specified 
    in characters relative to the current displacement. 

    The ends of the lines of a scrolled screen are delimited with a dollar (cD$cA) 
    character indicating that the text continues. When no scroll is in effect 
    the left hand margin of the screen does not show the cD$cA symbol. i.e. The 
    line cGThis text is scrolled on this linecA with a current scroll offset of 2 
    in a 22 column window would appear as follows: 

                 22 
        |<------------------->| 

        |$s text is scrolled $| 


    The amount of scroll (cCncA) is effectively unlimited, it is possible to 
    scroll all of the text in a buffer out of the window, when only cD$cA's appear 
    in the left margin, in the last highlighting color of the line (blank 
    lines always remain blank and are not delimited with a cD$cA). Text on the 
    current line is handled according to the value of lslm$scroll(5)le as follows: 

    cD$scroll 0cA 
        The current line ONLY is scrolled (about the current scroll position) 
        to enable the current buffers cursor position to be viewed. To enable 
        the user to determine where the current line is in relation to the 
        scrolled lines then the first character of the current line is 
        interpreted as follows:- 

        cDAll of user text appearscA 

            |$f line of te$| 
            |At start of l$| 
            |$f line of te$| 


            Surrounding lines commence with "$" indicates at the start of the 
            line. 

        cD$ in column 0cA 

            |$f line of te$| 
            |$f line of te$| 
            |$f line of te$| 


            Text column is the same as the surrounding text i.e. the line and 
            window scroll are the same. 

        cD> Left of scroll positioncA 

            |$f line of te$| 
            |>f line of te$| 
            |$f line of te$| 


            The current line is to the left of the scrolled position. 
            lsforward-char(2)lmforward-charle (i.e. interpret as cG-->cA indicating the direction of 
            travel) moves the cursor, and therefore the line, towards the 
            natural scroll position (cD$cA in column). 

        cD< Right of scroll positioncA 

            |$f line of te$| 
            |<f line of te$| 
            |$f line of te$| 


            The current line is to the right of the scrolled position. 
            lsforward-char(2)lmbackward-charle (i.e. interpret as cG<--cA indicating the direction of 
            travel) moves the cursor, and therefore the line, towards the 
            natural scroll position (cD$cA in column). 

    cD$scroll 1cA 
        The position of the cursor on the line determines the scrolled 
        position. In this case all lines in the window are scrolled to ensure 
        that the cursor is always visible. This mode is only useful when 
        dealing with large blocks of text whose line lengths do not vary. 


cEcENOTES cEcA


    The scrolling is an attribute of the WINDOW and not the BUFFER. If the 
    window is closed, or contents swapped to a different buffer then the 
    scroll setting is reset for the next buffer. A return to the previous 
    buffer does not restore the scroll setting. The only case where scrolling 
    is inherited is when a window is split (see lslmsplit-window-vertically(2)le). 

    When binding cDscroll-leftcA to the keyboard then it is important to note that 
    when no argument is specified the resolution is cCscreen-widthcA's. A key 
    binding would operate on character multiples, hence the command should be 
    bound with a numeric argument to perform the perform the keyboard action. 
    e.g. 
sB
        1 global-bind-key scroll-left  "A-left" 
        1 global-bind-key scroll-right "A-right" 

sA
    To move 5 columns on a key stroke, for an accelerated scroll, then the 
    binding may be re-written as:- 
sB
        5 global-bind-key scroll-left  "A-left" 
        5 global-bind-key scroll-right "A-right" 

sA

cEcESEE ALSO cEcA


    lslm$scroll(5)le, lslmscroll-up(2)le, lslmscroll-down(2)le, lslm$window-x-scroll(5)le. 

! 2 save-some-buffers
cEcENAME cEcA


    save-some-buffers - Save contents of all changed buffers to file (with 
    query) 
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-some-bufferscA 


cEcEDESCRIPTION cEcA


    cDsave-some-bufferscA cycles through all visible buffers (buffers without mode 
    lslmhide(2m)le set) and attempts to save all modified ones, writing the contents 
    back to the file from where it was read. For each buffer that has been 
    modified the user is prompted to save the buffer, a value of cDycA initiates a 
    save for the buffer, cDncA skips the buffer. 

    The argument cCncA can be used to change the default behavior of 
    save-some-buffers described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Enables the user prompt before the buffer is saved (default). If this 
        flag is not supplied then all modified visible buffers will be 
        written. 


cEcESEE ALSO cEcA


    lslmsave-buffer(2)le, lslmsave-buffers-exit-emacs(2)le, lslmwrite-buffer(2)le, lslmhide(2m)le. 

! 2 split-window-horizontally
cEcENAME cEcA


    split-window-horizontally - Split current window into two (horizontally) 
$a


cEcESYNOPSIS cEcA


    cCncA cDsplit-window-horizontallycA (cDC-x 5cA) 


cEcEDESCRIPTION cEcA


    cDsplit-window-horizontallycA splits the current window horizontally into two 
    near equal windows, each displaying the buffer displayed by the original 
    window. 

    A numeric argument cCncA of 1 forces the left window to be the new current 
    window, and an argument of 2 forces the right window to be the new current 
    window. The default when omitted is the left window. 


cEcESEE ALSO cEcA


    lslm$scroll-bar(5)le, lslm$scroll-bar-scheme(5)le, lslm$window-chars(5)le, 
    lslmgrow-window-horizontally(2)le, lslmsplit-window-vertically(2)le. 

! 2 grow-window-horizontally
! 2 shrink-window-horizontally
! 2 resize-window-horizontally
cEcENAME cEcA


|grow-window-horizontally
    grow-window-horizontally - Enlarge current window horizontally (relative) 
|shrink-window-horizontally
    shrink-window-horizontally - Shrink current window horizontally (relative) 
|resize-window-horizontally
    resize-window-horizontally - Resize current window horizontally (absolute) 
$a


cEcESYNOPSIS cEcA


    cCncA cDgrow-window-horizontallycA 
    cCncA cDshrink-window-horizontallycA 
    cCncA cDresize-window-horizontallycA 


cEcEDESCRIPTION cEcA


    cDgrow-window-horizontallycA enlarges the current window by cCncA number of 
    columns (1 by default). If cCncA is negative then the window is shrunk. 

    cDshrink-window-horizontallycA shrinks the current window by cCncA number of 
    columns (1 by default). If cCncA is negative then the window is enlarged. 

    cDresize-window-horizontallycA change the size of the current window to cCncA 
    columns, if possible. i.e. resize window is not a relative displacement. 

    Growth is performed by consuming space from the next horizontal window to 
    the right of the current window, except when the window is on the 
    right-hand edge of the screen when space is consumed from the left. 


cEcEEXAMPLE cEcA


    Refer to cGmouse.ehfcA for an example of window growth using the mouse to 
    manipulate the size of the windows. 


cEcESEE ALSO cEcA


    lslm$mouse-pos(5)le, lslm$scroll-bar(5)le, lslm$window-chars(5)le, 
    lslmgrow-window-vertically(2)le, lslmresize-all-windows(2)le, 
    lslmsplit-window-horizontally(2)le. 

! 2 resize-all-windows
cEcENAME cEcA


    resize-all-windows - Automatically resize the windows 
$a


cEcESYNOPSIS cEcA


    cCncA cDresize-all-windowscA 


cEcEDESCRIPTION cEcA


    cDresize-all-windowscA performs an automatic layout of the windows on the 
    screen, reorganizing the windows such that each window has an equal amount 
    of space. The argument cCncA determines which axes reorganization is performed 
    in. 

        * A +ve argument reorganizes the windows vertically, leaving the 
          horizontal arrangement as is. 
        * A -ve argument rearranges the windows horizontally, leaving the 
          vertical arrangement as is. 
        * An argument of zero performs no vertical or horizontal arrangement. 
        * No argument re-arranges both the vertical and horizontal window 
          layout. 


cEcESEE ALSO cEcA


    lslmresize-window-vertically(2)le, lslmresize-window-horizontally(2)le, 
    lslmsplit-window-vertically(2)le. 

! 2 mark-registry
cEcENAME cEcA


    mark-registry - Modify the operating mode of a registry node 


cEcESYNOPSIS cEcA


    cCncA cDmark-registrycA "cCrootcA" "cCmodecA" 


cEcEDESCRIPTION cEcA


    cDmark-registrycA modifies the cCmodecA of a registry node cCrootcA. If an argument cCncA 
    is supplied then the cCncAth register node down from cDrootcA (as viewed from 
    lslmlist-registry(2)le output) is modified instead. The cCmodecA is string 
    specifying the modes, each mode is represented by a character. Lower case 
    characters add a mode, upper case characters delete a mode. The modes are 
    defined as:- 

    cD?cA - Query Name 
        Returns the full name, including path, of the given registry node in 
        the variable lslm$result(5)le. This does not alter the registry. 

    cD!cA - Hide Value 
        Hides the value of the given registry node, i.e. its value will not be 
        displayed in the output of lslmlist-registry(2)le. Once set, this mode 
        cannot be removed. 

    cDacA - Autosave 
        Automatically saves the registry when it is deleted or unloaded from 
        the registry. The user is not prompted for a save. 

    cDbcA - Backup 
        Automatically performs a backup of the registry file whenever a save 
        operation is performed. 

    cDccA - Create 
        If the registry file cannot be loaded then the cCrootcA node is created 
        and the invocation succeeds. If this mode is omitted then the call 
        fails if the cCfilecA cannot be found. 

    cDdcA - Discard 
        Marks the registry as discardable. This is typically used for 
        registries that are not saved. 

    cDfcA - File 
        The registry node is marked as a file root, the value must be set to 
        the registry file name. 

    cDgcA - Get Modes 
        Returns the list of modes currently set on the given registry node in 
        the variable lslm$result(5)le. This does not alter the registry. 

    cDhcA - Hidden 
        The registry node is marked as cCHiddencA, i.e. its children will not be 
        shown in lslmlist-registry(2)le output. 

    cDucA - Updated 
        Marks the registry as modified. The modified bit is removed when the 
        registry file is saved. If the modified bit is applied to a registry 
        node the user will be prompted to save the registry when it is deleted 
        (or it will be automatically saved when the cCAutosavecA mode is used). 

    Multiple modes may be applied. 


cEcEEXAMPLE cEcA


    A history registry can be hidden with the following invocation:- 
sB
        mark-registry "/history" "h" 

sA
    It could then be made visible again using:- 
sB
        mark-registry "/history" "H" 

sA

cEcEBUGS cEcA


    At exit only registry nodes attached to the root are saved. 


cEcEDIAGNOSTICS cEcA


    cDmark-registrycA fails if cCrootcA does not exist. 


cEcESEE ALSO cEcA


    lslmget-registry(2)le, lslmlist-registry(2)le, lslmread-registry(2)le, lslmset-registry(2)le, 
    lslmerf(8)le. 

! 2 delete-some-buffers
cEcENAME cEcA


    delete-some-buffers - Delete buffers with query 
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-some-bufferscA 


cEcEDESCRIPTION cEcA


    cDdelete-some-bufferscA cycles through all visible buffers (buffers without 
    mode lslmhide(2m)le set) and prompts the user [cDycA/cDncA] as to whether the buffer 
    should be deleted. A cDycA response deletes the buffer, a cDncA response retains 
    the buffer. 

    If a cDycA response is given, the buffer has been edited, and its name does 
    not start with a 'cD*cA' then the user is prompted as to whether the changes 
    should be discarded. Also if the buffer has an active process running in 
    it then confirmation is sort from the user before the process is killed. 

    The argument cCncA can be used to change the default behavior of 
    delete-some-buffers described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Enables all checks (default). These include the initial y/n prompt on 
        each buffer, the buffer has not been modified check, if so the user is 
        prompted. Also if a process is running then user must confirm that the 
        process can be killed. If this flag is not supplied then all visible 
        buffers are killed without any user prompts (useful in macros). 


cEcESEE ALSO cEcA


    lslmdelete-buffer(2)le, lslmnext-buffer(2)le, lslmhide(2m)le. 

! 2 insert-tab
cEcENAME cEcA


    insert-tab - Insert tab(s) into current buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDinsert-tabcA (cDC-icA) 


cEcEDESCRIPTION cEcA


    cDinsert-tabcA inserts cCncA tab characters at the current cursor position, moving 
    the cursor. The command is not affected by the lslmtab(2m)le mode as it always 
    inserts literal tab characters. 


cEcESEE ALSO cEcA


    lslminsert-space(2)le, lslminsert-string(2)le, lslminsert-newline(2)le, lslmtab(2)le, 
    lslmnormal-tab(3)le, lslmtab(2m)le. 

! 2 read-registry
cEcENAME cEcA


    read-registry - Read in a registry definition file 
$a


cEcESYNOPSIS cEcA


    cDread-registrycA "cCrootcA" "cCfilecA" "cCmodecA" 


cEcEDESCRIPTION cEcA


    cDread-registrycA loads a registry file lslmerf(8)le into the internal registry 
    memory, where the information may be queried via the registry macro 
    commands. The arguments are defined as follows:- 

    cCrootcA 
        The root node in the registry to into which the registry contents are 
        attached. The root name is limited to 32 characters in length and is 
        specified without a leading forward slash 'cG/cA'. The node cCrootcA is 
        created at the root of the registry. 

    cCfilecA 
        The name of the registry file lslmerf(8)le to load. This may be an absolute, 
        relative or cG$MEPATHcA specified file; typically it is located on 
        cG$MEPATHcA. 

    cCmodecA 
        The cCmodecA is string specifying the registry node loading and saving 
        modes, each mode is represented by a character. Lower case characters 
        add a mode, upper case characters delete a mode. The modes are defined 
        as follows:- 

        cDacA - Autosave 
            Automatically saves the registry when it is deleted or unloaded 
            from the registry. The user is not prompted for a save. 

        cDbcA - Backup 
            Automatically performs a backup of the registry file whenever a 
            save operation is performed. 

        cDccA - Create 
            If the registry file cannot be loaded then the cCrootcA node is 
            created and the invocation succeeds. If this mode is omitted then 
            the call fails if the cCfilecA cannot be found. 

        cDdcA - Discard 
            Marks the registry as discardable. This is typically used for 
            registries that are not saved. 

        cDrcA - Reload 
            If the registry node already exists then it is deleted and 
            reloaded, see also the merge flag (cDmcA). By default, when both the cDrcA 
            and cDmcA flags are omitted and the registry node already exists the 
            read operation is not performed and the existing node is used. 

        cDmcA - Merge 
            The registry file is merged with the contents of any existing 
            registry node. (i.e. the existing registry tree nodes are not 
            deleted if they already exist). See also the reload flag (cDrcA). 

        cDhcA - Hidden 
            The registry node is created in the cCHiddencA state. (i.e. children 
            will not be shown in lslmlist-registry(2)le output). 

        cDucA - Updated 
            Marks the registry as modified. The modified bit is removed when 
            the registry file is saved. If the modified bit is applied to a 
            registry node the user will be prompted to save the registry when 
            it is deleted (or it will be automatically saved when the cCAutosavecA 
            mode is used). 

        Multiple modes may be applied. 


cEcEEXAMPLE cEcA


    The following example is a typical call made from a macro using a registry 
    file where the user may edit the registry file. In this case this a reload 
    of the registry is forced to ensure that the most up-to-date contents are 
    retrieved. Note that the name of the registry file is actually retrieved 
    from the cChistorycA registry. 
sB
        set-variable #l1 &reg "/history" "address" $MENAME 
        !if &seq &set #l0 &find #l1 ".ab" "ERROR" 
            set-variable #l0 &reg "/" "history" "" 
            set-variable #l0 &spr "%s%s.ab" &lef #l0 &rsin "/" #l0 #l1 
        !endif 
        read-registry "AddressBook" #l0 "rc" 

sA

cEcEBUGS cEcA


    At exit only registry nodes attached to the root are saved. 


cEcESEE ALSO cEcA


    lslmsave-registry(2)le, lslmlist-registry(2)le, lslmmark-registry(2)le, lslmerf(8)le. 

! 2 file-op
cEcENAME cEcA


    file-op - File system operations command 
$a


cEcESYNOPSIS cEcA


    cCncA cDfile-opcA [ ( [ "cCfrom-filecA" "cCto-filecA" ] ) | 
        ( ["cCdelete-filecA"] ) | ( ["cCdir-namecA"] ) ] 


cEcEDESCRIPTION cEcA


    cDfile-opcA can be used to perform numerous file system operations. The given 
    argument cCncA must be used to determine the required operation, the value is 
    a bit based flag denoting the operation as follows: 

    cD0x010cA 
        Log-off and close down the current ftp connect (not a file system 
        operation but functionality was required and it had to go somewhere). 

    cD0x020cA 
        When this bit is set the command functionality is changed to 
        delete-file, the single argument cCdelete-filecA is deleted. 

    cD0x040cA 
        When this bit is set the command functionality is changed to 
        move-file, the specified cCfrom-filecA is moved to cCto-filecA. 

    cD0x080cA 
        When this bit is set the command functionality is changed to 
        copy-file, the specified cCfrom-filecA is copied to cCto-filecA. 

    cD0x100cA 
        When this bit is set the command functionality is changed to making a 
        new directory, the specified cCdir-namecA is the name of the new 
        directory. A file or directory of the given name must not already 
        exist. 

    Only one operation can be performed per invocation. The following bits in 
    the given argument cCncA can be used to effect the behaviour of these 
    operations: 

    cD0x01cA 
        Enables validity checks, these include a check that the proposed file 
        does not already exist, if so confirmation of writing is requested 
        from the user. Also MicroEmacs checks all other current buffers for 
        one with the proposed file name, if found, again confirmation is 
        requested. Without this flag the command will always succeed wherever 
        possible. 

    cD0x02cA 
        Creates a backup of any file about to be deleted or over-written. Set 
        help on lslm$buffer-backup(5)le for backup file-name generation. 


cEcENOTES cEcA


    cDhttpcA files are not supported except as the source file when copying. cDftpcA 
    files are fully supported with the restriction that the from and to files 
    cannot both be url (http or ftp) files. 

    The command is used by lslmfile-browser(3)le and lslmftp(3)le which provides an easy 
    to use interfaces for file manipulation. 


cEcESEE ALSO cEcA


    lslmfile-browser(3)le, lslmftp(3)le, lslmfind-file(2)le, lslmwrite-buffer(2)le, lslm$temp-name(5)le. 

! 2 kill-rectangle
! 2 yank-rectangle
cEcENAME cEcA


|kill-rectangle
    kill-rectangle - Delete a column of text 
|yank-rectangle
    yank-rectangle - Insert a column of text 
$a


cEcESYNOPSIS cEcA


    cDkill-rectanglecA (cDesc C-wcA) 
    cCncA cDyank-rectanglecA (cDesc C-ycA) 


cEcEDESCRIPTION cEcA


    cDkill-rectanglecA deletes a rectangle (or column) of text defined be the 
    cursor and the lsset-mark(2)lmset-markle position. The text between the mark column and the 
    cursor column is removed from every line between the mark line and the 
    cursor line inclusive and copied to the kill buffer. The delete text may 
    then be extracted from the kill buffer using lslmyank(2)le or cDyank-rectanglecA. 

    The mark position may be ahead or behind the current cursor position. If 
    the rectangle column boundary divides a tab character which spans multiple 
    columns, the tab character is replaces with the equivalent number of 
    spaces. Similarly if the boundary divides an unprintable character which 
    is displayed using multiple characters (e.g. 'cG^AcA' for character 0x01) then 
    spaces are inserted before the character to move it to the right of the 
    boundary. 

    cDyank-rectanglecA inserts the current kill buffer (which may or may not have 
    been generated using cDkill-rectanglecA) into the current buffer in a column 
    fashion. That is to say that the first line of text in the kill buffer is 
    inserted into the current line of text in the current buffer from the 
    current cursor column, the cursor is then moved the the next line and 
    placed at the same column. The process is then repeated for the second 
    line of text in the kill buffer etc. 


cEcENOTES cEcA


    The command copy-rectangle is not provided by default as this command is 
    rarely required. If this command is required, the following macro 
    definition can be used: 
sB
        define-macro copy-rectangle 
            set-alpha-mark "T" 
            set-variable #l0 &bmod "view" 
            set-variable #l1 &bmod "edit" 
            set-variable #l2 &bmod "undo" 
            -1 buffer-mode view 
            1 buffer-mode undo 
            kill-rectangle 
            ; undo the kill and restore the buffer state 
            undo 
            &cond #l2 1 -1 buffer-mode "undo" 
            &cond #l1 1 -1 buffer-mode "edit" 
            &cond #l0 1 -1 buffer-mode "view" 
            goto-alpha-mark "T" 
            ; flag the command to be a copy-region type command 
            set-variable @cl copy-region 
        !emacro 

sA

cEcESEE ALSO cEcA


    lslmset-mark(2)le, lslmkill-region(2)le, lslmyank(2)le, lslmcopy-region(2)le, lslmreyank(2)le, lslmundo(2)le. 

! 2 command-wait
cEcENAME cEcA


    command-wait - Conditional wait command 
$a


cEcESYNOPSIS cEcA


    cCncA cDcommand-waitcA 


cEcEDESCRIPTION cEcA


    When a +ve argument cCncA is given cDcommand-waitcA waits for cCncA milliseconds 
    before returning, this wait cannot be interrupted. If a -ve argument is 
    given, cDcommand-waitcA waits for -cCncA milliseconds but the command will return 
    if the user interrupts with any input activity (i.e. presses a key). 

    When no argument is given cDcommand-waitcA loops getting and processing events 
    (user input, screen updates etc) until either the calling commands cD.waitcA 
    command variable is undefined or set to false (cG0cA). This more complex use 
    of the command is used when a main macro must wait and process input until 
    an exit criteria has been met, the input is best processed by setting the 
    lslm$buffer-input(5)le variable to a second macro. The macro lslmgdiff(3)le uses this 
    command in this way. 


cEcEEXAMPLE cEcA


    The following macro code will display a message on the screen for a fixed 
    5 seconds: 
sB
        16 screen-poke 10 10 0 "Hello World!" 
        5000 command-wait 

sA
    Similarly the following macro code will display a message for up to 5 
    seconds or till the user presses a key: 
sB
        16 screen-poke 10 10 0 "Hello World!" 
        -5000 command-wait 

sA

cEcESEE ALSO cEcA


    lslmml-write(2)le, lslm$buffer-input(5)le. 

! 2 Bindings
cEcEDEFAULT KEY BINDINGS cEcA


    The default key bindings are presented below in four alphabetical lists, 
    one for single key bindings and one for each of the 4 bound prefixes (cGesccA, 
    cGC-xcA, cGC-hcA & cGC-ccA). See lskeyNames(2)lmKey Namesle for a list of valid key names. 


cESingle-Key Sequences cA


    cGbackspacecA lsforward-delete-char(2)lmbackward-delete-charle Delete the previous character. 
    cGdeletecA lsforward-delete-char(2)lmforward-delete-charle Delete character under the cursor. 
    cGdowncA lsforward-line(2)lmforward-linele Move to next line. 
    cGendcA lsbeginning-of-buffer(2)lmend-of-bufferle Move to the end of the buffer. 
    cGesccA lsprefix(2)lmprefix 1le Meta character prefix. 
    cGf1cA lsosd(2)lmosdle Open top main menu. 
    cGhomecA lsbeginning-of-buffer(2)lmbeginning-of-bufferle Move to the start of the buffer. 
    cGinsertcA lsbuffer-mode(2)lmbuffer-modele Toggle over-write mode. 
    cGleftcA lsforward-char(2)lmbackward-charle Move backward one character (left). 
    cGpage-downcA lsscroll-down(2)lmscroll-downle Move forward by one screen. 
    cGpage-upcA lsscroll-down(2)lmscroll-uple Move backward by one screen. 
    cGreturncA lsnewline(2)lmnewlinele Insert a new line. 
    cGrightcA lsforward-char(2)lmforward-charle Move forward one character (right). 
    cGtabcA lstab(2)lmtable Insert a tab character. 
    cGupcA lsforward-line(2)lmbackward-linele Move to previous line. 

    cGS-backspacecA lsforward-delete-char(2)lmbackward-delete-charle Delete the previous character. 
    cGS-deletecA lsforward-delete-char(2)lmforward-delete-charle Delete character under the cursor. 
    cGS-tabcA lsbackward-delete-tab(2)lmbackward-delete-table Delete white space to previous tab-stop. 

    cGC-acA lsbeginning-of-line(2)lmbeginning-of-linele Move to beginning of line. 
    cGC-bcA lsforward-char(2)lmbackward-charle Move backwards by one character 
    cGC-ccA lsprefix(2)lmprefixle Control character prefix. 
    cGC-dcA lsforward-delete-char(2)lmforward-delete-charle Delete character under the cursor. 
    cGC-ecA lsbeginning-of-line(2)lmend-of-linele Move to end of line. 
    cGC-fcA lsforward-char(2)lmforward-charle Move forward one character (right). 
    cGC-gcA lsabort-command(2)lmabort-commandle Abort current command. 
    cGC-hcA lsprefix(2)lmprefixle Control character prefix. 
    cGC-icA lsinsert-tab(2)lminsert-table Insert tab character. 
    cGC-kcA lskill-line(2)lmkill-linele Delete from cursor to the end of the line. 
    cGC-lcA lsrecenter(2)lmrecenterle Redraw screen with current line in the center. 
    cGC-mcA lsnewline(2)lmnewlinele Insert a new line. 
    cGC-ncA lsforward-line(2)lmforward-linele Move to next line (down). 
    cGC-ocA lsinsert-newline(2)lminsert-newlinele Open up a blank line. 
    cGC-pcA lsforward-line(2)lmbackward-linele Move to previous line (up). 
    cGC-qcA lsquote-char(2)lmquote-charle Insert literal character. 
    cGC-rcA lsisearch-forward(2)lmisearch-backwardle Start incremental search backwards. 
    cGC-scA lsisearch-forward(2)lmisearch-forwardle Start incremental search forwards. 
    cGC-tcA lstranspose-chars(2)lmtranspose-charsle Transpose two letters. 
    cGC-ucA lsuniversal-argument(2)lmuniversal-argumentle Repeat the next command cCncA times (default is 4). 
    cGC-vcA lsscroll-down(2)lmscroll-downle Move forward by one screen. 
    cGC-wcA lskill-region(2)lmkill-regionle Delete a marked region. 
    cGC-xcA lsprefix(2)lmprefixle Control character prefix. 
    cGC-ycA lsyank(2)lmyankle Restore what was copied or deleted. 
    cGC-zcA lsscroll-down(2)lmscroll-uple Move backward by one screen. 
    cGC-_cA lsundo(2)lmundole Undo the previous edit. 
    cGC-downcA lsforward-line(2)lmforward-linele Move forward five lines. 
    cGC-leftcA lsforward-word(2)lmbackward-wordle Move one word backward. 
    cGC-page-downcA lsscroll-next-window-down(2)lmscroll-next-window-downle Scroll next window down a page. 
    cGC-page-upcA lsscroll-next-window-down(2)lmscroll-next-window-uple Scroll the next window up a page. 
    cGC-rightcA lsforward-word(2)lmforward-wordle Move one word forward. 
    cGC-upcA lsforward-line(2)lmbackward-linele Move backward 5 lines. 

    cGA-ecA lsfile-browser(3)lmfile-browserle Browse the file system. 
    cGA-rcA lsreplace-all-string(3)lmreplace-all-stringle Replace string with new string in a list of files. 
    cGA-downcA lsscroll-down(2)lmscroll-downle Scroll the current window down one line. 
    cGA-leftcA lsscroll-left(2)lmscroll-leftle Scroll the current window left one character. 
    cGA-rightcA lsscroll-left(2)lmscroll-rightle Scroll the current window right one character. 
    cGA-upcA lsscroll-down(2)lmscroll-uple Scroll the current window up one line. 


cEesc Prefix Sequences cA


    cGesc !cA lspipe-shell-command(2)lmpipe-shell-commandle Pipe a shell command to a buffer. 
    cGesc $cA lsspell-buffer(3)lmspell-wordle Spell a word. 
    cGesc .cA lsset-mark(2)lmset-markle Set the start of a region. 
    cGesc /cA lsexecute-file(2)lmexecute-filele Execute script lines from a file. 
    cGesc <cA lsbeginning-of-buffer(2)lmbeginning-of-bufferle Move to the start of the buffer. 
    cGesc >cA lsbeginning-of-buffer(2)lmend-of-bufferle Move to the end of the buffer. 
    cGesc ?cA lshelp(2)lmhelple Help - high level introduction to MicroEmacs. 
    cGesc @cA lspipe-shell-command(2)lmpipe-shell-commandle Pipe a shell command to a buffer. 
    cGesc [cA lsforward-paragraph(2)lmbackward-paragraphle Goto the beginning of the paragraph. 
    cGesc \cA lsipipe-shell-command(2)lmipipe-shell-commandle Incrementally pipe a shell command to a buffer. 
    cGesc ]cA lsforward-paragraph(2)lmforward-paragraphle Move forward one paragraph 
    cGesc ^cA lsdelete-indentation(3)lmdelete-indentationle Join 2 lines deleting white spaces. 
    cGesc bcA lsforward-word(2)lmbackward-wordle Move one word backwards 
    cGesc ccA lscapitalize-word(2)lmcapitalize-wordle Capitalize first letter of a word 
    cGesc dcA lsforward-kill-word(2)lmforward-kill-wordle Delete word the cursor is on. 
    cGesc ecA lsset-encryption-key(2)lmset-encryption-keyle Reset the encryption key. 
    cGesc fcA lsforward-word(2)lmforward-wordle Move one word forward. 
    cGesc gcA lsgoto-line(2)lmgoto-linele Goto a line. 
    cGesc icA lstab(2)lmtable Insert a tab character. 
    cGesc kcA lsglobal-bind-key(2)lmglobal-bind-keyle Bind a key to a command or macro. 
    cGesc lcA lscapitalize-word(2)lmlower-case-wordle Lowercase word. 
    cGesc mcA lsglobal-mode(2)lmglobal-modele Toggle a global mode. 
    cGesc ncA lsforward-paragraph(2)lmforward-paragraphle Move forward one paragraph 
    cGesc ocA lsfill-paragraph(2)lmfill-paragraphle Reformat (fill) current paragraph. 
    cGesc pcA lsforward-paragraph(2)lmbackward-paragraphle Goto the beginning of the paragraph. 
    cGesc qcA lsifill-paragraph(3)lmifill-paragraphle Reformat (fill) current paragraph. 
    cGesc rcA lsreplace-string(2)lmreplace-stringle Search and replace text (no query). 
    cGesc tcA lsfind-tag(2)lmfind-tagle Find a tag. 
    cGesc ucA lscapitalize-word(2)lmupper-case-wordle Uppercase word. 
    cGesc vcA lsscroll-down(2)lmscroll-downle Move to the previous screen. 
    cGesc wcA lscopy-region(2)lmcopy-regionle Copy region to the kill buffer. 
    cGesc xcA lsexecute-named-command(2)lmexecute-named-commandle Execute the named command. 
    cGesc ycA lsreyank(2)lmreyankle Kill current yank data and restore previous kill buffer data. 
    cGesc zcA lsquick-exit(2)lmquick-exitle Save all buffers and exit. 

    cGesc ~cA lsbuffer-mode(2)lmbuffer-modele Remove edited status from current buffer. 
    cGesc backspacecA lsforward-kill-word(2)lmbackward-kill-wordle Delete the word under the cursor. 
    cGesc esccA lsexpand-abbrev(2)lmexpand-abbrevle Expand an abbreviation. 
    cGesc spacecA lsset-mark(2)lmset-markle Set the start of a region. 

    cGesc C-ccA lscount-words(2)lmcount-wordsle Count words in a region. 
    cGesc C-fcA lsgoto-matching-fence(2)lmgoto-matching-fencele Reposition the cursor at an opposing bracket. 
    cGesc C-gcA lsabort-command(2)lmabort-commandle Abort current command. 
    cGesc C-icA lstab(2)lmtable Insert tab character. 
    cGesc C-kcA lsglobal-bind-key(2)lmglobal-unbind-keyle Unbind a key from a command or macro 
    cGesc C-ncA lschange-buffer-name(2)lmchange-buffer-namele Rename current buffer. 
    cGesc C-rcA lsquery-replace-string(2)lmquery-replace-stringle Search and replace with query. 
    cGesc C-vcA lsscroll-next-window-down(2)lmscroll-next-window-downle Scroll next window down a page. 
    cGesc C-wcA lskill-paragraph(2)lmkill-paragraphle Delete current paragraph. 
    cGesc C-zcA lsscroll-next-window-down(2)lmscroll-next-window-uple Scroll the next window up a page. 

    cGesc A-rcA lsquery-replace-all-string(3)lmquery-replace-all-stringle Query replace string in a list of files. 


cEC-x Prefix Sequences cA


    cGC-x #cA lsfilter-buffer(2)lmfilter-bufferle Filter the buffer through a shell filter. 
    cGC-x (cA lsstart-kbd-macro(2)lmstart-kbd-macrole Start recording a keyboard macro. 
    cGC-x )cA lsstart-kbd-macro(2)lmend-kbd-macrole Stop recording a keyboard macro. 
    cGC-x /cA lsisearch-forward(2)lmisearch-forwardle Start incremental search forwards. 
    cGC-x 0cA lsdelete-window(2)lmdelete-windowle Delete the current window. 
    cGC-x 1cA lsdelete-window(2)lmdelete-other-windowsle Delete other windows. 
    cGC-x 2cA lssplit-window-vertically(2)lmsplit-window-verticallyle Split the current window into two. 
    cGC-x 3cA lsnext-window-find-buffer(2)lmnext-window-find-bufferle Find a buffer into the next window, split if 
    necessary. 
    cGC-x 4cA lsnext-window-find-file(2)lmnext-window-find-filele Load a file into the next window, split if 
    necessary. 
    cGC-x 5cA lssplit-window-horizontally(2)lmsplit-window-horizontallyle Split the current window horizontally into 
    two. 
    cGC-x 9cA lsfind-bfile(3)lmfind-bfilele Find and load a file for binary editing. 
    cGC-x <cA lsscroll-left(2)lmscroll-leftle Scroll the window left by one screen width. 
    cGC-x =cA lsbuffer-info(2)lmbuffer-infole Show cursor position information 
    cGC-x >cA lsscroll-left(2)lmscroll-rightle Scroll the window right by one screen width. 
    cGC-x ?cA lsdescribe-key(2)lmdescribe-keyle Describe binding of command to key. 
    cGC-x @cA lspipe-shell-command(2)lmpipe-shell-commandle Pipe a shell command to buffer. 
    cGC-x [cA lsscroll-down(2)lmscroll-uple Move backward by one screen. 
    cGC-x ]cA lsscroll-down(2)lmscroll-downle Move forward by one screen. 
    cGC-x ^cA lsgrow-window-vertically(2)lmgrow-window-verticallyle Enlarge the current window by a line. 
    cGC-x `cA lsget-next-line(2)lmget-next-linele Find the next command line. 
    cGC-x acA lsgoto-alpha-mark(2)lmgoto-alpha-markle Move the cursor to an alphabetic mark. 
    cGC-x bcA lsnext-buffer(2)lmfind-bufferle Switch window to a buffer. 
    cGC-x ccA lsshell(2)lmshellle Start a new command processor. 
    cGC-x ecA lsexecute-kbd-macro(2)lmexecute-kbd-macrole Execute a macro. 
    cGC-x hcA lshunt-forward(2)lmhunt-forwardle Continue search in forward direction. 
    cGC-x kcA lsdelete-buffer(2)lmdelete-bufferle Delete buffer. 
    cGC-x mcA lsbuffer-mode(2)lmbuffer-modele Toggle a local buffer mode. 
    cGC-x ncA lschange-file-name(2)lmchange-file-namele Rename current buffer file name. 
    cGC-x ocA lsnext-window(2)lmnext-windowle Move to the next window. 
    cGC-x pcA lsnext-window(2)lmprevious-windowle Move to the previous window. 
    cGC-x qcA lskbd-macro-query(2)lmkbd-macro-queryle Query keyboard macro. 
    cGC-x rcA lssearch-forward(2)lmsearch-backwardle Search in a reverse direction. 
    cGC-x scA lssearch-forward(2)lmsearch-forwardle Search in a forward direction. 
    cGC-x ucA lsundo(2)lmundole Undo the previous edit. 
    cGC-x vcA lsset-variable(2)lmset-variablele Assign a new value to a variable. 
    cGC-x wcA lsgrow-window-vertically(2)lmresize-window-verticallyle Resize the window. 
    cGC-x xcA lsnext-buffer(2)lmnext-bufferle Switch to the next buffer. 
    cGC-x zcA lsgrow-window-vertically(2)lmgrow-window-verticallyle Enlarge the current window. 
    cGC-x {cA lsgrow-window-horizontally(2)lmshrink-window-horizontallyle Shrink current window horizontally. 
    cGC-x }cA lsgrow-window-horizontally(2)lmgrow-window-horizontallyle Enlarge current window horizontally. 

    cGC-x C-acA lsset-alpha-mark(2)lmset-alpha-markle Mark the current position with an alphabetic mark. 
    cGC-x C-bcA lslist-buffers(2)lmlist-buffersle Display buffer list. 
    cGC-x C-ccA lsquick-exit(2)lmsave-buffer-exit-emacsle Exit MicroEmacs '02. 
    cGC-x C-dcA lschange-directory(2)lmchange-directoryle Change the current working directory. 
    cGC-x C-ecA lsexecute-kbd-macro(2)lmexecute-kbd-macrole Execute a macro. 
    cGC-x C-fcA lsfind-file(2)lmfind-filele Find a file and load into buffer. 
    cGC-x C-gcA lsabort-command(2)lmabort-commandle Abort current command. 
    cGC-x C-hcA lshunt-forward(2)lmhunt-backwardle Resume search in backwards direction. 
    cGC-x C-icA lsinsert-file(2)lminsert-filele Insert file into the current buffer. 
    cGC-x C-lcA lscapitalize-word(2)lmlower-case-regionle Lowercase region. 
    cGC-x C-ncA lsscroll-down(2)lmscroll-downle Scroll the current window down one line. 
    cGC-x C-ocA lsdelete-blank-lines(2)lmdelete-blank-linesle Delete blank lines about the cursor. 
    cGC-x C-pcA lsscroll-down(2)lmscroll-uple Scroll the current window up one line. 
    cGC-x C-qcA lsrcs-file(2)lmrcs-filele Interact with RCS to check in/out a file. 
    cGC-x C-rcA lsread-file(2)lmread-filele Read a file from disk. 
    cGC-x C-scA lssave-buffer(2)lmsave-bufferle Save current file to disk. 
    cGC-x C-tcA lstranspose-chars(2)lmtranspose-linesle Swap adjacent lines. 
    cGC-x C-ucA lscapitalize-word(2)lmupper-case-regionle Uppercase region. 
    cGC-x C-vcA lsview-file(2)lmview-filele Read a file for viewing (read only). 
    cGC-x C-wcA lswrite-buffer(2)lmwrite-bufferle Write a file to disk witn new name. 
    cGC-x C-xcA lsexchange-point-and-mark(2)lmexchange-point-and-markle Exchange cursor with mark position. 
    cGC-x C-ycA lsinsert-file-name(2)lminsert-file-namele Insert filename into current buffer. 
    cGC-x C-zcA lsgrow-window-vertically(2)lmshrink-window-verticallyle Reduce size of current window. 


cEC-h Prefix Sequences cA


    cGC-h acA lscommand-apropos(2)lmcommand-aproposle List commands involving a concept. 
    cGC-h bcA lsdescribe-bindings(2)lmdescribe-bindingsle Show current command/key binding. 
    cGC-h ccA lslist-commands(2)lmlist-commandsle List available commands. 
    cGC-h dcA lsdescribe-variable(2)lmdescribe-variablele Describe current setting of a variable. 
    cGC-h kcA lsdescribe-key(2)lmdescribe-keyle Describe keyboard binding. 
    cGC-h vcA lslist-variables(2)lmlist-variablesle List defined variables. 

    cGC-h C-ccA lshelp(2)lmhelp-commandle Display command help information. 
    cGC-h C-icA lshelp(2)lmhelp-itemle Display item help information. 
    cGC-h C-vcA lshelp(2)lmhelp-variablele Display variable help information. 

! 2 Compatibility
cEcECOMPATIBILITY cEcA


    JASSPA MicroEmacs is based on the original version of cDMicroEMACScA produced 
    by Danial Lawrence at revision 3.8, the source files were obtained in 
    approximately 1990. The exact origin of the files is unknown. In that 
    period of time the source files have undergone an awful lot of change, 
    without reference to the subsequent releases made of MicroEMACS by Danial 
    Lawrence (due to no network access). As a result the JASSPA version of 
    cDMicroEmacscA does not include any modifications or features that may have 
    been implemented since. This version of cDMicroEmacscA has been tailored to 
    suite the requirements of a small group of individuals who have used the 
    editor on a daily basis across a limited number of platforms, for a 
    variety of very different tasks and operating requirements. 

    This version of MicroEmacs is biased towards UNIX environments, MS-DOS and 
    Microsoft Windows ports have been performed however they are heavily 
    influenced by UNIX and inherit UNIX characteristics wherever possible. The 
    intention is that programmers, and alike, may move across platforms using 
    a common editor environment without being frustrated by the idiosyncrasies 
    of different platforms. The most noticeable platform is the Microsoft 
    Windows platform which mimics the X-Windows cut and paste mechanism within 
    the MicroEmacs environment. If you want a Windows style environment then 
    use cDNotepad(1)cA or cDWordpad(1)cA, this editor is not for you !! 

    The gross changes to cDMicroEmacs '02cA are summarized as follows:- 

        * Macro language interpreter re-written allowing an unlimited number 
          of named macros to be supported. The macro implementation allows new 
          commands to be created by the user, as opposed to continually 
          extending the underlying command set. The named macros are 
          transparent to the user, appearing as built in commands on the 
          command line. Macro command set significantly increased. Support for 
          global, buffer and register variables within the macro language. 

        * Display drivers re-written providing color hilighting support on 
          most platforms. A macro interface allows information to be written 
          directly to the display canvas allowing the screen to be annotated 
          with additional transient information. 

        * Support for X-Window screen type in UNIX environments. Microsoft 
          Window's environments (3.x, '95, NT) treated in the same was as 
          X-Windows - this may be unorthodox for existing Window's users, UNIX 
          users will find it more comfortable. 

        * Introduction of integrated spell checker. Support includes 
          correction word guessing, word auto-correction and double word 
          detection. Ignore and personal dictionaries supported. 

        * Horizontal window splitting. 

        * Introduction of scroll bars on all platforms that support a mouse. 
          The scroll bar implementation is platform independent. 

        * Command and file completion available on all platforms. Most 
          commands support a command history allowing previous command 
          invocations to be recalled. 

        * Session history file kept, allowing the previous edit session to be 
          reinstated. 

        * Undo capability, allows previous edits to be undone when mistakes 
          are made. 

        * Backup capability, Includes a periodic timed backup while an editing 
          session is in progress. The timed backup is automatically recovered 
          by the next session in situations where the system (or editor) 
          crashes. 

        * A regular expression incremental search becomes the default search 
          forward mechanism. 

        * Support for abbreviation files allowing frequently used constructs 
          to be automatically expanded. 

        * Automatic time stamping of files, allowing the edit time to be 
          automatically maintained in the source file(s). 

        * Introduction of an electric 'C' mode. Editor intelligently handles 
          the layout of 'C' files (under user control). 

        * Improved documentation text mode providing left/right/center and 
          both justification methods with inclusion for bullet points. 
          Automatic justification may be continually performed as text is 
          entered, thereby maintaining the paragraph in the correct format. 

        * Integrated on-line help facilities. All commands are documented 
          on-line. New macros may be documented within the macro files and 
          become part of the help system. 

        * File type determination system, based on either the file name or 
          embedded file text allows file type specific macros (hooks) to be 
          applied, thereby configuring the editor into the correct mode for 
          the file type. 

        * Introduction of special MicroEmacs search path allowing all of the 
          standard configuration files to be utilized from a shared directory. 

    The name space of JASSPA MicroEmacs differs from the original MicroEMACS 
    and has become more compliant with the GNU implementation of Emacs. A list 
    of the original MicroEMACS verses the new command name set is as follows, 
    executing the compatibility macro file cGmeme3_8.emfcA will create macro 
    versions of these commands: 

        cDadd-global-modecA => lsglobal-mode(2)lmglobal-modele 
        cDadd-modecA => lsbuffer-mode(2)lmbuffer-modele 
        cDaproposcA => lscommand-apropos(2)lmcommand-aproposle 
        cDbackward-charactercA => lsforward-char(2)lmbackward-charle 
        cDbegin-macrocA => lsstart-kbd-macro(2)lmstart-kbd-macrole 
        cDbeginning-of-filecA => lsbeginning-of-buffer(2)lmbeginning-of-bufferle 
        cDbind-to-keycA => lsglobal-bind-key(2)lmglobal-bind-keyle 
        cDbuffer-positioncA => lsbuffer-info(2)lmbuffer-infole 
        cDcase-region-lowercA => lscapitalize-word(2)lmlower-case-regionle 
        cDcase-region-uppercA => lscapitalize-word(2)lmupper-case-regionle 
        cDcase-word-capitalizecA => lscapitalize-word(2)lmcapitalize-wordle 
        cDcase-word-lowercA => lscapitalize-word(2)lmlower-case-wordle 
        cDcase-word-uppercA => lscapitalize-word(2)lmupper-case-wordle 
        cDclear-message-linecA => lsml-clear(2)lmml-clearle 
        cDctlx-prefixcA => lsprefix(2)lmprefix 2le 
        cDdelete-global-modecA => lsglobal-mode(2)lmglobal-modele 
        cDdelete-modecA => lsbuffer-mode(2)lmbuffer-modele 
        cDdelete-next-charactercA => lsforward-delete-char(2)lmforward-delete-charle 
        cDdelete-next-wordcA => lsforward-kill-word(2)lmforward-kill-wordle 
        cDdelete-previous-charactercA => lsforward-delete-char(2)lmbackward-delete-charle 
        cDdelete-previous-wordcA => lsforward-kill-word(2)lmbackward-kill-wordle 
        cDend-macrocA => lsstart-kbd-macro(2)lmend-kbd-macrole 
        cDend-of-filecA => lsbeginning-of-buffer(2)lmend-of-bufferle 
        cDexecute-command-linecA => lsexecute-buffer(2)lmexecute-linele 
        cDexecute-macrocA => lsexecute-kbd-macro(2)lmexecute-kbd-macrole 
        cDexecute-macro-#cA => cCDeletedcA 
        cDfile-name-insertcA => lsinsert-file-name(2)lminsert-file-namele 
        cDforward-charactercA => lsforward-char(2)lmforward-charle 
        cDgrow-windowcA => lsgrow-window-horizontally(2)lmgrow-window-horizontallyle 
        cDhandle-tabcA => lstab(2)lmtable 
        cDi-shellcA => lsshell(2)lmshellle 
        cDincremental-searchcA => lsisearch-forward(2)lmisearch-forwardle 
        cDkill-to-end-of-linecA => lskill-line(2)lmkill-linele 
        cDmeta-prefixcA => lsprefix(2)lmprefix 1le 
        cDmove-window-downcA => lsscroll-down(2)lmscroll-downle 
        cDmove-window-upcA => lsscroll-down(2)lmscroll-uple 
        cDname-buffercA => lschange-buffer-name(2)lmchange-buffer-namele 
        cDnext-linecA => lsforward-line(2)lmforward-linele 
        cDnext-pagecA => lsscroll-down(2)lmscroll-downle 
        cDnext-paragraphcA => lsforward-paragraph(2)lmforward-paragraphle 
        cDnext-wordcA => lsforward-word(2)lmforward-wordle 
        cDopen-linecA => lsinsert-newline(2)lminsert-newlinele 
        cDpipe-commandcA => lspipe-shell-command(2)lmpipe-shell-commandle 
        cDprevious-linecA => lsforward-line(2)lmbackward-linele 
        cDprevious-pagecA => lsscroll-down(2)lmscroll-uple 
        cDprevious-paragraphcA => lsforward-paragraph(2)lmbackward-paragraphle 
        cDprevious-wordcA => lsforward-word(2)lmbackward-wordle 
        cDquote-charactercA => lsquote-char(2)lmquote-charle 
        cDredraw-displaycA => lsrecenter(2)lmrecenterle 
        cDrestore-windowcA => lsset-position(2)lmgoto-positionle 
        cDreverse-incremental-searchcA => lsisearch-forward(2)lmisearch-backwardle 
        cDsave-filecA => lssave-buffer(2)lmsave-bufferle 
        cDsave-windowcA => lsset-position(2)lmset-positionle 
        cDscroll-next-downcA => lsscroll-next-window-down(2)lmscroll-next-window-downle 
        cDscroll-next-upcA => lsscroll-next-window-down(2)lmscroll-next-window-uple 
        cDsearch-reversecA => lssearch-forward(2)lmsearch-backwardle 
        cDselect-buffercA => lsnext-buffer(2)lmfind-bufferle 
        cDsetcA => lsset-variable(2)lmset-variablele 
        cDshrink-windowcA => lsgrow-window-vertically(2)lmshrink-window-verticallyle 
        cDsplit-current-windowcA => lssplit-window-vertically(2)lmsplit-window-verticallyle 
        cDtop-bottom-switchcA => cCDeletedcA 
        cDtranspose-characterscA => lstranspose-chars(2)lmtranspose-charsle 
        cDunbind-keycA => lsglobal-bind-key(2)lmglobal-unbind-keyle 
        cDupdate-screencA => lsscreen-update(2)lmscreen-updatele 
        cDwrite-messagecA => lsml-write(2)lmml-writele 

! 2 fileHooks
cEcEFILE HOOKS cEcA


    File hooks provide a mechanism to automatically invoke a set of macros for 
    a given buffer type when the following events occur: 

        * Loading of a file into a buffer 
        * Moving into a buffer (i.e. making a buffer current) 
        * Moving out of a buffer (i.e. making another buffer current) 
        * Deleting an active buffer 

    The file hook selection (see below) is performed on the file name / 
    extension and on the textual content of the buffer using lsadd-file-hook(2)lmadd-file-hookle. 

    Refer to lslanguageTemplates(2)lmLanguage Templatesle for a description of how the file hooks are 
    used to define a new template for a new text format. 

    The hook macros allow buffer modes and highlighting, applicable to the 
    text type of the file, to be applied to the buffer. In addition, the 
    associated hook macros may be located in a separate file and are loaded on 
    demand when the file reading determines that a set of hook macros are 
    required. 

    Consider a file hook definition of the form; 
sB
        add-file-hook ".c .h" "fhook-c" 

sA
    which binds the file hook cDfhook-ccA to any files that are loaded with the 
    extension cD.ccA and cD.hcA. The operations undertaken by MicroEmacs '02 are 
    defined as follows when a file cGfoo.ccA is loaded:- 

        * Attempt to load file cGfoo.ccA, if cGfoo.ccA is not found then create a new 
          buffer and assign file name cGfoo.ccA. 

        * If cGfoo.ccA is found then load file into buffer. Search the first 
          line(s) of the buffer for magic hook text (cCadd-file-hookcA with 
          argument). 

        * If magic hook was not found then determine hook name from the file 
          extension (cCadd-file-hookcA information). 

        * If a hook command is located, assign the file hook cDfhook-ccA to the 
          buffer, assign the buffer entry (begin) hook macro of cDbhook-ccA; 
          assign a buffer exit hook of cDehook-ccA. 

        * If the macro cDfhook-ccA is undefined then execute the macro file 
          cDhkc.emfcA from the MicroEmacs home directory in an attempt to load the 
          macro. If the file cDmyc.emfcA is defined, then the modifications to the 
          language template are applied after cDhkc.emfcA is loaded. 

        * If the macro cDfhook-ccA is (now) defined then cGfoo.ccA is TEMPORARILY made 
          the current buffer and the file hook macro cDfhook-ccA is executed to 
          completion and the previous current buffer is restored. [cCTEMPORARYcA 
          here implies that no buffer hooks are executed on the flip in/out of 
          cGfoo.ccA]. 

        * The current buffer is officially swapped to cGfoo.ccA. At this point the 
          cCehookcA of the old current buffer is executed (while its still 
          current) and then cGfoo.ccA is swapped in to become the current buffer; 
          the begin buffer hook cCbhook-cmodecA is then executed for cGfoo.ccA (if it 
          exists). 

        * If the user moves to another buffer execute the end hook macro 
          cDehook-cmodecA (if it exists) and move to the new buffer, executing 
          it's begin hook. 

        * If the user subsequently returns to buffer cGfoo.ccA execute the 
          previous buffers end hook macro, set the current buffer to cCfoo.ccA and 
          execute the begin hook macro cDbhook-ccA (if it exists). 

        * If the user kills buffer cGfoo.ccA, if cGfoo.ccA is the current buffer then 
          an alternative buffer is made current, cGehookcA and cGbhookcA executed as 
          normal. If macro cDdhook-ccA is defined then cGfoo.ccA is TEMPORARILY made 
          the current buffer and the delete hook macro cDdhook-ccA is executed to 
          completion and the previous current buffer is restored. 

    The name of the file hook macro name is important, hook commands must 
    commence with the text cDfhook-cAcCmodecA where cCmodecA is an identifier for the 
    operating mode. The name space is decomposed as follows:- 

        * The initial cDfcA is removed and replaced with cDbcA for the begin hook 
          macro and cDecA for the end hook macro. 

        * When the cDfhookcA macro is undefined the cCmodecA component is removed and 
          the file cDhkcAcCmodecAcD.emfcA is executed from the MicroEmacs home directory 
          in an attempt to define the macro. 

    The cDfhook-cA nomenclature may be omitted provided that the name is less than 
    6 characters, however the file, begin and end hook macros MUST commence 
    with cDfcA, cDbcA and cDecA respectively. In addition the macros must be defined as no 
    auto file loading is performed. 


cEBuffer Hook Variables cA


    The macros bound to a buffer may be interrogated, the variables 
    lslm$buffer-fhook(5)le, lslm$buffer-bhook(5)le, lslm$buffer-ehook(5)le and lslm$buffer-dhook(5)le 
    contain the names of any associated macro attached as a macro hooks, 
    defining the cCfilecA, cCbegincA, cCendcA and cCdeletecA hooks respectively. If a macro is 
    not bound then the empty string cG""cA is returned. Setting the variables has 
    the effect of defining the hook and is a method by which the buffer hooks 
    may be affected after the buffer has been loaded. 


cEDetermination of a new file cA


    The cCfilecA hook cDfhook-XXXcA numeric argument may be used to determine if the 
    file associated with a buffer is a new file created by the user, or an 
    existing file. Typically this distinction is used to determine whether a 
    boiler template is added to the file or not. The macro argument cD@#cA is 
    defined as zero (0) if this is a new file that has been created, or 
    non-zero otherwise. 

    The macro argument status is typically tested on entry to the macro as 
    follows:- 
sB
        define-macro fhook-mode 
            !if &not @# 
                ; This is a new file. Do new file things 
            !else 
                ; This is an existing file 
            !endif 
            ; Set up bindings 
        !emacro 

sA
    An example of a generic cDhookcA file is given at the end of this section 
    which elaborates on the file hooks. 


cEBegin and End hooks cA


    The cCbegincA and cCendcA hooks are usually used to save and restore global states 
    which require special settings for a particular buffer type. This 
    typically involves saving and restoring global variables which are used by 
    other buffers in a different configuration. For example the following is 
    used to reformat the time stamp string; the time stamp is a global 
    variable lslm$timestamp(5)le and if it is changed in one buffer, it must be 
    restored ready for another. In this case the old time stamp is retained in 
    a local buffer variable whenever the buffer is entered, the time stamp is 
    then modified for the buffers requirements. On exit from the buffer the 
    old time stamp format is restored to it's former state. 
sB
        0 define-macro bhook-foo 
            set-variable .timestamp $timestamp      ; Save old time stamp. 
            set-variable $timestamp "19%Y/%M/%D %h:%m:%s" 
        !emacro 

        0 define-macro ehook-foo 
            set-variable $timestamp .bhook-foo.timestamp 
        !emacro 

sA
    Note that in both cases the lslmdefine-macro(2)le invocation is defined as zero, 
    this merely hides the macro from the command line since both are private 
    macros not normally invoked by the user. 


cEcEFILE HOOK SELECTION cEcA


    MicroEmacs '02 may be reconfigured to operate in different modes (referred 
    to a cCMajor ModescA in GNU cDemacs(1)cA) using the lsadd-file-hook(2)lmmacro file hooksle. The file 
    hooks allow the working environment to be customized for the editing of 
    text of a particular sort, by importing text specific macros, key 
    rebinding and highlighting. 

    MicroEmacs '02, by default, loads a file into a buffer with default global 
    modes with no highlighting. There are no mode specific key bindings, 
    variable settings, macros or highlights, buffer interaction behaves in 
    it's default state. The state of the buffer interaction may be modified 
    through the use of the buffer modes (see lslmOperating Modesle), for example the 
    'C' programming language lslmcmode(2m)le changes the characteristics of the cGtabcA 
    character and performs language specific indentation of statements. When a 
    text specific set of highlighting rules are applied to the buffer, the 
    text becomes emphasized through the use of color applied selectively to 
    the text i.e. comments, keywords, strings are shown in different colors, 
    allowing them to be differentiated without studying the content. 

    Setting the operating mode of the buffer would be tedious to perform from 
    the command line, instead MicroEmacs '02 uses three different prioritized 
    criteria to endeavor to select the correct operating mode. The operating 
    mode is applied to the buffer by execution of a set of file specific 
    macros, referred to a hook commands. The selection criteria of the hook 
    commands is performed as follows, ordered in lowest to highest priority:- 

    cDFile NamecA 
        MicroEmacs '02 uses the filename and/or the file extension to select a 
        start-up hook command. File names and extensions are bound to a set of 
        macro hooks in a space separated list e.g. 

            lsadd-file-hook(2)lmadd-file-hookle "cDc cppcA" "cDfhook-cmodecA" 
            lsadd-file-hook(2)lmadd-file-hookle "cDdoc txt READMEcA" "cDfhook-doccA" 

        The space separated list of names are interpreted as either file 
        extensions or filenames. In this case any file with the extension cD.ccA, 
        cD.cppcA is bound to a file hook called cDfhook-cmodecA e.g. cGfoo.ccA. Similarly 
        files with the extension cD.doccA or cD.txtcA are interpreted as plain text 
        documents and are bound to cDfhook-doccA. e.g. cGfoo.txtcA. The entry cDREADMEcA 
        that exists in the documentation hook list may refer to a file cGREADMEcA 
        and also cGfoo.READMEcA, both cases invoke the document hook. 

        The file selection is the lowest priority selection criteria but 
        usually satisfies most mode selection requirements. 

    cDMagic StringscA 
        There are cases when file extensions may be omitted from files, 
        typically these files include an identifier, or magic string, on the 
        first line of the file which is used to identify the file to the 
        operating system or application e.g. shell scripts under UNIX. 
        MicroEmacs '02 automatically interrogates the top of every file that 
        is loaded to locate some form of identification string. The 
        identification strings are defined in a similar way to the file name 
        hooks, except instead of defining a file extension the location and 
        text content of the identifier is defined: 

            1 lsadd-file-hook(2)lmadd-file-hookle "cD#!/bin/shcA" "cDfhook-shellcA" 
            1 lsadd-file-hook(2)lmadd-file-hookle "cD#!/usr/local/bin/wishcA" "cDfhook-tclcA" 

        In this case, any file that commences with "cD#!/bin/shcA" is interpreted 
        as a shell script and invokes the shell hook cDfhook-shellcA. Where the 
        identifier does not appear on the first non-blank line, the argument 
        may be increased to the number of lines to be searched. Also it the 
        magic sting should be search for without lslmexact(2m)le mode then the 
        argument should be negated, e.g. 

            -4 cDadd-file-hookcA "<html>" "cDfhook-htmlcA" 

        invokes cDfhook-htmlcA whenever "cG<html>cA", "cG<HTML>cA" etc. is found in the 
        first 4 lines of a file header, e.g.: 

            <!-- Comment line --> 
            <HtMl> 


        A match on a string identifier is assigned a higher priority than the 
        file extension. It is recommended that magic strings are only used 
        where there are no predefined file extensions, or conflicts exist 
        between files with the same extension containing data interpreted in a 
        different context. 

    cDExplicit StringscA 
        The last method allows an explicit identifier string to be embedded 
        into the text of the file informing MicroEmacs '02 which mode it 
        should adopt. GNU Emacs supports this (see cDMajor ModecA in the GNU Emacs 
        documentation) type of operation by insertion of strings of the form: 

            cD-*-cA cCmodecA cD-*-cA 

        Where cCmodecA represents the major mode within GNU Emacs. The same format 
        as used by cDMagic StringscA can be used to find and extract the cCmodecA, 
        e.g.: 

            cD-1cA lsadd-file-hook(2)lmadd-file-hookle "cD-[*!]-[ \t]nroff.*-[*!]-cA" "cDfhook-nroffcA" 

        The definition would detect the GNU Emacs mode defined in an Nroff 
        file e.g. 

            .\" -*- nroff -*- " 
            .TH man 1 
            .SH NAME 
            ... 

        It should be stressed that the cD-*-cA syntax belongs to GNU Emacs and NOT 
        MicroEmacs '02, MicroEmacs '02 provides a mechanism to locate, extract 
        and interpret the string. The cD-*-cA syntax should only be applied to 
        files if it is known that the cCmodecA is a GNU mode. 

        A MicroEmacs '02 specific string is also provided, defined as: 

            cD-!-cA cCmodecA cD-!-cA 

        where cCmodecA is an arbitrary string defined by cCadd-file-hookcA. User 
        defined modes may be created and assigned to files with this syntax, 
        this does not conflict with the GNU Emacs command. For example to 
        assign a new mode cCmymodecA to a file we would define the following:- 

            cD-1cA lsadd-file-hook(2)lmadd-file-hookle "cD-!-[ \t]mymode.*-!-cA" "cDfhook-mymodecA" 

        Files containing a the following identifier would be loaded with 
        cCmymodecA hook: 

            # -!- mymode -!- 
            # 
            # Last Modified:  <120683.1014> 


cEcEFILE HOOK SCRIPTS cEcA


    The buffer hook files cDhkcAcCnamecAcD.emfcA typically follow a standard layout, and 
    are generally associated with hi-lighting as follows, cDmodecA in this case is 
    the name of the file mode associated with the file:- 
sB
        !if &seq .hilight.mode "ERROR" 
            set-variable .hilight.mode &pinc .hilight.next 1 
        !endif 
        ; 
        ; Define the hilighting 
        ; 
        0 hilight .hilight.mode 1                $global-scheme 
        hilight .hilight.mode 2 "\*\*"           .scheme.comment 
        hilight .hilight.mode 4 "\"" "\"" "\\"   .scheme.string 
        hilight .hilight.mode 0 "'.'"            .scheme.quote 

        hilight .hilight.mode 1 "if"             .scheme.keyword 
        hilight .hilight.mode 1 "elif"           .scheme.keyword 
        hilight .hilight.mode 1 "else"           .scheme.keyword 
        ... 

        ; Reset the hilighting printer format and define the color bindings. 
        0 hilight-print .hilight.mode 
        hilight-print .hilight.mode "i"  .scheme.comment 
        hilight-print .hilight.mode "b"  .scheme.keyword .scheme.variable 
        hilight-print .hilight.mode "bi" .scheme.string .scheme.quote 
        ... 

        ; Define the indentation tokens 
        0 indent  .hilight.mode 2 10 
        indent .hilight.mode n "if" 4 
        indent .hilight.mode s "elif" -4 
        indent .hilight.mode s "else" -4 
        indent .hilight.mode o "endif" -4 
        indent .hilight.mode n "while" 4 
        ... 

        define-macro fhook-mode 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                etfinsrt "mode" 
            !endif 
            set-variable $buffer-hilight .hilight.mode 
            set-variable $buffer-indent .hilight.mode 
            1 buffer-mode "time" 
            1 buffer-mode "indent" 
            buffer-abbrev-file "mode" 
        !emacro 

sA
    The previous example shows how the cDfhook-modecA numeric argument is used to 
    determine if this is a new file. If the argument cD@#cA is zero then this is 
    interpreted as a new file, in this case a standard template is inserted 
    (from file cDmode.etfcA) and the generic strings such as cG$YEAR$cA replaced with 
    construction information. The template is generally used for standard 
    headers and skeleton text body. 

    In addition an abbreviation file cDmode.eafcA (see lslmeaf(8)le) is bound to the 
    buffer using the lslmbuffer-abbrev-file(2)le command and the buffer hi-lighting 
    enabled by assignment of the lslm$buffer-hilight(5)le variable. 


cEcEMODIFYING FILE HOOKS cEcA


    The standard hook files supplied with MicroEmacs '02 should not be 
    modified, changes to the file hooks may be applied using a separate macro 
    file called cDmycAcCXXX.emfcA, this is automatically executed after the cDhkcAcCXXX.emfcA 
    file is executed. 

    The extended hook functions may be defined company wide, or by the user, 
    to over-ride some of the standard hook functions, or to extend the syntax 
    of the base files with locally defined extensions. As an example, consider 
    the following file cDmyc.emfcA which extends the basic cDhkc.emfcA file set of 
    hi-lighting tokens for the 'C' Language. 
sB
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
        ; 
        ;  Created By    : Steven Phillips 
        ;  Created       : Thu Jun 18 15:34:05 1998 
        ;  Last Modified : <230798.0854> 
        ; 
        ;  Description   Extension hilighting for the 'C' language. 
        ; 
        ;  Notes         Define the locally defined 'C' library types and definitions 
        ;                as extensions to the 'C' programming language. 
        ; 
        ;  History 
        ; 
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 

        ; MicroEmacs specific tokens 
        hilight .hilight.c 1 "LINE"           .scheme.type 
        hilight .hilight.c 1 "BUFFER"         .scheme.type 
        hilight .hilight.c 1 "WINDOW"         .scheme.type 
        hilight .hilight.c 1 "REGION"         .scheme.type 
        hilight .hilight.c 1 "KEYTAB"         .scheme.type 
        hilight .hilight.c 1 "KILL"           .scheme.type 
        hilight .hilight.c 1 "KLIST"          .scheme.type 
        hilight .hilight.c 1 "HILNODE"        .scheme.type 
        hilight .hilight.c 1 "HILNODEPTR"     .scheme.type 
        hilight .hilight.c 1 "HILCOLOR"       .scheme.type 
        hilight .hilight.c 1 "SELHILIGHT"     .scheme.type 
        hilight .hilight.c 1 "VIDEO"          .scheme.type 
        hilight .hilight.c 1 "VVIDEO"         .scheme.type 
        hilight .hilight.c 1 "FRAMELINE"      .scheme.type 
        hilight .hilight.c 1 "IPIPEBUF"       .scheme.type 
        hilight .hilight.c 1 "DIRNODE"        .scheme.type 
        hilight .hilight.c 1 "UNDOND"         .scheme.type 
        hilight .hilight.c 1 "meVARLIST"      .scheme.type 
        hilight .hilight.c 1 "meVARIABLE"     .scheme.type 
        hilight .hilight.c 1 "meCMD"          .scheme.type 
        hilight .hilight.c 1 "meAMARK"        .scheme.type 
        hilight .hilight.c 1 "meABREV"        .scheme.type 
        hilight .hilight.c 1 "meMACRO"        .scheme.type 
        hilight .hilight.c 1 "meNARROW"       .scheme.type 
        hilight .hilight.c 1 "meREGISTERS"    .scheme.type 
        hilight .hilight.c 1 "meSTAT"         .scheme.type 
        hilight .hilight.c 1 "osdITEM"        .scheme.type 
        hilight .hilight.c 1 "osdDIALOG"      .scheme.type 
        hilight .hilight.c 1 "osdCHILD"       .scheme.type 
        hilight .hilight.c 1 "meSCROLLBAR"    .scheme.type 
        hilight .hilight.c 1 "osdCONTEXT"     .scheme.type 
        hilight .hilight.c 1 "osdDISPLAY"     .scheme.type 
        hilight .hilight.c 1 "RNODE"          .scheme.type 
        hilight .hilight.c 1 "REGHANDLE"      .scheme.type 
        hilight .hilight.c 1 "meDIRLIST"      .scheme.type 
        hilight .hilight.c 1 "meNAMESVAR"     .scheme.type 
        hilight .hilight.c 1 "meDICTADDR"     .scheme.type 
        hilight .hilight.c 1 "meSPELLRULE"    .scheme.type 
        hilight .hilight.c 1 "meDICTWORD"     .scheme.type 
        hilight .hilight.c 1 "meDICTIONARY"   .scheme.type 
        hilight .hilight.c 1 "meMODE"         .scheme.type 

sA

cEcESEE ALSO cEcA


    lslmOperating Modesle, lslanguageTemplates(2)lmLanguage Templatesle, lslmadd-file-hook(2)le, lslmcmode(2m)le. 

! 2 keyNames
cEcEKEY BINDING NAMES cEcA


    Every key which can be generated in MicroEmacs '02 has a character string 
    or name representation which can be used to bind and unbind the key to a 
    command. The name of simple keys like "cGacA" or "cG$cA" is simply the character, 
    i.e. "cGacA" and "cG$cA". Following is a list of other parts to a key name. 


cEModify Keys cA


    There are 3 modifying keys, Shift, Control and Alt, these are represented 
    as "cGS-cA", "cGC-cA", "cGA-cA" respectively. For example the key "cGA-C-S-upcA" is 
    generated when the up cursor key is pressed when Shift, Control and Alt 
    keys where also pressed. 

    The Control and Alt modifiers are case insensitive so cGC-acA is the same as 
    cGC-AcA and cGC-S-acA. 


cEPrefix Keys cA


    Many binding are single stroke key sequences (e.g. "cGC-acA" => 
    beginning-of-line). However MicroEmacs '02 has a lslmprefix(2)le command which 
    can be used to bind up to 8 single stroke keys, turning them into two 
    stroke keys; this greatly increasing the number of available bindable key 
    sequences. For example cDprefix 1cA is bound to the escape character (cGesccA), 
    this allows key sequences like "cGesc acA" to be used. Following is a list of 
    prefixes and their default bindings 

        lsprefix(2)lmprefix 1le => cGesccA 
        lsprefix(2)lmprefix 2le => cGC-xcA 
        lsprefix(2)lmprefix 3le => cGC-hcA 
        lsprefix(2)lmprefix 4le => cGC-ccA 


cESpecial Keys cA


    Following is a complete list of recognized keyboard key names, not all are 
    able to be generated on every platform:- 

        cGbackspacecA, cGdeletecA, cGdowncA, cGendcA, cGesccA, cGf1cA, cGf2cA, cGf3cA, cGf4cA, cGf5cA, cGf6cA, cGf7cA, cGf8cA, cGf9cA, 
        cGf10cA, cGf11cA, cGf12cA, cGf13cA, cGf14cA, cGf15cA, cGf16cA, cGf17cA, cGf18cA, cGf19cA, cGf20cA, cGhomecA, cGinsertcA, 
        cGkp-0cA, cGkp-1cA, cGkp-2cA, cGkp-3cA, cGkp-4cA, cGkp-5cA, cGkp-6cA, cGkp-7cA, cGkp-8cA, cGkp-9cA, cGkp-addcA, 
        cGkp-begincA, cGkp-decimalcA, cGkp-deletecA, cGkp-dividecA, cGkp-downcA, cGkp-endcA, cGkp-entercA, 
        cGkp-homecA, cGkp-insertcA, cGkp-leftcA, cGkp-multiplycA, cGkp-page-downcA, cGkp-page-upcA, 
        cGkp-rightcA, cGkp-subtractcA, cGkp-upcA, cGleftcA, cGpage-downcA, cGpage-upcA, cGreturncA, cGrightcA, 
        cGspacecA, cGtabcA, cGupcA 

    The name of any key can be obtained by using lslmdescribe-key(2)le. 


cEMouse Keys cA


    Following is a list of mouse related keys:- 

    cDmouse-pick-1cA, cDmouse-pick-2cA, cDmouse-pick-3cA, cDmouse-pick-4cA, cDmouse-pick-5cA 
        These keys are generated when the user presses a mouse button, these 
        key events are always created. On most systems button 1 is the left, 2 
        the middle and 3 the right mouse button. If the system only has a 2 
        button mouse then a cGmouse-pick-2cA cannot be generated. The order of the 
        buttons can be revered (i.e. 1 becomes right) and the number of 
        buttons can be set using the lslm$system(5)le variable. Note that X-servers 
        support up to 5 buttons and with the growing popularity of pilot 
        'wheel' mice, the 4th and 5th button are often used to report wheel 
        spin up and down events. The lslmtranslate-key(2)le command can be used to 
        translate these buttons to the mouse wheel keys. 

    cDmouse-drop-1cA, cDmouse-drop-2cA, cDmouse-drop-3cA, cDmouse-drop-4cA, cDmouse-drop-5cA 
        These keys are generated when the user release a mouse button, these 
        key events are always created. 

    cDmouse-move-1cA, cDmouse-move-2cA, cDmouse-move-3cA, cDmouse-move-4cA, cDmouse-move-5cA, 
    cDmouse-movecA 
        These key events are generated when the user moves the mouse and are 
        only if they are bound to a command. The key generated depends on 
        whether a button is being held down by the user, if the user is 
        pressing button 1 then a cGmouse-move-1cA key is created etc. 

    cDmouse-time-1cA, cDmouse-time-2cA, cDmouse-time-3cA, cDmouse-time-5cA, cDmouse-time-5cA, 
    cDmouse-timecA 
        These key events are generated only when they are bound to a command. 
        They are pseudo keys created when the user hold the mouse buttons done 
        for a period of time, see cDPseudo KeyscA below for more information. 

    cDmouse-wheel-upcA, cDmouse-wheel-downcA 
        Pilot mouse wheel events, generated when the wheel is spun up or down 
        respectively. 


cEModifier Keys cA


    The Shift, Control and Alt modifier keys will also generate key input 
    whenever pressed or released. The keys are however only generated if they 
    are bound to a command. The key names are as follows: 

    cDS-pickcA, cDS-dropcA 
        Shift modifier. 

    cDC-pickcA, cDC-dropcA 
        Control modifier. 

    cDA-pickcA, cDA-dropcA 
        Alt modifier. 

    Note that the keys are only generated when another key is pressed, i.e. if 
    the user presses and holds only the shift key, no "cGS-pickcA" key will be 
    generated until another key, such as cGdowncA, is also pressed. If the shift 
    key is released before another key is pressed the event will not be 
    reported. 


cEPseudo Keys cA


    Pseudo keys events cannot be directly created by the user, they are 
    created internally by MicroEmacs. They are treated like normal keys to 
    allow the user to handle the events properly themselves. Following is a 
    complete list of the system generated pseudo keys:- 

    cDbellcA 
        The pseudo key is generated when the bell is rung. 

    cDcallbackcA 
        The pseudo key when a lslmcreate-callback(2)le macro is executed, this 
        allows the executed macro to know it was executed via a 
        create-callback as lslm@cck(4)le will be set to this. 

    cDidle-pickcA, cDidle-dropcA, cDidle-timecA 
        The commands bound to these keys are executed when the system becomes 
        idle for a period of time. See help on lslm$idle-time(5)le for more 
        information. 

    cDmouse-time-1cA, cDmouse-time-2cA, cDmouse-time-3cA, cDmouse-time-4cA, cDmouse-time-5cA, 
    cDmouse-timecA 
        The command bound to these keys are executed when mouse button 1, 2, 
        3, 4, 5 or a combination are held bound for a period of time. See help 
        on lslm$delay-time(5)le for more information. 

    cDredrawcA 
        The command bound to this pseudo key is executed whenever the screen 
        needs redrawing, by default it is bound to lslmscreen-update(2)le. If the 
        user unbinds this key then cDscreen-updatecA is still called, but if the 
        user binds it to a function which does not redraw the screen, such as 
        lslmvoid(2)le, then the screen will not be up-dated. 

    The command executed is always given an argument, a non-zero argument 
    indicates a forced complete redraw, an argument of zero indicates that 
    just an up-date is required. 


cEAlt Key cA


    The cDAlt KeycA has special binding priorities defined as follows:- 

        * Direct key binding (e.g. cDA-bcA executes lsfile-browser(3)lmfile-browserle) 
        * Main menu hot key (e.g. cDA-fcA opens the File menu) 
        * Meta key binding (e.g. cDA-spacecA -> cDesc spacecA -> lsset-mark(2)lmset-markle) 

    If the cGALTcA key is to be used strictly as the Emacs Meta key then the 
    bindings for the menu should be over-ridden by cCDirect Key BindingscA from 
    the user configuration file i.e. to re-map the default MicroEmacs Alt key 
    to equivalent cGesccA keys then the following keys should be re-bound. 
emf-scheme

        global-bind-key forward-word "A-f"      ; Over-ride File menu binding 
        :                                       ; For all of the other menu items. 
        : 
        global-bind-key backward-word "A-b"     ; Over-ride the file browser. 
        global-bind-key replace-string "A-r"    ; Over-ride tools binding. 

ehf-scheme

    This creates a higher priority binding which overrides the underlying 
    default. The commands that are displaced would have to be re-bound to 
    different keys if required. 


cEcEKEYBOARD MACROS cEcA


    Keyboard macros do not store the name of keys, instead a more machine 
    oriented format is used (usually in the form "cG\s??cA") these will work 
    across platforms (assuming the key bindings are the same) but they may not 
    work across different releases. 

    As a result it is advised that any long term macro should avoid named keys 
    like cGupcA in favor of using a standard key binding such as cGC-pcA. See help on 
    lslmexecute-string(2)le for more information. 

! 2mauto
cEcENAME cEcA


    auto - Automatic source file line type detection 


cEcESYNOPSIS cEcA


    cDauto ModecA 

    cDAcA - mode line letter. 


cEcEDESCRIPTION cEcA


    When this mode is enabled the line style of the source file, with respect 
    to cGCR/LF/CTRL-ZcA characters, are automatically detected and the file (if 
    saved) is written out in the same style as it was read in. This mode is 
    designed to solve the problems of MS-DOS which utilize a 'cD\r\ncA' with every 
    new line and a cDctrl-ZcA as a file terminator, conversely UNIX utilizes only 
    'cD\ncA' as a line terminator. 

    cDautocA mode therefore allows files to be edited across file system types 
    without corrupting the line style of the native platform. 

    At load time, if cDautocA detects CR/LF style line feeds then it enables the 
    buffer mode lslmcrlf(2m)le, and if a CTRL-Z is found at the end of the file then 
    mode lslmctrlz(2m)le is enabled. Otherwise these modes are cleared. 

    At write time, if cDautocA mode is enabled then the file is written out is a 
    style determined by modes cDcrlfcA and cDctrlzcA. For example, if crlf was enabled 
    and ctrlz disabled then the file would be written out with new lines as 
    'cD\r\ncA' and with no ending ctrl-z. 

    If auto is not enabled then the file is written out in the style of the 
    current platform, regardless of the current settings on modes cDcrlfcA and 
    cDctrlzcA. 


cEcESUMMARY cEcA


    The operation on the modes may be summarized as follows:- 


cEUNIX Systems cA


        * cDauto EnabledcA UNIX and MS-DOS files may be edited normally, edits are 
          saved in the format read by the system. 
        * cDauto DisabledcA UNIX files may be edited normally, files saved as UNIX 
          files. MS-DOS files show a cG^McA character at the end of each line 
          (editing is not advised if the purity of the MS-DOS is to be 
          maintained), any edits are written back as displayed on the screen. 


cEMS-DOS Systems cA


        * cDauto EnabledcA UNIX and MS-DOS files may be edited normally, edits are 
          saved in the format read by the system. 
        * cDauto DisabledcA on reading all files are read and editing may be 
          undertaken normally. On writing, 'cD\rcA's and a cDctrl-ZcA are 
          automatically added. The act of reading a UNIX file and re-writing 
          it translates it to an MS-DOS file. 


cEcENOTES cEcA


    This mode MUST be enabled globally when the file is loaded for the file 
    style to be correctly detected. 

    It is cDstrongly advisedcA that auto mode is permanently enabled. 

    Windows systems tend to use a 'cD\r\ncA' style line feed but with no trailing 
    ctrl-z. 


cEcESEE ALSO cEcA


    lslmglobal-mode(2)le, lslmbuffer-mode(2)le, lslmcrlf(2m)le, lslmctrlz(2m)le, lslm$buffer-fmod(5)le. 

! 2mbackup
cEcENAME cEcA


    backup - Automatic file backup of last edit 


cEcESYNOPSIS cEcA


    cDbackup ModecA 

    cDBcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDbackupcA mode, when enabled, performs an automatic backup of the last edit 
    when a save file operation is performed. The backup file name is derived 
    from the base file name and is written into the same directory as the 
    source file, the backup file name can be obtained from the variable 
    lslm$buffer-backup(5)le. 

    On unlimited file name length systems the naming convention used depends 
    on bit cD0x400cA of variable lslm$system(5)le, if this bit is set then the system 
    simulates a DOS style 8.3 file naming convention. If this bit is clear 
    then variable lslm$kept-versions(5)le can be used to create multiple backup 
    files. 

    Where an existing backup file already exists, then the old backup file is 
    removed and replaced by the newer backup file. The naming convention for 
    backup files is defined as follows:- 

        On unlimited length file name systems (UNIX and some Windows systems) 
        with a single backup file, the following file naming conventions are 
        used for file cGxxxxxcA: 

            cGxxxxx -> xxxxx~cA 

        On unlimited length file name systems with multiple backup files, the 
        following file naming conventions are used for file cGxxxxxcA: 

            cGxxxxx -> xxxxx.~?~cA 

        Where cG?cA is the backup number, the most recent backup file is always 
        "cG.~0~cA". 

        On systems with an cGxxxxxxxx.yyycA file name (MS-DOS etc), the following 
        file naming conventions are used: 

            cGxxxxxxxx      -> xxxxxxxx.~~~cA 
            cGxxxxxxxx.yyy  -> xxxxxxxx.yy~cA 
            cGxxxxxxxx.yyyy -> xxxxxxxx.yyy~cA 

    The environment variables lslm$MEBACKUPPATH(5)le and lslm$MEBACKUPSUB(5)le can be used 
    to modify this behaviour. 


cEcENOTES cEcA


    cDbackupcA is enabled by default. 

    Reference should also be made to lslmundo(2)le which allows previous edits to be 
    removed. Also see lslm$auto-time(5)le and lslmautosv(2m)le which allows a timed backup 
    of a running edit to be periodically performed. 

    The user is warned to be extra careful if files ending in 'cG~cA' or 'cG#cA's are 
    used, it is advisable to disable backup creation (see lslmglobal-mode(2)le) and 
    auto-saving (cG$auto-time = 0cA). The author denies all responsibility (yet 
    again) for any loss of data! Please be careful. 


cEcESEE ALSO cEcA


    lslm$buffer-backup(5)le. lslm$system(5)le, lslm$kept-versions(5)le, lslm$MEBACKUPPATH(5)le, 
    lslm$MEBACKUPSUB(5)le, lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmundo(2m)le, lslmautosv(2m)le, 
    lslm$auto-time(5)le. 

! 2mcmode
cEcENAME cEcA


    cmode - C Programming language mode 


cEcESYNOPSIS cEcA


    cDcmode ModecA 

    cDCcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDcmodecA mode enters C programming language mode, providing automatic 
    indentation and bracket matching facilities. 

    New users might initially find 'C-mode' a little disconcerting as the cGtabcA 
    key is bound to the automatic formatting command, however the benefits of 
    'C-mode' far out weigh this. A lot of silly programming mistakes may be 
    corrected at source, which are reflected in the layout. An unexpected 
    automatic layout is a sure indication that the input syntax is incorrect - 
    generally as a result of a missing semi-colon or bracket/brace pair. 

    The layout of a C program in cmode is controlled by the C-mode variables. 
    The use of tab characters to create the required indentation is determined 
    by the setting of the buffers lslmtab(2m)le mode. If disabled tab characters are 
    used wherever possible. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmtab(2m)le, lslm$c-brace(5)le, lslm$c-case(5)le, 
    lslm$c-contcomm(5)le, lslm$c-continue(5)le, lslm$c-margin(5)le, lslm$c-statement(5)le. 

! 2mcrypt
cEcENAME cEcA


    crypt - Encrypted file mode 


cEcESYNOPSIS cEcA


    cDcrypt ModecA 

    cDYcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDcryptcA mode enables encrypted files to be loaded and saved for security 
    purposes. The key can be set at any time using the command 
    lslmset-encryption-key(2)le. Warning, take care if setting this as a global 
    mode, it can have side-effects. 

    The encryption algorithm is a Beaufort Cipher with a variant key. This is 
    reasonably difficult to decrypt. When you write out text, if cGcryptcA mode is 
    active and there is no encryption key, MicroEmacs '02 will ask: 

        cGEncryption String:cA 

    Type in a word or phrase of at least five and up to 128 characters for the 
    encryption to use. If you look at the file which is then written out, all 
    the printable characters have been scrambled. To read such a file later, 
    use lslmfind-cfile(3)le to load cCciphertextcA files, you will be asked the 
    encryption key before the file is read. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmfind-cfile(3)le, lslmglobal-mode(2)le, lslmset-encryption-key(2)le. 

! 2mexact
cEcENAME cEcA


    exact - Searching and sorting case sensitivity 


cEcESYNOPSIS cEcA


    cDexact ModecA 

    cDEcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDexactcA mode sets the searching and line sorting commands to case sensitive 
    when enabled (case insensitive when disabled). See lslmsearch-forward(2)le and 
    lslmsort-lines(2)le. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmsearch-forward(2)le, lslmsort-lines(2)le. 

! 2mindent
cEcENAME cEcA


    indent - Automatic indentation 


cEcESYNOPSIS cEcA


    cDindent ModecA 

    cDIcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDindentcA mode, when enabled, ensures that a new text line is automatically 
    indented to the same left hand column as the previous line's first 
    non-white character. If the previous line contains no non-white characters 
    then the line will not be indented. Automatic indentation is disabled when 
    using cCcentercA or cCrightcA justification. cDIndentcA is usually used in conjunction 
    with lslmwrap(2m)le and lslmjustify(2m)le. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmwrap(2m)le lslmjustify(2m)le. 

! 2mjustify
cEcENAME cEcA


    justify - Justification Mode 


cEcESYNOPSIS cEcA


    cDjustify ModecA 

    cDJcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDjustifycA mode, when enabled, performs paragraph justification as designated 
    by lslm$fill-mode(5)le - capable of cCleftcA, cCrightcA, cCbothcA or cCcentercA justification of 
    text. Justify removes all white spaces at the end of the line, if there 
    are no non-white characters on the line then the line is always left 
    empty. If the justification method is cCcentercA or cCrightcA then all white 
    spaces are removed at the beginning of the line. If the line is longer 
    than the lslm$fill-col(5)le or the method is cCleftcA then nothing more is done, 
    else the line is appropriately justified. The method used is set by the 
    variable lslm$fill-mode(5)le. Justify is usually used in conjunction with 
    lslmwrap(2m)le and lslmindent(2m)le. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmwrap(2m)le lslmindent(2m)le, lslm$fill-col(5)le, 
    lslm$fill-mode(5)le. 

! 2mletter
cEcENAME cEcA


    letter - Letter kill policy 


cEcESYNOPSIS cEcA


    cDletter ModecA 

    cDlcA - mode line letter. 


cEcEDESCRIPTION cEcA


    By default individually deleted characters are not added to the kill 
    buffer unless an argument is given to the command. This allows the user to 
    delete characters while preserving the kill buffer, at the expense of not 
    being able to lslmyank(2)le the character back out. Enabling cDlettercA mode ensures 
    that all deleted characters are added to the kill buffer. 


cEcENOTES cEcA


    This mode is implemented for backwards compatability only and the use of 
    it is strongly discouraged as this may alter the behaviour of many on the 
    supporting macros. If this feature is required it would be preferable to 
    use a numeric argument with the delete or backspace key binding as 
    follows: 
sB
        1 global-bind-key backward-delete-char "backspace" 

sA
    The use of the numeric argument of 1 has the same effect. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmyank(2)le, lslmline(2m)le. 

! 2mline
cEcENAME cEcA


    line - Line kill policy 


cEcESYNOPSIS cEcA


    cDline ModecA 

    cDLcA - mode line letter. 


cEcEDESCRIPTION cEcA


    By default an invocation of lslmkill-line(2)le at the left-hand margin will kill 
    the whole line. If cDlinecA mode is enabled and the line contains text then 
    only the text is killed, leaving an empty line. If the line is empty then 
    it is removed. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmletter(2m)le. 

! 2mmagic
cEcENAME cEcA


    magic - Regular expression search 


cEcESYNOPSIS cEcA


    cDmagic ModecA 

    cDMcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDmagiccA mode enables the regular expression search capability used in the 
    search and the replace commands such as lslmsearch-forward(2)le and 
    lslmquery-replace-string(2)le. 

    In the magic mode of MicroEmacs '02, certain characters gain special 
    meanings when used in a search pattern. Collectively they are know as 
    regular expressions, and a limited number of them are supported in 
    MicroEmacs '02. They grant greater flexibility when using the search 
    commands (note that they also affect lslmisearch-forward(2)le commands). 

    The symbols that have special meaning in magic mode are cG^cA, cG$cA, cG.cA, cG\|cA, cG*cA, cG[cA 
    cG]cA, cG\(cA cG\)cA, cG\{cA cG\}cA and cG\cA. 

    The characters cG^cA and cG$cA fix the search pattern to the beginning and end of 
    line, respectively. The cG^cA character must appear at the beginning of the 
    search string, and the cG$cA must appear at the end, otherwise they loose 
    their meaning and are treated just like any other character. For example, 
    in magic mode, searching for the pattern "cGt$cA" would put the cursor at the 
    end of any line that ended with the letter 'cGtcA'. Note that this is 
    different than searching for "cGt<NL>cA", that is, 'cGtcA' followed by a newline 
    character. The character cG$cA (and cG^cA, for that matter) matches a position, 
    not a character, so the cursor remains at the end of the line. But a 
    newline is a character that must be matched, just like any other 
    character, which means that the cursor is placed just after it - on the 
    beginning of the next line. 

    The character 'cG.cA' has a very simple meaning - it matches any single 
    character, except the newline. Thus a search for "cGbad.ercA" could match 
    "cGbadgercA", "cGbaddercA" (slang), or up to the 'cGrcA' of "cGbad errorcA". 

    The character cG*cA is known as closure, and means that zero or more of the 
    preceding character will match. If there is no character preceding, cG*cA has 
    no special meaning, and since it will not match with a newline, cG*cA will 
    have no special meaning if preceded by the beginning of line symbol cG^cA or 
    the literal newline character cG<NL>cA. The notion of zero or more characters 
    is important. If, for example, your cursor was on the line 

        This line is missing two vowels. 


    and a search was made for "cGa*cA", the cursor would not move, because it is 
    guaranteed to match no letter 'cGacA', which satisfies the search conditions. 
    If you wanted to search for one or more of the letter 'a', you would 
    search for "cGaa*cA", which would match the letter cGacA, then zero or more of 
    them, note that this pattern is better searched using "cGa+cA". 

    The character "cG+cA" is the same as "cG*cA" except that it searches for one or 
    more occurrences of the preceding character. 

    The character cG[cA indicates the beginning of a character class. It is 
    similar to the cCanycA (cG.cA) character, but you get to choose which characters 
    you want to match. The character class is ended with the character cG]cA. So, 
    while a search for "cGba.ecA" will match "cGbanecA", "cGbadecA", "cGbalecA", "cGbatecA", et 
    cetera, you can limit it to matching "cGbabecA" and "cGbakecA" by searching for 
    "cGba[bk]ecA". Only one of the characters inside the cG[cA and cG]cA will match a 
    character. If in fact you want to match any character except those in the 
    character class, you can put a cG^cA as the first character. It must be the 
    first character of the class, or else it has no special meaning. So, a 
    search for cG[^aeiou]cA will match any character except a vowel, but a search 
    for cG[aeiou^]cA will match any vowel or a cG^cA. If you have a lot of characters 
    in order that you want to put in the character class, you may use a dash 
    (cG-cA) as a range character. So, cG[a-z]cA will match any letter (or any lower 
    case letter if exact mode is on), and cG[0-9a-f]cA will match any digit or any 
    letter 'cGacA' through 'cGfcA', which happen to be the characters for hexadecimal 
    numbers. If the dash is at the beginning or end of a character class, it 
    is taken to be just a dash. 

    The cG?cA character provides a simple zero or one occurrence test of the 
    previous character e.g. "cGca?rcA" matches "cGcrcA" and "cGcarcA", it will not match 
    "cGcaarcA". 

    Where a previous item has a range of repetitions then the cG\{N,M\}cA syntax 
    may be used to denote the minimum and maximum iterations of the previous 
    item. Where a set quantity of repetitions is required then the simpler 
    syntax of cG\{N\}cA may be used. i.e. "cGca\{2\}rcA" matches "cGcaarcA", "cGca\{2,3\}rcA" 
    matches "cGcaarcA" and "cGcaaarcA". 

    The escape character cG\cA is for those times when you want to be in magic 
    mode, but also want to use a regular expression character to be just a 
    character. It turns off the special meaning of the character. So a search 
    for "cGit\.cA" will search for a line with "cGit.cA", and not "cGitcA" followed by any 
    other character. The escape character will also let you put cG^cA, cG-cA, or cG]cA 
    inside a character class with no special side effects. 

    In lsquery-replace-string(2)lmsearch-replacele strings the cG\(cA cG\)cA pair may be used to group characters 
    for in the search string for recall in the replacement string. The cG\(cA cG\)cA 
    bracket pair is recalled using cG\1cA-cG\9cA in the replace string, cG\1cA is the 
    first pair, cG\1cA the second and so on. Hence to replace cG%dgdg%name%dhdh%cA 
    with cG%dgdg%names%dhdh%cA then we could use the following search replace 
    string cG\(%[a-z]+%\)\([a-z]*\)\(%[a-z]+%\)cA replacing with cG\1\2s\3cA. 

    cG\0cA in the replace string implies the whole string. 

    A summary of magic mode special characters are defined as follows:- 

        cD^cA 
            Anchor search at beginning of line 

        cD$cA 
            Anchor search at end of line 

        cD.cA 
            Match any character except cG<NL>cA 

        cD*cA 
            Match zero or more occurrences of the preceding item. 

        cD\|cA 
            Match either/or i.e. cGcar\|bikecA matches the work cGcarcA and matches 
            the word cGbikecA. 

        cD+cA 
            Match one or more occurrences of the preceding item. 

        cD?cA 
            Match zero or one occurrences of the preceeding item. 

        cD[]cA 
            Match a class of characters (cG[a-z]cA would be all alphabetics) 

        cD\cA 
            Take next literally 

        cD\{cAcCNcAcD,cAcCMcAcD\}cA 
            Match a minimum of cCNcA occurrences and maximum of cCMcA occurrences of 
            the preceeding item. 

        cD\{cAcCNcAcD\}cA 
            Match a cCNcA occurrences of the preceeding item. 

        cD\(...\)cA 
            Delimit pattern to replicate in replace string. Max of 9 allowed. 
            Called in replace string with cG\1cA,..,cG\9cA. 1 being 1st etc. cG\0cA or cG\&cA 
            in the replace string is the whole string. i.e. 

            Search: cD\(ab\)\(dc\)cA 
            Replace: cD\1\2 \1\2cA 
            on "cDabdccA" => "cDabdc abdccA" 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmquery-replace-string(2)le, 
    lslmsearch-forward(2)le. 
    lsRegularExpressions(2)lmRegular Expressionsle 

! 2mover
cEcENAME cEcA


    over - Over-strike Mode 


cEcESYNOPSIS cEcA


    cDover ModecA 

    cDOcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDovercA mode, when enabled, over writes existing text in a buffer as opposed 
    to inserting text. over maintains the position of text aligned with cGtabcA 
    characters. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le. 

! 2mquiet
cEcENAME cEcA


    quiet - Quiet mode 


cEcESYNOPSIS cEcA


    cDquiet ModecA 


cEcEDESCRIPTION cEcA


    When cDquietcA mode is enabled, visual warnings are given instead of the 
    default audible warning. This mode can only be globally changed, an error 
    will occur if an attempt is made to change the mode for a buffer. 

    The default state is on, so users of MicroEmacs '02 can relax in the 
    knowledge that they won't annoy other people when things go wrong. 

    When disabled the system bell is rung when required, otherwise the usual 
    visual warning is the "cC[BELL]cA" string, printed on the bottom right hand 
    side. 


cEcESEE ALSO cEcA


    lslmglobal-mode(2)le. 

! 2mtab
cEcENAME cEcA


    tab - Tabulation mode 


cEcESYNOPSIS cEcA


    cDtab ModecA 

    cDTcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDtabcA mode, when enabled, simulates all tab stops with spaces. This allows 
    'cCvariablecA' tab sizes (see variable lslm$tabsize(5)le) and fixes indentation. If 
    cDtabcA mode is not enabled literal tab characters are inserted, their 
    displayed width may be controlled with the variable lslm$tabwidth(5)le. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le. lslm$tabsize(5)le, lslm$tabwidth(5)le, 
    lslmtabs-to-spaces(3)le. 

! 2mtime
cEcENAME cEcA


    time - File time stamping 


cEcESYNOPSIS cEcA


    cDtime ModecA 

    cDtcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDtimecA mode, when enabled, performs automatic time stamping of files on file 
    write operations. A time stamp string, defined by lslm$timestamp(5)le is 
    searched for in the file and updated with the current data and time 
    information, providing a record in the file of the last edit. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le. lslm$timestamp(5)le. 

! 2mundo
cEcENAME cEcA


    undo - Retain edit modifications 


cEcESYNOPSIS cEcA


    cDundo ModecA 

    cDUcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDundocA mode, when enabled, stores a history of all user edits so that the 
    command lslmundo(2)le may be used to undo the last cCncA edits to a buffer. If this 
    mode is not enabled the cDundocA command has no effect. 

    Obviously memory is required to store this information, particularly 
    storing deleted, reformed or replaced text, users editing large files or 
    operating in restricted memory environments may wish to use this mode 
    selectively. 


cEcENOTES cEcA


    The cDundocA information is flushed, and is effectively lost, when a save 
    operation is performed on the buffer. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le. lslmundo(2)le. 

! 2musr
!32musr1..usr8
cEcENAME cEcA


    usr1 - usr8 - User buffer modes 


cEcESYNOPSIS cEcA


    cDusr1-usr8 ModecA 

    cD1cA-cD8cA - mode line letters. 


cEcEDESCRIPTION cEcA


    cDusr1cA through cDusr8cA modes have no predefined purpose, they are present to 
    provide the user with the ability to store some buffer state. All of these 
    modes are off by default. For example, the user may wish to have two 
    commands bound to the same key, with another command to toggle which one 
    is currently active. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le. 

! 2mview
cEcENAME cEcA


    view - Read only 


cEcESYNOPSIS cEcA


    cDview ModecA 

    cDVcA - mode line letters. 


cEcEDESCRIPTION cEcA


    cDviewcA mode sets the buffer to read-only, disabling the ability to alter the 
    contents of the buffer. This mode is automatically set for any files 
    attributed with a read-only status on the file system when read into 
    MicroEmacs '02. Files loaded via lslmview-file(2)le are also assigned cDviewcA mode. 

    While in cDviewcA mode, any attempt to alter the buffer contents results in 
    the following message:- 

        cG[Key Illegal in view Mode]cA 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmview-file(2)le. 

! 2mwrap
cEcENAME cEcA


    wrap - Line wrap entered text 


cEcESYNOPSIS cEcA


    cDwrap ModecA 

    cDWcA - mode line letters. 


cEcEDESCRIPTION cEcA


    cDwrapcA mode causes automatic text wrapping when text passes then fill column 
    (see lslm$fill-col(5)le), allowing text to be entered non-stop on a standard 
    screen without bothering to use the cGRETURNcA key. 

    cDwrapcA mode is usually used in conjunction with the lslmjustify(2m)le and 
    lslmindent(2m)le modes for editing text documents. 

    cDwrapcA mode also automatically wraps long lines in the output of an 
    lslmipipe-shell-command(2)le to the width of the MicroEmacs '02 window. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmglobal-mode(2)le, lslmipipe-shell-command(2)le lslmjustify(2m)le, 
    lslmindent(2m)le, lslmpipe(2m)le. 

! 2mbinary
cEcENAME cEcA


    binary - Binary editor mode 


cEcESYNOPSIS cEcA


    cDbinary ModecA 

    cDbcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDbinarycA mode is enabled when a file is edited in binary mode. The mode is 
    automatically enabled when a file is loaded as a binary file via 
    lslmfind-bfile(3)le. 

    When a file is loaded using binary mode, every 16 bytes is converted into 
    a line of text giving the hex address of the current position in the file, 
    the bytes as hexadecimal numbers and all printable characters at the end 
    of the line (all non-printable characters are displayed as a 'cG.cA'). 
    However, This format makes it memory hungry in that every 16 bytes of the 
    file requires a 78 character line (approximately 5 times more memory!). 
    For a more memory efficient binary mode see lslmrbin(2m)le. 

    When writing out a file which has binary mode enabled the format of each 
    line must have the binary mode format which is as follows: 

        <address>: XX XX XX XX XX .... XX XX | <text-form> 


    Only the hex values (the cGXXcA's) between the starting 'cC:cA' marker and the 
    terminating '|' character are used, the cC<address>cA and cC<text-form>cA are 
    ignored. 


cEcEEXAMPLE cEcA


    Given a single line MSDOS file:- 

        Live long and prosper. 


    When loaded in using cDbinarycA mode the following 2 line buffer will be 
    produced:- 

        00000000: 4C 69 76 65 20 6C 6F 6E 67 20 61 6E 64 20 70 72  |  Live long and pr 
        00000010: 6F 73 70 65 72 2E 0D 0A 1A                       |  osper.... 


    Note the "cG0D 0A 1AcA" at the end, this is due to MSDOS's "cG\n\rcA" carriage 
    returns and cG^ZcA file termination, these characters are unprintable and are 
    shown as 'cG.cA' at the end of the line. 

    When saving a binary file, only the text between the 'cG:cA' and 'cG|cA' is 
    considered and it may contain any number of hexadecimal numbers. The given 
    file could be made UNIX compatible by editing the buffer to:- 

        00000000: 4C 69 76 65 20 6C 6F 6E 67 20 61 6E 64 20 70 72  |  Live long and pr 
        00000010: 6F 73 70 65 72 2E 0D                       |  osper.... 


    If the word "cDlongcA" is required to be removed, the following would not 
    work:- 

        00000000: 4C 69 76 65 20 6C 6F 6E 67 20 61 6E 64 20 70 72  |  Live and pr 
        00000010: 6F 73 70 65 72 2E 0D 0A 1A                       |  osper.... 


    The ASCII end letters are ignored, instead the following operation must be 
    performed which removes the characters from the binary representation:- 

        00000000: 4C 69 76 65 20 61 6E 64 20 70 72  |  Live long and pr 
        00000010: 6F 73 70 65 72 2E 0D 0A 1A                       |  osper.... 


    One could be nasty by doing the following:- 

        00000000: 4C 69 76 65 20 73 68 6F 72 74 20 61 6E 64 20 | 
        00000010: 64 6F 6E 27 74 20 70 72 6F 73 70 65 72 2E 0D 0A 1A           | 


    ("Live short and don't prosper"). 


cEcENOTES cEcA


    cDrbincA and cDbinarycA modes are mutually exclusive, i.e. they cannot both be 
    enabled at the same time. 


cEcESEE ALSO cEcA


    lslmfind-bfile(3)le, lslmfind-file(2)le, lslmrbin(2m)le. 

! 2mautosv
cEcENAME cEcA


    autosv - Automatic file save 


cEcESYNOPSIS cEcA


    cDautosv ModecA 

    cDacA - mode line letter. 


cEcEDESCRIPTION cEcA


    When this mode is enabled when the buffer is changed it will be 
    automatically saved to a temporary file lslm$auto-time(5)le later. 

    Automatic saving for a buffer will not occur if 

        The buffer name starts with a '*', this is considered a temporary 
        system buffer. 

        lslm$auto-time(5)le is set to 0, this disables auto-saving for all buffers. 

        The buffer does not a file name from which to generate a temporary 
        file name. When this occurs the error message: 

        cG[Auto-writeout failure for buffer xxxxx]cA 

        MicroEmacs '02 can not write to the generated temporary file name. 
        When this occurs the error message: 

        cG[Auto-writeout failure for file xxxxx#]cA 

    On unlimited length file name systems (UNIX), the temporary file naming 
    convention used for file cGxxxxxcA: 

        cGxxxxx -> xxxxx#cA 

    On systems with an cGxxxxxxxx.yyycA file name (DOS etc), the following file 
    naming convention is used: 

        cGxxxxxxxx     -> xxxxxxxx.###cA 
        cGxxxxxxxx.y   -> xxxxxxxx.y##cA 
        cGxxxxxxxx.yy  -> xxxxxxxx.yy#cA 
        cGxxxxxxxx.yyy -> xxxxxxxx.yy#cA 


cEcENOTES cEcA


    This mode MUST be enabled globally when the file is loaded for the file 
    style to be correctly detected. 

    It is cDstrongly advisedcA that autosv mode is permanently enabled. 

    Auto-save files of URL files (i.e. "cGftp://...cA" and "cGhttp://...cA") are 
    written to the system's temporary directory. This avoids potentially slow 
    auto-saves. This can however lead to recovery problems as the buffer name 
    must be used to avoid auto-saving conflict with other buffers with the 
    same base file name but different paths. 


cEcESEE ALSO cEcA


    lslm$auto-time(5)le, lslmbackup(2m)le, lslmfind-file(2)le, lslmftp(3)le. 

! 2mpipe
cEcENAME cEcA


    pipe - Incremental Pipe running 


cEcESYNOPSIS cEcA


    cDpipe ModecA 

    cDPcA - mode line letter. 


cEcEDESCRIPTION cEcA


    This mode indicates whether an incremental pipe (started by 
    lslmipipe-shell-command(2)le) is running in the current buffer. This mode is 
    automatically set and can not be changed by the user. pipe modes main use 
    is in macros. 

    Modes lslmlock(2m)le and lslmwrap(2m)le effect the output behavior of a piped command. 


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmlock(2m)le, lslmwrap(2m)le. 

! 2mlock
cEcENAME cEcA


    lock - Pipe cursor position lock 


cEcESYNOPSIS cEcA


    cDlock ModecA 

    cDkcA - mode line letter. 


cEcEDESCRIPTION cEcA


    This mode can only be used while an incremental pipe (started by 
    lslmipipe-shell-command(2)le) is running in the current buffer, denoted by the 
    lslmpipe(2m)le being set. When this mode is enabled and MicroEmacs '02 buffer 
    cursor is at the same location as the process shell cursor, the buffer 
    cursor is automatically moved with the shell cursor. 

    This mode is automatically enabled for a piped buffer. 


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmpipe(2m)le. 

! 2mhide
cEcENAME cEcA


    hide - Hide buffer 


cEcESYNOPSIS cEcA


    cDhide ModecA 

    cDHcA - mode line letter. 


cEcEDESCRIPTION cEcA


    This mode can only be set on a buffer and when enabled the buffer is 
    effectively hidden from the user. When set the buffer is hidden from the 
    buffer completion list used by commands such as lslmfind-buffer(2)le, the buffer 
    is also ignored by commands lslmlist-buffers(2)le, lslmsave-some-buffers(2)le and 
    lslmdelete-some-buffers(2)le. 


cEcESEE ALSO cEcA


    lslmfind-buffer(2)le, lslmlist-buffers(2)le. 

! 2mnact
cEcENAME cEcA


    nact - Buffer not active 


cEcESYNOPSIS cEcA


    cDnact ModecA 

    cDncA - mode line letter. 


cEcEDESCRIPTION cEcA


    This mode can not be set and is used to indicate that the buffer has not 
    been activated, i.e. the buffer has not been displayed in a window. If the 
    buffer is linked to a file but has not been displayed, so is not active, 
    the file will not have been loaded into the buffer. 

    The lslmlist-buffers(2)le command output denotes active buffers with a '@' 
    character in the left hand column, inactive buffers have a ' '. 

    This mode can not be tested using the more usual lslm&bmode(4)le macro command 
    as it only operates on the current buffer as which point the mode cannot 
    be set. Instead the lslm&nbmode(4)le macro command must be used. 


cEcESEE ALSO cEcA


    lslmlist-buffers(2)le, lslm&nbmode(4)le, lslm&bmode(4)le. 

! 2mcrlf
cEcENAME cEcA


    crlf - File's line feed style 


cEcESYNOPSIS cEcA


    cDcrlf ModecA 

    cDccA - mode line letter. 


cEcEDESCRIPTION cEcA


    When enabled cDcrlfcA indicates that a line feed should be written out in the 
    MS-DOS style of 'cD\r\ncA'. When clear then a UNIX style of 'cD\ncA' should be 
    used. 


cEcENOTES cEcA


    This mode only effects the style in which the buffer is written if 
    lslmauto(2m)le mode is enabled. 


cEcESEE ALSO cEcA


    lslmauto(2m)le, lslmctrlz(2m)le, lslmsave-buffer(2)le, lslmfind-file(2)le, lslm$buffer-fmod(5)le. 

! 2mnarrow
cEcENAME cEcA


    narrow - Buffer contains a narrow 


cEcESYNOPSIS cEcA


    cDnarrow ModecA 

    cDNcA - mode line letter. 


cEcEDESCRIPTION cEcA


    This mode can not be set and is used to indicate whether the buffer 
    contains a narrow, created by the lslmnarrow-buffer(2)le command. 


cEcESEE ALSO cEcA


    lslmnarrow-buffer(2)le. 

! 2mdel
cEcENAME cEcA


    del - Flag buffer to be deleted 


cEcESYNOPSIS cEcA


    cDdel ModecA 

    cDdcA - mode line letter. 


cEcEDESCRIPTION cEcA


    This mode cannot be set globally and is used to flag that the buffer is to 
    be deleted. The state of the mode is displayed in the output of 
    lslmlist-buffers(2)le, if the first column is a 'D' the mode is set, otherwise 
    it is not. Only the execute command in lslmlist-buffers(2)le (bound to 'x') uses 
    this flag to actually delete the buffer. 


cEcESEE ALSO cEcA


    lslmlist-buffers(2)le, lslmsave(2m)le. 

! 2msave
cEcENAME cEcA


    save - Flag buffer to be saved 


cEcESYNOPSIS cEcA


    cDsave ModecA 

    cDScA - mode line letter. 


cEcEDESCRIPTION cEcA


    This mode cannot be set globally and can only be set on a buffer which 
    needs saving. The mode is used to flag that the buffer is to be saved, the 
    state of the mode is displayed in the output of lslmlist-buffers(2)le. If the 
    second column is an 'S' the mode is set, otherwise it is not. Only the 
    execute command in lslmlist-buffers(2)le (bound to 'x') uses this flag to 
    actually save the buffer and the flag is automatically removed as soon as 
    the buffer is saved. 


cEcESEE ALSO cEcA


    lslmlist-buffers(2)le, lslmdel(2m)le. 

! 2mdir
cEcENAME cEcA


    dir - Buffer is a directory listing 


cEcESYNOPSIS cEcA


    cDdir ModecA 

    cDDcA - mode line letter. 


cEcEDESCRIPTION cEcA


    This mode can not be set and is used to indicate that the buffer is a 
    directory listing, created by the lslmfind-file(2)le command when the file name 
    given is a directory. 


cEcESEE ALSO cEcA


    lslmfind-file(2)le. 

! 2medit
cEcENAME cEcA


    edit - Buffer has be changed 


cEcESYNOPSIS cEcA


    cDedit ModecA 

    cDecA - mode line letters. 


cEcEDESCRIPTION cEcA


    cDeditcA mode indicated that the buffer has been edited. Many commands and 
    typing 'edit' the current buffer, automatically setting this mode. 
    Commands which save these edits, such as lslmsave-buffer(2)le, automatically 
    remove this mode. 

    A '*' character, 3 characters from the left on the mode line is used to 
    indicate that this mode is set, see lslm$mode-line(5)le. lslmlist-buffers(2)le also 
    displays the state of this mode in its output, as a '*' in the second 
    column. 

    When this mode is set and lslmundo(2m)le mode is enabled, the lslmundo(2)le command 
    can be used to undo all edits and the removal of this mode. 


cEcESEE ALSO cEcA


    lslmsave-buffer(2)le, lslmundo(2)le, lslmlist-buffers(2)le, lslm$mode-line(5)le, lslmundo(2m)le. 

! 2mctrlz
cEcENAME cEcA


    ctrlz - File's termination style 


cEcESYNOPSIS cEcA


    cDctrlz ModecA 

    cDzcA - mode line letter. 


cEcEDESCRIPTION cEcA


    When enabled cDctrlzcA indicates that an MS-DOS style 'cDctrl-zcA' file 
    termination character should be written out. When clear, a UNIX style of 
    no termination character should be used. 


cEcENOTES cEcA


    This mode only effects the style in which the buffer is written if 
    lslmauto(2m)le mode is enabled. 


cEcESEE ALSO cEcA


    lslmauto(2m)le, lslmcrlf(2m)le, lslmsave-buffer(2)le, lslmfind-file(2)le, lslm$buffer-fmod(5)le. 

! 2mrbin
cEcENAME cEcA


    rbin - Reduced binary editor mode 


cEcESYNOPSIS cEcA


    cDrbin ModecA 

    cDrcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDrbincA mode is enabled when a file is edited in reduced binary mode. The 
    mode is automatically enabled when a file is loaded as a binary data file 
    via lslmfind-file(2)le. 

    When a file is loaded using cDrbincA mode, every 256 bytes is converted into a 
    line of text, the line is a single list of hex numbers 512 characters 
    long, 2 bytes for each character. This format is not very user friend 
    unlike lslmbinary(2m)le mode, but is much more memory efficient (requiring 
    approximately 2 times more memory than the file size). 

    When writing out a file which has rbin mode enabled the format of each 
    line must be correct, namely an even number of hex numbers with no other 
    characters. 


cEcEEXAMPLE cEcA


    Given a single line MSDOS file:- 

        Live long and prosper. 


    When loaded in using cDbinarycA mode the following 2 line buffer will be 
    produced:- 

        4C697665206C6F6E6720616E642070726F737065722E0D0A1A 


    Note the "cG0D 0A 1AcA" at the end, this is due to MSDOS's "cG\n\rcA" carriage 
    returns and cG^ZcA file termination. The given file could be made UNIX 
    compatible by editing the buffer to:- 

        4C697665206C6F6E6720616E642070726F737065722E0D 


cEcENOTES cEcA


    cDrbincA and cDbinarycA modes are mutually exclusive, i.e. they cannot both be 
    enabled at the same time. 


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmbinary(2m)le. 

! 2mfence
cEcENAME cEcA


    fence - Auto fence matching mode 


cEcESYNOPSIS cEcA


    cDfence ModecA 

    cDfcA - mode line letter. 


cEcEDESCRIPTION cEcA


    cDfencecA mode can be used to enable or disable the automatic displaying of 
    and open fence when the corresponding closing fence is typed. When the 
    mode is enabled and the closing fence is typed the cursor is temporarily 
    move to the position of the opening fence. The duration of the move can be 
    controlled by the lslm$fmatchdelay(5)le variable; any user input interrupts the 
    display. 

    If lslmcmode(2m)le is also enabled the search algorithm used is 'cCCcA' aware and if 
    a matching fence is not found then the bell is rung as a warning. If cDcmodecA 
    is not enable any closing fence which cannot be matched is ignored. 


cEcENOTES cEcA


    The following characters are considered closing fences: 

        }  )  ] 


    These are match with the following opening fences respectively: 

        {  (  [ 


cEcESEE ALSO cEcA


    lslm$fmatchdelay(5)le, lslmcmode(2m)le, lslmgoto-matching-fence(2)le. 

! 2 languageTemplates
cEcEFILE LANGUAGE TEMPLATES cEcA


    MicroEmacs '02 provides a large range of macros and templates to deal with 
    the most commonly occurring types of ASCII file that may be edited. 
    However, there is a requirement for users to extend this capability to 
    include more obscure file types, in addition to bespoke files found 
    internally within organizations, or devised by the user. 

    For each file type, MicroEmacs '02 may be tailored to recognize the file 
    and modify it's hilighting, key binding configuration, osd display and 
    indentation to accommodate the file. In addition, new shorthand macros may 
    be introduced to help deal with the contents of the file. 

    This section outlines the steps to be taken to integrate a new file 
    language template into MicroEmacs '02. 


cEThe scope of the File Type cA


    The first step is to decide the scope of the file, this will determine 
    where the file hook should be defined. The options are:- 

    cDA standard file type not supportedcA 
        If this is a standard file type not supported by MicroEmacs '02 then 
        it should be added to cGme.emfcA, in addition lsMicroEmacs '02 - Contact Informationlmcontact usle and we will add 
        it to the standard release. Any macro files associated with this file 
        type should be available globally and are added to the MicroEmacs 
        cCmacrocA directory. 

    cDLocal To your organizationcA 
        If it is a file type local to your organization then it should be 
        added to your cCcompanycA.emf file. Any macro files associated with the 
        file type should be added to your local company MicroEmacs '02 
        directory. 

    cDLocal to an individualcA 
        If this is a file type that is only used by a limited number of 
        individuals then it should be added to the cCusercA.emf file. Any files 
        associated with the file type are added to your local user MicroEmacs 
        '02 directory. 


cERecognizing the File Type cA


    The next step to adding a new file type is to get MicroEmacs '02 to 
    recognize the file as the new type. Recognition is performed by the lsfileHooks(2)lmFileln
    lnHooksle which perform recognition on the file extension and/or the file 
    content. The name of the file type must be determined, this is typically 
    the name of the file prepended by cGhkcA. e.g. a file with extension cCfoocA uses 
    the file cGhkfoo.emfcA for it's language specific definitions. 

    Using the lslmadd-file-hook(2)le invocation the file recognition is bound to the 
    file hook macro whenever the file type is loaded. The file hook is added 
    to the appropriate global, company or user start up file as determined in 
    step 1. The file hooks for file cCfoocA might be defined as follows, depending 
    upon the recognition method:- 

    cDRecognizing the extensioncA 
        To recognize the file extension, then a space separated list of 
        extensions may be defined, including the dot 'cG.cA' (or other) extension 
        separator. 
sB
            add-file-hook ".foo"       fhook-foo 

sA
    cDRecognizing a magic editor string in the filecA 
        If the file type adopts multiple extensions (or does not use a file 
        extension) then an editor specific string may be inserted into the 
        file to enable the editor to recognize it, typically of the form cG-!-cA 
        cCtypecA cG-!-cA, if the string is GNU Emacs compatible then the cG-*-cA 
        convention may be used. The binding is defined as:- 
sB
            -1 add-file-hook "-!-[ \t]*foo.*-!-"           fhook-foo 

sA
    cDRecognizing a magic string in the filecA 
        UNIX files use a "cG#!<path>cA" notation for executable ASCII files. If 
        the file is this type of file (or uses any other type of common string 
        in the as the first characters of a file) then the binding may be 
        defined as follows, in this case we have assumed cCfoocA is the UNIX 
        executable variety i.e. cG#!/usr/local/bin/foocA:- 
sB
            1 add-file-hook "^#!/.*foo" fhook-foo 

sA
    Any, or all of the above recognition methods may be employed to invoke the 
    language specific macro. Note that the methods are evaluated in a LIFO 
    order, hence it is possible to over-ride an existing method. 


cEDefining the Macro File cA


    Once the hook has been defined, the language specific file must be 
    created. Create the language specific file with the same name as defined 
    in the hooks, removing the cDfhook-cA prefix and replacing it with cDhkcA, i.e. 
    cGfhook-foocA invokes the language specific file cGhkfoo.emfcA. Create, the file 
    and add the file hook macro. for example hkcCfoocA.emf contents may be defined 
    as: 
sB
        define-macro fhook-foo 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 
        ml-write "[MicroEmacs foo file hook loaded]" 

sA
    The file hook may be tested by exiting and re-loading MicroEmacs '02, or 
    simply by executing the file containing the cGadd-file-hookcA function. Once 
    the file bindings are installed a cCfoocA file may be loaded and the hook 
    message should be displayed. 


cEModifying an Existing file hook cA


    The standard file hooks supplied with MicroEmacs '02 should not be 
    modified, typically a user will want to extend the repertoire of 
    hi-lighting tokens to encompass locally defined programming libraries or 
    syntactical extensions, in addition to extending support macros that are 
    associated with the file type. In this case, an extension to the hook 
    function is required. The hook file cDmycAcCXXXcAcD.emfcA, allows extensions to be 
    made to the cDhkcAcCXXXcAcD.emfcA, without editing the original file. This may be 
    considered to be an cCincludecA file and is executed, if it exists, after the 
    cDhkcA file has been executed. i.e. if the hook file cDhkfoo.emfcA is already 
    defined and extensions are added to cDmyfoo.emfcA. 

    Note that the cDmycAcCXXXcAcD.emfcA files do not typically include any cDfhook-XXXcA 
    functions, the original cCfhookcA functions would be used. However, if a 
    different buffer environment is required from the one created be the hook, 
    such as a different setting of lslmtab(2m)le mode, the hook function should be 
    copied to cDmycAcCXXXcAcD.emfcA and altered appropriately. 


cEAdding Hilighting definitions cA


    File specific hilighting is used to pick out key words and tokens used 
    within the file type, it greatly improves readability; the hilighting is 
    also used for lsprint-buffer(2)lmprintingle. The hilighting is defined within the body of the 
    file and is executed once when the hook file is loaded, this occurs when 
    the hook function is executed. During development of the hilighting code, 
    it is usually necessary to lsexecute-buffer(2)lmexecutele the hook buffer to view the effects of 
    any changes to the hilighting. 

    The hilighting is defined using the command lslmhilight(2)le which requires a 
    hilighting identifier, used to identify the hilighting scheme. This 
    identifier is dynamically allocated when the hook file is loaded, again 
    using cCfoocA, the identifier is allocated at the top of the file and is 
    protected such that a value is assigned once only. 
sB
        !if &sequal .hilight.foo "ERROR" 
            set-variable .hilight.foo &pinc .hilight.next 1 
        !endif 

sA
    The variable cG.hilight.nextcA allocates unique hilighting numbers, typically 
    a single hilighting number is consumed, incrementing the cG.hilight.nextcA 
    variable ready for the next allocation. The hilighting color scheme is 
    defined in a macro variable cD.hilight.cAcCextcA, where cCextcA is the name of the 
    language scheme (i.e. cCfoocA). 

    Given a hilighting number, the hilighting scheme may be defined. Each of 
    the tokens in the language is assigned a hilighting color, for our simple 
    cCfoocA file type:- 
sB
        0 hilight .hilight.foo 1                $global-scheme 
        hilight .hilight.foo 2 "#"              .scheme.comment 
        hilight .hilight.foo 4 "\"" "\"" "\\"   .scheme.string 
        hilight .hilight.foo 0 "'.'"            .scheme.quote 
        hilight .hilight.foo 0 "'\\\\.'"        .scheme.quote ; '\?' quoted char 

        hilight .hilight.foo 1 "if"             .scheme.keyword 
        hilight .hilight.foo 1 "then"           .scheme.keyword 
        hilight .hilight.foo 1 "else"           .scheme.keyword 
        hilight .hilight.foo 1 "endif"          .scheme.keyword 

sA
    When the hilighting tokens have been defined, the hilighting scheme is 
    bound to the buffer. This is performed by assigning lslm$buffer-hilight(5)le 
    with the hilighting scheme within the cCfhookcA macro body, e.g. 
sB
        define-macro fhook-foo 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

sA
    Putting it all together cGhkfoo.emfcA now comprises:- 
sB
        !if &sequal .hilight.foo "ERROR" 
            ; Allocate a hilighting scheme number 
            set-variable .hilight.foo &pinc .hilight.next 1 
        !endif 

        ; Define the hilighting scheme 
        0 hilight .hilight.foo 1                $global-scheme 
        hilight .hilight.foo 2 "#"              .scheme.comment 
        hilight .hilight.foo 4 "\"" "\"" "\\"   .scheme.string 
        hilight .hilight.foo 0 "'.'"            .scheme.quote 
        hilight .hilight.foo 0 "'\\\\.'"        .scheme.quote ; '\?' quoted char 

        hilight .hilight.foo 1 "if"             .scheme.keyword 
        hilight .hilight.foo 1 "then"           .scheme.keyword 
        hilight .hilight.foo 1 "else"           .scheme.keyword 
        hilight .hilight.foo 1 "endif"          .scheme.keyword 

        ; File hook - called when new file is loaded. 
        define-macro fhook-foo 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

        ; Notification that hook is loaded. 
        ml-write "[MicroEmacs foo file hook loaded]" 

sA

cEAdding a Template cA


    A template inserts initial text into a new file that is created. This 
    mechanism is typically used to insert a standard header into the file on 
    creation. The insertion text is defined within a template file, given the 
    file extension lslmetf(8)le, which is created in the corresponding global, 
    company or user directory as determined in step 1. The template is named 
    cCextcA.etf, so for our example file cCfoocA, the template file is called cGfoo.etfcA. 
    We shall simply add a file header, our comment is cG#cA (as defined by the 
    hilighting tokens). Our example cCfoocA template file cGfoo.etfcA may be defined 
    as follows:- 

        #-!- foo -!- ################################# 
        # 
        #  Created By    : $USER_NAME$ 
        #  Created       : $ASCII_TIME$ 
        #  Last Modified : <160495.1521> 
        # 
        #  Description 
        # 
        #  Notes 
        # 
        #  History 
        # 
        #  Copyright (c) $YEAR$ $COMPANY_NAME$. 
        ############################################## 


    The template file must be explicitly loaded by the hook file, within the 
    cDfhookcA function. A new file condition may be tested within the fhook macro 
    by checking the numerical argument, an argument of 0 indicates that this 
    is a new file. The template file is inserted with an invocation of 
    lslmetfinsrt(3)le. The cDfhookcA macro checks the argument and inserts the template 
    file as follows:- 
sB
        ; File hook - called when new file is loaded. 
        define-macro fhook-foo 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                etfinsrt "foo" 
            !endif 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

sA

cEAdding abbreviations cA


    Abbreviations are short-cut expansions which may be defined for the 
    language specific file. The abbreviations are defined in a lslmeaf(8)le file, 
    cCextcA.eaf, located in the appropriately defined MicroEmacs directory. The 
    abbreviation file defines the key sequences which may be automatically 
    inserted, under user intervention, using lslmexpand-abbrev(2)le. An abbreviation 
    file for cCfoocA, cGfoo.eafcA, may be defined as:- 

        if "if \p\rthen\rendif\P" 
        el "else\r\p\P" 


    The binding to the hook is defined in the cCfhookcA macro using 
    lslmbuffer-abbrev-file(2)le. For the example language file cCfoocA the cCfhookcA macro 
    becomes:- 
sB
        ; File hook - called when new file is loaded. 
        define-macro fhook-foo 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                etfinsrt "foo" 
            !endif 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Set the abbreviation file 
            buffer-abbrev-file "foo" 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

sA

cEAutomatic Indentation cA


    Automatic indentation may be applied to the file, such that the 
    indentation is automatically performed when new lines are entered into the 
    file. Indentation also benefits from automatic re-styling operations using 
    lslmrestyle-region(3)le and lslmrestyle-buffer(3)le. 

    The indentation style is declared by defining language tokens that 
    constitute positions in the syntax where the indentation is changed. The 
    indentation requires a unique identifier to identify the indentation 
    style, the hilighting identifier is used. If hilighting is not defined, 
    then the language template may still obtain an identifier as described in 
    the hilighting section. 

    The indention is create with an argument of cG0cA to the lslmindent(2)le command, 
    the subsequent tokens are defined using cDindentcA with no argument. For our 
    simple cCfoocA syntax then the indentation might be defined as follows:- 
sB
        0 indent  .hilight.foo 2 10 
        indent .hilight.foo n "then" 4 
        indent .hilight.foo s "else" -4 
        indent .hilight.foo o "endif" -4 

sA
    This provides an indentation of the form:- 

        if condition 
        then 
            XXXX 
        else 
            if condition 
            then 
                XXXX 
            endif 
        endif 


    The indentation is bound to the buffer in the cCfhookcA macro by defining 
    lslm$buffer-indent(5)le. For the example file cCfoocA then the cCfhookcA is defined as:- 
sB
        ; File hook - called when new file is loaded. 
        define-macro fhook-foo 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                etfinsrt "foo" 
            !endif 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Assign the buffer indentation 
            set-variable $buffer-indent .hilight.foo 
            ; Set the abbreviation file 
            buffer-abbrev-file "foo" 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

sA

cESetting Buffer Modes cA


    Buffer modes which are to be adopted (or discarded) by the language 
    specific file are defined in the cCfhookcA macro. Typical modes that are 
    applied are:- 

    lstime(2m)lmtimele 
        Enables time stamping on the file, modifying the time stamp field with 
        the modification date and time. 

    lsindent(2m)lmindentle 
        Automatic indentation, where the cursor is returned to the same column 
        on entering a new line, rather than to the start of the line. 

    As an example, the cCfoocA cCfhookcA file becomes:- 
sB
        ; File hook - called when new file is loaded. 
        define-macro fhook-foo 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                etfinsrt "foo" 
            !endif 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Assign the buffer indentation 
            set-variable $buffer-indent .hilight.foo 
            ; Set the abbreviation file 
            buffer-abbrev-file "foo" 
            ; Set up the buffer modes 
            1 buffer-mode "time" 
            1 buffer-mode "indent" 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

sA

cEAssigning New Bindings cA


    New bindings and language specific macros may be added to the language 
    specific file. New macros, to extend the repertoire of commands 
    specifically developed for the language file are defined within the macro 
    body using lslmdefine-macro(2)le these are automatically loaded when the hook 
    file is loaded, which in turn is loaded when the file type is identified 
    and loaded. 

    New bindings, which may be associated with new macros or existing 
    commands, are assigned within the cCfhookcA macro. As an example, we shall 
    extend the cCfoocA language file to include a commenting and uncommenting 
    macros, locally binding the macros to the keys "cGC-c C-ccA" and "cGC-c C-dcA" 
    respectively. The macro definitions are defined as follows:- 
sB
        ; Macro to comment a line 
        define-macro foo-comment-line 
            !while &gre &pdec @# 1 0 
                beginning-of-line 
                insert-string "#" 
                beginning-of-line 
                forward-line 
            !done 
        !emacro 

        ; Macro to remove a comment from a line 
        define-macro foo-uncomment-line 
            !while &gre &pdec @# 1 0 
                beginning-of-line 
                -1 search-forward "#" 
                backward-delete-char 
                forward-line 
            !done 
        !emacro 

sA
    The key bindings for the macros are defined for the local buffer ONLY, as 
    such are added using lslmbuffer-bind-key(2)le. The bindings are declared in the 
    cCfhookcA macro as follows:- 
sB
        ; File hook - called when new file is loaded. 
        define-macro fhook-foo 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                etfinsrt "foo" 
            !endif 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Assign the buffer indentation 
            set-variable $buffer-indent .hilight.foo 
            ; Set the abbreviation file 
            buffer-abbrev-file "foo" 
            ; Set up the buffer modes 
            1 buffer-mode "time" 
            1 buffer-mode "indent" 
            ; Set up local bindings 
            buffer-bind-key foo-comment-line "C-c C-c" 
            buffer-bind-key foo-uncomment-line "C-c C-d" 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

sA

cEAllowing Other to Modify the Hook cA


    Other users of the file hook may need to modify or extend the file hook, 
    the most common form is the addition of user specific hilight tokens. 
    MicroEmacs uses a simple mechanism of executing a user hook extension file 
    if it exists. The extension file name must be of the form cDmycAcCXXXcAcD.emfcA, i.e. 
    for our example it must be "cGmyfoo.emfcA". This is performed at the end of 
    the macro file so that anything within the file can be altered, it is 
    executed as follows:- 
sB
        ; load in user extensions if found 
        !force execute-file "myfoo" 

sA
    Note the lslm!force(4)le directive is used as the file may not exist. 


cESumming Up cA


    The previous sections have presented the basic steps involved in setting 
    up a new language file template. They cater for simple file types, for 
    more complex examples then browse the cDhkcAcCxxxcA.emf files. 

    The completed files that should have been generated by following the 
    previous examples are now presented:- 

    cDfile.foocA 

        # This is a comment. 
        if condition 
        then 
            do something 
        else 
            if condition 
            then 
                do something 
            endif 
        endif 


    cDhkfoo.emfcA 
sB
        !if &sequal .hilight.foo "ERROR" 
            ; Allocate a hilighting scheme number 
            set-variable .hilight.foo &pinc .hilight.next 1 
        !endif 

        ; Define the hilighting scheme 
        0 hilight .hilight.foo 1                $global-scheme 
        hilight .hilight.foo 2 "#"              .scheme.comment 
        hilight .hilight.foo 4 "\"" "\"" "\\"   .scheme.string 
        hilight .hilight.foo 0 "'.'"            .scheme.quote 
        hilight .hilight.foo 0 "'\\\\.'"        .scheme.quote ; '\?' quoted char 

        hilight .hilight.foo 1 "if"             .scheme.keyword 
        hilight .hilight.foo 1 "then"           .scheme.keyword 
        hilight .hilight.foo 1 "else"           .scheme.keyword 
        hilight .hilight.foo 1 "endif"          .scheme.keyword 

        ; File hook - called when new file is loaded. 
        define-macro fhook-foo 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

        ; Define the indentation scheme 
        0 indent  .hilight.foo 2 10 
        indent .hilight.foo n "then" 4 
        indent .hilight.foo s "else" -4 
        indent .hilight.foo o "endif" -4 

        ; Reset the hilighting printer format and define the color bindings. 
        0 hilight-print .hilight.foo 
        hilight-print .hilight.foo "i"  .scheme.comment 
        hilight-print .hilight.foo "b"  .scheme.keyword 
        hilight-print .hilight.foo "bi" .scheme.string .scheme.quote 

        ; Macro to comment a line 
        define-macro foo-comment-line 
            !while &gre &pdec @# 1 0 
                beginning-of-line 
                insert-string "#" 
                beginning-of-line 
                forward-line 
            !done 
        !emacro 

        ; Macro to remove a comment from a line 
        define-macro foo-uncomment-line 
            !while &gre &pdec @# 1 0 
                beginning-of-line 
                -1 search-forward "#" 
                backward-delete-char 
                forward-line 
            !done 
        !emacro 

        ; File hook - called when new file is loaded. 
        define-macro fhook-foo 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                etfinsrt "foo" 
            !endif 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Assign the buffer indentation 
            set-variable $buffer-indent .hilight.foo 
            ; Set the abbreviation file 
            buffer-abbrev-file "foo" 
            ; Set up the buffer modes 
            1 buffer-mode "time" 
            1 buffer-mode "indent" 
            ; Set up local bindings 
            buffer-bind-key foo-comment-line "C-c C-c" 
            buffer-bind-key foo-uncomment-line "C-c C-d" 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

        ; Notification that hook is loaded. 
        ml-write "[MicroEmacs foo file hook loaded]" 

        ; load in user extensions if found 
        !force execute-file "myfoo" 

sA
    cDfoo.eafcA 

        if "if \p\rthen\rendif\P" 
        el "else\r\p\P" 


    cDfoo.etfcA 

        #-!- foo -!- ################################# 
        # 
        #  Created By    : $USER_NAME$ 
        #  Created       : $ASCII_TIME$ 
        #  Last Modified : <160495.1521> 
        # 
        #  Description 
        # 
        #  Notes 
        # 
        #  History 
        # 
        #  Copyright (c) $YEAR$ $COMPANY_NAME$. 
        ############################################## 


cEcESEE ALSO cEcA


    lslmadd-file-hook(2)le, lslmbuffer-abbrev-file(2)le, lslmetfinsrt(3)le, lslmexecute-buffer(2)le, 
    lslmexpand-abbrev(2)le, lslmglobal-abbrev-file(2)le, lslmhilight(2)le, lslmscheme-editor(3)le, 
    lslmindent(2)le, lslmindent(2m)le, lslmrestyle-buffer(3)le, lslmrestyle-region(3)le, lslmtime(2m)le, 
    lslm$buffer-hilight(5)le, lslm$buffer-indent(5)le, lslmetf(8)le, lslmeaf(8)le, 
    lsfileHooks(2)lmFile Hooksle. 

! 1 Installation
cEcEINSTALLATION cEcA


    This page describes introductory notes for the installation and setup of 
    MicroEmacs '02. 


cEQuick Install cA


    The quickest way to install MicroEmacs without reading the rest of this 
    document is to:- 

        * Create a new directory i.e. cGmecA or cGmicroemacscA. 
        * Unpack the macros archive into this directory. 
        * Unpack any spelling dictionaries into this directory. 
        * Unpack the executable into this directory. 
        * Run cGmecA from this directory. 

    On starting, use the mouse and configure the user from the menu bar:- 

        Help->User Setup 


    This allows the user and screen settings to be altered. On becoming more 
    accustomed to the editor then a fuller installation may be performed. 

    cDGetting HelpcA 
        See lslmContact Informationle for full contact information. A mail archive 
        exists at:- 

            http://groups.yahoo.com/group/jasspa/ 


        If you wish to participate in the list then you must first register by 
        sending an empty mail message body to:- 

            jasspa-subscribe@yahoogroups.com 


        You will then be able to mail any questions into the group. 
        Registration is required in order to prevent cCspamcA mailings from 
        entering into the lists. 


cEDistribution cA


    MicroEmacs is distributed in the following files:- 

    cDComplete Installations cA
        The Microsoft '95/'98/NT platforms may be installed using the cDInstallcA 
        cDShieldcA installation utility and do not require the components 
        specified in later sections. cGjasspame.execA - '95/'98/NT Self Extracting 
        Install Shield Installation 

    cDExecutable Source Code cA
        The source code release for MicroEmacs '02 contains makefiles (cG*.makcA) 
        for all supported platforms. Microsoft '95/'98/NT makefiles contain 
        options at the top of the makefile to enable/disable console and URL 
        support. cGmesrc.zipcA - Source code for all platforms 
        cGmesrc.tar.gzcA - Source code 

    cDExecutable Images cA
        cGmedos.zipcA - DOS Executable 
        cGmewin32.zipcA - Windows 32' (95/98/NT) Executable 
        cGmewin32s.zipcA - Windows win32s (Win3.1/3.11) Executable 
        cGmeirix6.gzcA - Silicon Graphics Irix 6 Executable 
        cGmeaix43.gzcA - IBM's AIX 4.3 Executable 
        cGmehpux10.gzcA - Hewlett Packard HP-UX 10 Executable 
        cGmehpux11.gzcA - Hewlett Packard HP-UX 11 Executable 
        cGmesunos55.gzcA - Sun OS 5.5 Executable 
        cGmesunos56.gzcA - Sun OS 5.5 Executable 
        cGmesolx86.gzcA - Sun Solaris 2.6 Intel Platform Executable 
        cGmelinux20.gzcA - Linux 2.0.0 Executable 
        cGmefreebsd.gzcA - Free BSD Executable 

    cDHelp File ImagescA (all platforms) 
        cGmewinhlp.zipcA - Windows Help file 
        cGmehtm.zipcA  - HTML Help files for 8.3 file systems (.htm) 
        cGmehtml.tar.gzcA - HTML Help files (.html) 

    cDMacro File ImagescA (all platforms) 
        cGmemacros.zipcA - Macro files 
        cGmemacros.tar.gzcA - Macro files 

    cDSpelling DictionariescA (all platforms) 
        One of the following base dictionaries is required for spelling. The 
        extended dictionaries require the base dictionary and are recommended 
        for a more comprehensive spelling list. Other languages are supported. 

        cGlsdmenus.zipcA - American rules and base dictionary. 
        cGlsdxenus.zipcA - American extended dictionary. 
        cGlsdmengb.zipcA - British rules and base dictionary. 
        cGlsdxengb.zipcA - British extended dictionary. 
        cGlsdmfrfr.zipcA - French rules and dictionary. 
        cGlsdmdede.zipcA - German rules and base dictionary. 
        cGlsdxdede.zipcA - German extended dictionary. 
        cGlsdmitit.zipcA - Italian rules and dictionary 
        cGlsdmplpl.zipcA - Polish rules and dictionary. 
        cGlsdmptpt.zipcA - Portuguese rules and dictionary. 
        cGlsdmeses.zipcA - Spanish rules and dictionary. 

        cGlsdmenus.tar.gzcA - American rules and base dictionary. 
        cGlsdxenus.gzcA - American extended dictionary. 
        cGlsdmengb.tar.gzcA - British rules and base dictionary. 
        cGlsdxengb.gzcA - British extended dictionary. 
        cGlsdmfrfr.tar.gzcA - French rules and dictionary. 
        cGlsdmdede.tar.gzcA - German rules and base dictionary. 
        cGlsdxdede.gzcA - German extended dictionary. 
        cGlsdmitit.tar.gzcA - Italian rules and dictionary 
        cGlsdmplpl.tar.gzcA - Polish rules and dictionary. 
        cGlsdmptpt.tar.gzcA - Portuguese rules and dictionary. 
        cGlsdmeses.tar.gzcA - Spanish rules and dictionary. 

        cDNOTE:cA The binary versions of the executables held on the site include 
        the platform name as part of the executable name i.e. cDmecA for cGDOScA is 
        called cDmedos.execA. On installing the binaries onto the target machine, 
        you should rename the executable to cDmecA or cDme.execA, whatever is 
        appropriate. The ONLY exception to this rule is the Microsoft Windows 
        executable where cDmewin32.execA should be renamed to cDme32.execA. Our reason 
        for this naming is to allow the executables to be unpacked in the same 
        directory and not be confused with each other. 


cEQuick Start Guild For All Platforms cA


    Simply create a directory, down-load the files required (see list for each 
    platform below) and extract into this directory. From a shell or command 
    prompt, change to the directory, making it the current one (i.e. cDcdcA to 
    it), and run the executable. MicroEmacs '02 should open with the on-line 
    help page visible. 

    On Windows based systems this can also be achieved by creating a short-cut 
    and setting the Working Directory in Properties to this path. 

    To enable MicroEmacs to be run from any directory, simply include this 
    directory in you cDPATHcA environment variable. Alternatively, copy the 
    executable to somewhere in your PATH and set the environment variable 
    ls$search-path(5)lmMEPATHle to point to this directory. 

    MicroEmacs '02 will function normally in this environment, but in 
    multi-user environments and for up-dating purposes, it is strongly 
    recommended that a proper installation is used, see below. 


cEInstallation cA


    cDDOScA 

        Executable: 
            Compiled with DJGPP V1.0 

        Distribution components required: 
            cGmedos.zipcA 
            cGmemacros.zipcA 
            cC<spelling>cAcG.zipcA 

            cGmewinhlp.zipcA if you are using windows 3.1/3.11 

        Recommended installed components: 
            cG4doscA - Command shell (giving cCstderrcA redirection). 
            cGgrepcA - Version of grep (djgpp recommended) 
            cGmakecA - Version of make (djgpp recommended) 
            cGdiffcA - Version of diff (djgpp recommended) 

        Installation: 
            Create the directory cGc:\mecA (or other location) 

            Unzip the MicroEmacs components into cGc:\mecA 

            Edit "cGc:\autoexec.batcA" and add the following lines:- 

                SET MENAME=<name> 
                SET PATH=%PATH%;c:\me 
                SET MEPATH="c:\me" 


            Reboot the system. 

                MicroEmacs may be run from the command line using 

                me 


        Graphics Cards: 
            MicroEmacs may be configured to the text modes of your graphics 
            card. Refer to you graphics card DOS text modes to identify the 
            text modes supported by your monitor. The text mode number may be 
            entered into the user monitor configuration, defined in cDHelpcA->cDUser 
            SetupcA. 

        Running From Windows (3.x) 
            The DOS version of MicroEmacs may be executed from a cD.pifcA file. 
            Use the pif editor to create a new cD.pifcA file to launch MicroEmacs. 
            The size of the DOS window may be configured from the command 
            line, set the terminal size using one of the following command 
            lines:- 

                me -c -v$TERM=E80x50        - 80 x 50 window 
                me -c -v$TERM=E80x25        - 80 x 25 window. 


            We usually add the cG-ccA option so that MicroEmacs is executed with 
            history information. This may be omitted if required. 

    cDWindows 3.1/3.11cA 

        Executable: 
            Compiled with Microsoft Developer 2.0 

        Helper DLL: 
            Under cDWin32scA a helper DLL cDmethnk16.dllcA is required to perform the 
            lslmpipe-shell-command(2)le in a synchronous manner. This should be 
            installed into the cGC:\WINDOWS\SHELLcA directory. This (rather 
            inelegantly) gets around the problems of spawning a process under 
            cDwin32scA due to a number of Microsoft bugs in the operating system. 
            Note: that on a spawn operation a cGMS-DOScA window is visible, this 
            is due to the nature of the command shell on this platform which 
            has a tendency to prompt the user at every opportunity, hence a 
            certain amount of interaction (which is out of our control) is 
            necessary. 

            The helper DLL is compiled with a 16-bit Windows compiler - MSVC 
            1.5. 

        Distribution components required: 
            cGmewin32s.zipcA 
            cGmemacros.zipcA 
            cGmewinhlp.zipcA 
            cC<spelling>cAcG.zipcA 

        Recommended installed components: 
            cG4doscA - command shell (giving cCstderrcA redirection) 
            cGgrepcA - Version of grep (GNU port of grep recommended) 
            cGdiffcA - Version of diff (GNU port of grep recommended) 
            cGmakecA - use nmake or GNU port of make. 

        win32s 
            cDwin32scA is a requirement on this platform, typically taken from 
            cDpw1118.execA which freely available on the Internet. 

        Installation: 
            This version of Windows does not have a cCinstallcA directory as 
            '95/'98 and it is expected that the cGMS-DOScA version will coexist. 
            No cCInstallcA cCShieldcA installation is provided. Install in a directory 
            structure similar to cGMS-DOScA. Install the helper DLL cDmethnk16.dllcA 
            in the cGC:\WINDOWS\SHELLcA directory. Create a lslmme32.ini(8)le file in 
            the cGC:\WINDOWScA directory to identify the location of the 
            MicroEmacs '02 components, this much the same as the '95/'98 file, 
            change the directory paths to suite the install base. 

        Support Status: 
            The cDwin32scA release has not been used with vengeance, although no 
            specific problems have been reported with this release. 

    cDWindows '95/'98/NTcA 

        Executable: 
            Compiled with Microsoft Developer 5.0 

        Install Shield 
            An cDInstall ShieldcA version of MicroEmacs is available which 
            includes all of the distribution components. 

        Distribution components required: 
            cGmewin32.zipcA 
            cGmemacros.zipcA 
            cC<spelling>cAcG.zipcA 
            cGmewinhlp.zipcA (optional) 

        Recommended installed components: 
            cG4doscA or cG4ntcA - command shell 
            cGgrepcA - Version of grep (GNU port of grep recommended) 
            cGdiffcA - Version of diff (GNU port of grep recommended) 
            cGmakecA - use nmake or GNU port of make. 

        Installation: 
            Create the directory "cGC:\Program Files\Jasspa\MicroEmacscA" (or 
            other location) 

            Unzip the MicroEmacs components into "cGC:\Program 
            Files\Jasspa\MicroEmacscA" 

            Create the file "cGc:\windows\me32.inicA" and add the following 
            lines:- 

                [Defaults] 
                mepath=C:\Program Files\Jasspa\MicroEmacs 
                userPath=C:\Program Files\Jasspa\MicroEmacs 
                fontfile=dosapp.fon 


            Create a short cut to MicroEmacs for the Desktop 

            Right click on the desk top 

                => New 
                => Short 
                => Command Line: "c:\Program Files\Jasspa\MicroEmacs\me.exe -c" 
                => Short Cut Name: "MicroEmacs" 


            MicroEmacs may be executed from the shortcut. 

        Open Actions 
            Microsoft Windows 95/98/NT provide short cut actions, assigning an 
            open action to a file. The short cuts may be installed from the 
            cDInstall ShieledcA installation, but may alternativelly be explictly 
            defined by editing the registry file with cDregedit(1)cA. 

            A file open action in the registry is bound to the file file 
            extension, to bind a file extension cC.foocA to the editor then the 
            following registry entries should be defined:- 

                [HKEY_CLASSES_ROOT\.foo] 
                "MicroEmacs_foo" 
                [HKEY_CLASSES_ROOT\MicroEmacs_foo\DefaultIcon] 
                "C:\Program File\JASSPA\MicroEmacs\meicons,23" 
                [HKEY_CLASSES_ROOT\MicroEmacs_foo\Shell\open] 
                "&Open" 
                [HKEY_CLASSES_ROOT\MicroEmacs_foo\Shell\open\command] 
                "C:\Program File\JASSPA\MicroEmacs\me32.exe -o "%1"" 


            In the previous exaple the cCDefaultIconcA entry is the icon assigned 
            to the file. This may be an icon taken from cGmeicons.execA (in this 
            case icon number 23), or may be some other icon. The open action 
            in the example uses the cD-ocA option of the cCclient-servercA, which 
            loads the file into the current MicroEmacs '02 session, 
            alternatively the cD-ccA option may be used to retain the previous 
            context, or no option if a new session with no other files loaded 
            is started. 

            A generic open for ALL files may be defined using a wildcard, this 
            may be used to place a cCMicroEmacscA edit entry in the right-click 
            popup menu, as follows:- 

                [HKEY_CLASSES_ROOT\*\shell] 
                [HKEY_CLASSES_ROOT\*\shell\MicroEmacs] 
                "&MicroEmacs" 
                [HKEY_CLASSES_ROOT\*\shell\MicroEmacs\command] 
                "C:\Program File\JASSPA\MicroEmacs\me32.exe -o "%1"" 


    cDUNIXcA 

        Executable: 
            Compiled with native compilers. 

        Distribution Components Required: 
            cGmecAcC<unix>cAcG.gzcA 
            cGmemacros.tar.gzcA 
            cC<spelling>cAcG.gzcA 
            cGhtml.tar.gzcA (optional) 

        Installation: 
            It is recommended that all files are placed in cG/usr/localcA, 
            although they may be installed locally. 

            Unpack the executable and placed in "cG/usr/local/bincA" 

            Create the new directory "cG/usr/local/microemacscA", unpack and 
            install the cGmemacros.tar.gzcA into this directory. 

            For cDcsh(1)cA users execute a "cGrehashcA" command and then lslmme(1)le can be 
            executed from the command line. 

            By default a X-Windows terminal is displayed, ensure that cG$DISPLAYcA 
            and cG$TERMcA are correctly configured. To execute a terminal 
            emulation then execute cDmecA with the cG-ncA option i.e. "cGme -ncA". Note 
            that this is not required if you are using a cGvt100cA emulation. 


cEOrganizing a local user profile cA


    MicroEmacs uses local user configuration profiles to store user specific 
    information. The user information may be stored in the MicroEmacs 
    directory, or more typically in a users private directory. The environment 
    variable cG$MENAMEcA is typically used to determine the identity of the user. 

    The location of the user profile will depend upon your installation 
    configuration. 

    cDSingle Machine cA
        For a single user machine it is typically easiest to use the installed 
        MicroEmacs directory where user specific files are placed. This 
        method, although not recommended, is simple as all files that are 
        executed are in the same location. The cG$MEPATHcA is not changed. 

    cDUNIX cA
        The UNIX environment is fairly easy and operates as most other UNIX 
        applications. The user should create a MicroEmacs directory in their 
        home directory for their own local configuration. Assigning a suitable 
        name such as "cGmicroemacscA", or if the file is to be hidden 
        "cG.microemacscA". 

        The cG$MEPATHcA environment variable of the user should be modified to 
        include the users MicroEmacs path BEFORE the default macros MicroEmacs 
        path i.e. 

        Ksh/Zsh: 
            cGexport MEPATH=$HOME/microemacs:/usr/local/bincA 

        Csh/Bash: 
            cGsetenv MEPATH $HOME/microemacs:/usr/local/bincA 

        Where cG$HOMEcA is defined as "cG/usr/<name>cA" (typically by default). 

    cDDOS/Windows cA
        DOS and Windows are a little more tricky as numerous directories at 
        the root level are more than a little annoying. It is suggested that 
        the user directory is created as a sub-directory of the MicroEmacs 
        directory. i.e. 

            "cGc:\me\cAcC<user>cA" for DOS 

        or 
            "cGc:\Program Files\Jasspa\MicroEmacs\cAcC<user>cA" for Windows 

        The cG$MEPATHcA environment variable (see lslmme32.ini(8)le for Windows) is 
        modified to include the user component before the MicroEmacs component 
        where cG$MEPATHcA is defined i.e. 

            SET MEPATH=c:\me\<user>;c:\me 


        where cG<user>cA is the user name (or cG$MENAMEcA). 


cEAlternative Directory Configurations cA


    Numerous other configurations exist to organize the macro directories, to 
    take the directory organization to the extreme then it is sometimes 
    easiest to keep all of the macro components separate. An installation 
    layout which encompasses different macro directories for:- 

        * User profiles - 1 per user. 
        * Shared company profiles - 1 per organization. 
        * MicroEmacs macros which are updated from time to time. 

    The configuration on different systems may be defined as follows:- 

    cDUNIX cA
        The shared files are placed in cG/usr/localcA 

            /usr 
               \ 
              local 
                 \ 
              microemacs   - Spelling + standard macros 
                   \ 
                 company   - Company specific files 


        The user profile is stored in the users directory 

            /usr 
              \ 
            <name> 
                \ 
             microemacs    - User specific files 


        The user should configure the cG$MEPATHcA as: 

            MEPATH=$(HOME)/microemacs:/usr/local/microemacs/company:/usr/local/microemacs 


    cDDOS/WINDOWS cA
        For DOS and MS-Windows environments, bearing in mind the problem of 
        the root directory, then it is easier to use the "cGmecA" directory as a 
        place holder for a number of sub-directories, using a configuration 
        such as:- 

                        c: 
                        | 
                        me      - Place holder directory 
                      / | \ 
                    /   |   \ 
               <name> macros company 


        The user should configure the cG$MEPATHcA as:- 

            SET MEPATH=c:\me\<name>;c:\me\company;c:\me\macros 


cEUser Profile Files cA


    Files contained in the user profiles typically include:- 

    cC<name>cAcG.emfcA - The users start up profile. 
    cC<name>cAcG.edfcA - The users spelling dictionary. 
    cC<name>cAcG.erfcA - The users registry configuration file. 

    These files are established from the menu "cDHelp->User SetupcA". The "cDSetup 
    PathcA" item defines the location of the files, but must be MANUALLY 
    included in the cG$MEPATHcA environment. 


cECompany Profiles cA


    Company profiles include standard files and extensions to the standard 
    files which may be related to a company, this is typically cC<company>cA.emf 
    where cC<company>cA is the name of the company. 

    The directory may also include template files lslmetf(8)le files which defines 
    the standard header template used in the files. Files in the "cGcompanycA" 
    directory would over-ride the standard template files. 

    The company directory should be added to the cG$MEPATHcA after the user 
    profile and before the MicroEmacs standard macro directory. 


cEcESEE ALSO cEcA


    lslm$MENAME(5)le, lslm$MEPATH(5)le, lsCompanyProfiles(2)lmCompany Profilesle, lsfileHooks(2)lmFile Hooksle, lslanguageTemplates(2)lmFile Languageln
    lnTemplatesle, lsUserProfiles(2)lmUser Profilesle. 

! 2 CompanyProfiles
cEcECOMPANY PROFILES cEcA


    This section describes how a company profile should be incorporated into 
    MicroEmacs '02. A company profile defines a set of extensions to 
    MicroEmacs which encapsulate settings which are used on a company wide 
    basis. This type of configuration is typically used with a networked 
    (shared) installation. The company profile would typically include:- 

        * Name of the company. 
        * Standard header files including company copyright statements. 
        * Standard file layouts 
        * Company defined language extensions. 


cELocation Of The Company Information cA


    It is suggested that all of the company extensions applied to MicroEmacs 
    '02 are performed in a separate directory location which shadows the 
    MicroEmacs standard macro file directory. This enables the original files 
    to be sourced if a user does not want to include the company files. This 
    method also allows MicroEmacs to be updated in the future, whilst 
    retaining the company files. For our example, we shall use a company 
    called cDJASSPAcA, you should replace references to cCjasspacA with your own 
    company name. The steps involved are laid out as follows:- 

    cDCreate a new company directory cA
        You may skip this step if you are going to modify the standard 
        installation. 

        Create a new directory to hold the company information. i.e. 

            cG/usr/local/microemacs/jasspacA - UNIX 
            cGc:\Program Files\JASSPA\MicroEmacs\jasspacA - Microsoft 

        Modify the lslm$MEPATH(5)le of the (of all users) to include the company 
        directory on the search path i.e. 

        UNIX 
            Users edit their local cG$MEPATHcA or a base $MEPATH is added to the 
            system cG.logincA or cG.profilecA scripts. 

                cGMEPATH=/usr/local/microemacscA 
                cGMEPATH=/usr/local/microemacs/jasspa:$MEPATHcA 

        Microsoft Windows Platforms 
            Edit the cGme32.inicA file and modify the cGmepathcA entry to reflect the 
            location of the company directory:- 

                cGmepath=C:\Prog....\Mic...\macros\
                jasspa;C:\Prog...\Mic...\macroscA 

        DOS Platforms 
            Edit the cDautoexec.batcA file and modify cGMEPATHcA to include the 
            company directory location. 

                cGSET MEPATH=c:\me\jasspa;c:\mecA 


cEContent Of The Company Information cA


    cDCompany macro file cA
        The company file is typically called by the company name (i.e. 
        cGjasspa.emfcA) create a new company file. The file includes your company 
        name and hook functions for any new file types that have been defined 
        for the company, an example company file for cDJasspacA might be defined 
        as:- 
sB
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
            ; 
            ;  Author        : Jasspa 
            ;  Created       : Thu Jul 24 09:44:49 1997 
            ;  Last Modified : <190698.2225> 
            ; 
            ;  Description     Extensions for Jasspa 
            ; 
            ;  Notes 
            ; 
            ;  History 
            ; 
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
            ; Define the name of the company. 
            set-variable %company-name "Jasspa" 
            ; Add Jasspa specific file hooks 
            ; Make-up foo file hook 
            add-file-hook ".foo"    fhook-foo 
            1 add-file-hook "-!-[ \t]*foobar.*-!-" fhook-foo ; -!- foobar -!- 
            ; Override the make with localised build command 
            set-variable %compile-com "build" 

sA
        The file contains company specific file hooks and the name of the 
        company. 

    cDOther Company Files cA
        Files defined on behalf of the company are included in the company 
        directory. These would include:- 

                * Template header files lslmetf(8)le. 
                * Hook file definitions (cDhkcAcCXXXcAcD.emfcA) for company specific 
                  files, see lslmadd-file-hook(2)le. 
                * Extensions to the standard hook definitions (cDmycAcCXXXcAcD.emfcA) for 
                  company specific language extensions to the standard hook 
                  files. See lsfileHooks(2)lmFile Hooksle and lslanguageTemplates(2)lmFile Language Templatesle. 


cEcESEE ALSO cEcA


    lslm$MENAME(5)le, lslm$MEPATH(5)le, lsfileHooks(2)lmFile Hooksle, lslanguageTemplates(2)lmFile Language Templatesle, lsInstallation(1)lmInstallationle, 
    lslmuser-setup(3)le, lsUserProfiles(2)lmUser Profilesle. 

! 2 UserProfiles
cEcEUSER PROFILES cEcA


    This section describes how a user profile should be incorporated into 
    MicroEmacs '02. A user profile defines a set of extensions to MicroEmacs 
    which encapsulates settings which are used by an individual user. 

    The user profile allows:- 

        * Saving of the last session (history), allowing the next invocation 
          of MicroEmacs '02 to restore your previous session. 
        * Personalized spelling dictionaries. 
        * Redefinition of MicroEmacs '02, allowing the editor to be tailored 
          to an individual's requirements. Including the re-binding of keys, 
          modification of the screen colors. Definition of personal macros 
          etc. 


cEIdentification cA


    In order to identify a user MicroEmacs '02 uses information in the system 
    to determine the name of the user, and in turn the configuration to use. 
    On all systems the value of the environment variable lslm$MENAME(5)le takes 
    priority over any other means of user identification. If this variable is 
    not defined then the host system typically provides a mechanism to 
    determine the current user. DOS and cCWindowscA systems present problems where 
    a login prompt is not supplied. 

    Each of the supported platforms are now described. 

    cDUNIX cA
        The environment variable cG$LOGNAMEcA is defined. This is the user name 
        used by the system. 

    cDDOS cA
        MS-DOS typically has no concept of the user name. The user name should 
        be defined in the cGautoexec.batcA file, choose a name of 8 characters or 
        less, i.e. to fix the user name to cGfredcA then add the following line:- 

            SET MENAME=fred 


        Remember to re-boot the system before the new command takes effect. 
        (see the next step, there is another change to cGautoexec.batcA). 

    cDMicrosoft Windows cA
        Microsoft windows environments may, or may not, have logging enabled. 
        If you have to log into your system then a login identification has 
        been supplied and will be recognized by MicroEmacs, setting the 
        environment variable lslm$MENAME(5)le to this value. 

        If login is not enabled then the lslmme32.ini(8)le file may be modified to 
        provide a default login name. To add the user cDfredcA then add the 
        following lines to the cCinicA file:- 

            [guest] 
            MENAME=fred 


        If login is subsequently enabled on the system then these lines should 
        be removed. These lines force the user identification to be cDfredcA. 

        The above technique may be used within the windows environment to 
        modify your login name. Assuming that the system administrator has 
        assigned cDfredcA a user login name of cDfwhitecA, and cCfredcA requires all of 
        his configuration files to be the same name as his UNIX login which is 
        cDfredcA. Then cCfredcA may force his user name to cCfredcA from the cGme32.inicA file 
        as follows:- 

            [fwhite] 
            MENAME=fred 


        Once cCfredcA has entered MicroEmacs he will adopt his new login name 
        which will be used to identify his own files etc. The action of this 
        statement is to force the environment variable cG$MENAMEcA to a new value. 
        Any other environment variables may be forced in this way i.e. 
        cG$HOSTNAMEcA is a good candidate here as the cGme32.inicA is local to the 
        machine. 

    cDShared Platforms cA
        Platforms may share the same set of configuration files. Consider a 
        system which may boot under MS-DOS, Windows '98, NT and Linux. 
        Provided that the macro files are located on a file system that may be 
        mounted by all of the other operating systems and the $MEPATH is set 
        appropriately, then a single set of MicroEmacs macro files may be 
        shared across all platforms. 


cEPersonal MicroEmacs Directory cA


    The private user profile is stored in a separate directory. The directory 
    that MicroEmacs uses must be created by the user, create the directory in 
    your local file system. In addition, the MicroEmacs search path lslm$MEPATH(5)le 
    should be modified to include your new MicroEmacs personal directory. 

    cDUNIX cA
        Create in your local directory, typically called cGmicroemacscA or 
        cG.microemacscA (if it is to be hidden). 

        Add/modify the lslm$MEPATH(5)le environment variable to include your 
        personal directory in your cG.logincA, cG.chsrccA or cG.profilecA file, the file 
        and exact syntax will depend upon your shell. For a Korn shell the 
        following line would be added to the cG.profilecA file:- 

            export MEPATH=$HOME/.microemacs:/usr/local/microemacs 


        Where cG$HOMEcA is assumed to be the users login home directory, or use 
        the directory location of your new directory. 

    cDDOS cA
        For MS-DOS environments, there is typically no user directory, it is 
        suggested that the user directory is created in the MicroEmacs 
        directory, use the cG$MENAMEcA defined in the previous step i.e. 

            mkdir c:\me\fred 


        Change the lslm$MEPATH(5)le in the cDautoexec.batcA to include the new directory 
        i.e. 

            SET MEPATH=c:\me\fred;c:\me 


    cDWindows cA
        Windows environments, the lslmme32.ini(8)le cDuserPathcA entry defines the 
        location of the user profile directories, within the cDInstallcA cDShieldcA 
        installation, the cGme32.inicA is typically defined as:- 

            userPath=C:\Program Files\JASSPA\MicroEmacs 


        Create your MicroEmacs personal directory in this folder, the name of 
        the folder should be your login name or cG$MENAMEcA, depending upon how 
        your name is identified. 


cECreating Your Profile cA


    Once you have created a new directory to store your user profile, create a 
    default profile for yourself from MicroEmacs using the lslmuser-setup(3)le 
    dialog:- 

        Help => User Setup 


    Fill in the entries in the dialog, and ensure that cDSavecA is depressed on 
    exit to write the files. 

    The dictionaries often present difficulties the first time, a prompt to 
    save the dictionary requires the full pathname and the name of the file, 
    the pathname is the path to your personal folder, the filename is 
    typically your cCusernamecA.edf. Once the file is created you will not have a 
    problem in the future. 


cEThe User Profile cA


    Files created in the user directory include:- 

        * Setup registry and previous session history cCusernamecA.erf, see 
          lslmerf(8)le). This stores the cDuser-setupcA settings and also the context 
          from your previous edit session. 
        * Users start-up file cCusernamecA.emf, see lslmemf(8)le the user may make local 
          changes to MicroEmacs in this file, this may include changing key 
          bindings, defining new hook functions etc. You should over-ride the 
          standard MicroEmacs settings from your start-up file rather than 
          modifying the standard MicroEmacs files. 
        * Personal spelling dictionary cCusername.edfcA, see lslmedf(8)le. This file 
          contains your personal spelling modifications, any words that are 
          added to the spelling dictionary are added to this file. 

    In addition to the above, if new file hooks are defined then they should 
    be added to this directory (if they are not global to the company). 


cEcEEXAMPLE cEcA


    The following are examples of some individuals start-up files:- 
sB
        ; Jon's special settings 
        ; 
        ; Last Modified <190698.2226> 
        ; 
        ; Macro to delete the whitespace, or if an a word all of the 
        ; word until the next word is reached. 
        define-macro super-delete 
            set-variable #l0 0 
            !while &not &sin @wc " \t\n" 
                forward-char 
                set-variable #l0 &add #l0 1 
            !done 
            !repeat 
                !force forward-char 
                !if $status 
                    set-variable #l0 &add #l0 1 
                !endif 
            !until &or &seq @wc "" &not &sin @wc " \t\n" 
            #l0 backward-delete-char 
            !return 
        !emacro 
        ; Make a previous-buffer command. 
        define-macro previous-buffer 
            &neg @# next-buffer 
        !emacro 
        ; spotless; Perform a clean and remove any multi-blank lines. 
        define-macro spotless 
            -1 clean 
        !emacro 
        ; comment-adjust; Used for comments in electric-c mode (and the other 
        ; electic modes. Moves to the comment fill position, saves having to mess 
        ; around with comments at the end of the line. 
        0 define-macro comment-adjust 
            ; delete all spaces up until the next character 
            !while &sin @wc " \t" 
                forward-delete-char 
            !done 
            ; Fill the line to the current $c-margin. We use this as 
            ; this is the only variable that tells us where the margin 
            ; should be. 
            !if &gre $window-acol 0 
                backward-char 
                !if &sin @wc " \t" 
             forward-delete-char 
                    !jump -4 
                !else 
                    forward-char 
                !endif 
            !endif 
            ; Now fill to the $c-margin 
            &sub $c-margin $window-acol insert-string " " 
        !emacro 
        ; Macro to force buffer to compile buffer for C-x ' 
        define-macro compile-error-buffer 
            !force delete-buffer *compile* 
            change-buffer-name "*compile*" 
        !emacro 
        ; 
        ; Set up the bindings. 
        ; 
        global-bind-key super-delete            "C-delete" 
        global-bind-key beginning-of-line       "home" 
        global-bind-key end-of-line             "end" 
        global-bind-key undo                    "f4" 
        !if &seq %emulate "ERROR" 
            global-bind-key comment-adjust      "esc tab" 
            global-bind-key comment-adjust      "C-insert" 
            ; Like a korn shell please. 
            ml-bind-key tab "esc esc" 
        !endif 
        ; 
        ; Setup for windows and UNIX. 
        ; 
        ; Define my hilighting colour for Windows and UNIX. 
        !if &equ &band $system 0x001 0 
            !if &not &seq $platform "win32" 
                ; Small bold font is better for me. 
                change-font "-*-clean-medium-r-*-*-*-130-*-*-*-*-*-*" 
                ; Small non-bold font. 
                ; change-font "-misc-fixed-medium-r-normal--13-*-*-*-c-70-iso8859-1" 
                ; Change the size of the screen 
                82 change-screen-width 
                50 change-screen-depth 
            !endif 
        !endif 
        ; Change the default diff command-line for GNU diff utility all platforms 
        set-variable %diff-com "diff --context --minimal --ignore-space-change --report-identical-files --recursive" 
        set-variable %gdiff-com "diff --context --ignore-space-change -w" 
        ; Setup for cygnus 
        !if &seq $platform "win32" 
            set-variable %cygnus-bin-path "c:/cygwin/bin" 
            set-variable %cygnus-hilight 1 
            set-variable %cygnus-prompt "$" 
        !endif 
        ; Set up the ftp flags. The letters have the following meaning: 
        ; c   - Create a console (*ftp-console* for ftp, *http-console* for http) 
        ; s   - Show the console 
        ; p   - Show download progress ('#' every 2Kb downloaded) 
        set-variable %ftp-flags "csp" 
        ; Info files 
        ;To hilight the .info and also the dir file 
        add-file-hook ".info dir"                                   fhook-info   ; Info-files 
        ;To hilight all info files without the extension .info 
        ;but starting with the text "This is info file.. 
        -2 add-file-hook "This is Info file"                        fhook-info 

        ; Finished 
        ml-write "Configured to Jon's requirements" 

sA

cEcESEE ALSO cEcA


    lslm$MEPATH(5)le, lslm$MENAME(5)le, lslmuser-setup(3)le, lsCompanyProfiles(2)lmCompany Profilesle, lsfileHooks(2)lmFile Hooksle, lslanguageTemplates(2)lmFileln
    lnLanguage Templatesle, lsInstallation(1)lmInstallationle. 

! 2 Interfacing
cEcEINTERFACING cEcA


    This sections describes how MicroEmacs '02 may be interfaced to external 
    components. 


cEShells cA


    A shell window may be opened within the context of the editor using the 
    command lslmishell(3)le, whereby an interactive command shell is presented 
    within a buffer. 

    In the Microsoft Windows environment a cDcygnuscA UNIX style BASH shell may be 
    realised with the lslmcygnus(3)le command. 


cEDebugger cA


    Within the UNIX environment the GNU cDgdb(1)cA or native UNIX cDdbx(1)cA debuggers 
    may be invoked from the editor using lslmgdb(3)le or lslmdbx(3)le. respectively This 
    invokes the debugger and follows the debugging process in the editor 
    window, automatically opening the source files as the debugger calls for 
    them. 


cEMicrosoft Developer Studio cA


    In the Microsoft windows environment, the lslmmemsdev(1)le DLL may be attached 
    to the cDMicrosoft Developer StudiocA to enable MicroEmacs '02 to be used in 
    place of the in-built editor. 


cEFile Searching cA


    File searching is performed using cDgrep(1)cA using the lslmgrep(3)le command. For 
    Windows then the GNU grep utility is recommended, for MS-DOS then the 
    DJGPP version of GNU grep is recommended. 


cEFile Differencing cA


    Differencing files, or directories is performed using the cDdiff(1)cA utility 
    using the lslmdiff(3)le command. For all platforms the GNU diff utility is 
    recommended as this provides a comprehensive differencing that is not 
    typically available with native UNIX diff utilities. 


cETag Files cA


    A cDtagcA capability exists (see lslmfind-tag(2)le) such that source functions and 
    alike may be located quickly using a cDtagscA file. The standard cDctags(1)cA 
    format is used by MicroEmacs. The cDtagscA file itself may be generated by 
    MicroEmacs '02 from the menu (cCTools->XX Tools->Create Tags FilecA). 
    Alternatively a cDtagscA file may be generated by the cDctags(1)cA utility. This 
    is typically standard on UNIX platforms. For Windows and DOS platforms 
    then the cDExuberant CtagscA is recommended, this is available from:- 

       cG http://darren.hiebert.comcA 

    A MicroEmacs '02 compatible tags file may be generated using the command 
    line "cGctags -N --format=1 ."cA cataloging the current directory. To generate 
    cDtagscA for a directory tree then use "cGctags -NR --format=1 .cA". Refer to the 
    cDExuberant CtagscA documentation for a more detailed description of the 
    utility. 


cECompilation cA


    Compilation is performed using the lslmcompile(3)le command. This invokes a 
    command shell, typically using cDmake(1)cA to initiate a build sequence. 


cEClient-Server cA


    The lsClient-Server(2)lmClient-Serverle interface allows other client applications to inject 
    commands into an already existing MicroEmacs '02 session (the server), 
    thereby controlling the editor remotely. This is typically used to inject 
    new files into the editor to be presented to the user. 

    The cCClient-ServercA interface is available in both the UNIX and Microsoft 
    Windows environments. This mechanism is used in the Microsoft windows 
    environment by the lslmmemsdev(1)le DLL to attach the cDMicrosoft Developer StudiocA 
    to MicroEmacs '02. This may be used with similar effects within the UNIX 
    environments from the X-Window managers desktop in addition to other 
    utilities such as cDTkDesk(1)cA. 


cECommand Line Filer cA


    MicroEmacs may be invoked as a command filter in it's own right, macro 
    scripts have been developed to perform a cDdos2unix(1)cA conversion operation, 
    generate tags files etc. See lslmCommand Line Filtersle. 


cEcESEE ALSO cEcA


    cDctags(1)cA, lslmcompile(3)le, lslmcygnus(3)le, lslmdbx(3)le, lslmdiff(3)le, lslmfind-tag(2)le lslmgdb(3)le, 
    lslmgrep(3)le, lslmishell(3)le, lslmmemsdev(1)le, 
    lsClient-Server(2)lmClient-Serverle, lslmCommand Line Filtersle. 

! 2 Client-Server
cEcECLIENT-SERVER cEcA


    This sections describes how MicroEmacs '02 may be interfaced to external 
    components through the cDClient-ServercA interface. 

    The cDClient-ServercA interface of MicroEmacs '02 provides a capability for 
    other applications to inject commands into a running version of the 
    editor, which are interpreted and executed. The interface is only 
    available on multi-tasking operating systems such as UNIX and Microsoft 
    Windows; it is not available on MS-DOS systems. 

    Within the following discussions, the cDServercA is a running version of the 
    MicroEmacs '02 editor; the cDclientcA is the application (or shell script) 
    that communicates a new command to the cCservercA. 

    The cDClient-ServercA interface may provide a bidirectional interface such 
    that a cCclientcA may submit a command to the cCservercA and may also retrieve a 
    response to that command. 


cEcEDESCRIPTION cEcA


    The cDClient-ServercA interface operates by making an external interface 
    available which is continually monitored by the cCservercA. The external 
    interface may be provided by a file, named pipe or socket (depending upon 
    the platform) with a well know location in the file system. Typically two 
    files are provided, an input file into which the cCclientcA writes commands 
    (cC$TEMPcAcD/mecAcC$MENAMEcAcD.cmdcA); and an output file where responses to those 
    commands my be read (cC$TEMPcAcD/mecAcC$MENAMEcAcD.rspcA). 

    Within MicroEmacs, the client server interface appears as a hidden 
    lslmipipe-shell-command(2)le buffer, with the name cG*server*cA. Commands are 
    received through this buffer and responses are written back to the buffer. 


cEClient Commands cA


    cCClientscA may write directly to the cCcommandcA through the use of explicit 
    embedded code, or may use a lslmme(1)le invocation with the cD-mcA option. Commands 
    to the client interface take the form "cDC:cAcC<client>cAcD:cAcC<command>cA". 

    cC<client>cA 
        cC<client>cA is an identification string that may be used to identify the 
        client, this information may be used when the command is handled to 
        interpret the command if some special client specific action is 
        required. 

    cC<command>cA 
        The cC<command>cA is an editor command (or macro) of the given name with 
        any arguments. Standard command escape sequences must be adhered to. 
        i.e. to write "cGHello WorldcA" on the message line then a client may 
        issue the command:- 

            me -m "C:<client>:ml-write \"Hello world\" 


        The cCclient-servercA interface is typically used to load a file, this may 
        be performed as follows:- 

            me -m "C:<client>:find-file \"/path/foo.bar\"" 


        The absolute path is specified in this type of transaction as the 
        current working directory of the active MicroEmacs session is unknown. 
        The cD-mcA option de-iconize's the existing editor session and bring it to 
        the foreground. 


cEClient Responses cA


    Responses from cCclientcA commands are written to the response file, responses 
    take a similar form to cCclientcA commands except they are prefixed by an cDRcA, 
    i.e. "cDR:cAcC<client>cAcD:cAcC<data>cA". 

    As multiple cCclientscA may be utilizing the cCclient-servercA mechanism then the 
    cC<client>cA sting passed in the command is typically returned in the response 
    to allow the cCclientcA to identify it's own response (rather than any other 
    cCclientscA. It is the cCclientscA responsibility that this string is unique in 
    order that it may be differentiated. 

    The returned cC<data>cA format is undefined and would be generated by a macro 
    command used to handle the cCclientcA command; sufficient to say that the data 
    should exist on a single line. 


cEServer Side cA


    On the cCservercA side, the cDClient-ServercA interface is managed like an 
    lslmipipe-shell-command(2)le using the hidden buffer cG*server*cA (as previously 
    mentioned). 

    The cCClient-ServercA interface is enabled from the lslmuser-setup(3)le interface, 
    the user setting of the interface is confirmed by checking bit cG0x20000cA of 
    the lslm$system(5)le variable. 

    The client server interface is typically initialized within the cGme.emfcA 
    initialization file, whereby the cCipipecA input handler is bound to the 
    client pipe buffer and the buffer is hidden, so it is not available when 
    the buffers are swapped. (Note that the client buffer may be explicitly 
    interrogated using lsnext-buffer(2)lmfind-bufferle cG*server*cA). The client handler is installed 
    as follows:- 
sB
        ; Setup the Client Server 
        !if &band $system 0x20000 
            define-macro-file meserver server-input 
            find-buffer "*server*" 
            set-variable :last-line 2 
            set-variable :client-list ":" 
            set-variable $buffer-ipipe server-input 
            beginning-of-buffer 
            goto-alpha-mark  "I" 
            -1 find-buffer "*server*" 
        !endif 

sA
    This binds a MicroEmacs macro called cCserver-inputcA to handle the client 
    commands as they arrive on the input, an lsgoto-alpha-mark(2)lmalpha-markle is used to record the 
    processed position at the end of the buffer. The pipe handler itself 
    decodes the client request and executes it. The default handler supplied 
    with MicroEmacs '02 is defined within the macro file cGmeserver.emfcA 

    Responses to the client are inserted into the response file by writing 
    directly into the ipipe buffer (cG*server*cA) using the lslmipipe-write(2)le 
    command. It is the calling macros responsibility to ensure that the 
    response string adheres to the format outlined above in the previous 
    sections. 


cEcENOTES cEcA


    It is not possible to kill the cG*server*cA buffer, and lslmipipe-kill(2)le is 
    ignored within the context of the buffer. 


cEcEFILES cEcA


    cGmeserver.emfcA - Default Client-Server ipipe handler. 
    cC$TEMPcAcD/mecAcC$MENAMEcAcD.cmdcA - Command file. 
    cC$TEMPcAcD/mecAcC$MENAMEcAcD.rspcA - Response file. 


cEcEBUGS cEcA


    The first MicroEmacs '02 session that executes becomes the editor server, 
    additional editor sessions that are executed do not become server 
    processes. In the event that the cCservercA editor is terminated, any other 
    sessions do not take over the role of server. Subsequently issuing a 
    client command may fail, or invoke a new editor session which adopts the 
    role of server. 


cEcESEE ALSO cEcA


    lslmme(1)le, lslmipipe-shell-command(2)le 

! 2 RegularExpressions
cEcEREGULAR EXPRESSIONS cEcA


    Regular Expressions are used in the search (and replace) operations. The 
    following notes are applicable when lslmmagic(2m)le mode is enabled. 


cEOverview cA


    A "cCregular expressioncA" (or "cCregexcA", or "cCpatterncA") is a text string that 
    describes some (mathematical) set of strings. A regex cDRcA "cCmatchescA" a string 
    cDScA if cDScA is in the set of strings described by cDRcA. 

    MicroEmacs '02 includes the GNU cDregcAular cDexpcAression pattern matcher 
    library, cDregexcA which provides a powerful search engine, using the search 
    engine you can: 

        * see if a string matches a specified pattern as a whole, and 
        * search within a string for a substring matching a specified pattern. 

    Some regular expressions match only one string, i.e., the set they 
    describe has only one member. For example, the regular expression 'cGfoocA' 
    matches the string 'cGfoocA' and no others. Other regular expressions match 
    more than one string, i.e., the set they describe has more than one 
    member. For example, the regular expression 'cGf*cA' matches the set of 
    strings made up of any number (including zero) of 'cGfcA's. As you can see, 
    some characters in regular expressions match themselves (such as 'cGfcA') and 
    some don't (such as 'cG*cA'); the ones that do not match themselves instead 
    let you specify patterns that describe many different strings. 


cESyntax of Regular Expressions cA


    Regular expressions have a syntax in which a few characters are special 
    constructs and the rest are "cCordinarycA". An ordinary character is a simple 
    regular expression which matches that same character and nothing else. The 
    special characters are 'cG$cA', 'cG^cA', 'cG.cA', 'cG*cA', 'cG+cA', 'cG?cA', 'cG[cA', 'cG]cA' and 'cG\cA'. Any 
    other character appearing in a regular expression is ordinary, unless a 
    'cG\cA' precedes it. 

    For example, 'cGfcA' is not a special character, so it is ordinary, and 
    therefore 'cGfcA' is a regular expression that matches the string 'cGfcA' and no 
    other string. (It does cDnotcA match the string 'cGffcA'.) Likewise, 'cGocA' is a 
    regular expression that matches only 'cGocA'. (When case distinctions are 
    being ignored, these regexs also match 'cGFcA' and 'cGOcA', but we consider this a 
    generalization of "cCthe same stringcA", rather than an exception.) 

    Any two regular expressions cGAcA and cGBcA can be concatenated. The result is a 
    regular expression which matches a string if cGAcA matches some amount of the 
    beginning of that string and cGBcA matches the rest of the string. 

    As a simple example, we can concatenate the regular expressions 'cGfcA' and 
    'cGocA' to get the regular expression 'cGfocA', which matches only the string 
    'cGfocA'. Still trivial. To do something nontrivial, you need to use one of 
    the special characters. Here is a list of them. 

    cD.cA (Period) 
        is a special character that matches any single character except a 
        newline. Using concatenation, we can make regular expressions like 
        'cGa.bcA', which matches any three-character string that begins with 'cGacA' 
        and ends with 'cGbcA'. 

    cD*cA (asterisk) 
        is not a construct by itself; it is a postfix operator that means to 
        match the preceding regular expression repetitively as many times as 
        possible. Thus, 'cGo*cA' matches any number of 'cGocA's (including no 'cGocA's). 

        'cG*cA' always applies to the cDsmallestcA possible preceding expression. 
        Thus, 'cGfo*cA' has a repeating 'cGocA', not a repeating 'cGfocA'. It matches 'cGfcA', 
        'cGfocA', 'cGfoocA', and so on. 

        The matcher processes a 'cG*cA' construct by matching, immediately, as 
        many repetitions as can be found. Then it continues with the rest of 
        the pattern. If that fails, backtracking occurs, discarding some of 
        the matches of the 'cG*cA'-modified construct in case that makes it 
        possible to match the rest of the pattern. For example, in matching 
        'cGca*arcA' against the string 'cGcaaarcA', the 'cGa*cA' first tries to match all 
        three 'cGacA's; but the rest of the pattern is 'cGarcA' and there is only 'cGrcA' 
        left to match, so this try fails. The next alternative is for 'cGa*cA' to 
        match only two 'cGacA's. With this choice, the rest of the regex matches 
        successfully. 

        cD+cA (plus) is a postfix operator, similar to 'cG*cA' except that it must 
        match the preceding expression at least once. So, for example, 'cGca+rcA' 
        matches the strings 'cGcarcA' and 'cGcaaaarcA' but not the string 'cGcrcA', 
        whereas 'cGca*rcA' matches all three strings. 

    'cD?cA' (question mark) 
        is a postfix operator, similar to 'cG*cA' except that it can match the 
        preceding expression either once or not at all. For example, 'cGca?rcA' 
        matches 'cGcarcA' or 'cGcrcA'; nothing else. 

    cD[cA ... cD]cA 
        is a "character set", which begins with 'cG[cA' and is terminated by 'cG]cA'. 
        In the simplest case, the characters between the two brackets are what 
        this set can match. 

        Thus, 'cG[ad]cA' matches either one 'cGacA' or one 'cGdcA', and 'cG[ad]*cA' matches 
        any string composed of just 'cGacA's and 'cGdcA's (including the empty 
        string), from which it follows that 'cGc[ad]*rcA' matches 'cGcrcA', 'cGcarcA', 
        'cGcdrcA', 'cGcaddaarcA', etc. 

        You can also include character ranges in a character set, by writing 
        the starting and ending characters with a 'cG-cA' between them. Thus, 
        'cG[a-z]cA' matches any lower-case ASCII letter. Ranges may be intermixed 
        freely with individual characters, as in 'cG[a-z$%.]cA', which matches any 
        lower-case ASCII letter or 'cG$cA', 'cG%cA' or period. 

        Note that the usual regex special characters are not special inside a 
        character set. A completely different set of special characters exists 
        inside character sets: 'cG]cA', 'cG-cA' and 'cG^cA'. 

        To include a 'cG]cA' in a character set, you must make it the first 
        character. For example, 'cG[]a]cA' matches 'cG]cA' or 'cGacA'. To include a 'cG-cA', 
        write 'cG-cA' as the first or last character of the set, or put it after a 
        range. Thus, 'cG[]-]cA' matches both 'cG]cA' and 'cG-cA'. 

        To include 'cG^cA' in a set, put it anywhere but at the beginning of the 
        set. 

        When you use a range in case-insensitive search, you should write both 
        ends of the range in upper case, or both in lower case, or both should 
        be non-letters. The behavior of a mixed-case range such as 'cGA-zcA' is 
        somewhat ill-defined, and it may change in future Emacs versions. 

    cD[^cA ... cD]cA 
        'cG[^cA' begins a "cCcomplemented character setcA", which matches any 
        character except the ones specified. Thus, 'cG[^a-z0-9A-Z]cA' matches all 
        characters *cDexceptcA* letters and digits. 

        'cG^cA' is not special in a character set unless it is the first 
        character. The character following the 'cG^cA' is treated as if it were 
        first (in other words, 'cG-cA' and 'cG]cA' are not special there). 

        A complemented character set can match a newline, unless newline is 
        mentioned as one of the characters not to match. This is in contrast 
        to the handling of regexs in programs such as cDgrep(1)cA. 

    cD^cA (caret) 
        is a special character that matches the empty string, but only at the 
        beginning of a line in the text being matched. Otherwise it fails to 
        match anything. Thus, 'cG^foocA' matches a 'cGfoocA' that occurs at the 
        beginning of a line. 

    cD$cA (dollar) 
        is similar to 'cG^cA' but matches only at the end of a line. Thus, 'cGx+$cA' 
        matches a string of one 'cGxcA' or more at the end of a line. 

    cD\cA (backslash) 
        has two functions: it quotes the special characters (including 'cG\cA'), 
        and it introduces additional special constructs. 

        Because 'cG\cA' quotes special characters, 'cG\$cA' is a regular expression 
        that matches only 'cG$cA', and 'cG\[cA' is a regular expression that matches 
        only 'cG[cA', and so on. 

        cDNote:cA for historical compatibility, special characters are treated as 
        ordinary ones if they are in contexts where their special meanings 
        make no sense. For example, 'cG*foocA' treats 'cG*cA' as ordinary since there 
        is no preceding expression on which the 'cG*cA' can act. It is poor 
        practice to depend on this behavior; it is better to quote the special 
        character anyway, regardless of where it appears. 

        For the most part, 'cG\cA' followed by any character matches only that 
        character. However, there are several exceptions: two-character 
        sequences starting with 'cG\cA' that have special meanings. The second 
        character in the sequence is always an ordinary character when used on 
        its own. Here is a table of 'cG\cA' constructs. 

        cD\|cA (bar) 
            specifies an alternative. Two regular expressions cGAcA and cGBcA with 
            'cG\|cA' in between form an expression that matches some text if 
            either cGAcA matches it or cGBcA matches it. It works by trying to match 
            cGAcA, and if that fails, by trying to match cGBcA. 

            Thus, 'cGfoo\|barcA' matches either 'foo' or 'bar' but no other 
            string. 

            'cG\|cA' applies to the largest possible surrounding expressions. Only 
            a surrounding 'cG\( ... \)cA' grouping can limit the grouping power of 
            'cG\|cA'. 

            Full backtracking capability exists to handle multiple uses of 
            'cG\|cA'. 

        cD\(cA ... cD\)cA 
            is a grouping construct that serves three purposes: 

                    * To enclose a set of 'cG\|cA' alternatives for other 
                      operations. Thus, 'cG\(foo\|bar\)xcA' matches either 'cGfooxcA' 
                      or 'cGbarxcA'. 
                    * To enclose a complicated expression for the postfix 
                      operators 'cG*cA', 'cG+cA' and 'cG?cA' to operate on. Thus, 
                      'cGba\(na\)*cA' matches 'cGbanananacA', etc., with any (zero or 
                      more) number of 'cGnacA' strings. 
                    * To record a matched substring for future reference. This 
                      last application is not a consequence of the idea of a 
                      parenthetical grouping; it is a separate feature that is 
                      assigned as a second meaning to the same 'cG\( ... \)cA' 
                      construct. In practice there is no conflict between the 
                      two meanings. 

        'cD\DcA' 
            matches the same text that matched the Dth occurrence of a `cG\(cA ... 
            cG\)cA' construct. 

            After the end of a 'cG\( ... \)cA' construct, the matcher remembers 
            the beginning and end of the text matched by that construct. Then, 
            later on in the regular expression, you can use 'cG\cA' followed by 
            the digit cGDcA to mean "match the same text matched the cGDcAth time by 
            the 'cG\(cA ... cG\)cA' construct." 

            The strings matching the first nine 'cG\(cA ... cG\)cA' constructs 
            appearing in a regular expression are assigned numbers 1 through 9 
            in the order that the open-parentheses appear in the regular 
            expression. So you can use 'cG\1cA' through 'cG\9cA' to refer to the text 
            matched by the corresponding 'cG\(cA ... cG\)cA' constructs. 

            For example, 'cG\(.*\)\1cA' matches any newline-free string that is 
            composed of two identical halves. The 'cG\(.*\)cA' matches the first 
            half, which may be anything, but the 'cG\1cA' that follows must match 
            the same exact text. 

            If a particular 'cG\( ... \)cA' construct matches more than once 
            (which can easily happen if it is followed by 'cG*cA'), only the last 
            match is recorded. 

        cG\`cA 
            matches the empty string, but only at the beginning of the buffer 
            or string being matched against. 

            cDNOTE:cA This currently only matches the start of the current line - 
            it does not match the start of the buffer. 

        cG\'cA 
            matches the empty string, but only at the end of the buffer or 
            string being matched against. 

            cDNOTE:cA This currently only matches the end of the current line - it 
            does not match the end of the buffer. 

        cG\=cA 
            matches the empty string, but only at point. 

        cG\bcA 
            matches the empty string, but only at the beginning or end of a 
            word. Thus, 'cG\bfoo\bcA' matches any occurrence of 'cGfoocA' as a 
            separate word. 'cG\bballs?\bcA' matches 'cGballcA' or 'cGballscA' as a 
            separate word. 

            'cG\bcA' matches at the beginning or end of the buffer regardless of 
            what text appears next to it. 

            cG\BcA matches the empty string, but *not* at the beginning or end of 
            a word. 

        cG\<cA 
            matches the empty string, but only at the beginning of a word. 
            'cG\<cA' matches at the beginning of the buffer only if a 
            word-constituent character follows. 

        cG\>cA 
            matches the empty string, but only at the end of a word. 'cG\>cA' 
            matches at the end of the buffer only if the contents end with a 
            word-constituent character. 

        cG\wcA 
            matches any word-constituent character. The syntax table 
            determines which characters these are. 

        cG\WcA 
            matches any character that is not a word-constituent. 

        cG\sCcA 
            matches any character whose syntax is cGCcA. Here cGCcA is a character 
            that represents a syntax code: thus, 'cGwcA' for word constituent, 'cG-cA' 
            for whitespace, 'cG(cA' for open parenthesis, etc. Represent a 
            character of whitespace (which can be a newline) by either 'cG-cA' or 
            a space character. 

        cG\SCcA 
            matches any character whose syntax is not cGCcA. 

        cG\{N,M\}cA 
            Matches an integer number of the previous item, where cGNcA and cGMcA are 
            integer constants interpreted as follows:- 

            cG\{N\}cA 
                The preceeding item is matched exactly cGNcA times. 

            cG\{N,\}cA 
                The preceeding item is matched cGNcA or more times. 

            cG\{N,M\}cA 
                The preceeding item is matched at least cGNcA times, but no more 
                than cGMcA times. 

            cG\{,M\}cA 
                The preceeding item is optional and is matched at most cGMcA 
                times. 

    The constructs that pertain to words and syntax are controlled by the 
    setting of the syntax table. 


cESyntax of Replacement Expressions cA


    A regular expression replacement, lslmquery-replace-string(2)le command (with 
    lslmmagic(2m)le mode enabled), replaces exact matches for a single string or 
    pattern. The replacement pattern may be a constant; it may also refer to 
    all or part of what is matched by the regular expression search string. 

    cD\&cA 
        In the replacement pattern, cD\&cA stands for the entire match being 
        replaced. (as does cG\0cA). 

    cD\DcA 
        In the replacement pattern, where cDDcA is a digit 1-9, stands for 
        whatever matched the Dth parenthesized grouping (cG\( .. \)cA) in search 
        pattern. To include a 'cG\cA' in the text to replace with, you must enter 
        'cG\\cA'. For example, 

            M-x query-replace-string<RET> c[ad]+r <RET> \&-safe <RET> 


        replaces (for example) "cGcadrcA" with "cGcadr-safecA" and "cGcddrcA" with 
        "cGcddr-safecA". 

            M-x query-replace-string<RET> \(c[ad]+r\)-safe <RET> \1 <RET> 


        performs the inverse transformation. 

        cD\0cA is a special case, this represents the whole of the search pattern, 
        it is equivalent to cD\&cA. 


cESearching and Case cA


    Searching may be either case sensitive or case insensitive, and is 
    controlled by the lslmexact(2m)le mode. When cCexactcA mode is enabled (default) the 
    then searches are case sensitive; disabled then case is ignored. The 
    lslmexact(2m)le mode is set on a per-buffer basis. 


cEcENOTES cEcA


    The search engine searches for the longest string that matches a given 
    pattern, the longest pattern is sometimes the pattern that is not actually 
    required. For instance, consider searching for an HTML bracket set. The 
    simplest search is:- 

        M-x search-forward "<.*>" 


    Unfortunately, this pattern is not specific enough, given an HTML line:- 

        <a href="www.jasspa.com">Jasspa Site</a> 


    Then the pattern matched is actually the whole line as the cG.*cA matches 
    everything to the last cG>cA, this is the longest string. To rectify the 
    pattern then we must be more specific, the correct search pattern to use 
    in this instance is:- 

        M-x search-forward "<[^>]*>" 


    In this case we match any character excluding the closing character, this 
    guarantees that we always find the shortest string match. A search of our 
    HTML line locates two separate instances of the regular expression cG<a 
    href="www.jasspa.com">cA and cG</a>cA. 


cEcESEE ALSO cEcA


    lslmsearch-forward(2)le, lslmsearch-backward(2)le, lslmbuffer-mode(2)le, lslmexact(2m)le, 
    lslmhunt-backward(2)le, lslmhunt-forward(2)le, lslmisearch-forward(2)le, lslmmagic(2m)le, 
    lslmreplace-string(2)le. 

! 2 Build
cEcEBUILD cEcA


    MicroEmacs '02 may be compiled from the source files using the command 
    shell build scripts cCbuildcA (UNIX Bourne Shell) or cCbuild.batcA (DOS/Windows). 
    A default compile sequence may be achieved with a simple: 

        build 


    from the command line. The build script attempts to detect the host system 
    and available compiler and build the editor. 

    The build script recognizes the following options:- 

    cD-CcA 
        Build clean. Delete all of the object files. 

    cD-dcA 
        Build a debugging version, the output is cGmedcA (or cGmed32cA for 32-bit 
        Windows versions) 

    cD-gcA 
        UNIX only. Builds using GNU compiler and tools as opposed to native 
        tools. 

    cD-hcA 
        Display a simple help page 

    cD-mcA cCmakefilecA 
        Build using the specified makefile. over-riding the auto system 
        detect. The supplied makefiles include:- 

                * cGaix43.makcA IBM AIX 4.3 native 
                * cGcygwin.gmkcA Cygwin using GNU tools under Windows. 
                * cGdosdj1.makcA Microsoft DOS build using djgpp version 1. 
                * cGdosdj2.makcA Microsoft DOS build using djgpp version 2. 
                * cGfreebsd.gmkcA Free BSD using GNU tools. 
                * cGhpux9.gmkcA HP-UX 9.x using GNU tools. 
                * cGhpux9.makcA HP-UX 9.x native 
                * cGhpux10.gmkcA HP-UX 10.x using GNU tools. 
                * cGhpux10.makcA HP-UX 10.x native 
                * cGhpux11.gmkcA HP-UX 11.x using GNU tools. 
                * cGhpux11.makcA HP-UX 11.x native 
                * cGirix5.gmkcA Silicon Graphics IRIX 5.x using GNU tools 
                * cGirix5.makcA Silicon Graphics IRIX 5.x native 
                * cGirix6.gmkcA Silicon Graphics IRIX 6.x using GNU tools 
                * cGirix6.makcA Silicon Graphics IRIX 6.x native 
                * cGlinux2.gmkcA Linux 2.x using GNU tools 
                * cGopenstep.makcA Openstep 4.2 on NeXTstep (BSD 4.3). 
                * cGsunos55.gmakcA Sun Solaris 5.5 using GNU tools 
                * cGsunos55.makcA Sun Solaris 5.5 native 
                * cGsunos56.gmakcA Sun Solaris 5.6 using GNU tools 
                * cGsunos56.makcA Sun Solaris 5.6 native 
                * cGsunosx86.gmkcA Sun Solarais 2.6 (Intel) using GNU tools. 
                * cGwin32bc.makcA Borland C, 32-bit Windows version. 
                * cGwin32b55.makcA Borland C 5.5, 32-bit Windows version (Free 
                  compiler). 
                * cGwin32sv2.makcA Microsoft Developer v2.x, Win32s (for Win 3.xx) 
                * cGwin32sv4.makcA Microsoft Developer v4.2, Win32s (for Win 3.xx) 
                * cGwin32v2.makcA Microsoft Developer v2.x, 32-bit Windows. 
                * cGwin32v5.makcA Microsoft Developer v5.x, 32-bit Windows. 
                * cGwin32v6.makcA Microsoft Developer v6.x, 32-bit Windows. 

    cD-ncA 
        Build a console version (i.e. no window support). Constructs the 
        executable cGmen32.execA on Windows, cGmencA on Linux. 

    cD-nucA 
        Build a console version with URL support (Windows '95/'98/NT only), 
        constructs the executable cGmenu32.execA. 

    cD-pcA cC<searchpath>cA 
        Sets the default system search path to cC<searchpath>cA, the default is 
        cG/usr/local/microemacscA. Sets the default system search path to 

    cD-ScA 
        Build spotless. Deletes all of the object files and any backup files, 
        tag files etc. 

    cD-ucA 
        Build a URL version (Windows '95/'98/NT only), constructs the 
        executable cGmeu32.execA. 


cEMakefiles cA


    The supplied makefiles are provided in two forms:- 

        * cD.gmkcA - GNU make, using gcc. 
        * cD.makcA - Native make, consistent with the compiler and platform. 

    The makefiles are supplied with the following targets:- 

        * cDallcA - Default build. 
        * cDcleancA - Removes intermediate files. 
        * cDspotlesscA - Removes intermediate files and any backup files. 
        * cDmedcA - Builds a debugging version. 
        * cDmencA - Builds console version (Windows only). 
        * cDmencA - Builds a URL version (Windows only). 
        * cDmenucA - Builds console and URL version (Windows only). 


cEcENOTES cEcA


    Other UNIX ports should be fairly easy from the base set of ported 
    platforms. If any new platform ports are performed by individuals then 
    please submit the makefiles and any source changes back to JASSPA - see 
    lslmContact Informationle. 


cESearch Path cA


    The default search path is defined as "cC/usr/local/microemacscA" for all UNIX 
    type environments. Recently there has been a move to use the "cC/usr/sharecA" 
    directory. The search path may be re-defined through the macro definition 
    "cG_SEARCH_PATHcA". Change the C pre-processor to include the macro 
    definition. For example, to use "cC/usr/share/jasspacA" with multiple 
    sub-directories for each of the components:- 

        -D_SEARCH_PATH="\"/usr/share/jasspa/company:\ 
        /usr/share/jasspa/macros:\ 
        /usr/share/jasspa/spelling\"" 


    Note due to the line length then the cCbackslashcA (\) has been used to 
    continue the lines. 

! 2 localeSupport
cEcELOCALE SUPPORT cEcA


    Locale support within MicroEmacs handles the hardware and software 
    configuration with respect to location, including:- 

        Displayed Character Set 
        Keyboard Support 
        Word characters 
        Spell Support 

    There are many other locale problems which are not addressed in this help 
    page. Supporting different locale configurations often requires specific 
    hardware (a locale specific keyboard) and knowledge of the language and 
    customs of the region. This makes it a very difficult area for one 
    localized development team to support, as such, JASSPA rely heavily on the 
    user base to report locale issues. 


cENote on Names and IDs cA


    The language name is not sufficient to identify a locale (Mexican Spanish 
    is different to Spanish Spanish) neither is the country name (two 
    languages are commonly used in Belgium), so before we've really started 
    the first problem of what to call the locale has no standard answer! Call 
    it what you like but please try to call it something meaningful so others 
    may understand and benefit from your work. 

    In addition, the cCinternal idcA and cCdata filecA names have a length limit of 
    just four characters due to the "cG8.3cA" naming conversion of MS-DOS. The 
    standard adopted by JASSPA MicroEmacs for the internal locale id is to 
    combine the 2 letter ISO language name (ISO 639-1) with the 2 letter ISO 
    country name (ISO 3166-1). Should the locale encompasses more than one 
    country, then the most appropriate cCcountry idcA is selected. 


cEcEDisplayed Character Set cEcA


    A character set is the mapping of an integer number to a display symbol 
    (i.e. character). The ASCII standard defines a mapping of numbers to the 
    standard English characters, this standard is well defined and accepted, 
    as a result the character set rarely causes a problem for plain English. 

    Problems occur when displaying characters found outside the ASCII 
    standard, such as letters with accents, letters which are not Latin based 
    (e.g. Greek alphabet) and graphical characters (used for drawing dialog 
    boxes etc.). There are many different character sets to choose between and 
    if the wrong character set is selected then the incorrect character 
    translation is performed resulting in an incorrect character display. If 
    the character display looks incorrect then first try changing the font and 
    character-set setting, these can be configured using the platform page of 
    lslmuser-setup(3)le. 

    If the problem persists (i.e. because the character set used to write the 
    text is not supported on your current system) use the lslmcharset-change(3)le 
    command to convert the text to the current character set. 

    If your character-set is not supported then first make sure that 
    MicroEmacs will draw all of the characters to be used. By default 
    MicroEmacs does not draw some characters directly as the symbol may not be 
    defined. When a character is not defined then there will typically be a 
    gap or space in the text at the unknown character, in some cases there may 
    be no space at all which will make it very hard to use. The lslmsymbol(3)le 
    command (menu->symbol) is a good way of looking at which characters can be 
    used with the current character set. 

    For a character to be rendered (when in main text) or poked (drawn by 
    lslmscreen-poke(2)le or lslmosd(2)le) is defined by the lslmset-char-mask(2)le command. The 
    characters that are used when drawing MicroEmacs's window boarders or cDosdcA 
    dialogs is set via the lslm$box-chars(5)le and lslm$window-chars(5)le variables. 

    MicroEmacs attempts to improve the availability of useful graphics 
    characters on Windows and UNIX X-Term interfaces. The characters between 0 
    and 31 are typically control characters with no graphical representation 
    (e.g. new-line, backspace, tab etc.) if bit 0x10000 of the lslm$system(5)le 
    variable is set then MicroEmacs renders its own set of characters. These 
    characters are typically used for drawing boxes and scroll-bars. 

    With so many character sets, each with their own character mappings, then 
    the problem of spelling dictionary support is also tied to the locale. 
    MicroEmacs uses the ISO standard character sets (ISO 8859) internally for 
    word and spelling support and therefore a mapping between the ISO standard 
    and the user character set is required. This mapping is defined by using 
    the 'cGMcA' flag of the lslmset-char-mask(2)le command. 

    The user may declare the current character set in the platform page of 
    lslmuser-setup(3)le. All the settings required for supporting each character set 
    may be found in the cGcharset.emfcA macro file, so if your character set is 
    not supported, this is the file to edit. 


cEcEKeyboard Support cEcA


    The keyboard to character mapping is defined in the Start-Up page of 
    lslmuser-setup(3)le, where the keyboard may be selected from a list of known 
    keyboards. If your keyboard is not present, or is not working correctly, 
    then this section should allow you to fix the problem (please send JASSPA 
    the fix). 

    Most operating systems seem to handle keyboard mappings with the exception 
    of MS-Windows which requires a helping hand. The root of the problems with 
    MS-Windows is it's own locale character mappings which change the 
    visibility status of the keyboard messages which conflict with Emacs 
    keystroke bindings. To support key-bindings like 'cGC-tabcA' or 'cGS-returncA' a 
    low level keyboard interface is required, but this can lead to strange 
    problems with the more obscure keys, particularly with the 'cGAlt GrcA' 
    accented letter keys. For example on American keyboards pressing 'cGC-#cA' 
    results in two 'cGC-#cA' key events being generated, this peculiarity only 
    occurs with this one key. On a British keyboard the same key generates a 
    'cGC-#cA' followed by a 'cGC-\cA'. 

    This problem can be diagnosed using the lslm$recent-keys(5)le variable. Simply 
    type an obvious character, e.g. 'cGAcA' then the offending key followed by 
    another obvious key ('cGBcA'), then look for this key sequence in the 
    cD$recent-keyscA variable (use the lslmlist-variables(2)le or lslmdescribe-variable(2)le 
    command). So for the above British keyboard problem the recent-keys would 
    be: 

            B C-\\ C-# A 


    ($recent-keys lists the keys backwards). Once you have found the key 
    sequence generated by the key, the problem may be fixed using the 
    lslmtranslate-key(2)le to automatically convert the incorrect key sequence into 
    the required key. For the problem above the following line is required: 
sB
        translate-key "C-# C-\\" "C-#" 

sA
    Note that once a key sequence has been translated everything, including 
    cD$recent-keyscA, receive only the translated key. So if you a suspected a 
    problem with the existing definition, change the keyboard type in 
    cDuser-setupcA to cDDefaultcA so no translations are performed, quit and restart 
    MicroEmacs before attempting to re-diagnose the problem. 

    All the settings required for supporting each keyboard may be found in the 
    cGkeyboard.emfcA macro file, so if your keyboard is not supported, this is the 
    file you need to edit. 


cEcEWord characters cEcA


    Word characters are those characters which are deemed to be part of a 
    word, numbers are usually included. Many MicroEmacs commands use the 
    'Word' character set such as lslmforward-word(2)le and lslmupper-case-word(2)le. The 
    characters that form the word class are determined by the language being 
    used and this can be set in the Start-Up page of lslmuser-setup(3)le. 

    If your language is not supported you will need to add it to the list and 
    define the word characters, these settings may be found in the 
    cGlanguage.emfcA macro file. The 'cGacA' flag of command lslmset-char-mask(2)le is used 
    to specify whether a character is part of a word, you must specify the 
    uppercase letter and then the lowercase equivalent so the case conversion 
    functions work correctly. 

    A list of characters to be removed from the word character set is stored 
    in the cD.set-char-mask.rm-charscA variable. This is done so that the language 
    may be changed many times in the same session of MicroEmacs without any 
    side effects (such as the expansion of the word character set to include 
    all letters of all languages). This makes MicroEmacs ideal for writing 
    multi-language documents. 

    This may unfortunately be made a little more tricky by the requirement 
    that this list must be specified in the most appropriate ISO standard 
    character set (see cDDisplayed Character SetcA section). When extending the 
    word character set the characters have to be mapped to the current 
    character set which may not support all the required characters. For 
    example in the PC-437 DOS character set there is an e-grave (cG`ecA) but no 
    E-grave so the E-grave is mapped to the normal E. As a result, if trying 
    to write French text the case changing commands will behave oddly, for 
    example: 

            r`egle -> REGLE -> r`egl`e 


    The conversion of all 'cGEcA's to 'cG`ecA' is an undesirable side effect of 'cG`EcA' 
    being mapped to cGEcA. This can be avoided by redefining the base letter again 
    at the end of the word character list, for example: 
sB
        set-char-mask "a" "`E`eEe" 

sA

cEcESpell Support cEcA


    The current language is set using the Language setting on General page of 
    lslmuser-setup(3)le, if your required language is not listed you must first 
    create the basic language support by following the guide lines in the cDWord 
    CharactercA section above. If you Language is listed, select it and enable 
    it by either pressing cDCurrentcA or saving and restarting MicroEmacs. in a 
    suitable test buffer run the lsspell-buffer(3)lmspelling checkerle, one of three things will 
    happen: 

    The cGSpelling CheckercA dialog opens and spelling is checked 

        The spelling checker is supported by the current language and can be 
        used (the rules and dictionaries have been downloaded and installed). 

    Dialog opens with the following error message: 

            Rules and dictionaries for language "XXXX" 
               are not available, please download. 


        The spelling checker is supported by the current language but the 
        required rules and dictionaries have not been downloaded. You should 
        be able to download them from the JASSPA website, see lsMicroEmacs '02 - Contact InformationlmContactln
        lnInformationle. Once downloaded they must be placed in the MicroEmacs 
        ls$search-path(5)lmsearch pathle, i.e. where the other macro files (like cGme.emfcA) are 
        located. 

    Dialog opens with the following error message: 

            Language "XXXX" not supported! 


        The spelling checker is not supported by the current language, see the 
        following cDAdding Spell SupportcA section. 


cEAdding Spell Support cA


    To support a language MicroEmacs's spelling checker requires a base word 
    dictionary and a set of rules which define what words can be derived from 
    each base word in the dictionary. The concept and format of the word list 
    and rules are compatible with the cDFree Software FoundationcA GNU cDispell(1)cA 
    package. 

    The best starting point is to obtain cDispellcA rules and word lists in plain 
    text form, the web can usually yield these. Once these have been obtained 
    the rules file (or affix file) must be converted to a MicroEmacs macro 
    file calling the lslmadd-spell-rule(2)le command to define the rules. The rule 
    file should be named "cGlsrcAcC<lang-id>cAcG.emfcA" where "cC<lang-id>cA" is the spelling 
    language id, determined by the cD.spell.languagecA variable set in the 
    cGlanguage.emfcA macro file. 

    The cGspellutl.emfcA macro file contains the command cDspell-conv-aff-buffercA 
    which will attempt to convert the buffer but due to formatting anomalies 
    this process often goes wrong so using the command cDspell-conv-aff-linecA 
    (also contained in cGspellutl.emfcA) to convert a single line is often 
    quicker. See existing spelling rule files (cGlsr*.emfcA) for examples and help 
    on command lslmadd-spell-rule(2)le. 

    cDNotecA: the character set used by the rules should be the most appropriate 
    ISO standard (see cDDisplayed Character SetcA section), this can make the 
    process much more difficult if the current character set not compatible, 
    if you are having difficulty with this please e-mail lsMicroEmacs '02 - Contact InformationlmJASSPA Supportle. 

    Once the rules have been created, create a dictionary for the language 
    from the word lists, see help on command lslmadd-dictionary(2)le. The dictionary 
    file name should be "cGlsdmcAcC<lang-id>cAcG.edfcA", if the dictionary is large and 
    can be split into two sections, a set of common words and a set of more 
    obscure ones, create two dictionaries calling the dictionary containing 
    obscure words "cGlsdxcAcC<lang-id>cAcG.edfcA" and the other as above. 

    Once the generated word and dictionary files have been place in the 
    MicroEmacs ls$search-path(5)lmsearch pathle, the spelling checker should find and use them. 
    Please submit your generated support to MicroEmacs for others to benefit. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmcharset-change(3)le, lslmset-char-mask(2)le, lslmtranslate-key(2)le, 
    lslm$box-chars(5)le, lslm$window-chars(5)le, lslm$recent-keys(5)le. 

! 3fgdiff
cEcENAME cEcA


    gdiff - Command line graphical file difference 
$a


cEcESYNOPSIS cEcA


    cDmecA "@gdiff" "cCversion1cA" "cCversion2cA" 


cEcEDESCRIPTION cEcA


    MicroEmacs may be executed from the command line to invoke the cCGraphical 
    DifferencecA lslmgdiff(3)le macro, showing the difference(s) between two files. 

    The editor is invoked in cDgdiffcA mode and shows the difference between the 
    two files on the command line. 


cEcENOTES cEcA


    The macro is defined in file cGgdiff.emfcA. 


cEcESEE ALSO cEcA


    lslmgdiff(3)le, lslmstart-up(3)le. 

! 3fdos2unix
cEcENAME cEcA


    dos2unix - Convert DOS format files to UNIX format files 
$a


cEcESYNOPSIS cEcA


    cDmecA "@dos2unix" cC<files>cA 


cEcEDESCRIPTION cEcA


    The start-up file cGdos2unix.emfcA may be invoked from the command line as a 
    filter to convert all files in MS-DOS (or Windows) format into the correct 
    UNIX format. 

    Each file specified on the command line is interrogated and the line 
    ending modified to UNIX. 


cEcESEE ALSO cEcA


    lslmstart-up(3)le, lslmauto(2m)le, lslmcrlf(2m)le, lslmctrlz(2m)le. 

! 3fbenchmrk
cEcENAME cEcA


    benchmrk - Benchmark MicroEmacs macro processor speed 
$a


cEcESYNOPSIS cEcA


    cDmecA "@benchmrk" 


cEcEDESCRIPTION cEcA


    The start-up file cGbenchmrk.emfcA may be invoked from the command line to 
    time the macro processor variable manipulation times. 

    This macro suite was developed to optimize the macro processor 
    performance, and allows comparable analysis of various macro variable 
    manipulations. The macro is not important in it's own right and is not 
    likely to be useful. Running it will provide an in-site into the speed of 
    the macro language and should indicate to the user what are good and bad 
    things to be doing. 

    As an aside, as MicroEmacs interprets the macro code the it is important 
    that the processing operates at a reasonable speed. Most extensions 
    offering additional functionality are likely to be added to MicroEmacs by 
    way of a macro implementation - this allows speedy development of new 
    features. Obviously core changes do occur when we find that we cannot 
    support certain new requirements, or when the macro code becomes too 
    convoluted. In these cases, new commands are added to help us solve the 
    problem. However, recent evolution of the code has indicated that the core 
    set is now reasonably complete. 


cEcESEE ALSO cEcA


    lslmstart-up(3)le. 

! 3fctags
cEcENAME cEcA


    ctags - Generate a C tags file 
$a


cEcESYNOPSIS cEcA


    cDmecA "@ctags" [cC-v%tag-option=<flags>cA] [cCfilescA] 


cEcEDESCRIPTION cEcA


    The start-up file cGctags.emfcA may be invoked from the command line to 
    generate a cDtagscA file for C and C++ source and header files. 

    Given a list of cCfilescA a tags file cGtagscA is generated in the current 
    directory, which may be used by the lslmfind-tag(2)le command. This is a good 
    alternative on Microsoft platforms where a utility such as cDctags(1)cA is not 
    typically available. If no cCfilescA are specified the default file list is 
    "cG./cA", i.e. process the current directory. If a directory name is given 
    (such as the default "cG./cA") all C and C++ source and header files within 
    the directory will be processed. 

    The value of variable cD%tag-optioncA is used to control the tag generation 
    process, its value cC<flags>cA can contain any number of the following flags: 

    cGacA 
        Append new tags to the existing tag file, note that if also using flag 
        'cGmcA' multiple 'tags' to the same item may be created. 

    cGmcA 
        Enable multiple tags. This enables the existence of 2 tags with the 
        same tag name, but typically with different locations. See help on 
        lslmfind-tag(2)le for more information on multiple tag support. 

    cGrcA 
        Enables recursive mode, any sub-directory found within any given 
        directories will also be processed. 

    cGvcA 
        Add global variables to the tag file. (i.e. variables marked with 
        cCexterncA). 

    cGecA 
        Add enumerated variables to the tag file (i.e. cCenumcA members). 

    cGscA 
        Add structure, type definitions and classes to the tag file (i.e. 
        cCstuctcA, cCtypedefcA and cCclasscA). 

    The generated tags file includes cG#definecA and C++ class names. 


cEcENOTES cEcA


    This function is invoked from menu 

        cDTools -> C Tools -> Create Tags FilecA 

    when the user requests a tags file to be generated. 

    The user setup file "cGmyctags.emfcA" is executed by ctags during start-up, 
    this file can be used to over-ride any of the ctags configuration 
    variables (see below). 

    The following variables are set within "cGctags.emfcA" and are used to control 
    the process:- 

    cD%tag-optioncA 
        Tags options flag, default value is "". See above for more 
        information. 

    cD%tag-filemaskcA 
        A list of source file masks to be processed when a directory is given, 
        default value is "cG:*.[cC]:*.cpp:*.cc:*.h:*.hpp:cA". 

    cD%tag-ignoredircA 
        A list of directories to be ignored when recursive option is used, 
        default value is "cG:SCCS/:CVS/:cA". 

    These variables can be changed using the -v command-line option or via the 
    "cGmyctags.emfcA" file 


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmc(9)le. 

! 3fehftools
cEcENAME cEcA


    ehftools - Generate a MicroEmacs help file 
$a


cEcESYNOPSIS cEcA


    cDmecA "@ehftools" *.htm 


cEcEDESCRIPTION cEcA


    The start-up file cGehftools.emfcA may be invoked from the command line to 
    generate a MicroEmacs help file from a set of HTML files (with the 
    extension cG.htmcA). 

    The MicroEmacs documentation suite of tools has not been officially 
    released as part of the distribution. For reference, the sequence of 
    operations that are performed from the command line or shell script are:- 

        make meehf.hts 
        hts2html -l .htm meehf.hts 
        mv me.htm me/1.htm 
        cd me 
        me "@ehftools" *.htm 


cEcENOTES cEcA


    The cCnroffcA to HTML generator leaves the special markers cG<!-- XI: %s -->cA in 
    the generated HTML code which contain the hypertext link information. 


cEcESEE ALSO cEcA


    lslmstart-up(3)le, lslmehf(8)le. 

! 3femftags
cEcENAME cEcA


    emftags - Generate a MicroEmacs macro tags file 
$a


cEcESYNOPSIS cEcA


    cDmecA "@emftags" [cC-v%tag-option=<flags>cA] [cCfilescA] 


cEcEDESCRIPTION cEcA


    The start-up file cGemftags.emfcA may be invoked from the command line to 
    generate a cDtagscA file for MicroEmacs macro files, lslmemf(8)le. 

    Given a list of cCfilescA a tags file cGtagscA is generated in the current 
    directory, which may be used by the lslmfind-tag(2)le command. If no cCfilescA are 
    specified the default file list is "cG./cA", i.e. process the current 
    directory. If a directory name is given (such as the default "cG./cA") all 
    MicroEmacs macro files within the directory will be processed. 

    The value of variable cD%tag-optioncA is used to control the tag generation 
    process, its value cC<flags>cA can contain any number of the following flags: 

    cGacA 
        Append new tags to the existing tag file, note that if also using flag 
        'cGmcA' multiple 'tags' to the same item may be created. 

    cGmcA 
        Enable multiple tags. This enables the existence of 2 tags with the 
        same tag name, but typically with different locations. See help on 
        lslmfind-tag(2)le for more information on multiple tag support. 

    cGrcA 
        Enables recursive mode, any sub-directory found within any given 
        directories will also be processed. 


cEcENOTES cEcA


    This function is invoked from menu 

        cDTools -> Emf Tools -> Create Tags FilecA 

    when the user requests a tags file to be generated. 

    The user setup file "cGmyemftags.emfcA" is executed by emftags during 
    start-up, this file can be used to over-ride any of the emftags 
    configuration variables (see below). 

    The following variables are set within "cGemftags.emfcA" and are used to 
    control the process:- 

    cD%tag-optioncA 
        Tags options flag, default value is "". See above for more 
        information. 

    cD%tag-filemaskcA 
        A list of source file masks to be processed when a directory is given, 
        default value is "cG:*.emf:cA". 

    cD%tag-ignoredircA 
        A list of directories to be ignored when recursive option is used, 
        default value is "cG:SCCS/:CVS/:cA". 

    These variables can be changed using the -v command-line option or via the 
    "cGmyemftags.emfcA" file 


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmemf(8)le. 

! 3fntags
cEcENAME cEcA


    ntags - Generate a nroff tags file 
$a


cEcESYNOPSIS cEcA


    cDmecA "@ntags" cC<files>cA 


cEcEDESCRIPTION cEcA


    The start-up file cGntags.emfcA may be invoked from the command line to 
    generate a cDtagscA file for nroff files. 

    Given a list of cCfilescA a tags file cGtagscA is generated in the current 
    directory, which may be used by the lslmfind-tag(2)le command. If no cCfilescA are 
    specified the default file list is "cG./cA", i.e. process the current 
    directory. If a directory name is given (such as the default "cG./cA") all 
    nroff files within the directory will be processed. 

    The value of variable cD%tag-optioncA is used to control the tag generation 
    process, its value cC<flags>cA can contain any number of the following flags: 

    cGacA 
        Append new tags to the existing tag file, note that if also using flag 
        'cGmcA' multiple 'tags' to the same item may be created. 

    cGmcA 
        Enable multiple tags. This enables the existence of 2 tags with the 
        same tag name, but typically with different locations. See help on 
        lslmfind-tag(2)le for more information on multiple tag support. 

    cGrcA 
        Enables recursive mode, any sub-directory found within any given 
        directories will also be processed. 


cEcENOTES cEcA


    This function is invoked from menu 

        cDTools -> Nroff Tools -> Create Tags FilecA 

    when the user requests a tags file to be generated. 

    The tags are generated from the nroff macro:- 

        .XI <name> ...... 


    which indicates an index entry, where cC<name>cA is the tag name. cC<name>cA may 
    be delimited by double quotes if any whitespace is present in the string. 

    This is the macro definition used in the MicroEmacs documentation system. 
    The cGntags.emfcA file should be edited and shadowed in the user directory if 
    some other search criteria is used for nroff files. This macro file should 
    provide a good starting point for any other search. 

    The user setup file "cGmyntags.emfcA" is executed by ntags during start-up, 
    this file can be used to over-ride any of the ntags configuration 
    variables (see below). 

    The following variables are set within "cGntags.emfcA" and are used to control 
    the process:- 

    cD%tag-optioncA 
        Tags options flag, default value is "". See above for more 
        information. 

    cD%tag-filemaskcA 
        A list of source file masks to be processed when a directory is given, 
        default value is "cG:*.nrs:*.[1-9]:*.n:cA". 

    cD%tag-ignoredircA 
        A list of directories to be ignored when recursive option is used, 
        default value is "cG:SCCS/:CVS/:cA". 

    These variables can be changed using the -v command-line option or via the 
    "cGmyntags.emfcA" file 


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmnroff(9)le. 

! 3fprintall
cEcENAME cEcA


    printall - Formatted print job 
$a


cEcESYNOPSIS cEcA


    cDmecA "@printall" cC<files>cA 


cEcEDESCRIPTION cEcA


    The start-up file cGprintalls.emfcA may be invoked from the command line to 
    generate a print job for each file specified on the command line. 

    Given a list of cC<files>cA, the files are loaded into the editor, and then 
    printed through MicroEmacs printing formatter. This is an alternative to 
    cDcgrind(1)cA or some other syntax smart cCpretty printcA filter. 

    The operation of this macro assumes that the printer is functioning 
    correctly. 


cEcEBUGS cEcA


    As a guess, I would probably bet that this does not work very well on 
    Windows as a dialog is invoked for the print. 


cEcESEE ALSO cEcA


    lslmstart-up(3)le. 

! 3ftcltags
cEcENAME cEcA


    tcltags - Generate a Tcl/Tk tags file 
$a


cEcESYNOPSIS cEcA


    cDmecA "@tcltags" cC<files>cA 


cEcEDESCRIPTION cEcA


    The start-up file cGtcltags.emfcA may be invoked from the command line to 
    generate a cDtagscA file for lstcl(9)lmTcl/Tkle files. 

    Given a list of cCfilescA a tags file cGtagscA is generated in the current 
    directory, which may be used by the lslmfind-tag(2)le command. If no cCfilescA are 
    specified the default file list is "cG./cA", i.e. process the current 
    directory. If a directory name is given (such as the default "cG./cA") all 
    Tcl/Tk files within the directory will be processed. 

    The value of variable cD%tag-optioncA is used to control the tag generation 
    process, its value cC<flags>cA can contain any number of the following flags: 

    cGacA 
        Append new tags to the existing tag file, note that if also using flag 
        'cGmcA' multiple 'tags' to the same item may be created. 

    cGmcA 
        Enable multiple tags. This enables the existence of 2 tags with the 
        same tag name, but typically with different locations. See help on 
        lslmfind-tag(2)le for more information on multiple tag support. 

    cGrcA 
        Enables recursive mode, any sub-directory found within any given 
        directories will also be processed. 


cEcENOTES cEcA


    This function is invoked from menu 

        cDTools -> Tcl Tools -> Create Tags FilecA 

    when the user requests a tags file to be generated. 

    The following variables are set within "cGtcltags.emfcA" and are used to 
    control the process:- 

    cD%tag-optioncA 
        Tags options flag, default value is "". See above for more 
        information. 

    cD%tag-filemaskcA 
        A list of source file masks to be processed when a directory is given, 
        default value is "cG:*.tcl:*.tk:cA". 

    cD%tag-ignoredircA 
        A list of directories to be ignored when recursive option is used, 
        default value is "cG:SCCS/:CVS/:cA". 

    These variables can be changed using the -v command-line option or via the 
    "cGmytcltags.emfcA" file 


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmtcl(9)le. 

! 3ftextags
cEcENAME cEcA


    textags - Generate a LaTeX/BibTeX tags file 
$a


cEcESYNOPSIS cEcA


    cDmecA "@textags" cC<files>cA 


cEcEDESCRIPTION cEcA


    The start-up file cGtextags.emfcA may be invoked from the command line to 
    generate a cDtagscA file for lslatex(9)lmLaTeXle and lslatex(9)lmBibTeXle files. 

    Given a list of cCfilescA a tags file cGtagscA is generated in the current 
    directory, which may be used by the lslmfind-tag(2)le command. If no cCfilescA are 
    specified the default file list is "cG./cA", i.e. process the current 
    directory. If a directory name is given (such as the default "cG./cA") all 
    LaTeX files within the directory will be processed. 

    The value of variable cD%tag-optioncA is used to control the tag generation 
    process, its value cC<flags>cA can contain any number of the following flags: 

    cGacA 
        Append new tags to the existing tag file, note that if also using flag 
        'cGmcA' multiple 'tags' to the same item may be created. 

    cGmcA 
        Enable multiple tags. This enables the existence of 2 tags with the 
        same tag name, but typically with different locations. See help on 
        lslmfind-tag(2)le for more information on multiple tag support. 

    cGrcA 
        Enables recursive mode, any sub-directory found within any given 
        directories will also be processed. 


cEcENOTES cEcA


    This function is invoked from menu 

        cDTools -> LaTeX Tools -> Create Tags FilecA 

    when the user requests a tags file to be generated. 

    The following variables are set within "cGtextags.emfcA" and are used to 
    control the process:- 

    cD%tag-optioncA 
        Tags options flag, default value is "". See above for more 
        information. 

    cD%tag-filemaskcA 
        A list of source file masks to be processed when a directory is given, 
        default value is "cG:*.tex:*.bib:cA". 

    cD%tag-ignoredircA 
        A list of directories to be ignored when recursive option is used, 
        default value is "cG:SCCS/:CVS/:cA". 

    These variables can be changed using the -v command-line option or via the 
    "cGmytextags.emfcA" file 


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmtex(9)le. 

! 3fjavatags
cEcENAME cEcA


    javatags - Generate a C tags file from Java sources. 
$a


cEcESYNOPSIS cEcA


    cDmecA "@javatags" [cC-v%tag-option=<flags>cA] [cCfilescA] 


cEcEDESCRIPTION cEcA


    The start-up file cGjavatags.emfcA may be invoked from the command line to 
    generate a cDtagscA file for java source files. 

    Given a list of cCfilescA a tags file cGtagscA is generated in the current 
    directory, which may be used by the lslmfind-tag(2)le command. This is a good 
    alternative on Microsoft platforms where a utility such as cDctags(1)cA is not 
    typically available to process Java files. If no cCfilescA are specified the 
    default file list is "cG./cA", i.e. process the current directory. If a 
    directory name is given (such as the default "cG./cA") all Java source files 
    within the directory will be processed. 

    The value of variable cD%tag-optioncA is used to control the tag generation 
    process, its value cC<flags>cA can contain any number of the following flags: 

    cGacA 
        Append new tags to the existing tag file, note that if also using flag 
        'cGmcA' multiple 'tags' to the same item may be created. 

    cGmcA 
        Enable multiple tags. This enables the existence of 2 tags with the 
        same tag name, but typically with different locations. See help on 
        lslmfind-tag(2)le for more information on multiple tag support. 

    cGrcA 
        Enables recursive mode, any sub-directory found within any given 
        directories will also be processed. 

    cGvcA 
        Add global variables to the tag file. (i.e. variables marked with 
        cCexterncA). 

    cGscA 
        Add classes definitions to the tag file (i.e. cCclasscA). 

    The generated tags file includes cG#definecA and C++ class names. 


cEcENOTES cEcA


    This function is invoked from menu 

        cDTools -> C Tools -> Create Tags FilecA 

    when the user requests a tags file to be generated. 

    The user setup file "cGmyjavatags.emfcA" is executed by javatags during 
    start-up, this file can be used to over-ride any of the javatags 
    configuration variables (see below). 

    The following variables are set within "cGjavatags.emfcA" and are used to 
    control the process:- 

    cD%tag-optioncA 
        Tags options flag, default value is "". See above for more 
        information. 

    cD%tag-filemaskcA 
        A list of source file masks to be processed when a directory is given, 
        default value is "cG:*.java:*.jav:cA". 

    cD%tag-ignoredircA 
        A list of directories to be ignored when recursive option is used, 
        default value is "cG:SCCS/:CVS/:cA". 

    These variables can be changed using the -v command-line option or via the 
    "cGmyjavatags.emfcA" file 


cEcESEE ALSO cEcA


    lslmfind-tag(2)le, lslmstart-up(3)le, lslmjava(9)le. 

! 3 compile
cEcENAME cEcA


    compile - Start a compilation process 
$a


cEcESYNOPSIS cEcA


    cCncA cDcompilecA "cCcompile-commandcA" 


cEcEDESCRIPTION cEcA


    cDcompilecA gets and executes the compile command using a pipe execution 
    (incremental pipe on UNIX platforms), loading the output into a buffer 
    called "cD*compile*cA", with go to error parsing using the command 
    lslmget-next-line(2)le. The default compile execution is set by variable 
    lslm%compile-com(5)le, the error parsing is setup using the command 
    lslmadd-next-line(2)le. 

    Before the compile command is executed lslmsave-some-buffers(2)le is executed to 
    allow the user to ensure that all relevant buffers are saved. If an 
    argument is given to compile then it is passed on to this command, so if 
    an argument of 0 is given, all buffers are automatically saved. 


cEcENOTES cEcA


    cDcompilecA is a macro defined in cGtools.emfcA. 


cEcESEE ALSO cEcA


    lslmadd-next-line(2)le, lslm%compile-com(5)le, lslmget-next-line(2)le, lslmsave-some-buffers(2)le, 
    lslmgrep(3)le. 

! 3 grep
! 3 rgrep
cEcENAME cEcA


    grep - Execute grep command rgrep - Execute recursive grep command 
$a


cEcESYNOPSIS cEcA


|grep
    cDgrepcA "cCexpression files...cA" 
|rgrep
    cDrgrepcA "cCexpressioncA" "cCbase-pathcA" "cCfile-maskcA" 


cEcEDESCRIPTION cEcA


    cDgrepcA executes the cDgrep(1)cA command with the command line set by the 
    lslm%grep-com(5)le variable and the user supplied cCexpressioncA and file list 
    cCfiles...cA. The output of the command is piped into the cD*grep*cA buffer ready 
    for the lslmget-next-line(2)le command to step through all matched lines. The 
    syntax from the grep output must be setup using lslmadd-next-line(2)le. 

    If an argument is given then a lslmpipe-shell-command(2)le is used instead of 
    lslmipipe-shell-command(2)le, this is useful when used in macros as it ensures 
    that cDgrepcA has finished before the command returns. 

    cDrgrepcA is simpler to cDgrepcA in that it uses cDgrep(1)cA to search for all 
    occurrences of cCexpressioncA, but cDrgrepcA also uses cDfind(1)cA to search for 
    cCexpressioncA in all files matching the cCfile-maskcA in all directories from 
    cCbase-pathcA down. 


cEcENOTES cEcA


    cDgrepcA is a macro defined in cGtools.emfcA. 

    cDgrep(1)cA must be executable on the system before grep or rgrep can 
    function, cDfind(1)cA must also be available for rgrep to work. 


cEcEEXAMPLE cEcA


    The cDgrepcA command is generally set up in the startup files as follows:- 
sB
        ; 
        ; setup the next-error stuff including grep and compiling 
        ; 
        set-variable $line-template "[0-9]+" 
        set-variable $file-template "[a-zA-Z:]*[0-9a-zA-Z\_.]+" 
        ; 
        ; Definitions for GNU grep utility. 
        ; 
        set-variable %grep-com "grep -n " 
        0 add-next-line "*grep*" 
        add-next-line "*grep*" "%f:%l:" 

sA

cEcESEE ALSO cEcA


    cDgrep(1)cA, lslm%grep-com(5)le, lslmadd-next-line(2)le, lslmget-next-line(2)le, lslmcompile(3)le. 

! 3 save-all
cEcENAME cEcA


    save-all - Save all modified files (with query) 
$a


cEcESYNOPSIS cEcA


    cCncA cDsave-allcA 


cEcEDESCRIPTION cEcA


    cDsave-allcA cycles through all buffers, dictionaries and registry files 
    writing back any changes made. For each buffer, dictionary or registry 
    file which has been modified the user is prompted before the changes are 
    saved, a value of cDycA initiates the save, cDncA skips the save. 

    The argument cCncA can be used to change the default behavior of save-all 
    described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Enables the user prompt before the file is saved (default). If this 
        flag is not supplied then all modified files will automatically be 
        written. 


cEcENOTES cEcA


    cDsave-allcA is a macro defined in cGme.emfcA, using commands 
    lslmsave-some-buffers(2)le, lslmsave-dictionary(2)le and lslmsave-registry(2)le. 


cEcESEE ALSO cEcA


    lslmsave-some-buffers(2)le, lslmsave-dictionary(2)le, lslmsave-registry(2)le. 

! 3 paragraph-to-line
cEcENAME cEcA


    paragraph-to-line - Convert a paragraph to a single line 
$a


cEcESYNOPSIS cEcA


    cCncA cDparagraph-to-linecA 


cEcEDESCRIPTION cEcA


    cDparagraph-to-linecA is a variation of lslmfill-paragraph(2)le. cDparagraph-to-linecA 
    reduces each of the next cCncA paragraphs of text to single lines. This 
    command is typically used to prepare text for import into a word processor 
    such as cDMicrosoft WordcA or cDWord PerfectcA. Reduction of text to a single line 
    allows the word processor to import the raw text file and keep the text 
    within paragraph blocks. If the text is not prepared then all of the 
    line-feeds have to be manually deleted. 

    cDparagraph-to-linecA allows text based documents to be prepared in MicroEmacs 
    '02 and imported into the word processor at the final stage for formatting 
    and layout. 


cEcENOTES cEcA


    cDparagraph-to-linecA is a macro defined in cGformat.emfcA. 


cEcESEE ALSO cEcA


    lslmfill-paragraph(2)le. 

! 3 sort-lines-ignore-case
cEcENAME cEcA


    sort-lines-ignore-case - Alphabetically sort lines ignoring case" 
$a


cEcESYNOPSIS cEcA


    cCncA cDsort-lines-ignore-casecA 


cEcEDESCRIPTION cEcA


    cDsort-lines-ignore-casecA forces the current buffers lslmexact(2m)le mode to off 
    and then calls lslmsort-lines(2)le which will perform a case insensitive 
    alphabetical line sort from the mark position to the current cursor 
    position. The state of the current buffers cDexactcA mode is restored on 
    completion. 


cEcENOTES cEcA


    cDsort-lines-ignore-casecA is a macro defined in cGformat.emfcA, see help on 
    command lslmsort-lines(2)le for a complete definition. 


cEcESEE ALSO cEcA


    lslmsort-lines(2)le, lslmbuffer-mode(2)le, lslmexact(2m)le, lslmtranspose-lines(2)le. 

! 3 clean
cEcENAME cEcA


    clean - Remove redundant white spaces from the current buffer 
$a


cEcESYNOPSIS cEcA


    cCncA cDcleancA 


cEcEDESCRIPTION cEcA


    cDcleancA removes redundant white spaces from the current buffer, there are 
    three types this command remove: 

    1) 
        Any space or tab character at the end of the line. All are removed 
        until the last character is not a space or a tab, or the line is 
        empty. Note that an empty line is not removed unless at the end of the 
        buffer. 

    2) 
        Space characters are removed when the next character is a tab, making 
        the space redundant, e.g. the strings "cG Hello WorldcA" and "cG Hello 
        WorldcA" will look identical because the tab character ('cC cA') will indent 
        the text to the 8th column with or without the space so the space can 
        be removed. 

    3) 
        Superfluous empty lines at the end of the buffer are removed, leaving 
        only one empty line. 

    4) 
        If argument cCncA is given (value is not used) multiple blank lines are 
        reduced to a single blank line. 


cEcEDIAGNOSTICS cEcA


    cG[Command illegal in view mode]cA 
        Caused by a redundant white space being found and the buffer being in 
        view mode. Note that if clean completes while the buffer is in view 
        mode then no superfluous white spaces where found. 


cEcENOTES cEcA


    cDcleancA is a macro defined in cGformat.emfcA. 

    Most of this command's operation is performed by simple regex search and 
    replace strings: 

    a) 
        Search for: "[\t ]+$" Replace with: "\\0" 

    b) 
        Search for: "[ ]+\t" Replace with: "\t" 

    c) 
        Search for: "\n\n\n" Replace with: "\n\n" 


cEcESEE ALSO cEcA


    lslmreplace-string(2)le, lslmtab(2m)le, lslmdelete-blank-lines(2)le, lslmtabs-to-spaces(3)le. 

! 3 replace-all-string
cEcENAME cEcA


    replace-all-string - Replace string with new string in a list of files 
$a


cEcESYNOPSIS cEcA


    cCncA cDreplace-all-stringcA "cCfromcA" "cCtocA" "cCfilescA" ["cCgrep-fromcA"] 


cEcEDESCRIPTION cEcA


    cDreplace-all-stringcA, similar to lslmreplace-string(2)le, replaces all occurrences 
    of "cCfromcA" to "cCtocA" in the given list of files without prompting the user. 

    The command finds all occurrences of "cCfromcA" by calling the command lslmgrep(3)le 
    to search for string "cCfromcA" in files "cCfilescA". Thus all relevant edited 
    files must be saved or cDgrepcA may return the wrong line numbers. This is 
    achieved by a call to lslmsave-some-buffers(2)le which prompts the user to save 
    any changed buffers one at a time. 

    Each occurrence of "cCfromcA" is jumped to using lslmget-next-line(2)le and the 
    string is replaced by the call: 
sB
        -1 replace-string "from" "to" 

sA
    This replaces all occurrences of "cCfromcA" to "cCtocA" on the current line only, 
    hence the line numbers must be correct. This also means that the "cCfromcA" 
    search string must be correctly formatted for both grep and 
    replace-string, unless bit 0x02 is set (see below). 

    The given argument cCncA is a bit based flag which changes the default 
    behavior described above. The bits have the following effect:- 

    cD0x01cA 
        Prompt before saving any changed buffer, enabled by default. If this 
        bit is not set then any changed buffer is automatically saved before 
        the cDgrepcA is performed. 

    cD0x02cA 
        If set then a fourth argument "cCgrep-fromcA" must also be given. This 
        string is used in place of the "cCfromcA" string for the cDgrepcA only. 


cEcENOTES cEcA


    cDreplace-all-stringcA is a macro defined in cGsearch.emfcA. 

    The cDgrepcA command must be working before this command can function 
    properly. 

    It is not recommended to use a "from" or "to" string which uses more that 
    one line as the results may be unpredictable. 

    As the change is likely to be over several files a single call to lslmundo(2)le 
    at the end of execution will not undo all the changes made. To undo all 
    the changes made, use lslmget-next-line(2)le to loop through all the occurrences 
    and call cDundocA for each occurrence 


cEcESEE ALSO cEcA


    lslmreplace-string(2)le, lslmsave-some-buffers(2)le, lslmgrep(3)le, lslmget-next-line(2)le, 
    lslmundo(2)le, lslmquery-replace-all-string(3)le, lslmreplace-all-pairs(3)le, 
    lslmsearch-forward(2)le. 

! 3 query-replace-all-string
cEcENAME cEcA


    query-replace-all-string - Query replace string in a list of files 
$a


cEcESYNOPSIS cEcA


    cCncA cDquery-replace-all-stringcA "cCfromcA" "cCtocA" "cCfilescA" ["cCgrep-fromcA"] 


cEcEDESCRIPTION cEcA


    cDquery-replace-all-stringcA, similar to lslmquery-replace-string(2)le, replaces all 
    occurrences of "cCfromcA" to "cCtocA" in the given list of files prompting the 
    user before replacing each occurrence. 

    The command finds all occurrences of "cCfromcA" by calling the command lslmgrep(3)le 
    to search for string "cCfromcA" in files "cCfilescA". Thus all relevant edited 
    files must be saved or cDgrepcA may return the wrong line numbers. This is 
    achieved by a call to lslmsave-some-buffers(2)le which prompts the user to save 
    any changed buffers one at a time. 

    Each occurrence of "cCfromcA" is jumped to using lslmget-next-line(2)le and the 
    string is replaced by the call: 
sB
        -1 query-replace-string "from" "to" 

sA
    This query-replaces all occurrences of "cCfromcA" to "cCtocA" on the current line 
    only, hence the line numbers must be correct. This also means that the 
    "cCfromcA" search string must be correctly formatted for both grep and 
    query-replace-string, unless bit 0x02 is set (see below). 

    The given argument cCncA is a bit based flag which changes the default 
    behavior described above. The bits have the following effect:- 

    cD0x01cA 
        Prompt before saving any changed buffer, enabled by default. If this 
        bit is not set then any changed buffer is automatically saved before 
        the cDgrepcA is performed. 

    cD0x02cA 
        If set then a fourth argument "cCgrep-fromcA" must also be given. This 
        string is used in place of the "cCfromcA" string for the cDgrepcA only. 


cEcENOTES cEcA


    cDquery-replace-all-stringcA is a macro defined in cGsearch.emfcA. 

    The cDgrepcA command must be working before this command can function 
    properly. 

    It is not recommended to use a "from" or "to" string which uses more that 
    one line as the results may be unpredictable. 

    As the change is likely to be over several files a single call to lslmundo(2)le 
    at the end of execution will not undo all the changes made. To undo all 
    the changes made, use lslmget-next-line(2)le to loop through all the occurrences 
    and call cDundocA for each occurrence 


cEcESEE ALSO cEcA


    lslmquery-replace-string(2)le, lslmsave-some-buffers(2)le, lslmgrep(3)le, lslmget-next-line(2)le, 
    lslmundo(2)le, lslmreplace-all-string(3)le, lslmsearch-forward(2)le. 
    lsRegularExpressions(2)lmRegular Expressionsle 

! 3 tabs-to-spaces
cEcENAME cEcA


    tabs-to-spaces - Converts all tabs to spaces 
$a


cEcESYNOPSIS cEcA


    cDtabs-to-spacescA 


cEcEDESCRIPTION cEcA


    cDtabs-to-spacescA converts all tab characters found in the current buffer 
    with spaces. The number of spaces a tab is replaced with depends on the 
    column of the tab character and the setting of lslm$tabwidth(5)le. 

    The cursor is restored to the start of the current line after completion. 


cEcENOTES cEcA


    cDtabs-to-spacescA is a macro defined in cGformat.emfcA. 


cEcESEE ALSO cEcA


    lslm$tabwidth(5)le, lslmtab(2)le, lslmtab(2m)le, lslmclean(3)le. 

! 3 calc
cEcENAME cEcA


    calc - Integer calculator 
$a


cEcESYNOPSIS cEcA


    cCncA cDcalccA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cDcalccA can perform simple integer based calculations given by "cCstringcA", 
    where the "cCstringcA" takes the following form:- 

        "[b]<s>" 


    Where 'cCbcA' is an optional letter setting the required output base which can 
    be one of the following: 

        cGb   cA - Binary 
        cGo   cA - Octal 
        cGd   cA - Decimal 
        cGx   cA - Hexadecimal 

    Default when omitted is 'cCdcA' (decimal). "cCscA" is the sum to be calculated, 
    which should be bodmas in form. Following is a list of valid symbols. 

        cG(..)cA - Parentheses (contents calculated first) 
        cG!   cA - Logical not 
        cG&&  cA - Logical and 
        cG||  cA - Logical or 
        cG==  cA - Logical equals 
        cG!=  cA - Logical not equals 
        cG~   cA - Bitwise not 
        cG&   cA - Bitwise and 
        cG|   cA - Bitwise or 
        cG^   cA - Bitwise xor 
        cG/   cA - Divide 
        cG*   cA - Multiply 
        cG%   cA - Modulus 
        cG+   cA - Addition 
        cG-   cA - Subtraction 
        cG0xNNcA - Hexadecimal number 
        cG0NN cA - Octal number 
        cGLR  cA - Last calculation recall 

    Any MicroEmacs variables can be used in the calculation. The result of the 
    calculation is stored in lslm.calc.result(5)le. The argument cCncA is a bitwise flag 
    where: 

    cD0x01cA 
        Print out the result on the message-line. 

    cD0x02cA 
        Use string comparisons for == and != comparisons. This has the 
        advantage of being able to calc "Foo" == "Bar" etc. 

    When omitted the default argument is 1. 


cEcEEXAMPLE cEcA


    To calculate the number of hours in a year: 

        calc "365*24" 


    To then calculate the number of seconds in the year: 

        calc "LR*60*60" 


cEcENOTES cEcA


    cDcalccA is a macro defined in cGcalc.emfcA. 


cEcESEE ALSO cEcA


    lslm.calc.result(5)le. 

! 3 time
cEcENAME cEcA


    time - Command time evaluator 
$a


cEcESYNOPSIS cEcA


    cDtimecA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cDtimecA evaluates the time take to execute line "cCstringcA". cDtimecA uses command 
    lslmexecute-line(2)le to execute the given string. 


cEcEEXAMPLE cEcA


    The following example simply times the time take to save the current 
    buffer:- 

        time "save-buffer" 


cEcENOTES cEcA


    cDtimecA is a macro defined in cGmisc.emfcA. 

    On multi-task systems like UNIX cDtimecA cannot take into account the number 
    of other processes running at the same time, it can only return the actual 
    time elapse. This leads to inaccuracies and variation in results. 


cEcESEE ALSO cEcA


    lslmexecute-line(2)le. 

! 3 alarm
cEcENAME cEcA


    alarm - Set an alarm 
$a


cEcESYNOPSIS cEcA


    cDalarmcA "cCmessagecA" "cChourscA" "cCminutescA" 


cEcEDESCRIPTION cEcA


    cDalarmcA creates an alarm for the user which will print the given "cCmessagecA" 
    in the given number of "cChourscA" and "cCminutescA" time from the moment of 
    creation. 

    The message is printed on the screen using lslmosd(2)le. 


cEcENOTES cEcA


    cDalarmcA is a macro defined in cGmisc.emfcA. 


cEcESEE ALSO cEcA


    lslmosd(2)le. 

! 3 Mahjongg
cEcENAME cEcA


    Mahjongg - MicroEmacs '02 version of the solitaire Mah Jongg game 
$a


cEcESYNOPSIS cEcA


    cDMahjonggcA 


cEcEDESCRIPTION cEcA


    Mah Jongg is an ancient Chinese game usually played by four players with 
    tiles similar to dominos. This is a MicroEmacs '02 version which was 
    inspired by the X-Windows version of the same game. The X-Windows version 
    for the solitaire game originally seen on the PC and later ported to 
    SunView. 


cETheory Of Play cA


    The object of the game is to remove all the tiles from the board. Tiles 
    are removed by matching two identical tiles which have either an open left 
    edge or open right edge. The only exception to this rule is that any open 
    "cCflowercA" tile (bamboo cG[BAMB]cA, orchid cG[ORCH]cA, plum cG[PLUM]cA, or chrysanthemum 
    cG[CHRY]cA) matches any other open "cCflowercA" tile and any open "cCseasoncA" tile 
    (spring, summer, autumn, or winter) matches any other open "cCseasoncA" tile. 

    Tiles are stacked on the board, the height of the tile is indicated by the 
    color coding as follows:- 

        cGLevel 5cA - White 
        cGLevel 4cA - Red 
        cGLevel 3cA - Yellow 
        cGLevel 2cA - Green 
        cGLevel 1cA - Cyan 

    To remove a pair of tiles, click the left mouse button on a tile (which 
    will show in the selection color) and then click the left mouse button on 
    the matching tile. At this point, both tiles will disappear from the 
    board. If after selecting the first tile, you decide that you don't wish 
    to play that tile, simply reclick the left button on the selected tile, 
    alternatively click the right button to deselect any selected tile. 

    To the right of the board are a number of control buttons. To select an 
    option, click the left mouse button on it. 

    cDNEWcA 
        Start a new game (keyboard n). 

    cDSAMEcA 
        Start the same game again (keyboard s). 

    cDQUITcA 
        Exit the game (keyboard q). 

    cDHELPcA 
        This help page (keyboard esc h). 

    The counter shows the number of remaining tiles on the board, at the start 
    of the game there are 144 tiles. 


cEcENOTES cEcA


    Mahjongg is a macro defined in cGmahjongg.emfcA. 

    Mah Jongg may only be played with a mouse, there is no keyboard support, 
    with the exception of the re-start keys. 


cEcEACKNOWLEDGEMENT cEcA


    Thanks to Jeff S. Young who (I think) wrote the original X-Windows 
    version, and whose manual page formed the basis of this page. 

    The tile patterns were inspired from the X-Windows tile patterns. The 
    X-Windows tile patterns themselves are copyright 1988 by Mark A. Holm 
    <tektronix!tessi!exc!markh>. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - GameslmGamesle, lslmMatch-It(3)le, lslmPatience(3)le. 

! 3 Match-It
cEcENAME cEcA


    Match-It - MicroEmacs '02 version of the Match-It game 
$a


cEcESYNOPSIS cEcA


    cDMatch-ItcA 


cEcEDESCRIPTION cEcA


    The object of the game is to score the largest number of points, to do 
    this the player must complete as many sheets as possible. A sheet is 
    completed when all the tiles are removed from the board within the given 
    time limit - ALL sheet are possible. If the player fails to remove all the 
    tiles before the time runs out a life is lost, if all lives have been lost 
    then the game is over. 

    Tiles are removed from the board by matching two identical tiles which 
    have an 'extraction' path between them. The only exception to this rule is 
    that any open "cCflowercA" tile (bamboo cG[BAMB]cA, orchid cG[ORCH]cA, plum cG[PLUM]cA, or 
    chrysanthemum cG[CHRY]cA) matches any other open "cCflowercA" tile and any open 
    "cCseasoncA" tile (spring, summer, autumn, or winter) matches any other open 
    "cCseasoncA" tile. 

    An 'extraction' path is a straight line which uses 2 or less right angles, 
    the following are legal extraction paths, 'cG*cA's denote the right angles: 

                        A---*       *-----*     A----* 
            A----A          A       AXXXXXA     XXXXX| 
                                                A----* 


    The following are illegal paths: 

            *----*          *---* 
            AXXXX|          |XXXA 
            XXXXA*      A---*XXXX 


    2 points are added to the score whenever a pair is successfully removed, a 
    point is deducted whenever a pair is selected which can not be removed 
    because there is no valid extraction path. There are 2 aids, pressing the 
    right button on a tile when no other tile is selected will hilight all 
    tiles of matching type, this costs 4 points. The other help is activated 
    by a button at the top right of the screen and it removes a random 
    removable pair (or informs the user that there are no removable pairs), 
    there are a limited number of these helps. 

    At the end of a successful sheet the score is increased be the time left, 
    the number of lives and helps remaining and by the Pedigree and Internal 
    bonuses if they were achieved. 

    The Pedigree bonus is obtained when only identical tiles are paired, i.e. 
    no differing flowers or seasons were paired, 50 points are awarded when 
    achieved. Its status is indicated by a 'P' to the left of the 'Help' 
    button and the top of the window. 

    The internal bonus is obtained when the outer 4 margins are not used. If 
    the left or right margins are not used then 10 points are awarded for 
    each, if the top or bottom are not used then 20 points are awarded for 
    each and if none are used then 400 points are awarded! The status on the 
    Internal bonus is indicated by an 'cGIcA' surrounded by 'cG*cA's, one for each 
    margin. This can be found next to the Pedigree bonus 'cGPcA'. 


cEcEGAME CONTROLS cEcA


    To the right of the high score table on the main menu there are a number 
    of control buttons. To select an option, click the left mouse button on 
    it. 

    cDNEWcA 
        Start a new game. 

    cDQUITcA 
        Exit Match-It. 

    cDHELPcA 
        This help page (keyboard esc h). 

    During a sheet, to remove a pair of tiles, click the left mouse button on 
    a tile (which will show in the selection color) and then click the left 
    mouse button on the matching tile. At this point, if the tiles can be 
    removed, the extraction path is drawn and both tiles will disappear from 
    the board. If after selecting the first tile, you decide that you don't 
    wish to play that tile, simply reclick the left button on the selected 
    tile, alternatively click the right button to deselect any selected tile. 

    To the top right of the sheet there are a number of control buttons:- 

    cDHELPcA 
        Removes a tile pair. 

    cDQUITcA 
        Exit the game. 

    cDBOSScA 
        Hides Match-It, also acts as a pause. Execute Match-It again to return 
        to the game. 

    The top left shows the number of remaining lives, the current sheet level, 
    the current score, time remaining for the current sheet and the status of 
    the Internal and Pedigree bonuses. 


cEcENOTES cEcA


    Match-It is a macro defined in cGmatchit.emfcA. 

    Match-It may only be played with a mouse, there is no keyboard support, 
    with the exception of the re-start keys. 

    The sheet database file matchit.edf must be accessible for Match-It to 
    work. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - GameslmGamesle, lslmMahjongg(3)le, lslmMetris(3)le. 

! 3 Metris
cEcENAME cEcA


    Metris - MicroEmacs '02 version of the falling blocks game 
$a


cEcESYNOPSIS cEcA


    cDMetriscA 


cEcEDESCRIPTION cEcA


    Traditional falling blocks game, make solid horizontal lines out of the 
    falling blocks. The blocks can be rotated and moved left or right by the 
    user as they fall. Once a horizontal line is completely solid it will 
    disappear and everything above it will drop down. A bonus is given if 3 
    solid rows are made at the same time, i.e. using one block. 

    Every line you make the game speeds up until it gets too fast!! The game 
    ends when there is no more room to put a block. 

    The keys used to control Metris are: 

    cDleftcA or cDjcA 
        Move the block left one character. 

    cDrightcA or cDlcA 
        Move the block right one character. 

    cDdowncA or cDkcA 
        Rotate the block counter-clockwise 90 degrees. 

    cDspacecA 
        Drop the current block. 

    cDpcA 
        Pause the current game. 

    cDqcA 
        Quit the current game. 

    cDC-lcA 
        Redraw the display. 

    cDreturncA 
        Start a new game. 

    cDesc hcA 
        View this help page. 


cEcENOTES cEcA


    cDMetriscA is a macro defined in cGmetris.emfcA. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - GameslmGamesle, lslmMatch-It(3)le, lslmPatience(3)le. 

! 3 Patience
cEcENAME cEcA


    Patience - MicroEmacs '02 version of Patience (or Solitaire) 
$a


cEcESYNOPSIS cEcA


    cDPatiencecA 


cEcEDESCRIPTION cEcA


    Patience (or Solitaire) is a solitaire game using a standard set of 
    playing cards. The object of the game is to use all of the cards in the 
    deck to build up four suit stacks from Ace to King. 

    The board is laid out with the dealer pile at the top right hand corner, 
    to the left are four suit stacks onto which cards of the same suit are 
    placed, in ascending order from the Ace. Below these two areas of the 
    board are seven row stacks, organized in a triangular shape with zero to 
    six downward facing cards. 

    Cards may be moved around the playing area by stacking alternative red and 
    black cards in descending order on the row stacks. When a row stack has no 
    upturned cards on the stack then the top card may be turned over and may 
    be played. If a stack becomes empty then only a King may be moved into the 
    vacant position. Cards may be removed from the dealer, they are 
    over-turned in sets of three cards, the underlying 2 cards are visible, 
    but are not accessible, only the top card may be removed and played from 
    the dealer. 

    Cards are moved around the board using the mouse. Cards may be moved from 
    the dealer or between the row stacks by placing the mouse over the card to 
    be moved and pressing the left mouse button. Move the cursor to the new 
    card position and release the left mouse button. If the move is legal then 
    the card(s) are moved to the new stack. Multiple cards may be moved from 
    the row stacks, the appropriate card(s) to be moved is automatically 
    determined. 

    Cards may be moved onto the suit stacks by a single left mouse press and 
    release on the same card, the card is moved to the appropriate suit stack. 
    The same technique is used to turn cards over in the suit stacks, and to 
    deal the next set of cards by the dealer. To deal, then click on the 
    down-turned card stack, if there are no further cards at the dealer then 
    click on the empty position and the dealer will turn over the dealer stack 
    and deal from the top again. 

    Note that once a card is played onto the suit stacks then it cannot be 
    removed. 

    To the right of the board are a number of control buttons. To select an 
    option, click the left mouse button on it, the buttons are labeled: 

    cDDEALcA 
        Start a new game by dealing new cards. 

    cDQUITcA 
        Exit the game 

    cDHELPcA 
        This help page 

    Note that the screen may be updated at any time using "cCC-lcA". 


cEcENOTES cEcA


    cDPatiencecA is a macro defined in cGpatience.emfcA. 

    The game is best played with a mouse, it is possible to play with the 
    keyboard, as follows:- 

        "cCesc hcA" for help 

        To move a card between stacks enter the source and destination column 
        number ("cC1cA","cC2cA",.."cC7cA"). To move from the dealer pile then the source 
        is the "cCspacecA" key. 

        "cCtabcA" deals the next cards. 

        To overturn a card on the row stacks then enter the card column twice 
        i.e. source and destination are the same. 

        To move a card from the row to the suit stacks then either enter the 
        card column twice, or enter the destination as "cChcA","cCdcA","cCccA","cCscA" (i.e. 
        "cC2 2cA" or "cC2 scA" to move the card in column 2 to the spades stack). 

        "cCC-c C-ccA" to deal the cards again. 

        "cCC-lcA" redraw the screen. 

        "cCqcA" to quit the game. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - GameslmGamesle, lslmTriangle(3)le, lslmMahjongg(3)le. 

! 3 Triangle
cEcENAME cEcA


    Triangle - MicroEmacs '02 version of Triangle patience game 
$a


cEcESYNOPSIS cEcA


    cDTrianglecA 


cEcEDESCRIPTION cEcA


    cDTrianglecA is a solitaire game using a standard set of playing cards. The 
    object of the game is to use all of the cards in the deck to build up four 
    suit stacks from Ace to King. 

    The board is laid out so that every card is used to create a triangle 
    shape. In the first column there is one up-turned card, in the second 
    column there is one down-turned card and 2 up-turned, third has 2 down 3 
    up etc. The only break form this pattern is in the last 3 columns where 
    there is an extra up-turned card so that all the deck is used. 

    Cards may be moved around the playing area by stacking the same suit cards 
    in descending order on the row stacks. When a row stack has no up-turned 
    cards on the stack then the top card may be turned over and may be played. 
    If a stack becomes empty then only a King may be moved into the vacant 
    position. 

    If the last card in a stack is an Ace then it can be moved to its suit 
    stack, then the 2 of that suit etc. until finally the King is removed. 

    Cards are moved around the board using the mouse. Cards may be moved from 
    one row stack to another row stack by placing the mouse over the 'from' 
    stack and pressing the left mouse button. Move the cursor to the 'to' 
    stack and release the left mouse button. If the move is legal then the 
    card(s) are moved to the new stack. Multiple cards may be moved from the 
    row stacks, the appropriate card(s) to be moved is automatically 
    determined. 

    Cards may be moved onto the suit stacks by a single left mouse press and 
    release on the same card, the card is moved to the appropriate suit stack. 
    The same technique is used to turn cards over in the suit stacks. 

    Note that once a card is played onto the suit stacks then it cannot be 
    removed. 

    To the right of the board are a number of control buttons. To select an 
    option, click the left mouse button on it, the buttons are labeled: 

    cDDEALcA 
        Start a new game by dealing new cards. 

    cDQUITcA 
        Exit the game 

    cDHELPcA 
        This help page 

    Note that the screen may be updated at any time using "cCC-lcA". 


cEcENOTES cEcA


    cDTrianglecA is a macro defined in cGtriangle.emfcA. 

    The game is best played with a mouse, it is possible to play with the 
    keyboard, as follows:- 

        "cCesc hcA" for help 

        To move a card between stacks enter the source and destination column 
        number ("cC1cA","cC2cA",.."cC7cA"). 

        To overturn a card on the row stacks then enter the card column twice 
        i.e. source and destination are the same. 

        To move a card from the row to the suit stacks then either enter the 
        card column twice, or enter the destination as "cChcA","cCdcA","cCccA","cCscA" (i.e. 
        "cC2 2cA" or "cC2 scA" to move the card in column 2 to the spades stack). 

        "cCC-c C-ccA" to deal the cards again. 

        "cCC-lcA" redraw the screen. 

        "cCqcA" to quit the game. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - GameslmGamesle, lslmPatience(3)le, lslmMahjongg(3)le. 

! 3 c-hash-eval
! 3 c-hash-del
! 3 c-hash-set-define
! 3 c-hash-unset-define
cEcENAME cEcA


|c-hash-eval
    c-hash-eval - Evaluate C/C++ #defines 
|c-hash-del
    c-hash-del - Remove C/C++ #define evaluation 
|c-hash-set-define
    c-hash-set-define - Set a C/C++ #define 
|c-hash-unset-define
    c-hash-unset-define - Unset a C/C++ #define 
$a


cEcESYNOPSIS cEcA


    cCncA cDc-hash-evalcA 
    cDc-hash-delcA 
    cDc-hash-set-definecA "cCvariablecA" "cCvaluecA" 
    cDc-hash-unset-definecA "cCvariablecA" 


cEcEDESCRIPTION cEcA


    cDc-hash-evalcA evaluates C/C++ '#' lines, hiding sections of code which have 
    been 'hashed' out. cDc-hash-evalcA evaluates the following '#' lines:- 

        #define <variable> .... 
        #ifdef <variable> 
        #if ... 
        #else 
        #endif 

    For cG#definecAs cDc-hash-evalcA creates a user variable "cG%cd<variable>cA", setting 
    it to the value found. For cG#ifdefcA a simple check for the existence of 
    variable "cG%cd<variable>cA" is made. If defined then code between the cG#ifdefcA 
    and either its matching cG#elsecA or cG#endifcA is displayed and code between the 
    cG#elsecA and cG#endifcA is hidden. If it is not defined then the reverse happens. 

    The state of cG#ifcA's are evaluated using lslmcalc(3)le, the following code is then 
    displayed as for cG#ifdefcA. 

    Code is hidden by setting the lslm$line-scheme(5)le to a color similar to the 
    back-ground. If an argument is given to the command the code is also 
    narrowed out using lslmnarrow-buffer(2)le. 

    cDc-hash-delcA undoes the effect of cDc-hash-evalcA by restores hidden code. 

    cDc-hash-set-definecA and cDc-hash-unset-definecA can be used to manually set and 
    unset cG#definecA variables. 


cEcENOTES cEcA


    cDc-hash-evalcA, cDc-hash-delcA, cDc-hash-set-definecA and cDc-hash-unset-definecA are 
    macros defined in cGcmacros.emfcA. 

    Executing cDc-hash-evalcA in a project header file (h file) which contains all 
    used cG#definecA definitions will set up all cG#definecA variables ready for the 
    main C files. 


cEcESEE ALSO cEcA


    lslmcalc(3)le, lslm$line-scheme(5)le, lslmnarrow-buffer(2)le. 

! 3 etfinsrt
cEcENAME cEcA


    etfinsrt - Insert template file into current buffer 
$a


cEcESYNOPSIS cEcA


    cDetfinsrtcA "cCtemplatecA" 


cEcEDESCRIPTION cEcA


    cDetfinsrtcA is generally called by file hooks when the new buffer has been 
    created as opposed to loaded from a file (see lslm$buffer-fhook(5)le). 

    cDetfinsrtcA uses lslm&find(4)le to locate and insert the required "cCtemplatecA.etf" 
    file. If successful, cDetfinsrtcA then replaces the following strings in the 
    template: 

    cG$ASCII_TIME$cA 
        To the current time. Inserts the output of lslmascii-time(3)le. 

    cG$BUFFER_NAME$cA 
        To the buffer name. The name is capitalized, '.'s are replaced with 
        '_' and any trailing "cC<##>cA" digits (used to make the buffer name 
        unique) are removed. 

    cG$COMPANY_NAME$cA 
        To the value of cD%company-namecA, or if not defined to the value used for 
        cG$USER_NAME$cA. cD%company-namecA is usually set up in the company setup file 
        defined in User setup. 

    cG$USER_NAME$cA 
        To the value of the registry entry "cG/history/user-namecA", or if not 
        defined to the value "cG<unknown>cA". The user name is usually set up in 
        the User setup dialog. 

    cG$YEAR$cA 
        To the current year (4 digit number). 


cEcEEXAMPLE cEcA


    The following is taken from hkmake.emf and inserts the "cCmakefile.etfcA" 
    template if the buffer has been created. 
sB
        define-macro fhook-make 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                etfinsrt "makefile" 
            !endif 
            set-variable $buffer-hilight .hilight.make 
            -1 buffer-mode "tab"  ; Normal tabs please !!! 
            1 buffer-mode "indent" 
            1 buffer-mode "time" 
        !emacro 

sA

cEcENOTES cEcA


    cDetfinsrtcA is a macro defined in cGetfinsrt.emfcA. 

    lslmmagic(2m)le mode is always used to perform the the search/replace so the 
    replace strings should be appropriate for cDmagiccA. 


cEcESEE ALSO cEcA


    lslm$buffer-fhook(5)le, lslm&find(4)le, lslmascii-time(3)le. 

! 3 ascii-time
cEcENAME cEcA


    ascii-time - Return the current time as a string 
$a


cEcESYNOPSIS cEcA


    cDascii-timecA 


cEcEDESCRIPTION cEcA


    cDascii-timecA returns the current time as a formatted string in cG#p9cA which is 
    equivalent to cG#l9cA for the calling macro. The format of the time string is: 

            "cCWWW MMM DD hh:mm:ss yyyycA" 

    Where: cGWWW cA - Week day, cGSuncA - cGSatcA 
    cGMMM cA - Month, cGJancA - cGDeccA 
    cGDD  cA - Day, cG1cA - cG31cA 
    cGhh  cA - Hour, cG00cA - cG23cA 
    cGmm  cA - Minute, cG00cA - cG59cA 
    cGss  cA - Second, cG00cA - cG59cA 
    cGyyyycA - Year, cG1998cA... 


cEcEEXAMPLE cEcA


    The following is taken from etfinsrt.emf, it uses cDascii-timecA in replacing 
    "cG$ASCII_TIME$cA" with the current. 
sB
        0 define-macro etfinsrt 
            . 
            . 
            ; Change the create date $ASCII_TIME$. 
            beginning-of-buffer 
            ; Get ASCII time in #l9 
            ascii-time 
            !force replace-string "\\$ASCII_TIME\\$" #l9 
            . 
            . 
        !emacro 

sA

cEcENOTES cEcA


    cDascii-timecA is a macro defined in cGutils.emfcA. 


cEcESEE ALSO cEcA


    lslm$buffer-fhook(5)le, lslm&find(4)le, lslmascii-time(3)le. 

! 3 replace-all-pairs
cEcENAME cEcA


    replace-all-pairs - Replace string pairs in a list of files 
$a


cEcESYNOPSIS cEcA


    cCncA cDreplace-all-pairscA "cCfilescA" 


cEcEDESCRIPTION cEcA


    cDreplace-all-pairscA uses the current buffer to extract "cCfromcA" and "cCtocA" pairs 
    and then replaces all occurrences of "cCfromcA" to "cCtocA" in the given list of 
    files without prompting the user. An optional third argument "cCgrepcA" can be 
    given which will be used as the grep string, if not given the "cCfromcA" 
    string is used. The format of the current buffer must be: 

        /from1/to1/ 
        Xfrom2Xto2X 
        ?from3?to3? 
        /from4/to4/grep4/ 
          . 
          . 
        /fromN/toN/ 


    For each pair the command finds all occurrences of "cCfromcA" (or "cCgrepcA" if 
    specified) by calling the command lslmgrep(3)le to search for string "cCfromcA" in 
    files "cCfilescA". Thus all relevant edited files must be saved or cDgrepcA may 
    return the wrong line numbers. This is achieved by a call to 
    lslmsave-some-buffers(2)le between each replace pair, it is called with an 
    argument of 0 to ensure that any changed buffers are automatically saved. 

    Each occurrence of "cCfromcA" is jumped to using lslmget-next-line(2)le and the 
    string is replaced by the call: 
sB
        -1 replace-string "from" "to" 

sA
    This replaces all occurrences of "cCfromcA" to "cCtocA" on the current line only, 
    hence the line numbers must be correct. This also means that the "cCfromcA" 
    search string must be correctly formatted for both grep and 
    replace-string. 

    The given argument cCncA is a bit based flag which changes the default 
    behavior described above. The bits have the following effect:- 

    cD0x01cA 
        Prompt before saving any changed buffers FIRST time ONLY, enabled by 
        default. If set then the user is also prompted to continue before any 
        changes are made. If this bit is not set then the command executes 
        without any user input. 


cEcENOTES cEcA


    cDreplace-all-pairscA is a macro defined in cGsearch.emfcA. 

    The cDgrepcA command must be working before this command can function 
    properly. 

    It is not recommended to use a "from" or "to" string which uses more that 
    one line as the results may be unpredictable. 

    As the change is likely to be several pair strings with each changed 
    buffer being saved between pairs lslmundo(2)le cannot be used to undo the 
    changes. Neither can the backups be relied on as a buffer may be saved 
    more than once in this process, therefore it is strongly recommend that a 
    backup of the files is made before commencing with this command. 


cEcESEE ALSO cEcA


    lslmreplace-all-string(3)le, lslmreplace-string(2)le, lslmsave-some-buffers(2)le, lslmgrep(3)le, 
    lslmget-next-line(2)le, lslmundo(2)le, lslmquery-replace-all-string(3)le, lslmsearch-forward(2)le. 
    lsRegularExpressions(2)lmRegular Expressionsle 

! 3 delete-indentation
cEcENAME cEcA


    delete-indentation - Join 2 lines deleting white spaces 
$a


cEcESYNOPSIS cEcA


    cCncA cDdelete-indentationcA 


cEcEDESCRIPTION cEcA


    cDdelete-indentationcA deletes all white characters between the beginning of 
    the current line and the end of the previous line, including the 
    line-feed. If the current line is not empty then a space is inserted to 
    divide the two lines now joined. 

    If a positive argument cCncA is given then the process is repeated cCncA times. 
    Note that the deleted characters are not added to a kill buffer. 


cEcENOTES cEcA


    cDdelete-indentationcA is a macro defined in cGformat.emfcA. 


cEcESEE ALSO cEcA


    lslmdelete-blank-lines(2)le, lslmclean(3)le, lslmkill-line(2)le. 

! 3 edit-dictionary
! 3 restore-dictionary
cEcENAME cEcA


|edit-dictionary
    edit-dictionary - Insert a dictionary in a buffer 
|restore-dictionary
    restore-dictionary - Save dictionary user changes 
$a


cEcESYNOPSIS cEcA


    cDedit-dictionarycA "cCdictionarycA" 
    cDrestore-dictionarycA 


cEcEDESCRIPTION cEcA


    cDedit-dictionarycA dumps the contents of "cCdictionarycA" into the temporary 
    buffer "*cCdictionarycA*", if this buffer already exists then cDedit-dictionarycA 
    simply swaps to this buffer. This enables the user to correct and prune 
    the words in any dictionary. The given dictionary must have already been 
    added as a main dictionary using lslmadd-dictionary(2)le. 

    The format of the created buffer is one word on each line, each word takes 
    one of the following 3 forms: 

        cGxxxxcA - Good word cGxxxxcA with no spell rules allowed 
        cGxxxx/abccA - Good word cGxxxxcA with spell rules cGabccA allowed 
        cGxxxx>yyyycA - Erroneous word with an auto-replace to cGyyyycA 

    Executing cDrestore-dictionarycA in a buffer created by cDedit-dictionarycA will 
    first call lslmdelete-dictionary(2)le to remove the original dictionary from 
    memory. It then uses lslmadd-dictionary(2)le to create a new dictionary with the 
    same name and then uses lslmspell-add-word(3)le to add all the words in the 
    current buffer into the new dictionary. 

    cDrestore-dictionarycA does not save the new dictionary. 


cEcENOTES cEcA


    cDedit-dictionarycA and cDrestore-dictionarycA are macros defined in file 
    cGspellutl.emfcA. They are not defined by default so cCspellutl.emfcA must be 
    executed first using lslmexecute-file(2)le. 


cEcESEE ALSO cEcA


    lslmspell-add-word(3)le, lslmadd-dictionary(2)le, lslmsave-dictionary(2)le, 
    lslmdelete-dictionary(2)le. 

! 3 spell-add-word
cEcENAME cEcA


    spell-add-word - Add a word to the main dictionary 


cEcESYNOPSIS cEcA


    cCncA cDspell-add-wordcA ["cCwordcA"] 


cEcEDESCRIPTION cEcA


    cDspell-add-wordcA adds words to the last dictionary added using the command 
    lslmadd-dictionary(2)le. If no argument is supplied the user is prompted for the 
    word and rule flags, only a 'Good' word can be added (see below). If an 
    argument cCncA is given then the next cCncA words from the current buffer are 
    added. The words must take one of the following three forms: 

        cGxxxxcA - Good word cGxxxxcA with no spell rules allowed 
        cGxxxx/abccA - Good word cGxxxxcA with spell rules cGabccA allowed 
        cGxxxx>yyyycA - Erroneous word with an auto-replace to cGyyyycA 


cEcENOTES cEcA


    cDspell-add-wordcA is a macro defined in file cGspellutl.emfcA. It is not defined 
    by default so cGspellutl.emfcA must be executed first using lslmexecute-file(2)le. 


cEcESEE ALSO cEcA


    lslmadd-dictionary(2)le, lslmedit-dictionary(3)le, lslmsave-dictionary(2)le, 
    lslmdelete-dictionary(2)le. 

! 3 start-up
! 3 shut-down
cEcENAME cEcA


|start-up
    start-up - Editor startup callback command 
|shut-down
    shut-down - Editor exit callback command 
$a


cEcESYNOPSIS cEcA


    cDstart-upcA 
    cDshut-downcA 


cEcEDESCRIPTION cEcA


    By default cDstart-upcA is not defined, if the command is defined (via a user 
    macro) then it is executed immediately after MicroEmacs '02 has completed 
    its initialization. 

    This command may initially seem redundant as the user may execute any 
    command at start-up by editing the "cGme.emfcA" file or using the 'cD@cA' 
    command-line argument. At the point of "cGme.emfcA" file execution none of the 
    files specified on the command-line will be loaded, thus any actions 
    required on the given command-line files will not work (the only buffer 
    present will be the "cD*scratch*cA" buffer). 

    The cDstart-upcA command is executed AFTER the execution of "cGme.emfcA" and 
    initialization of buffers, but before MicroEmacs '02 waits for user input. 

    The cDshut-downcA command is also not defined by default, but if it is defined 
    during the running of MicroEmacs the command will be called when 
    MicroEmacs exits. The command is not called if MicroEmacs has to perform 
    an emergency exit (due to the system being shut down or process being 
    killed etc). 


cEcESEE ALSO cEcA


    lslmme(1)le. 

! 3 restyle-buffer
! 3 restyle-region
cEcENAME cEcA


|restyle-buffer
    restyle-buffer - Automatically reformat a buffer's indentation. 
|restyle-region
    restyle-region - Automatically reformat a regions indentation. 
$a


cEcESYNOPSIS cEcA


    cDrestyle-buffercA 
    cDrestyle-regioncA 


cEcEDESCRIPTION cEcA


    cDrestyle-buffercA automatically re-formats the indentation of a buffer. The 
    indentation only operates if the indentation method is defined with 
    lslmcmode(2m)le or lslm$buffer-indent(5)le, otherwise the command has no effect. 

    cDrestyle-regioncA modifies the indentation between cCpointcA and cCmarkcA. 


cEcENOTES cEcA


    cDrestyle-buffercA and cDrestyle-regioncA are macros defined in cGformat.emfcA. 


cEcESEE ALSO cEcA


    lslmcmode(2m)le, lslmindent(2)le, lslm$buffer-indent(5)le. 

! 3 ifill-paragraph
cEcENAME cEcA


    ifill-paragraph - Format a paragraph 
$a


cEcESYNOPSIS cEcA


    cCncA cDifill-paragraphcA (cDesc qcA) 


cEcEDESCRIPTION cEcA


    cDifill-paragraphcA, like cDfill-paragraphcA, fills the current paragraph from the 
    left margin to the current fill column. In addition ifill-paragraph also 
    recognizes joined bullet lists and fills each bullet paragraph separately. 

    See lslmfill-paragraph(2)le for more information on the process of filling 
    paragraphs. 


cEcEEXAMPLE cEcA


    Following are 2 copies of the same paragraph, the first has been filled 
    using cDifill-paragraphcA: 

        This  is the  main  paragraph  which  can be as long as  required, 
        following is a list of bullets, some with a sub-bullet  list. Here 
        is the list: 
            a) The bullet paragraph can also be as long as required and it 
               also can have a bullet  list  following  (sub-bullet  list) 
               which will also be filled correctly. Here is the sub-bullet 
               list: 
               1. First  sub-bullet - again no length  restrictions,  this 
                  will be filled correctly. 
               2. second sub-bullet - no problems. 
               3. Third sub-bullet - again no length restrictions, this is 
                  getting boring. 
            b) This is the second  major bullet and this can just carry on 
               for ever, but all things must come to an 


    The following version has been filled using the normal cDfill-paragraphcA: 

        This  is the  main  paragraph  which  can be as long as  required, 
        following is a list of bullets, some with a sub-bullet  list. Here 
        is the  list:  a) The  bullet  paragraph  can  also  be as long as 
        required and it also can have a bullet list following  (sub-bullet 
        list) which will also be filled  correctly. Here is the sub-bullet 
        list: 1. First  sub-bullet  - again no length  restrictions,  this 
        will be filled  correctly. 2. second  sub-bullet - no problems. 3. 
        Third sub-bullet - again no length  restrictions,  this is getting 
        boring. b) This is the second major bullet and this can just carry 
        on for ever, but all things must come to an 


cEcENOTES cEcA


    cDifill-paragraphcA is a macro defined in cGformat.emfcA. 


cEcESEE ALSO cEcA


    lslmfill-paragraph(2)le, lslmparagraph-to-line(3)le. 

! 3 file-browser
! 3 file-browser-close
! 3 file-browser-swap-buffers
cEcENAME cEcA


    file-browser - Browse the file system file-browser-close - Close the 
    file-browser file-browser-swap-buffers - Swap between file-browser windows 
$a


cEcESYNOPSIS cEcA


    cDfile-browsercA (cDf10cA) 
    cDfile-browser-closecA 
    cDfile-browser-swap-bufferscA 


cEcEDESCRIPTION cEcA


    cDfile-browsercA can be used to browse around the file system. When first 
    executed cDfile-browsercA creates 2 buffers, "cG*directory*cA" displaying the 
    directory structure and "cG*files*cA" listing the files in the current 
    directory with information on each file. cDfile-browsercA displays these 
    buffers side by side, splitting the current window horizontally if 
    required. 

    Once open the user can browse through the system using the following keys 
    in the cG*directory*cA buffer: 

    cGspacecA 
        Selects the directory on the current line and up-dates the cG*files*cA 
        buffer with the information on this directory. This can also be done 
        by clicking the left mouse button on the directory name. 

    cGreturncA 
        Selects the directory on the current line, if open (sub-directories 
        displayed) then closes it or if closed it is opened. The cG*files*cA 
        buffer is up-dated with the information on the directory. This can 
        also be done by clicking the left mouse button on the 'cG+cA' or 'cG-cA' 
        symbol just before the directory name. 

    cGC-returncA 
        As with cGreturncA expect sub-directories are recursively opened or 
        closed, note that this could take some time on large file systems. 
        This can also be done by clicking the right mouse button on the 'cG+cA' or 
        'cG-cA' symbol just before the directory name. 

    cGtabcA 
        Move to the cG*files*cA buffer. 

    cGdeletecA 
        Closes file-browser. 

    The following keys can be used in the cG*files*cA buffer: 

    cGreturncA 
        If the current line is a directory, this because the current 
        directory, updating both the cG*directory*cA and cG*files*cA buffers. If the 
        line is a file then it is opened using lslmfind-file(2)le. This can also be 
        done by clicking the left mouse button on the file name. 

    cGspacecA 
        Toggles the tag state of the file on the current line, see cGxcA command. 
        This can also be done by clicking the left mouse button anywhere 
        before the file name, or for multiple files drag a region with the 
        left mouse button. 

    cGXcA or cGxcA 
        Executes a lslmshell-command(2)le on all tagged files. The user is prompted 
        for the command line which can contain the following special tokens: 
            cG%p  cAFull file name, including path. 
            cG%f  cAThe file name without the path. 
        As the cDshell-commandcA is executed in the directory cG%fcA is safe to use in 
        a command such as "cGdel %fcA". 

    cGDcA or cGdcA 
        Deletes all the tags in the buffer. 

    cGtabcA 
        Move to the cG*directory*cA buffer. 

    cGdeletecA 
        Closes file-browser. 

    cDfile-browser-swap-bufferscA swaps between the cG*directory*cA and cG*file*cA 
    windows, making the other the current window, this is usually locally 
    bound to the cGtabcA key. 

    cDfile-browser-closecA hides both the cG*directory*cA and cG*file*cA windows, closing 
    the file-browser, this is usually locally bound to the cGdeletecA key. 


cEcESEE ALSO cEcA


    lslmdirectory-tree(2)le, lslmfind-file(2)le, lslmshell-command(2)le. 

! 3 vm
! 3 mail-check
! 3 stop-mail-check
! 3 mail
cEcENAME cEcA


|vm
    vm - Email viewer 
|mail-check
    mail-check - Check for new email 
|stop-mail-check
    stop-mail-check - Disable the check for new email 
|mail
    mail - Compose and send an email 
$a


cEcESYNOPSIS cEcA


    cDvmcA 
    cDmail-checkcA 
    cDstop-mail-checkcA 
    cDmailcA 


cEcEDESCRIPTION cEcA


    cDvmcA is a simple email manager, it is configured to send and receive emails 
    using the lslmuser-setup(3)le Mail dialog. 

    cDmail-checkcA tests the size of this incoming mail box, a non-zero length 
    indicates that new mail has arrived and cDmail-checkcA informs the user by 
    inserting a 'cGMcA' in the mode-line (2nd character for the left) and ringing 
    the system bell. cDmail-checkcA uses lslmcreate-callback(2)le to check for new mail 
    every 10 minutes, this can be disabled by executing cDstop-mail-checkcA. 

    When cDvmcA is executed it checks for new mail, if found it first copies the 
    new mail to a file called "cGnew_mailcA" in the users mail directory. The 
    incoming box is then emptied by truncating the file to zero length. The 
    users main mail box is then loaded and the new mail (if any) is appended. 
    The mail box is then processed after which 2 windows are created the 
    bottom window listing all messages in the box and the top displaying the 
    current message. 

    cDvmcA is capable of: 

        * Scrolling through the mail box displaying each message (cGupcA, cGpcA, cGdowncA, 
          cGncA, cGreturncA, cGspacecA). 
        * Check and get new mail messages (cGgcA). 
        * Extract and cut embedded data files (cGxcA, cGCcA, cGccA). 
        * Reply to and forward mail messages (cGRcA, cGrcA, cGzcA). 
        * Delete mail messages (cGdcA, cGucA). 
        * Archive messages to other mail boxes (cGAcA, cGacA). 
        * Save changes to the current mail box (cGScA, cGscA). 
        * Delete the current mail box (cGDcA). 
        * Visit another mail box (cGvcA). 
        * Send a mail message (cGmcA). 
        * Hide vm windows (cGdeletecA). 

    Use the vm help page (bound to "cGesc hcA") for further information. 

    cDvmcA supports two types of embedded data, uuencode and mime encoding and 
    uses lslmipipe-shell-command(2)le to extract the data, the commanding to use 
    must be supplied by the user using the setup dialog, which can contain the 
    following special tokens: 

    cG%icA 
        Temporary file name, if used, the embedded data is written to the this 
        file first. 

    cG%ocA 
        User supplied output file name, if cG%icA is not used, the embedded data 
        is written to this file first. 

    cG%bcA 
        The output base name, i.e. cG%ocA without the path. 

    If no command line is supplied then the embedded data is written to the 
    user supplied file name as a text file in the form found in the mail 
    message. 

    cDmailcA can be used to compose and send an email, it can insert embedded data 
    in a similar way to cDvmcA's data extraction, the following special tokens can 
    be used: 

    cG%icA 
        The user supplied data file to be embedded. 

    cG%bcA 
        The input base name, i.e. cG%icA without the path. 

    cG%ocA 
        Temporary file name used to output the processed data file, this file 
        is inserted into the mail message using lslminsert-file(2)le. 

    cDmailcA also uses cDipipe-shell-commandcA to send the mail message, the following 
    special tokens can be used: 

    cG%fcA 
        The from user name. 

    cG%scA 
        The email subject. 

    cG%tcA 
        A comma separated list of 'To' recipients. 

    cG%ccA 
        A comma separated list of 'Cc' recipients. 

    cG%ocA 
        A file name of the mail message. 

    Any field not used in the command-line is left at the head of the mail 
    message. 


cEcEEXAMPLE - UNIX cEcA


    The following command-line can be used on most UNIX systems to extract 
    uuencoded data: 

        rm -f %o ; uudecode %i ; rm -f %i 


    The following command-line can be used on most UNIX systems to extract 
    mime encoded data: 

        rm -f /tmp/%b ; metamail -B -d -q -w -x -z %i ; mv -f /tmp/%b %o 


    The following command-line can be used on most UNIX systems to uuencode a 
    data file ready for it to be embedded, the original file is not changed: 

        uuencode %b < %i > %o 


    The following command-line can be used on most UNIX systems to send an 
    email: 

        /usr/lib/sendmail -oi -oem -odi -t < %o 


cEcEEXAMPLE - WIN32 cEcA


    Typically the cDcygnus(1)cA utilities can be used for data insertion and 
    extraction. These have the advantage of being very similar to the unix 
    ones so only minor changes are required, i.e. try the following for data 
    insertion and mime & uuencode extraction respectively: 

        del %o ^ uudecode %i ^ del %i 
        del c:\tmp\%b ^ metamail -B -d -q -w -x -z %i ^ move c:\tmp\%b %o 
        uuencode %b < %i > %o 


    This assumes that the shell you are using supports the 'cG^cA' multiple 
    commands on a single line feature, this is supported by cD4dos(1)cA and 
    cD4nt(1)cA. If your shell does not support this feature a simple batch file 
    command could be used instead. 

    cDpostie(1)cA is a freely available pop3/smpt e-mail support program, 
    available on the net, which can be used to provide a fully working cDvmcA on 
    windows systems. As it is typically used in a dial-up connect environment, 
    the cDuser-setupcA 'Queue Outgoing Mail' option will be enabled while the 
    'Check Mail' and 'VM Gets Mail' will be disabled. This ensures that a 
    connection is only made when the cDvmcA 'cGgcA' command is used which sets all 
    queued outgoing mail and gets any incoming mail. 

    The following command-line can be used to get mail from your pop server 
    using postie: 

        postie -host:pop-mail-addr -user:user-addr -pass:password -file:inbox 
                "-sep:From root Mon Jan 11 20:02:02 1999" -raw -rm 


    Where the cGinboxcA is the 'Incoming Mail Box' file specified in user-setup. 
    The cG-sepcA option is used to partition each mail message from the previous 
    message, this string is used as it is in a unix standard form so the 
    resulting mail box could be understood by unix mail systems such as 
    netscape etc. 

    NOTE: The cD-rmcA option is used to remove the incoming mail messages from the 
    server. It is strongly recommended that the system is thoroughly tested 
    without this option first. 

    The following command-line can be used to send mail to your smtp server 
    using postie: 

        postie -host:smtp-mail-addr "-from:user@mail-addr" -use_mime:0 
                "-to:%t" "-s:%s" "-cc:%c" "-file:%o" 


    cDblat(1)cA is another freely available windows program which can be used to 
    send mail with the following command-line: 

        blat %o -f %f -s \"%s\" -t \"%t\" -c \"%c\" 


cEcENOTES cEcA


    cDvmcA is a macro defined in cGvm.emfcA, cDmail-checkcA, cDstop-mail-checkcA and cDmailcA are 
    macros defined in cGmail.emfcA. 

    cDvmcA has only been tested in a couple of environments, the author will not 
    except any responsibility for any loss of data, i.e. use at your own 
    peril. You have been warned! Back-up all data files and test cDvmcA THOROUGHLY 
    before using it. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmipipe-shell-command(2)le, lslmcreate-callback(2)le, cDsendmail(1)cA. 

! 3 fold-current
! 3 fold-all
cEcENAME cEcA


|fold-current
    fold-current - (un)Fold a region in the current buffer 
|fold-all
    fold-all - (Un)Fold all regions in the current buffer 
$a


cEcESYNOPSIS cEcA


    cDfold-currentcA 
    cDfold-allcA 


cEcEDESCRIPTION cEcA


    MicroEmacs '02 provides a generic, albeit course, folding mechanism which 
    is applied to some of the well known file modes. The folding mechanism 
    allows parts of the buffer to be scrolled up and hidden, leaving a residue 
    hilighting marker within the buffer indicating a folded region. A folded 
    buffer typically allows a summary of the buffer contents to be viewed 
    within several windows, hiding the detail of the buffer. 

    The folding mechanism uses well defined cCstartcA and cCendcA markers which form 
    part of the syntax of the well known file mode. i.e. in 'C' this is the 
    open and closed braces that appear on the left-hand margin (cG{cA .. cG}cA). The 
    intention is that the natural syntax of the text is used to determine the 
    fold positions, requiring no additional text formating or special text 
    tags to be inserted by the user. 

    cDfold-currentcA opens and closes a folded region within the buffer. If the 
    current cursor position lies between a cCstartcA and cCendcA marker then the 
    region between the start and end is folded out and hidden from view, 
    leaving a highlight marker in the buffer. If the fold already exists then, 
    moving the cursor to the folded line and invoking cDfold-currentcA removes the 
    fold marker and reveals the text. 

    cDfold-allcA opens and closes all folded regions within the buffer, if the 
    current state is unfolded then all of the cCstartcA/cCendcA markers are located 
    and their regions folded. Conversely, if the buffer is currently folded 
    and cDfold-allcA is invoked, then all folds are removed and the associated 
    text revealed. 


cEcECONFIGURATION cEcA


    In order to utilize the cDfold-current/allcA commands within a buffer, the 
    cCstartcA and cCendcA markers have to be initialized for the syntactical contents 
    of the buffer. This is performed within the hook function for the buffer, 
    using the hook-name. Buffer specific variables are defined within the 
    context of the buffer to configure that start and end fold handling. The 
    buffer specific variables are defined as follows, where cCxxxxcA is the file 
    hook base name. 

    cCxxxxcAcD-fold-opencA 
        A regular expression search string used to locate the start of the 
        string. For speed the search string should include a regular 
        expression start or end of line character whenever possible. i.e. in C 
        the open is defined as "cG^{cA". 

    cCxxxxcAcD-fold-closecA 
        A regular expression search string used to locate the end of the 
        string. For speed the search string should include a regular 
        expression start or end line character whenever possible. i.e. in C 
        the close is defined as "cG^}cA". 

    cCxxxxcAcD-fold-mopencA 
        An integer value that denotes the number of lines to move in a forward 
        or (-ve) backward direction from the cCstartcA line located by the search 
        string to the position in the buffer to be folded. If default value 
        when cDmopencA is omitted is 0, starting the fold from the search string 
        line. 

    cCxxxxcAcD-fold-mclosecA 
        The relative displacement from the close fold line to the fold 
        position, this is a positive or negative displacement depending on 
        where the fold is to be positioned. 

    cCxxxxcAcD-fold-mnextcA 
        Specifies the number of lines to advance before the next search is 
        continued on the fold operation. This is only used by cDfold-allcA. 


cEcEEXAMPLE cEcA


    The following examples show how the fold variables are set up in each of 
    the buffer modes. 


cEC and C++ cA


    cDCcA and cDC++cA fold on the open and close brace appearing in the left-hand 
    margin. The fold variables are defined in cGhkccA/cGhkcpp.emfcA as follows:- 
sB
        set-variable %c-fold-open  "^{" 
        set-variable %c-fold-close "^}" 

sA
    Given a 'C' function definition:- 

        static void 
        myfunc (int a, int b) 
        { 
            /* Function body */ 
        } 


    the folded version appears as follows:- 

        static void 
        myfunc (int a, int b) 
        } 


cEemf cA


    MicroEmacs macro files cDemfcA support folding of macro definitions, the fold 
    variables are defined in cGhkemf.emfcA as follows:- 
sB
        set-variable %emf-fold-open  "^0? ?define-macro" 
        set-variable %emf-fold-close "^!emacro" 
        set-variable %emf-fold-mopen "1" 

sA
    Given a macro definition:- 
sB
        0 define-macro mymacro 
        ; This is the body of the macro 
        ; ... and some more ... 
        !emacro 

sA
    the folded version of the macro is defined as:- 
sB
        0 define-macro mymacro 
        !emacro 

sA

cEnroff cA


    cDnroffcA is configured for manual pages only and folds between cG.SHcA and cG.SScA 
    sections, the hook variables are defined as follows:- 
sB
        set-variable %nroff-fold-open  "^\.S[SH]" 
        set-variable %nroff-fold-close "^\.S[SH]" 
        set-variable %nroff-fold-mopen "1" 
        set-variable %nroff-fold-mnext "-1" 

sA
    Given an nroff block of text defined as:- 

        .SH SYNOPSIS 
        .\" Some text 
        .\" Some more text 
        .SH DESCRIPTION 


    Then the folded version appears as: 

        .SH SYNOPSIS 
        .SH DESCRIPTION 


cEtcl/tk cA


    cDtcl/tkcA is configured to fold procedures. The fold variables are defined 
    as:- 
sB
        set-variable %tcl-fold-open  "^proc " 
        set-variable %tcl-fold-close "^}" 
        set-variable %tcl-fold-mopen "1" 

sA
    Given a tcl procedure definition:- 

        proc tixControl:InitWidgetRec {w} { 
            upvar #0 $w data 

            tixChainMethod $w InitWidgetRec 

            set data(varInited)   0 
            set data(serial) 0 
        } 


    The folded version of the same section appears as:- 

        proc tixControl:InitWidgetRec {w} { 
        } 


cEcENOTES cEcA


    cDfold-currentcA and cDfold-allcA are macros implemented in cGfold.emfcA. The folding 
    is performed using the lslmnarrow-buffer(2)le command. 

    cDfold-currentcA may also be bound to the mouse using the lslmuser-setup(3)le. The 
    typical binding is cGC-mouse-drop-1cA. 


cEcESEE ALSO cEcA


    lsfileHooks(2)lmFile Hooksle, lslmuser-setup(3)le, lslmnarrow-buffer(2)le. 

! 3 find-bfile
! 3 find-cfile
cEcENAME cEcA


|find-bfile
    find-bfile - Load a file as binary data 
|find-cfile
    find-cfile - Load a crypted file 
$a


cEcESYNOPSIS cEcA


    cCncA cDfind-bfilecA "cCfile-namecA" (cDC-x 9cA) 
    cCncA cDfind-cfilecA "cCfile-namecA" 


cEcEDESCRIPTION cEcA


    cDfind-bfilecA and cDfind-cfilecA provide a simple interface to loading files in 
    lslmbinary(2m)le and lslmcrypt(2m)le modes respectively. The numeric argument has the 
    same effect as with the lslmfind-file(2)le command except the respective modes 
    are always enabled. See documentation on the modes an cDfind-filecA command 
    for more information. 


cEcENOTES cEcA


    cDfind-bfilecA and cDfind-cfilecA are macros defined in file cGtools.emfcA. 

    The command lslmfind-file(2)le is bound to key "cGC-x 9cA" with a numeric argument 
    of 2, this is equivalent to executing cDfind-bfilecA with no argument. 


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmbinary(2m)le, lslmcrypt(2m)le. 

! 3 man
! 3 man-clean
cEcENAME cEcA


    man - UNIX manual page viewer. man-clean - Clean UNIX manual page. 
$a


cEcESYNOPSIS cEcA


    cDmancA 
    cDman-cleancA 


cEcEDESCRIPTION cEcA


    cDmancA provides a mechanism to display a UNIX manual page within the 
    MicroEmacs window. On invoking cDmancA the user is prompted for the name of 
    the manual page to display:- 

        Man on ? 


    The name of the manual page (and any options) are entered on the command 
    line. The macro invokes the UNIX utility cDman(1)cA to generate the page and 
    displays the results in a window. 

    Another manual page can be selected by either moving the cursor to the 
    link and pressing return or double clicking on it with the left mouse 
    button. MicroEmacs will then attempt to load and display the selected 
    manual page. 

    cDman-cleancA removes any man-page formatting codes from the current buffer 
    reducing a manual page to plain text. The formatting codes are used to 
    create the bold and underline fonts. This allows the page to be treated as 
    a normal buffer, i.e. string searches and other similar command will work 
    as expected. 


cEcENOTES cEcA


    cDmancA and cDman-cleancA are macros defined in cGhkman.emfcA. 

    cDmancA is only made available within UNIX environments, the UNIX start up 
    file cGunixterm.emfcA links in the macro. If the cDmancA utility is required on 
    other platforms then the following definition is required in a start-up 
    file. 
sB
        define-macro-file hkman man 

sA

cEcESEE ALSO cEcA


    lslmman(9)le, lslmuser-setup(3)le, lslmspell-buffer(3)le. 

! 3 draw
cEcENAME cEcA


    draw - Simple line drawing utility 
$a


cEcESYNOPSIS cEcA


    cDdrawcA 


cEcEDESCRIPTION cEcA


    cDdrawcA provides a simple way of drawing lines into the current buffer, this 
    has a variety of uses such as drawing tables. cDdrawcA copies the current 
    buffer into a temporary buffer and then allows the user to draw using 
    simple commands until the user either aborts, discarding any changes, or 
    exits insert the changes back into the buffer. 

    The keys for cDdrawcA are defined as follows:- 

    cDesc hcA 
        Display a help dialog. 

    cDupcA, cDdowncA, cDleftcA, cDrightcA 
        The cursor keys (or any other keys bound the the same commands) will 
        move the cursor, drawing in the current mode. 

    cDdcA 
        Change the current mode to cDdcAraw (default), cursor movement will result 
        in drawing in the current style. 

    cDecA 
        Change the current mode to cDecArase, cursor movement will result in 
        erasing to spaces. 

    cDmcA 
        Change the current mode to cDmcAove, no drawing is performed with cursor 
        movement. 

    cDucA 
        Change the current mode to cDucAndo, cursor movement will result in 
        undoing the character to the original or a space. 

    cD-cA 
        Sets the current horizontal line drawing style to use 'cG-cA's (default). 

    cD=cA 
        Sets the current horizontal line drawing style to use 'cG=cA's. 

    cDC-gcA 
        Abort - changes are lost. 

    cDreturncA 
        Exit, inserting any changes into the current buffer. 


cEcENOTES cEcA


    cDdrawcA is a macro defined in cGdraw.emfcA. 

! 3 cygnus
! 5 %cygnus-bin-path
! 5 %cygnus-hilight
! 5 %cygnus-prompt
cEcENAME cEcA


|cygnus
    cygnus - Open a Cygwin BASH window 
|%cygnus-bin-path
    %cygnus-bin-path - Cygwin BASH directory 
|%cygnus-hilight
    %cygnus-hilight - Cygwin shell hilight enable flag 
|%cygnus-prompt
    %cygnus-prompt - Cygwin shell prompt 
$a


cEcEPLATFORM cEcA


    Windows '95/'98/NT - win32 ONLY 


cEcESYNOPSIS cEcA


    cDcygnuscA 

    cD%cygnus-bin-pathcA "cCpathcA" 
    cD%cygnus-hilightcA [cG0cA|cG1cA] 
    cD%cygnus-promptcA "cChilightStringcA" 


cEcEDESCRIPTION cEcA


    cDcygnuscA creates an interactive BASH shell window within a MicroEmacs buffer 
    window, providing a UNIX command line facility within the Microsoft 
    Windows environment. This is a preferable environment to the MS-DOS shell 
    and is certainly far more comfortable for those people familiar with UNIX. 

    Within the window BASH commands may be entered and executed, the results 
    are shown in the window. Within the context of the BASH shell window then 
    directory naming conforms to the cDcygwincA standard conventions (as opposed 
    to the Microsoft directory naming). 

    On running cDcygnuscA a new buffer is created called cG*cygnus*cA which contains 
    the shell. Executing the command again creates a new shell window called 
    cG*cygnus1*cA, and so on. If a cygwin window is killed off then the available 
    window is used next time the command is run. 

    Additional controls are available within the shell window to control the 
    editors interaction with the window. The operating mode is shown as a 
    digit on the buffer mode line, this should typically show "3", which 
    corresponds to cCF3cA. The operating modes are mapped to keys as follows:- 

    cDF2cA 
        Locks the window and allows local editing to be performed. All 
        commands entered into the window are interpreted by the editors. cDF2cA 
        mode is typically entered to cut and paste from the window, search for 
        text strings etc. In mode 2, a cD2cA is shown on the mode line. 

    cDF3cA 
        The normal operating mode, text typed into the window is presented to 
        the shell window. Translation of MicroEmacs commands (i.e. 
        beginning-of-word) are translated and passed to the shell. For 
        interactive use this is the default mode. In mode 3, a cD3cA is shown on 
        the mode line. 

    cDF4cA 
        All input is passed to the shell, no MicroEmacs commands are 
        interpreted and keys are passed straight to the shell window. This 
        mode is used where none of the keys to be entered are to be 
        interpreted by MicroEmacs. Note that you have to un-toggle the F4 mode 
        before you can swap buffers as this effectively locks the editor into 
        the window. 

    cDF5cA 
        Clears the buffer contents. This simply erases all of the historical 
        information in the buffer. The operation of the shell is unaffected. 

    To exit the shell then end the shell session using "cGexitcA" or "cGC-dcA" as 
    normal and then close the buffer. A short cut "cGC-c C-kcA" is available to 
    kill off the pipe. However, it is not recommended that this method is used 
    as it effectively performs a hard kill of the buffer and attached process 

    cD%cygnus-bin-pathcA is a user defined variable that defines the file system 
    location of the cCcygwincA directory. This variable MUST be defined within the 
    user start up script in order for the cDcygnuscA command to start the shell. 
    With a default installation of cCcygwincA then the settings are typically 
    defined as:- 

    cDRelease B19cA 
sB
        set-variable %cygnus-bin-path "C:/Cygnus/B19/h-i386~1/bin" 

sA
    cDRelease B20cA 
sB
        set-variable %cygnus-bin-path "c:/cygnus/cygwin-b20/H-i586-cygwin32/bin" 

sA
    cD%cygnus-hilightcA is a boolean flag which controls how the cygnus command 
    shell window is hilighted. This value MUST be defined within the user 
    start up script prior to executing cygnus if hilighting is to be enabled; 
    by default hilighting is disabled. A value of 1 enables shell hilighting 
    i.e. 
sB
        set-variable %cygnus-hilight 1 

sA
    cD%cygnus-promptcA is an optional variable that is used in conjunction with 
    cD%cygnus-hilightcA, it defines the hilighting string identifying the prompt. 
    This allows the prompt to be rendered with a different color. The default 
    prompt is cGbash-2.01$cA and may be hilighted using a definition:- 
sB
        set-variable %cygnus-prompt "bash-2.01$" 

sA
    The user typically overrides the prompt definition within the BASH startup 
    file, a more appropriate definition of the prompt may be:- 
sB
        set-variable %cygnus-prompt "^[a-z]*@[^>]*>" 

sA

cEcENOTES cEcA


    The cDcygnuscA command uses the lslmipipe-shell-command(2)le to manage the pipe 
    between the editor and the cDbashcA shell. The window is controlled by the 
    macro file cGhkcygnus.emfcA which controls the interaction with the shell. 

    The macro cDcygnuscA in cGhkcygnus.emfcA defines the parameter setup to connect to 
    the cygwin bash shell (Version 19), installed in the default location 
    cGc:/cygnuscA. If your installation of cygnus is in a different location then 
    correct the macro to match your install location, preferably correct by 
    creating a cCmycygnus.emfcA file in your user directory simply containing a 
    re-defined cDcygnuscA macro. 

    If you have exported some of the cygwin environment variables in your 
    cGautoexec.batcA then you will have to figure out for yourself what variables 
    macro cCcygnuscA needs to export - the current configuration is for a vanilla 
    install. 

    The cDbashcA shell is executed with options cCicA, for interactive shell and cCmcA to 
    enable job control. 


cEcETESTED CONFIGURATIONS cEcA


    This configuration has only been tested on a Windows '98 installation, 
    whether this works on NT and Windows '95 (OEM SR2) is unknown. 

    We have only been running "make" operations in the shell and do not know 
    how the likes of "more", "man" or anything other terminal interaction 
    works. 

    cDTested ConfigurationscA 
        Windows '98 (Pentium 120MHz/Pentium Pro 200MHz/Cyrix 300MHz/Pentium II 
        450MHz) 

        cygwin version B19.3 - this is the original "cygwin" distribution + 
        the latest "coolview.tar.gz" patch. 
        cygwin version B20 - the latest cygwin distribution. 


cEcEBUGS cEcA


    cDBreak KeycA 
        A break in a bash shell is cGC-ccA, the macros define the key cGC-c C-ccA to 
        perform the break. This sequence is sent to the process but is not 
        enacted by the shell. This is a property of the Bash shell rather than 
        MicroEmacs. 

    cDSlow ResponsecA 
        If you are getting a very slow response from the bash shell then check 
        the directory where cCbashcA was started. Sometimes there are problems if 
        the shell is started in "cGc:/cA" (which is typically "cG/cA") then the cCbashcA 
        shell is very unresponsive and tends to 'cCignore mecA' for periods of 
        time. If it is started in another location, i.e. "cCc:/tempcA" directory, 
        then this problem does not occur. 

        You can see the start-up location in the top of the buffer when the 
        shell is started. 

    cDPrompt at top of buffercA 
        Very, very occasionally the ishell sticks at the top of the buffer 
        with only a couple of lines showing. A swap of the buffers or a quick 
        window resize sorts out the problem. A fix for this problem has been 
        applied but still may occasionally occur. 

    cDWinOldApcA 
        cDWinoldapcA is created by the Microsoft environment whenever a BASH shell 
        is created. On occasions where processes have terminated badly the 
        user may be prompted to kill these off; this is the normal behaviour 
        of windows. It is strongly advised that all of the BASH processes are 
        killed from within the Bash shell itself and the shell is always 
        exited correctly (i.e. cGexitcA) before leaving the editor. The Windows 
        operating system for '95/'98 is not particularly resilient to 
        erroneous processes (for those of us familiar with UNIX) and can bring 
        the whole system down. I believe that NT does not suffer from these 
        problems (much). 

    cDLocked InputcA 
        There are occasions after killing a process the editor appears to lock 
        up. This is typically a case that the old application has not shut 
        down correctly. Kill off the erroneous task (cGAlt-Ctrl-DelcA - cCEnd TaskcA) 
        then bring the editor under control using a few cGC-gcA lslmabort-command(2)le 
        sequences. 


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmishell(3)le. 
    Cygnus Win32 home sites cDwww.cygnus.comcA and cDwww.cygnus.co.ukcA 

! 3 ishell
! 5 $ME_ISHELL
cEcENAME cEcA


|ishell
    ishell - Open a interactive shell window 
|$ME_ISHELL
    $ME_ISHELL - Windows ishell command comspec 
$a


cEcEPLATFORM cEcA


    Windows '95/'98/NT - win32 
    Unix - All variants. 


cEcESYNOPSIS cEcA


    cDishellcA 

    cC[Windows Only]cA 
    cD$ME_ISHELLcA cC= <comspec>cA 


cEcEDESCRIPTION cEcA


    cDishellcA creates an interactive shell window within the a MicroEmacs buffer 
    window, providing access to the native operating systems command shell. 
    Within the window commands may be entered and executed, the results are 
    shown in the window. 

    On running cDishellcA a new buffer is created called cG*shell*cA which contains 
    the shell. Executing the command again creates a new shell window called 
    cG*shell1*cA, and so on. If a cG*shell*cA window is killed off then the available 
    window is used next time the command is run. 

    Additional controls are available within the shell window to control the 
    editors interaction with the window. The operating mode is shown as a 
    digit on the buffer mode line, this should typically show "3", which 
    corresponds to cCF3cA. The operating modes are mapped to keys as follows:- 

    cDF2cA 
        Locks the window and allows local editing to be performed. All 
        commands entered into the window are interpreted by the editors. cDF2cA 
        mode is typically entered to cut and paste from the window, search for 
        text strings etc. In mode 2, a cD2cA is shown on the mode line. 

    cDF3cA 
        The normal operating mode, text typed into the window is presented to 
        the shell window. Translation of MicroEmacs commands (i.e. 
        beginning-of-word) are translated and passed to the shell. For 
        interactive use this is the default mode. In mode 3, a cD3cA is shown on 
        the mode line. 

    cDF4cA 
        All input is passed to the shell, no MicroEmacs commands are 
        interpreted and keys are passed straight to the shell window. This 
        mode is used where none of the keys to be entered are to be 
        interpreted by MicroEmacs. Note that you have to un-toggle the F4 mode 
        before you can swap buffers as this effectively locks the editor into 
        the window. 

    cDF5cA 
        Clears the buffer contents. This simply erases all of the historical 
        information in the buffer. The operation of the shell is unaffected. 

    To exit the shell then end the shell session using the normal exit command 
    i.e. "cGexitcA" or "cGC-dcA" as normal and then close the buffer. A short cut "cGC-c 
    C-kcA" is available to kill off the pipe. However, it is not recommended 
    that this method is used as it effectively performs a hard kill of the 
    buffer and attached process 


cEcEUNIX cEcA


    The UNIX environment uses the native cDptycA support of the operating system. 
    The shell that is opened is determined by the conventional cG$SHELLcA 
    environment variable. 

    The shell window assumes that the user is running some sort of Emacs 
    emulation on the command line (i.e. cGVISUAL=emacscA for cDksh(1)cA, cDzsh(1)cA, 
    cDbash(1)cA, cDtsch(1)cA) and passes Emacs controls for command line editing. 

    The shell window understands re-size operations and provides a limited 
    decoding of the cCtermiocA characters for a VT100 screen. From within the 
    shell window it is possible to run the likes of cDtop(1)cA correctly. It is 
    even possible to run another MicroEmacs terminal session !! 


cEcEWINDOWS cEcA


    The Windows environment provides a very poor command shell facility, this 
    is more of a fundamental problem with the operating system than anything 
    else. Unfortunately NT is no better than Windows '95/'98, stemming from 
    the fact that the Windows is not actually an O/S but a huge window 
    manager, hindered by legacy issues of MS-DOS. 

    For those familiar with the UNIX command shell then it is strongly 
    recommended that the lslmcygnus(3)le BASH shell is used as an alternative. This 
    is a far more responsive shell window and provides the familiar Emacs 
    editing of the command line. 

    The command shell under Windows is slow and very unresponsive, this would 
    appear to be a problem with the cCcommand.comcA as the same problems are not 
    apparent with the lscygnus(3)lmcygwinle environment. However, the shell window is good 
    for kicking off command line utilities (such as cCmakecA), or any command line 
    processes that generate output on cCstdoutcA as all of the output is captured 
    in the buffer window which can be scrolled backwards for post analysis. 
    For this very reason it is more preferable to the standard MS-DOS box. 

    It is not possible to run any utilities that use embedded screen control 
    characters as these are not interpreted by the editor. 


cEChanging the Shell cA


    The default shell that is executed is defined by the environment variable 
    cD$COMSPECcA. Where the user is using a different command shell (i.e. 4-DOS), 
    then problems may arise if this is an old 16-bit executable. The shell 
    that MicroEmacs executes may be overridden by setting the environment 
    variable cD$ME_ISHELLcA. This is typically set in the lslmme32.ini(8)le file i.e. 

        [username] 
        ME_ISHELL=c:\windows\command.com 


cEBugs cA


    cDWinOldApcA 
        cDWinoldapcA is created by the Microsoft environment whenever a shell is 
        created. On occasions where processes have terminated badly the user 
        may be prompted to kill these off; this is the normal behaviour of 
        Windows. It is strongly advised that the shell is always exited 
        correctly (i.e. cGexitcA) before leaving the editor. The Windows operating 
        system for '95/'98 is not particularly resilient to erroneous 
        processes can bring the whole system down. I believe that NT does not 
        suffer from these problems (much). 

    cDLocked InputcA 
        There are occasions after killing a process the editor appears to lock 
        up. This is typically a case that the old application has not shut 
        down correctly. Kill off the erroneous task (cGAlt-Ctrl-DelcA - cCEnd TaskcA) 
        then bring the editor under control using a few cGC-gcA lslmabort-command(2)le 
        sequences. 


cEcENOTES cEcA


    The cDishellcA command uses the lslmipipe-shell-command(2)le to manage the pipe 
    between the editor and the shell. The window is controlled by the macro 
    file cGhkipipe.emfcA which controls the interaction with the shell. 


cEcESEE ALSO cEcA


    lslmipipe-shell-command(2)le, lslmcygnus(3)le, lslmme32.ini(8)le. 

! 3 diff
! 3 diff-changes
! 5 %diff-com
cEcENAME cEcA


    diff - Difference files or directories 
    diff-changes - Find the differences from a previous edit session 
    %diff-com - Diff command line 
$a


cEcESYNOPSIS cEcA


|diff
    cDdiffcA "cColdFilecA" "cCnewFilecA" 
|diff-changes
    cDdiff-changescA 
|%diff-com
    cG%diff-comcA "cCstringcA"; Default is "cGdiffcA" 


cEcEDESCRIPTION cEcA


    cDdiffcA executes the cDdiff(1)cA command with the command line set by the 
    lslm%diff-com(5)le variable and the user supplied cColdFilecA and cCnewFilecA. The 
    output of the command is piped into the cD*diff*cA buffer and is hilighted to 
    show the changes (GNU diff only). 

    Your version of cDdiff(1)cA will determine whether it is possible to 
    difference directories. 

    cDdiff-changescA is a simple macro that differences the current buffer and the 
    last backup of the associated file. It is a quick way to determine what 
    has been modified recently. This macro only works if a backup file exists. 

    cD%diff-comcA is the command line that is used to execute a cDdiff(1)cA system 
    command. 

    For GNU diff then the following command line setting is recommended:- 

        diff --context --minimal --ignore-space-change \ 
            --report-identical-files --recursive 


    which should be defined in your personal user configuration. This is the 
    default for Linux. 


cEcENOTES cEcA


    cDdiffcA and cDdif-changescA are macros defined in cGtools.emfcA. 

    cDdiff(1)cA must be executable on the system before diff or diff-changes can 
    function. 

    cDdiff(1)cA is a standard utility on UNIX systems. For Windows 95/NT a version 
    of GNU cDdiffcA may be found at: 

        cC<ftp.winsite.com/ftp/pub/pc/winnt/misc/gnudiff.zip>cA 

    For MS-DOS users, a DJGPP port of cDdiffcA is also available on the net. A 
    commercial version of cDdiffcA is also available from MKS. 


cEcESEE ALSO cEcA


    lslmcompare-windows(2)le, lslmcompile(3)le, lslmgdiff(3)le, lslmgrep(3)le, lslm%grep-com(5)le. 

! 3 regex-forward
! 3 regex-backward
cEcENAME cEcA


|regex-forward
    regex-forward - Search for a magic string in the forward direction 
|refex-backward
    regex-backward - Search for a magic string in the backward direction 
$a


cEcESYNOPSIS cEcA


    cCncA cDregex-forwardcA "cCstringcA" 
    cCncA cDregex-backwardcA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cDregex-forwardcA searches for a regular expression string from the current 
    cursor position to the end of the file. A case insensitive regular 
    expression search is performed regardless of the lslmmagic(2m)le and lslmexact(2m)le 
    mode settings. 

    The numeric argument cCncA is interpreted as follows:- 

    cDn > 0cA 
        The cCncAth occurrence of the cCstringcA is located. 

    cDn < 0cA 
        The first occurrence of the cCstringcA is located in the next cCncA lines. 

    cDregex-backwardcA searches backwards in the file. In all other ways it is 
    like cDregex-forwardcA. 


cEcEDIAGNOSTICS cEcA


    The command returns a status of cGFALSEcA if the cCstringcA could not be located 
    (or cCncAth cCstringcA where cCncA occurrences are requested). If the cCstringcA is found 
    within the given search criteria the return status is cGTRUEcA. 


cEcENOTES cEcA


    The cDregex-forwardcA and cDregex-backwardcA commands are not publically available 
    from the command line, but may be used within macros to perform regular 
    expression searches regardless of the user mode settings. 

    These commands are implemented as macros in cGutils.emfcA. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmexact(2m)le, lslmisearch-forward(2)le, lslmmagic(2m)le, 
    lslmreplace-string(2)le, lslmsearch-backward(2)le, lslmsearch-forward(2)le. 
    lsRegularExpressions(2)lmRegular Expressionsle 

! 3 osd-dialog
! 3 osd-xdialog
! 3 osd-entry
cEcENAME cEcA


|osd-dialog
    osd-dialog - OSD dialog box 
|osd-xdialog
    osd-xdialog - OSD Extended dialog box 
|osd-entry
    osd-entry - OSD entry dialog box 
$a


cEcESYNOPSIS cEcA


    cCncA cDosd-dialogcA "cCtitlecA" "cCpromptcA" [ "cCx-poscA" "cCy-poscA" ] "cCbut1cA" 
    cCncA cDosd-xdialogcA "cCtitlecA" "cCpromptcA" cCdefaultcA [ "cCx-poscA" "cCy-poscA" ] 
        "cCbut1cA" "cCbut2cA" ... 
    cCncA cDosd-entrycA "cCtitlecA" "cCpromptcA" cCvariablecA [ "cCx-poscA" "cCy-poscA" ] 
        [ [ "cCentry-xsizecA" | "cCentry-xsizecAxcCentry-ysizecA" ] [ "cCtypecA" ] ] 


cEcEDESCRIPTION cEcA


    cDosd-dialogcA constructs a OSD dialog prompt with a title string cCtitlecA, a 
    prompt string within the dialog of cCpromptcA. A single button, with text 
    rendering cCbut1cA, is placed within the dialog. The dialog remains on the 
    screen until the button is selected or the user aborts. 

    cDosd-xdialogcA creates an extended dialog with multiple buttons similar to 
    cDosd-dialogcA, the number of buttons created (cC#cA) is determined from the 
    number of cCbutcA arguments. The cCdefaultcA integer argument specifies the 
    default button (1..cC#cA), a value of 0 specifies that there is no default 
    button. 

    The commands return the button pressed in the variable lslm$result(5)le. 

    cDosd-entrycA constructs a simple OSD entry dialog which prompts the user to 
    type in a value. The value of the supplied variable is used as an initial 
    entry value, the variable is set to the entered value when the user 
    presses the "cGOkaycA" button but remains unchanged if the user Cancel or 
    aborts. 

    The size of the entry defaults to 30 characters if not specified by the 
    user, when a size parameter is given it can take one of two forms, either 
    simply "cGwcA" specifying the width, the height defaulting to 1, or "cGwcAcDxcAcGhcA" 
    (i.e. "cG40x5cA") specifying both. The last optional argument cCtypecA sets the 
    type of value being entered (e.g. file name, buffer name, etc) see flag cDhcA 
    on the help page for lslm@ml(4)le for a list of entry types and the numerical 
    value to be supplied. 

    The argument cCncA can be used to change the default behavior of the commands 
    described above, cCncA is a bit based flag where:- 

    cD0x01cA 
        Enables command abort (default), except cDosd-entrycA which ignores the 
        setting of this bit. When enabled, if the user abort by either closing 
        the dialog (top right button) or using the cDabort-commandcA the dialog 
        command will also abort. If bit 0x01 is not set the command will not 
        abort and cD$resultcA will be set to -1. 

    cD0x02cA 
        When set, flags that a dialog position has also been provided, extra 
        arguments cDx-poscA and cDy-poscA must also be given. By default the dialog is 
        placed under the mouse. 


cEcEEXAMPLE cEcA


    A simple query dialog is typically constructed using cDosd-dialogcA, as 
    follows:- 
sB
        !if &seq %osd-search-str "" 
            osd-dialog "Replace" "Error: Search string is empty!" "  &OK  " 
            !return 
        !endif 

sA
    The following example uses multiple buttons within a single dialog, using 
    cDosd-xdialogcA, as follows:- 
sB
        0 define-macro osd-close 
            !if &bmod "edit" 
                set-variable #l0 &spr "Buffer \"%s\" changed" $buffer-bname 
                osd-xdialog "Buffer Close" #l0 1 "&Save First" \ 
                                                "&Loose Changes" "&Cancel" 
                !if &equ $result 3 
                    !abort 
                !elif &equ $result 2 
                    -1 buffer-mode "edit" 
                !else 
                    !if &seq $buffer-fname "" 
                        !nma write-buffer 
                    !else 
                        !nma save-buffer 
                    !endif 
                !endif 
            !endif 
            delete-buffer $buffer-bname @mna 
        !emacro 

sA
    The next example macro can be used to change the value of a user variable 
    to a user supplied file name: 
sB
        set-variable %source-root "~/" 

        define-macro set-source-root 
            osd-entry "Source Root" "&Path : " %source-root 35 1 
        !emacro 

sA

cEcENOTES cEcA


    cDosd-dialogcA, cDosd-xdialogcA and cDosd-entrycA are macros defined in cGosd.emfcA, using 
    lslmosd(2)le to create the dialog. 


cEcESEE ALSO cEcA


    lslm$result(5)le, lslmosd(2)le. 

! 3 which
! 5 .which.result
cEcENAME cEcA


|which
    which - Program finder 
|.which.result
    .which.result - Program path 
$a


cEcESYNOPSIS cEcA


    cDwhichcA "cCprognamecA" 
    cD.which.resultcA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cDwhichcA searches for the given program "cCprognamecA" on the system path (set by 
    the environment variable cD$PATHcA). If found the location is printed on the 
    message line, otherwise an error message is printed and the command fails. 

    The variable cD.which.resultcA is set to the last found program or the string 
    "cGERRORcA" if the program was not found. 


cEcENOTES cEcA


    cDwhichcA is a macro defined in cGtools.emfcA, it used the &which macro directive. 


cEcESEE ALSO cEcA


    lslm&which(4)le. 

! 3 auto-spell
! 3 auto-spell-buffer
! 3 auto-spell-reset
cEcENAME cEcA


|auto-spell
    auto-spell - Auto-spell support 
|auto-spell-buffer
    auto-spell-buffer - Auto-spell whole buffer 
|auto-spell-reset
    auto-spell-reset - Auto-spell hilight reset 
$a


cEcESYNOPSIS cEcA


    cCncA cDauto-spellcA 
    cDauto-spell-buffercA 
    cDauto-spell-resetcA 


cEcEDESCRIPTION cEcA


    cDauto-spellcA enables and disables the auto spell checking of the current 
    buffer. Auto spell detects word breaks as you type and checks the spelling 
    of every completed word hilighting any erroneous words in the error color 
    scheme (usually red). 

    The argument cCncA determines whether auto-spell is enabled or disabled, a +ve 
    argument enables and a -ve argument disables. If no argument or cC0cA is 
    supplied the auto-spell state is toggled. 

    cDauto-spell-buffercA checks all words within the current buffer for spell, 
    hilighting any unknown or miss-spelled words found. 

    cDauto-spell-resetcA resets the buffer hilighting scheme, removing any added 
    erroneous words. 


cEcENOTES cEcA


    cDauto-spellcA and cDauto-spell-resetcA are macros defined in cGspellaut.emfcA. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmspell-buffer(3)le, lslmspell(2)le. 

! 3 find-zfile
! 3 zfile-setup
cEcENAME cEcA


|find-zfile
    find-zfile - Compressed file support 
|auto-spell-reset
    zfile-setup - Compressed file support setup 
$a


cEcESYNOPSIS cEcA


    cDfind-zfilecA "cCfile-namecA" 
    cDzfile-setupcA "cCextensioncA" "cClist-commandcA" "cCcut-tocA" 
        "cCcolumncA" "cCfile-endcA" "cCextract-commandcA" 
        "cCremove-commandcA" 


cEcEDESCRIPTION cEcA


    cDfind-zfilecA provides generic support for listing and extracting the 
    contents of compressed files. cDfind-zfilecA also supports the extraction of 
    the internal files into another buffer. 

    cDfind-zfilecA must be configured for each compression format using 
    cDzfile-setupcA. It relies on command-line programs to generate content lists 
    which are used to generate the main file listing, and subsequently, the 
    ability to extract individual files for file extraction support. 

    For basic content listing support the first 3 arguments must be given to 
    zfile-setup. The first argument "cCextensioncA" is used as the compressed file 
    id string. The compressed file type is derived from the file extension, 
    e.g. "cGzipcA" or "cGZcA" for UNIX compressed files. The exact case of the 
    extension is checked first, followed by the lower case and upper case 
    string. 

    The compressed file contents list is generated from executing the user 
    supplied "cClist-commandcA" and dumping the output into the list buffer. The 
    command is run from the directory containing the compressed file and the 
    following special tags may be used within the "cClist-commandcA" which get 
    substituted as follows:- 

    cD%zbcA 
        The token is replaced with the compressed files base name, i.e. the 
        file name without the path. 

    cD%zfcA 
        The token is replaced with the compressed files absolute file name, 
        i.e. the file complete with the path. 

    The head of the list output is often unwanted verbose printout, this can 
    be automatically be removed by the use of the "cCcut-tocA" argument. The 
    argument, if supplied (not an empty string), must be a lsRegularExpressions(2)lmregexle search string 
    matching the start of the required list. If found, all text before it is 
    removed. 

    For single file extraction support the last 4 arguments must be specified 
    by cDzfile-setupcA. The file to extract is selected either by selecting the 
    file name using the left mouse button or by moving the cursor to the line 
    containing the file name and pressing the "cGreturncA" key. 

    cDfind-zfilecA assumes that the file name starts at a fixed column number, 
    specified with the "cCcolumncA" argument. The end of the file name is obtained 
    by searching for the regular expression "cCfile-endcA" string, the file name 
    is assumed to end at the start of the search string match. 

    The file is then extracted by executing the supplied "cCextract-commandcA" and 
    then loading the extracted file into a new buffer. The command is run from 
    the system temporary directory (i.e. "cG/tmp/cA" on UNIX or cG$TEMPcA on Windows 
    etc.). The following special tags may be used within the "cCextract-commandcA" 
    which get substituted as follows:- 

    cD%zbcA 
        The token is replaced with the compressed files base name, i.e. the 
        file name without the path. 

    cD%zfcA 
        The token is replaced with the compressed files absolute file name, 
        i.e. the file name complete with the path. 

    cD%fbcA 
        The name of the file to be extracted. 

    The file is assumed to be extracted to the temp directory due to the way 
    the command is run, this file is then loaded into a new buffer. The 
    temporary file should then be removed using the supplied "cCremove-commandcA" 
    with is run from the temp directory, the "cD%fbcA" special tag may be used in 
    the command. This argument may be given as an empty string, thereby 
    disabling the removal. 


cEcEEXAMPLE cEcA


    For zip file support the freely available cDunzip(1)cA command can be used, 
    following is the list of arguments with suitable entries: 

        extension           zip 
        list-command        unzip -v %zb 
        cut-to              ^ Length 
        column              58 
        file-end            $ 
        extract-command     unzip -o %zf %fb 
        remove-command      rm %fb 


    For the zip file "cC/usr/jasspa/memacros.zipcA", after substitution the list 
    command becomes "cGunzip -v memacros.zipcA" which will be executed in the 
    "cC/usr/jasspa/cA" directory. This will produce the following form of output: 

        Archive:  memacros.zip 
         Length  Method   Size  Ratio   Date    Time   CRC-32     Name 
         ------  ------   ----  -----   ----    ----   ------     ---- 
            565  Defl:N     258  54%  02-27-99  22:56  018a7f70   american.emf 
           3409  Defl:N     872  74%  02-28-99  01:37  6a6f9722   americar.emf 
           4201  Defl:N     772  82%  03-01-99  12:58  d4e3bc4a   benchmrk.emf 
            565  Defl:N     258  54%  02-27-99  22:56  dd394e24   british.emf 
           3408  Defl:N     872  74%  02-28-99  01:37  32f3eeca   britishr.emf 
           7239  Defl:N    1923  73%  02-28-99  15:13  d408f0da   calc.emf 
           7292  Defl:N    2072  72%  01-23-99  12:49  5979d6b2   cbox.emf 
           7104  Defl:N    1402  80%  02-28-99  15:13  6faf4fc5   cmacros.emf 
           5967  Defl:N    1239  79%  02-13-99  16:38  27601523   ctags.emf 
           1097  Defl:N     489  55%  02-16-99  10:58  53a55e36   dos.emf 
            562  Defl:N     310  45%  01-16-98  07:54  ec24f65e   dos2unix.emf 
        . 
        . 
        . 


    The top Archive line is not require, this is automatically removed by 
    setting the "cCcut-tocA" to "cG^ LengthcA" which matches the start of the next 
    line. 

    For file extract, consider the file "cGctags.emfcA", the first character 'cGccA' 
    is at column 58 and the first character after the end of the file name is 
    the end-of-line character ('cG\ncA') which is matched by the lsRegularExpressions(2)lmregexle string "$", 
    hence the settings on "cCcolumncA" and "cCfile-endcA". When this and the zip file 
    name are substituted into the extract-command, it becomes "cGunzip -o 
    /usr/jasspa/memacros.zip calc.emfcA" and is run from the "cC/tmp.cA" directory. 
    Note that the "cG-ocA" option disables any overwrite prompts, these are not 
    required as tests and prompting have already been performed by cDfind-zfilecA. 
    The extracted file "cC/tmp/calc.emfcA" is then loaded into a new buffer. 

    The temporary file is removed by executing the substituted remove-command 
    which becomes "cGrm calc.emfcA" from the "cG/tmp/cA" directory. 

    For gzipped tar files, extension "cDtgzcA" the following setup can be used on 
    UNIX platforms: 

        extension           tgz 
        list-command        unzip -v %zb 
        cut-to 
        column              43 
        file-end            $ 
        extract-command     gunzip -c %zf | tar xof - %fb 
        remove-command      rm %fb 


    For the tgz file "cC/usr/jasspa/memacros.tgzcA", this will produce the 
    following listing: 

        tgz file: /usr/jasspa/memacros.tgz 


        rw-rw-r-- 211/200    565 Feb 27 22:56 1999 american.emf 
        rw-rw-r-- 211/200   3409 Feb 28 01:37 1999 americar.emf 
        rw-rw-r-- 211/200   4201 Mar  1 12:58 1999 benchmrk.emf 
        rw-rw-r-- 211/200    565 Feb 27 22:56 1999 british.emf 
        rw-rw-r-- 211/200   3408 Feb 28 01:37 1999 britishr.emf 
        rw-rw-r-- 211/200   7239 Feb 28 15:13 1999 calc.emf 
        rw-rw-r-- 211/200   7292 Jan 23 12:49 1999 cbox.emf 
        rw-rw-r-- 211/200   7104 Feb 28 15:13 1999 cmacros.emf 
        rw-rw-r-- 211/200   5967 Feb 13 16:38 1999 ctags.emf 
        rw-rw-r-- 211/200   1097 Feb 16 10:58 1999 dos.emf 
        rw-rw-r-- 211/200    562 Jan 16 07:54 1998 dos2unix.emf 
        . 
        . 
        . 


cEcENOTES cEcA


    cDfind-zfilecA and cDzfile-setupcA are macros defined in cGzfile.emfcA. 


cEcESEE ALSO cEcA


    lslmfind-file(2)le. 

! 3 charset-change
! 3 charset-iso-to-user
! 3 charset-user-to-iso
cEcENAME cEcA


|charset-change
    charset-change - Convert buffer; between two character sets 
|charset-iso-to-user
    charset-iso-to-user - Convert buffer; ISO standard to user character set 
|charset-user-to-iso
    charset-user-to-iso - Convert buffer; user to ISO standard character set 
$a


cEcESYNOPSIS cEcA


    cDcharset-changecA 
    cDcharset-iso-to-usercA 
    cDcharset-user-to-isocA 


cEcEDESCRIPTION cEcA


    cDcharset-changecA opens a dialog allowing the user to select a cDFromcA and cDTocA 
    character set. If the cCConvertcA button is selected the current buffer is 
    converted to the destination character set. The command assumes that the 
    current buffer is written in the cDFromcA character set, no attempt is made to 
    verify this. 

    cDcharset-iso-to-usercA converts the current buffer, assumed to be in 
    ISO-8859-1 (Latin 1) font format, to the current user's character set 
    (defined by lslmuser-setup(3)le). This process typically corrects any foreign 
    language display problems. 

    Conversely, cDcharset-user-to-isocA converts the current buffer from the 
    user's character set to ISO-8859-1 (Latin 1), this is typically used for 
    the transfer of text files between different systems. 

    The current character set is configured using the lslmuser-setup(3)le dialog 
    (see lsuser-setup(3)lmDisplay Font Setle). This in turn uses the command lslmset-char-mask(2)le to 
    create the low level character conversion tables. 


cEcENOTES cEcA


    cDcharset-changecA, cDcharset-iso-to-usercA and cDcharset-user-to-isocA are macros 
    defined in cGlangutl.emfcA. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmset-char-mask(2)le, lslocaleSupport(2)lmLocale Supportle. 

! 3 execute-tool
cEcENAME cEcA


    execute-tool - Execute a user defined shell tool 
$a


cEcESYNOPSIS cEcA


    cCncA cDexecute-toolcA "cCtool-namecA" 


cEcEDESCRIPTION cEcA


    cDexecute-toolcA launches a predefined shell tool, the tools are typically 
    defined by the lslmuser-setup(3)le Tools page and executed using the MicroEmacs 
    main Tools menu. See help on lslmuser-setup(3)le for more information on the 
    basic facilities given by execute-tool. 

    If the numeric argument cCncA is supplied it is used as the tool name to be 
    executed, otherwise the argument "cCtool-namecA" must be given. 

    A tool with a numeric name can be executed via a key binding, for example, 
    to execute tool cD3cA (as defined by cDuser-setupcA) to 'cGC-3cA' add the following 
    line to the user setup file:- 
sB
        3 global-bind-key execute-tool "C-3" 

sA

cEcENOTES cEcA


    The registry entries for a tool must be located in registry directory 
    "cG/history/cAcD$platformcAcD/tool/cAcDtool-namecA" where cD$platformcA is the current setting 
    of variable lslm$platform(5)le and cDtool-namecA is the name of the tool as given to 
    the command. The following registry entries are used:- 

    cDnamecA 
        The name of the tool as displayed in the user-setup Tools dialog and 
        the Main Tools menu. This is only used for tools cG0cA to cG9cA. 

    cDcommandcA 
        The command-line to be launched when the tool is executed, the 
        following special tokens may be used in the command-line which are 
        substituted at execution:- 

        cD%ffcA 
            The current buffer's full file name, including the path. 

        cD%fpcA 
            The current buffer's file path. 

        cD%fncA 
            The current buffer's file name without the path. 

        cD%fbcA 
            The current buffer's file base name, i.e. the file name without 
            the path or the extension. 

        cD%fecA 
            The current buffer's file extension with the 'cC.cA' (e.g. "cC.emfcA"), 
            set to the empty string if the file name does not have an 
            extension. 

        Note that "cD%ffcA" is always the same as "cD%fp%fncA" and "cD%fp%fb%fecA". If any 
        of these tokens are used, the tool will fail to execute if the current 
        buffer does not have a file name. 

    cDflagcA 
        A bit based flag setting the tool characteristics, where:- 

        cD0x01cA 
            Enable current buffer saving. 

        cD0x02cA 
            Enable prompt before saving current buffer. 

        cD0x04cA 
            Enable all edited buffers saving. 

        cD0x08cA 
            Enable prompt before saving an edited buffer. 

        cD0x10cA 
            Enable output capturing. 

        cD0x20cA 
            Enable concurrent running, not available on all platforms, see 
            variable lslm$system(5)le. 

    cDbnamecA 
        The name of the buffer to be used if the output is captured. The 
        following special tokens may be used in the buffer name which are 
        substituted at execution:- 

        cD%fncA 
            The current buffer's file name without the path, set to the buffer 
            name if the current buffer does not have a file name. 

        cD%fbcA 
            The current buffer's file base name, i.e. the file name without 
            the path or the extension. Set to the buffer name if the current 
            buffer does not have a file name. 

        cD%fecA 
            The current buffer's file extension with the 'cC.cA' (e.g. "cC.emfcA"), 
            set to the empty string if the current buffer does not have a file 
            name or it does not have an extension. 
        Note that "cD%fncA" is always the same as "cD%fb%fecA". Default buffer name 
        when this field is left empty is "cC*command*cA", or "cC*icommand*cA" if cGRun 
        ConcurrentlycA is enabled. 

    If more than 10 tools are required (maximum number definable by 
    cDuser-setupcA) or names are preferred, it is recommended that the cDuser-setupcA 
    dialog is used to define the tool and then use the registry copy utility 
    bound to 'cGccA' in a lslmlist-registry(2)le buffer. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmipipe-shell-command(2)le, lslmpipe-shell-command(2)le, 
    lslmshell-command(2)le, ls$system(5)lmsystem(5)le. 

! 3 info
! 3 info-on
! 3 info-goto-link
! 5 $INFOPATH
cEcENAME cEcA


|info
    info - Display a GNU Info database 
|info-on
    info-on - Display Info on a given topic 
|info-goto-link
    info-goto-link - Display Info on a given link 
|$INFOPATH
    $INFOPATH - GNU info files base directory 
|.info.path
    .info.path - Cached info search path 
$a


cEcESYNOPSIS cEcA


    cDinfocA 

    cDinfo-oncA cCtopic-strcA 

    cDinfo-goto-linkcA cClink-strcA 

    cD$INFOPATHcA cCstringcA 

    cD.info.pathcA cCstringcA 


cEcEDESCRIPTION cEcA


    cDinfocA interprets the GNU cCinfocA pages, and presents the info file information 
    within a buffer window called cG*info XXXXXcA, where cGXXXXXcA is the name of the 
    info file. The root of the info page is displayed and may be traversed by 
    selecting the links with the mouse, or by using the standard cCinfocA 
    traversal keys. 

    The root of the cCinfocA tree is, by default, a file called cDdircA, which points 
    to the other information sources. The default search paths for the cCinfocA 
    directories are:- 

        cGc:/infocA - MS-DOS and MS-Windows (all). 
        cG/usr/local/infocA - All UNIX platforms. 

    The root directory may also be specified with the cG$INFOPATHcA environment 
    variable. This is a colon (cG:cA) or semi-colon (cG;cA) separated list of 
    directory paths which specify the locations of the info files, for UNIX 
    and Microsoft DOS/Windows environment's, respectively. 

    cDinfo-oncA gets info on a user specified top level topic, e.g. "cGgcccA", the 
    info file "cCtopic-strcAcG.infocA" must be found in the info search path. 

    cDinfo-goto-linkcA gets and displays info on a user specified link or subject. 
    The link may be within the currently displayed topic (the cClink-strcA need 
    only specify the subject node name) or a subject within another topic (in 
    which case the cClink-strcA takes the following form "cG(cAcCtopiccAcG)cA cCsubjectcA"). 


cEcENOTES cEcA


    cDinfocA is a macro implemented in file cGinfo.emfcA. 

    When an cDinfocA command is run for the first time, the info search path is 
    constructed and stored locally in the command variable cD.info.pathcA. This 
    variable must be directly changed by the user if changes to the info 
    search path are required. 


cEcESEE ALSO cEcA


    lslminfo(9)le. 

! 3 gdiff
! 5 %gdiff-com
cEcENAME cEcA


    gdiff - Graphical file difference 
    %gdiff-com - Gdiff diff(1) command line 
$a


cEcESYNOPSIS cEcA


|gdiff
    cDgdiffcA "cCversion1cA" "cCversion2cA" 
|%gdiff-com
    cG%gdiff-comcA "cCstringcA"; Default is "cGdiff -c -wcA" 


cEcEDESCRIPTION cEcA


    cDgdiffcA is a macro utility that facilitates the merging of two files 
    (typically with different modification revisions). The changes between the 
    revisions are hilighted with color, allowing modification regions and 
    lines to be selected for the generation of a newer revision file, which 
    might encompass selected modifications from each of the base revisions. 

    cDgdiffcA executes the cDdiff(1)cA command with the command line set by the 
    lslm%gdiff-com(5)le variable and the user supplied cCversion1cA and cCversion2cA. The 
    output is displayed in two buffer windows, side by side, and the 
    differences in the lines are hilighted to show the changes. In addition 
    the content of the two buffers is cCnormalizedcA such that both windows are 
    aligned at the same line position, allowing the changes in the text to be 
    viewed in both windows at the same time. 

    Whilst in cDgdiffcA view mode then both scroll bars (if visible) are cClockedcA, 
    such that either scrolls BOTH windows at the same time. Other key commands 
    are disabled, as are the menu interactions. The short cut keys are defined 
    as follows:- 

    cGesc h/A-hcA - View the help page. 
        Invokes the display of a OSD help box, summarizing the interaction 
        commands 

    cGC-upcA - Move to previous difference 
        Moves to the previous changed region above the current cursor 
        position. 

    cGC-downcA - Move to next difference 
        Moves to the next changed region below the current cursor position. 

    cGleft mouse buttoncA 
    cGspacecA 
    cGentercA 
    cGrcA - Select difference version 
        Selects the difference version of the currently selected window. The 
        region is hilighted as the required region to be incorporated into the 
        new revision. 

    cGRcA - Select neither version. 
        Marks both regions as not required. 

    cGlcA - Line select current version 
        Selects the current line from the region as being included, without 
        including ALL of the region modifications. 

    cGLcA - Line select neither version 
        Discards lines from both revisions of the file. 

    cGgcA - Globally selects the current version. 
        Shortcut allows ALL modifications to the current side to be accepted. 
        This is typically the fastest method to select all changes, minor 
        region adjustment may then be performed on those regions which are 
        inappropriately included by the selection. 

    cGGcA - Globally selects neither version. 
        Marks all regions as not being acceptable. 

    cGC-x C-scA - Save current side 
        Saves the current window to the specified file, merging the selected 
        changes between the two revisions. Note that the save only operates 
        iff all hilighted changes have been selected. 

    cGC-x C-wcA - Save current side as 
        Same as cDSave current sidecA except the user is prompted to enter a new 
        filename to which the modifications are written. 

    cGC-x kcA - Exit graphical diff 
        Exits the cDgdiffcA utility. 


cEHilighting cA


    The hilighting within the windows is dependent upon the color scheme 
    selected, in general the following hilights apply:- 

    normal text 
        No change 

    cyan/grey 
        Addition/removal of line(s)/region(s) between files. 

    yellow 
        Modification in line(s)/region(s). 

    green/red 
        Selected region, red or green is attributed to a selection for each 
        window. 


cEcENOTES cEcA


    cDgdiffcA is a macro defined in cGgdiff.emfcA, inspired by the GNU utility of the 
    same name cDgdiff(1)cA 

    cDdiff(1)cA must be executable on the system before cDgdiffcA can function. The 
    cDdiff(1)cA invocation must include the cCcontextcA difference, which annotates 
    the differences with a cG+cA, cG-cA or cG!cA markers. cDdiff(1)cA is typically invoked 
    with the options cD-c -wcA. 

    cDdiff(1)cA is a standard utility on UNIX systems. For Windows 95/NT a version 
    of GNU cDdiffcA may be found at: 

        cC<ftp.winsite.com/ftp/pub/pc/winnt/misc/gnudiff.zip>cA 

    For MS-DOS users, a DJGPP port of GNU cDdiffcA is also available on the net. A 
    commercial version of cDdiffcA is also available from MKS. 


cEcESEE ALSO cEcA


    lslmcompare-windows(2)le, lslmcompile(3)le, cDdiff(1)cA, lslmgdiff(3f)le, lslmgrep(3)le, lslm%grep-com(5)le. 

! 3 iso-accents-mode
! 3 iso-accents-expand
cEcENAME cEcA


|iso-accents-mode
    iso-accents-mode - Enable/disable ISO accent expansion short-cut mode 
|iso-accents-expand
    iso-accents-expand - Expand an ISO accent 
$a


cEcESYNOPSIS cEcA


    cCncA cDiso-accents-modecA 
    cCncA cDiso-accents-expandcA 


cEcEDESCRIPTION cEcA


    cDiso-accents-modecA provides a facility to enter a plain text representation 
    of an ISO accent and then to expand it into a proper ISO accented 
    character. For example:- 

        cG`acA => small a, grave accent 
        cG^acA => small a, circumflex accent 
        cG'acA => small a, acute accent 
        cG"acA => small a, umlaut 
        cG~acA => small a, tilde 
        cG.acA => small a, ring 
        cG14cA => fraction, one-quater 
        cG12cA => fraction, one-half 
        cG34cA => fraction, three-quaters 
        cGaecA => ae ligature 
        cGszcA => small sz ligature, German. 
        cG+-cA => plus or minus (math.) 
        cGcocA => copyright 
        cGrgcA => registered trademark 
        cGtmcA => trade mark 
        cGoecA => small oe ligature 
        cG/ocA => small o, slash 

    In order to use the ISO accent expansion then it must be installed, either 
    from the command line or, for a more permanent installation, from the 
    cCusercA.emf file. Installation is performed using the command 
    cDiso-accents-modecA, if cCncA is specified (any non-zero numeric value) then the 
    ISO accent expansion is installed locally into the current buffer. If cCncA is 
    omitted then expansion is available globally (across all buffers). An 
    argument of 0 and the cDiso-accents-modecA is un-installed. 

    cDiso-accents-expandcA is the macro command that expands the ISO abbreviated 
    character sequence into it's ISO ASCII character equivalent. This is by 
    default bound to cGESCcA cGESCcA. If an ISO character is not located then 
    lslmexpand-abbrev(2)le is invoked to try a standard abbreviation. 


cEcENOTES cEcA


    cDiso-accents-modecA and cDiso-accents-expandcA are implemented as macros in the 
    file cGlangutl.emfcA, the repertoire of expansions may be enhanced by editing 
    this file. 

    The operation of the cDiso-accents-modecA could equally as well be implemented 
    with the appropriate definitions in a lslmglobal-abbrev-file(2)le. 


cEcESEE ALSO cEcA


    lslmbuffer-abbrev-file(2)le, lslmexpand-abbrev(2)le, lslmglobal-abbrev-file(2)le, 
    lslmglobal-abbrev-file(2)le. 

! 3 gdb
! 3 dbx
cEcENAME cEcA


|gdb
    gdb - GNU Debugger 
|dbx
    dbx - UNIX Debugger 
$a


cEcESYNOPSIS cEcA


    cDgdbcA "cCprogram-namecA" "cCadditional-argscA" 
    cDdbxcA "cCprogram-namecA" "cCadditional-argscA" 


cEcEDESCRIPTION cEcA


    cDgdbcA and cDdbxcA provide an editor interface to the GNU and native system 
    debuggers, respectively. On running either command then an interactive 
    shell window is opened to the debugger command line interface. MicroEmacs 
    then interprets the information from the debugger interface and opens 
    files and hilights the current line as required. The current line is 
    maintained while single stepping through the code. 

    Buffers opened and referenced by the debugger have the key cGF9cA bound to 
    setting a break point. 


cEcENOTES cEcA


    cDgdbcA and cDdbxcA are macros defined in file cGhkipipe.emfcA. 


cEcESEE ALSO cEcA


    lslmperldb(3)le, lslmipipe-shell-command(2)le. 

! 3 expand-abbrev-handle
cEcENAME cEcA


    expand-abbrev-handle - Expand an abbreviation handler 
$a


cEcESYNOPSIS cEcA


    cDexpand-abbrev-handlecA (cDesc esccA) 


cEcEDESCRIPTION cEcA


    cDexpand-abbrev-handlecA pulls together all forms of abbreviation expansion 
    into a single command so that it can be bound to a single key. The 
    abbreviation must be an alpha-numeric string and the cursor must be one 
    position to the right of the abbreviation (which must not be 
    alpha-numeric) when this command is called. The command attempts to expand 
    the abbreviation using the following commands in turn: 

    lslmexpand-abbrev(2)le 

        Uses a buffer specific and global abbreviation files, if set, to look 
        up the abbreviation. 

    lslmiso-accents-expand(3)le 

        Expands ISO accent letter if the expansion mode is enabled. 

    cDBuffer specific expansioncA 

        Executes a buffer specific abbreviation expansion if the current 
        buffer's lsfileHooks(2)lmfile hookle supports abbreviation expansion. 

    cDWord expansioncA 

        If the current buffer does not support file type specific expansion 
        and the variable cD.spell-complete-word.oncA is set to cG1cA the abbreviation 
        is assumed to be the start of a word and completed against the 
        dictionary of the user's current language. 

    The command exits after first command to successfully expand or if none 
    expand the command fails. See the help in the individual expansion 
    commands for more help. 


cEcESEE ALSO cEcA


    lslmexpand-abbrev(2)le, lslmiso-accents-expand(3)le. 

! 3 spell-complete-word
cEcENAME cEcA


    spell-complete-word - Complete a word by invocation of the speller 
$a


cEcESYNOPSIS cEcA


    cDspell-complete-wordcA 


cEcEDESCRIPTION cEcA


    cDspell-complete-wordcA presents attempts to complete the word at the current 
    position through the use of the current language dictionary. The user is 
    presented with a list of endings for the given word portion. These may be 
    selected with the cursor or mouse. 

    cDspell-complete-wordcA is automatically invoked from the 
    lslmexpand-abbrev-handle(3)le macro in response to an expansion command, it is 
    only invoked if the macro variable cG.spell-complete-word.oncA is defined to 
    be cGTRUEcA. Spelling expansion is enabled by enabling within the cCusercA.emf as 
    follows:- 
emf-scheme

        set-variable .spell-complete-word.on 1 

ehf-scheme

    It may be subsequently disabled by setting the variable back to 0. 


cEcENOTES cEcA


    cDspell-complete-wordcA is a macro implemented in cGattrib.emfcA. 


cEcESEE ALSO cEcA


    lslmexpand-abbrev-handle(3)le, lslmspell-buffer(3)le, lslmfind-word(3)le. 

! 3 uniq
cEcENAME cEcA


    uniq - Make lines in a sorted list unique 
$a


cEcESYNOPSIS cEcA


    cDuniqcA 


cEcEDESCRIPTION cEcA


    cDuniqcA reduces a sorted lines of text in the current buffer to a unique list 
    such that no entries are repeated. The list is made unique from the lsset-mark(2)lmmarkle 
    position to the current cursor position (point). The operation is case 
    sensitive. 


cEcENOTES cEcA


    cDuniqcA is a macro implemented in cGtools.emfcA. 

    For cDuniqcA to operate correctly then the list must have been previously 
    sorted, see lslmsort-lines(2)le. 


cEcESEE ALSO cEcA


    lslmsort-lines(2)le, lslmsort-lines-ignore-case(3)le, lslmtranspose-lines(2)le, 

! 3 ftp
cEcENAME cEcA


    ftp - Initiate an FTP connection 
$a


cEcESYNOPSIS cEcA


    cDftpcA 


cEcEDESCRIPTION cEcA


    cDftpcA initiates a File Transfer Protocol (FTP) connection to a remote host 
    on the network. Using FTP, editing of files may be performed in much the 
    same way as on the local file system. Directory listings may be retrieved 
    and traversed using the mouse or cursor keys. Using the directory listing, 
    files may be transfered to/from the remote host to the local machine. 

    On issuing the command then a dialog is presented to the user which is 
    used to open the connection. The dialog entries are defined as follows:- 

    cDRegistry FilecA 
        The name of a MicroEmacs registry file which is used to store the FTP 
        information. If a registry name is provided then all FTP address 
        information is stored in the registry file and saved for later 
        sessions. Be aware that password information is saved in this file as 
        plain text if a password is entered into the site information. 

        If the registry information is omitted then the information is not 
        saved between sessions. 

    cDSite NamecA 
        An ASCII pseudo name for the remote host. The pull-down menu may be 
        used to select existing sites that have been previously entered. 

    cDHost AddresscA 
        The address of the host, this may be an IP address (cG111.222.333.444cA) 
        or a DNS name (i.e. cGftp.mysite.comcA). 

    cDUser NamecA 
        The login name for the site. If this is omitted then cGguestcA is used by 
        default. 

    cDPasswordcA 
        The password used to enter the site for the given login name. If the 
        password is NOT supplied then the user is prompted for the password 
        when a transaction takes place. If the password is omitted and left to 
        promt then it is not stored in the registry. 

        Take note of the comments provided above regarding the password 
        information. 

    cDInitial Host PathcA 
        The starting directory at the remote host. If this is omitted then the 
        root directory ('cG/cA') is used by default. 

    On selecting cDConnectcA then a FTP connection is opened and the initial 
    directory appears as a directory listing, if the initial path is a file 
    then the file is loaded into the editor. 

    Thereafter the file may be edited within the editor as normal, on a write 
    operation then the file is written back to the host, via FTP. 

    On opening a FTP connection the progress of the transfer, and the FTP 
    commands issued, may be viewed in the cG*ftp-console*cA buffer. This buffer 
    may automatically appear depending upon the value of the lslm%ftp-flags(5)le 
    variable. 


cEcENOTES cEcA


    cDftpcA is a macro implemented in cGftp.emfcA. This uses the underlying command 
    lslmfind-file(2)le to implement the FTP transfer. 

    FTP files can be directly loaded and edited using the standard file 
    commands such as lslmfind-file(2)le. 

    The FTP addresses are retained in a registry file (see lslmerf(8)le). The 
    registry file is automatically loaded when MicroEmacs starts up each 
    session. The current site information may be viewed using lslmlist-registry(2)le 
    and is located at the following registry addresses:- 

    cD/urlcA 
        Data value is file system location of the FTP registry file. 

    cD/url/ftp/cAcC<hostName>cA 
        The name of the host to which the connection is to be made. 

    cD/url/ftp/cAcC<hostName>cAcD/hostcA 
        The name or IP address of the remote host 

    cD/url/ftp/cAcC<hostName>cAcD/usercA 
        The user name used to log into the remote host. 

    cD/url/ftp/cAcC<hostName>cAcD/passcA 
        The user password to the remote host. If this entry is empty then the 
        user is always prompted for the password when the connection is made. 

    cD/url/ftp/cAcC<hostName>cAcD/pathcA 
        The initial path at the remote site. 

    When a FTP connection is initiated then the connection (socket) remains 
    open for a period of approximately 4 minutes from the last transfer time, 
    after that the connection is automatically closed and is re-initiated if 
    required again. 

    cDNOTE:cA For windows platforms then the resultant executable must be built 
    with URL support enabled, for UNIX platforms socket support is 
    automatically enabled. 


cEcEBUGS cEcA


    Directory completion is not available when the current working directory 
    is an FTP address. To work around this from the command line, select 
    cG<RETURN>cA to get a directory listing of the current directory and select 
    the file(s) from the directory to load. 


cEcESEE ALSO cEcA


    lslm%ftp-flags(5)le, lslmerf(8)le, lslmfind-file(2)le, lslmfile-op(2)le, lslmlist-registry(2)le. 

! 3 display-white-chars
cEcENAME cEcA


    display-white-chars - Toggle the displaying of white characters 
$a


cEcESYNOPSIS cEcA


    cDdisplay-white-charscA 


cEcEDESCRIPTION cEcA


    cDdisplay-white-charscA toggles the displaying of white characters in the main 
    display. By default white characters, space tab and new-lines, are 
    represented with invisible characters such as one or more 'cG cA's for spaces 
    and tabs and text moving to the next line for new-lines. The user can make 
    this characters become 'visible' using this function. 

    When this function is first called it toggle enables the displaying of 
    these characters, other characters are drawn in their place to make them 
    visible. A subsequent call will disable the displaying of them. 


cEcENOTES cEcA


    cDdisplay-white-charscA is a macro implemented in cGmisc.emfcA and uses bit 
    cG0x80000cA of the lslm$system(5)le variable. 

    The displaying of white characters can be enabled or disabled at start-up 
    using lslmuser-setup(3)le. 

    This feature may be more confusing on some terminals due to the lack of 
    characters available for displaying the white characters. The characters 
    used when displaying white characters are defined in the variable 
    lslm$window-chars(5)le. 


cEcESEE ALSO cEcA


    lslm$system(5)le, lslmuser-setup(3)le, lslm$window-chars(5)le. 

! 3 check-line-length
cEcENAME cEcA


    check-line-length - Check the length of text lines are valid 
$a


cEcESYNOPSIS cEcA


    cDcheck-line-lengthcA 


cEcEDESCRIPTION cEcA


    cDcheck-line-lengthcA checks that the length of each line of the current 
    buffer, starting with the current line, is less than or equal to 
    ls$fill-col(5)lmfill-col(5)le. The command aborts if a line too long is found, leaving the 
    cursor on the offending line. If no invalid lines are found the command 
    succeeds leaving the cursor at the end of the buffer. 


cEcENOTES cEcA


    cDcheck-line-lengthcA is a macro implemented in cGmisc.emfcA. 


cEcESEE ALSO cEcA


    lslm$fill-col(5)le. 

! 3 reread-file
cEcENAME cEcA


    reread-file - Reload the current buffer's file 
$a


cEcESYNOPSIS cEcA


    cDreread-filecA 


cEcEDESCRIPTION cEcA


    cDreread-filecA reloads from disk the file associated with the current buffer, 
    this command is particularly useful when the file is continually updated 
    by an external program. If the buffer has been edited and its name does 
    not start with a 'cG*cA' then the user is prompted as to whether the changes 
    should be discarded. Also if the buffer has an active process running in 
    it then confirmation is sort from the user before the process is killed. 


cEcENOTES cEcA


    cDreread-filecA is a macro implemented in cGtool.emfcA. 


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmread-file(2)le, lslmview-file(2)le. 

! 3 normal-tab
cEcENAME cEcA


    normal-tab - Insert a normal tab 
$a


cEcESYNOPSIS cEcA


    cCncA cDnormal-tabcA 


cEcEDESCRIPTION cEcA


    cDnormal-tabcA insert a tab into the current buffer by temporarily disabling 
    any auto indentation schemes. The macro first disables any indentation 
    rules by setting lslm$buffer-indent(5)le to 0 and disabling the lslmcmode(2m)le, the 
    command lslmtab(2)le is then called with the given argument cCncA. This means that 
    the buffer's lslmtab(2m)le mode setting will be respected, i.e. whether a tab 
    character or spaces are inserted. The initial indentation rules are 
    restored on exit. 


cEcENOTES cEcA


    cDnormal-tabcA is a macro implemented in cGformat.emfcA. 


cEcESEE ALSO cEcA


    lslmtab(2)le, lslminsert-tab(2)le, lslmtab(2m)le. 

! 3 perldb
cEcENAME cEcA


    perldb - Perl Debugger 
$a


cEcESYNOPSIS cEcA


    cCncA cDperldbcA [ "cCscript-namecA" ] "cCscript-argscA" 


cEcEDESCRIPTION cEcA


    cDperldbcA provides an editor interface to the Perl debugger, on running the 
    command an interactive shell window is opened to the debugger command line 
    interface. MicroEmacs then interprets the information from the debugger 
    interface and opens files and hilights the current line as required. The 
    current line is maintained while single stepping through the script. 

    Buffers opened and referenced by the debugger have the key cGF9cA bound to 
    setting a break point, this only works if the buffer contains the current 
    execution point. 

    If an argument cCncA of 2 is given to cDperldbcA the command assumes that the 
    current buffer is the script file to debug, the "cGscript-namecA" argument is 
    not prompted for. 


cEcENOTES cEcA


    cDperldbcA is a macro defined in file cGhkipipe.emfcA. 


cEcEBUGS cEcA


    The 'cDRcA' rerun command does not work correctly on Windows platforms, perldb 
    is rerun in a newly created external dos command window instead of inside 
    the MicroEmacs ipipe buffer. 


cEcESEE ALSO cEcA


    lslmgdb(3)le, lslmipipe-shell-command(2)le. 

! 3 generate-tags-file
cEcENAME cEcA


    generate-tags-file - Generate a tags file 
$a


cEcESYNOPSIS cEcA


    cCncA cDgenerate-tags-filecA [ "cCtag-commandcA" ] 


cEcEDESCRIPTION cEcA


    The cDgenerate-tags-filecA command provides an interface to tag file 
    generation. Typically the "cCtag-commandcA" argument will not be required as 
    the current buffer will automatically configure cDgenerate-tags-filecA on how 
    tags are generated for the current buffer's file type. See the notes below 
    for more information on configuration. 

    cDgenerate-tags-filecA supports two different methods of tag generation, 
    firstly via a MicroEmacs macro file and secondly by an external shell 
    command (such as cDctags(1)cA). It is generally configured in the current 
    buffer's lsfileHooks(2)lmsetup hookle. 

    If a macro file is used a setup dialog is opened if an argument of 0 is 
    given to cDgenerate-tagscA. This dialog can be used to configure which type of 
    tags are required and the starting directory (useful when using recursive 
    tags over a source tree). Note that not all tag types are available for 
    all file types. 

    The generated tags file can then be used by the lslmfind-tag(2)le command. 


cEcENOTES cEcA


    cDgenerate-tags-filecA is a macro defined in file cGgentags.emfcA. 

    cDgenerate-tags-filecA can be configured in one of 2 ways: 

        When a MicroEmacs macro file (such as cGctags.emfcA) is to be used, simply 
        give the name of the macro file to be run as the "cCtag-commandcA" 
        argument. Alternatively set the variable cD.cAcC<$buffer-fhook>cAcD.tagscA to this 
        name, e.g. for C files 
sB
                set-variable .fhook-c.tags "ctags" 

sA
        Note the "cG.emfcA" extension is assumed. 

        When an external shell command is to be used, set the cCtag-commandcA to 
        the shell command-line prefixed with a 'cG!cA' character, for example to 
        use cDctags(1)cA try the following: 
sB
                set-variable .fhook-c.tags "!ctags *.c *h" 

sA
        Note that the generate-tags dialog is not available in this mode of 
        execution. 


cEcESEE ALSO cEcA


    lslmfind-tag(2)le. 

! 3 cvs
! 3 cvs-add
! 3 cvs-checkout
! 3 cvs-commit
! 3 cvs-diff
! 3 cvs-gdiff
! 3 cvs-log
! 3 cvs-remove
! 3 cvs-resolve-conflicts
! 3 cvs-state
! 3 cvs-update
cEcENAME cEcA


|cvs
    cvs - MicroEmacs CVS interface 
|cvs-add
    cvs-add - MicroEmacs CVS interface - add file 
|cvs-checkout
    cvs-checkout - MicroEmacs CVS interface - checkout files and directories 
|cvs-commit
    cvs-commit - MicroEmacs CVS interface - commit changes 
|cvs-diff
    cvs-diff - MicroEmacs CVS interface - diff changes 
|cvs-gdiff
    cvs-gdiff - MicroEmacs CVS interface - graphical diff changes 
|cvs-log
    cvs-log - MicroEmacs CVS interface - log changes 
|cvs-remove
    cvs-remove - MicroEmacs CVS interface - remove file 
|cvs-resolve-conflicts
    cvs-resolve-conflicts - MicroEmacs CVS interface - resolve conflicts 
|cvs-state
    cvs-state - MicroEmacs CVS interface - list state of directory files 
|cvs-update
    cvs-update - MicroEmacs CVS interface - update directory files 
$a


cEcESYNOPSIS cEcA


    cDcvscA 

    cDcvs-addcA 
    cDcvs-checkoutcA 
    cDcvs-commitcA 
    cDcvs-diffcA 
    cDcvs-gdiffcA 
    cDcvs-logcA 
    cDcvs-removecA 
    cDcvs-resolve-conflictscA 
    cDcvs-statecA 
    cDcvs-updatecA 


cEcEDESCRIPTION cEcA


    The cvs and sub-commands provide MicroEmacs with an interface to cDcvs(1)cA. 
    cDCVScA is a version control system; using it, you can record the history of 
    your source file modifications. CVS is licensed under the GNU General 
    Public License and is freely available on the Internet, see the 
    documentation provided with CVS for more information on its features and 
    use. 

    The MicroEmacs cDcvscA command opens up a modified lslmfile-browser(3)le with an 
    additional "cG*cvs-console*cA" window. The "cG*files*cA" window includes 
    additional columns showing the CVS state, revision and repository date. 
    The functionality of the file-browser is the same as a non-CVS folder with 
    the exception that additional CVS item controls are located in the mouse 
    context menu (opened by clicking the right mouse button in the cG*files*cA 
    buffer). This menu item opens another sub-menu providing access to the 
    following items: 

    cDCheckout filescA 
        Checks out a file or directory from the repository into the current 
        directory. The file or directory is specified by typing the name into 
        a dialog which is opened when this option is selected. This runs the 
        command "cGcvs checkout <file>cA". 

    cDUpdate filescA 
        Updates the currently selected files, files are selected by clicking 
        the left button to the left of the required file name. Multiple files 
        may be selected by 'dragging' a hilight region over the required 
        files. This runs the command "cGcvs update <files>cA". 

    cDCommit filescA 
        Commits any changes made to the selected files back to the CVS 
        repository. This runs the command "cGcvs commit <files>cA". 

    cDDiff filescA 
        Displays any differences between the selected files and the CVS 
        repository version in the cC*cvs-console*cA window. This runs the command 
        "cGcvs diff <files>cA". 

    cDLog filescA 
        Displays the CVS logs for the selected files in the cC*cvs-console*cA 
        window. This runs the command "cGcvs log <files>cA". 

    cDStatus filescA 
        Displays the CVS status for each of the selected files in the 
        cC*cvs-console*cA window. This runs the command "cGcvs status -v <files>cA". 

    cDAdd filescA 
        Adds the selected files to the CVS repository. Note this command only 
        performs the local add, a cDCVS commitcA is required to make the addition 
        permanent. This runs the command "cGcvs add <files>cA". 

    cDRemove filescA 
        This command is deliberately not implemented as its far to dangerous! 
        Instead it opens a dialog informing the user to use the cDcvs-removecA 
        command instead. 

    cDGraphical diffcA 
        This command opens a lslmgdiff(3)le window showing the differences between 
        the currently selected file and the CVS repository version. Note this 
        command only works with a single file. 

    cDResolve conflictscA 
        This command may be used to resolve merge conflicts created by a cCCVScA 
        cCupdatecA operation. The command opens a lslmgdiff(3)le window showing the 
        areas of conflict allowing the user to select the correct version and 
        saving the resultant version back to the local file. Note this command 
        only works with a single file. 

    cDClear cvs consolecA 
        Clears the cC*cvs-console*cA buffer. 

    The cDcvs-addcA command adds the current buffers file to the repository. Note 
    that this command only performs the local addition, a cCCVScA cCcommitcA is 
    required to make the addition permanent. 

    The cDcvs-checkoutcA command checks out a file or directory from the 
    repository into the current directory. The user specifies the file on the 
    message line. 

    The cDcvs-commitcA command commits any changes made to the currently buffer's 
    file (including additions) to the repository. The user is prompted for a 
    commit log message. 

    The cDcvs-diffcA command opens a cC*cvs-diff*cA window displaying the differences 
    between the current buffer's local file and repository version. If the 
    current buffer is a directory list it will list all the differences found 
    in all files within the directory. 

    The cDcvs-gdiffcA command opens a lslmgdiff(3)le window displaying the differences 
    between the current buffer's local file and repository version. 

    The cDcvs-logcA command opens a cC*cvs-log*cA window displaying the CVS log of the 
    current buffer's file. 

    The cDcvs-removecA command removes the current buffer's file from the 
    repository - PLEASE NOTE THIS CAN LEAD TO LOST DATA!!! This command only 
    performs the local removal; as it deletes the buffer and file the 
    cDcvs-commitcA command cannot be used to commit the removal to the CVS 
    repository. Instead the main cDcvscA file-browser menu or cDcvs(1)cA itself must 
    be used. 

    The cDcvs-resolve-conflictscA command may be used to resolve any conflicts 
    created by CVS when the current buffer's file is updated. The command 
    opens a gdiff window displaying the areas of conflict, the user may then 
    select the correct version in each case and save the resultant new version 
    over the local file. 

    The cDcvs-statecA command opens a cC*cvs-state*cA window listing the state of any 
    file in the current directory which is not up-to-date. Note that unlike 
    most cvs sub commands this command executes over all files in the current 
    buffer's file directory. 

    The cDcvs-updatecA command updates all files in the current directory, the 
    output being reported to a new cC*cvs-update*cA window. Note that unlike most 
    cvs sub commands this command executes over all files in the current 
    buffer's file directory. 


cEcENOTES cEcA


    cDcvscA and sub-commands are macros defined in file cGcvs.emfcA. 

    By default MicroEmacs's cDcvscA commands skip all files ignored by cDcvs(1)cA. 
    This is configured by the variable cD.cvs.filtercA, defining this variable to 
    cG0cA disables this special filtering. 


cEcESEE ALSO cEcA


    lslmfile-browser(3)le. 

! 3 occur
cEcENAME cEcA

$a

cEcESYNOPSIS cEcA


    cDoccurcA 


cEcEDESCRIPTION cEcA


    cDoccurcA performs a regular expression search for a string in the current 
    buffer; generating a list of every occurrence of the regular expression in 
    the buffer. 

    On invocation the user is prompted for a lsRegularExpressions(2)lmRegular Expressionsle the buffer is 
    searched for the expression and the results are presented in the 
    cG*item-list*cA window appearing at the left-hand side of the window. 

    The user may interact with the cG*item-list*cA buffer using the mouse or 
    cG<RETURN>cA, on selecting a line then the user is moved to the corresponding 
    line in the original buffer. 


cEcENOTES cEcA


    The cG*item-list*cA window may be closed with the command lslmitem-list-close(3)le 
    typically bound to cGesc-F7cA. 

    cDoccurcA is a macro defined in cGitemlist.emfcA. 


cEcESEE ALSO cEcA


    lslmitem-list(3)le, lslmitem-list-close(3)le, lslmsearch-forward(2)le, lsRegularExpressions(2)lmRegular Expressionsle 

! 3 item-list
! 3 item-list-find
! 3 item-list-close
cEcENAME cEcA


|item-list
    item-list - Abbreviated search and list buffer contents. 
|item-list-find
    item-list-find - Find the selected item in the item list 
|item-list-close
    item-list-close - "Close the item list" 
$a


cEcESYNOPSIS cEcA


    cDitem-listcA (cDF7cA) 
    cDitem-list-findcA 
    cDitem-list-closecA (cDesc F7cA) 


cEcEDESCRIPTION cEcA


    cDitem-listcA performs a regular expression search of a buffer, presenting a 
    list of the located text and associated types in a separate window which 
    is presented to the left of the buffer window. cDitem-listcA is a generic 
    function that interacts with the buffer environment variables to present 
    abbreviated buffer information to the user. 

    The regular expression search strings are predefined in the language 
    templates. To add support for a new buffer type a list of search/replace 
    strings must be created. The search strings must use regex (magic mode) 
    and groups cG\(..\)cA to place the located object string into the replace 
    string. Within the template buffer search strings (cDscA) and replace (cDrcA) are 
    defined with the following syntax:- 

        set-variable .cChooknamecA.item-list-scCxcA "cCregexpcA" 
        set-variable .cChooknamecA.item-list-rcCxcA "cCreplacecA" 

    Where:- 

    cChooknamecA 
        The name of the file hook i.e. cGfhook-ccA for ANSI 'C'. 

    cCxcA 
        The search number, this is valid in the range 1..9, commencing from 1. 
        The search is processed in the order of the numeric identity. 

    cCregexpcA 
        The regular expression to search for. One of the arguments must 
        include a groups cG\(..\)cA definition to allow the string to be moved to 
        the replace. 

    cCreplacecA 
        The replace string, this typically includes a cCtypecA and part of the 
        search string. 

    On invocation of cDitem-listcA the buffer is searched and the results are 
    presented in the cG*item-list*cA window appearing at the left-hand side of the 
    window. If there is no item list set up for the file type then an error 
    message is displayed. 

    The user may interact with the cG*item-list*cA buffer using the mouse or 
    cG<RETURN>cA, on selecting a line then the user is moved to the corresponding 
    line in the original buffer. 

    cDitem-list-findcA finds the current item list item and searches for the text 
    in the original buffer. This is typically bound to a mouse or key stroke 
    action. 

    cDitem-list-closecA closes the item list buffer. 


cEcEEXAMPLE cEcA


    The following example works through the cDitem-listcA definition for the ME 
    macros e.g. given that the ME macro definition is: 

        define-macro macro-name 


    Searching for "cGdefine-macro \([a-z-]+\)cA" and replacing with "cGMacro \1cA" 
    will work most of the time. The space between cGdefine-macrocA and the name 
    does not have to be a single space and the cCnamecA does not have to contain 
    just lower case letters, so these search strings should be a flexible as 
    possible, try 

        "define-macro\s +\(\w+\)" 


    This however is not as optimal as it could be and if you have large files 
    this could become slow. Performance can be greatly increased if it can be 
    anchored to the start of the line, e.g. 

        "^define-macro\s +\(\w+\)" 


    but to allow for initial white spaces and the optional numeric argument, 
    you really need 

        "^\s *[0-9]*\s *define-macro\s +\(\w+\)" 


    To hilight the function name you need the name encased the name in a magic 
    hilighting string, 

        "\ecBmacro-name\ecA" 


    where cG\ecA is an escape char, so the replace string should be 

        "Macro \ecB\1\ecA" 


    Now all thats needed is to set these variables as fhook command variables, 
    for macro files, the file hook command is cGfhook-emfcA, therefore the 
    following is required: 
sB
        set-variable .fhook-emf.item-list-s1 "^\\s *[0-9]*\\s *define-macro\\s +\\(\\w+\\)" 
        set-variable .fhook-emf.item-list-r1 "Macro \ecB\\1\ecA" 

sA
    Note that you can have as many of these search and replace variables as 
    you require, i.e. cG.item-list-s1cA, cG.item-list-s2cA, cG.item-list-s3cA, ... ; but 
    the more you have the slower it will be, often a good regex can do the job 
    of 2 or 3. 


cEcESEE ALSO cEcA


    lslmoccur(3)le, lslmsearch-forward(2)le, lsRegularExpressions(2)lmRegular Expressionsle 

! 3 user-setup
cEcENAME cEcA


    user-setup - Configure MicroEmacs for a specific user 
$a


cEcESYNOPSIS cEcA


    cDuser-setupcA 


cEcEDESCRIPTION cEcA


    cDuser-setupcA provides a dialog interface to enable the user to configure the 
    editor. cDuser-setupcA may be invoked from the main cCHelpcA menu or directly from 
    the command line using lslmexecute-named-command(2)le. cDuser-setupcA configures the 
    user's setup registry file, "cC<logname>cAcG.erfcA" which is used by MicroEmacs to 
    initialize the environment to a user's preference. 

    Note, if your screen is too small to display the whole dialog, it may be 
    moved using any key bound to the scroll commands such as cDscroll-upcA, e.g. 
    cGA-upcA, cGC-zcA, cGA-downcA, cGC-vcA, cGA-leftcA etc. For systems without mouse support, the 
    cGtabcA key may be used to move between fields. 

    On all pages the following buttons are available at the bottom of the 
    dialog and have the following effect: 

    cGSavecA 
        Saves the changes made to the users registry file, i.e. 
        "cC<Log-Name>cAcG.erfcA" but does not re-initialize MicroEmacs. Some changes, 
        such as color scheme changes, only take effect when the cDCurrentcA button 
        is used or when MicroEmacs is restarted. 

    cGCurrentcA 
        Makes the current user and the changes made Current to this MicroEmacs 
        session, dismissing the cDuser-setupcA dialog and reinitializing 
        MicroEmacs. This also saves the registry file out! 

    cGExitcA 
        Quits user-setup, if changes where not cDSavecAd or made cDCurrentcA they will 
        be lost. 

    The following pages, which appear in the dialog, are defined as follows:- 


cEStart-up cA


    cGLog NamecA 
        Sets the name of the current user to setup, this can be set to any 
        valid file base name (no extension) which need not be the current 
        user. The rest of the cDuser-setupcA entries are then initialized to the 
        settings defined for the given user (or standard defaults if not 
        defined). 

    cGDefault UsercA 
        Creates a small macro file, "cGdefault.emfcA", setting lslm$MENAME(5)le to the 
        current setting of cDLog NamecA. This may be executed at start-up to 
        determine the current user. See lslm$MENAME(5)le for more information. 

    cGSetup PathcA 
        Sets the location of the user files, the files are searched for and 
        created in this directory. lslm$MEPATH(5)le should be defined to include 
        this path. 

    cGSetup FilecA 
        Sets the personal user setup macro file name which is executed at 
        start-up. A user macro file should contain all personal settings such 
        as preferred key bindings etc. See lsUserProfiles(2)lmSetting Up A User Profilele for more 
        information. The cDEditcA check box can be used to enable/disable the 
        automatic loading of the setup file ready for editing when the cDCurrentcA 
        button is used. 

    cGCompany FilecA 
        Sets the company setup macro file name which is executed at start-up. 
        A company macro file should contain all company wide standard settings 
        such as cG%company-namecA, No cG.emfcA extension is supplied. See lsCompanyProfiles(2)lmSetting Up aln
        lnCompany Profilele for more information. 

    cGEmulatecA 
        Sets an emulation mode which changes the behaviour on MicroEmacs to 
        emulate another editor/program; this is done by executing a macro file 
        at start-up. An emulation macro file should contain the macro code 
        required to simulate the environment of the other editor. MicroEmacs 
        '02 is released with two emulation modes, MicroEmacs v3.8 which 
        executes macro file cGmeme3_8.emfcA (See lsCompatibility(2)lmCompatibilityle for more 
        information) and NEdit v5 which is at best a demonstration of what can 
        be achieved, this executes macro file cGmenedit.emfcA. 

    cGMS Shift RegioncA 
        Enables/disables cursor key manipulation with the shift key similar to 
        the conventional Microsoft region selection. When enabled, pressing 
        the shift key in conjunction with the cursor movement keys selects a 
        region which is hilighted. Once the region is selected then the 
        cG<DELETE>cA or cG<BACKSPACE>cA key erases the selected region. This also 
        enables a similar behaviour with the Mouse cDDrag regioncA driver, see 
        below. 


cELocale Setup cA


    cGKeyboardcA 
        Configures MicroEmacs to the user's keyboard. Accent character 
        generation keys present on foreign keyboards cannot be automatically 
        supported on Windows platforms. MicroEmacs must be informed of the 
        keyboard being used to correctly interpret the keys. If a required 
        keyboard is not supported please see lsfaq38(0f)lmFAQ38le on how to setup the 
        keyboard, also see lslocaleSupport(2)lmLocale Supportle. 

    cGLanguagecA 
        Sets the user language, this sets the word (or letter) characters and 
        if available sets up lslmspell(2)le with appropriate spelling rules and 
        dictionaries. For more information on adding support for a language 
        see lslocaleSupport(2)lmLocale Supportle. 

    cDNOTEScA 
        Earlier versions MicroEmacs had "cG(Ext)cA" languages which use extended 
        language dictionaries, vastly increasing the word list. New versions 
        automatically test for and use these dictionaries if available. 

        In earlier versions a personal dictionary name could be set in the 
        next field, this option was removed on Oct 2001. Instead a personal 
        dictionary for each language is automatically created for you, any 
        words or auto-corrected words will be added to the current languages 
        personal dictionary. The name of dictionary is "cGlsdpcAcC<lang-id>cAcG.edfcA" 
        where "cC<lang-id>cA" is the 4 letter MicroEmacs language name (e.g. 
        "cGenuscA" for American), simply rename any existing personal dictionary 
        to this new name. 

    cGAuto SpellcA 
        Enables Auto Spell Checking in file types which support this feature 
        (usually text based files such as lslmtxt(9)le or lslmnroff(9)le files etc). Auto 
        spell detects word breaks as you type and checks the spelling of every 
        completed word hilighting any erroneous words in the error color 
        scheme (usually red). The feature can be manually enabled and disabled 
        by invoking the lslmauto-spell(3)le command (usually bound to "cGf5cA"). 

    cGAuto Save DicscA 
        Enables auto-saving of any changed dictionaries on exit. If this is 
        disabled the user is prompted to save for each changed dictionary. 


cEGeneral cA


    cGFull NamecA 
        This should be set to the user's name and is used in a variety of 
        places, e.g. by lslmetfinsrt(3)le to set the "Created By" field in a 
        template. 

    cGOrganizercA 
        Sets the organizer file base name, defaults to the cDLog NamecA. When 
        notes and addresses are stored using lslmorganizer(3)le the file 
        "cC<Organizer>cAcG.eofcA" is used. 

    cGAuto-Save TimecA 
        Sets the length of time in seconds between buffer auto-saves, a 
        setting of cG0cA or an empty string disables auto-saving. The default 
        setting is 300 seconds or 5 minutes. This indirectly sets the 
        ls$auto-time(5)lmauto-time(5)le variable and the lslmautosv(2m)le global mode. 

    cGGlobal ModescA 
        Sets the initial state of the global lslmquiet(2m)le mode. This indirectly 
        executes lslmglobal-mode(2)le to set the required modes. 

    cGBuffer ModescA 
        Sets the initial state of the global modes lslmauto(2m)le, lslmbackup(2m)le, 
        lslmtab(2m)le and lslmundo(2m)le, any buffers created will inherit the state of 
        these modes. However, as changing these modes directly effects only 
        the global modes, any existing buffers (including ones re-created 
        using the cG-ccA command-line option, see lslmme(1)le) will not be effect by the 
        setting of these modes. For them to take effect, the buffers should be 
        reloaded. These modes can be changed on a per file type basis using 
        the command lslmbuffer-setup(3)le, also some file hooks override these 
        global settings, such as the lslmmakefile(9)le hook which overrides the cDtabcA 
        mode. This indirectly executes lslmglobal-mode(2)le to set the required 
        modes. 

    cGSearch ModescA 
        Sets the initial state of the global search modes lslmexact(2m)le and 
        lslmmagic(2m)le. This indirectly executes lslmglobal-mode(2)le to set the required 
        modes. 

    cGKeep Undo HistorycA 
        If this is enabled the lsundo(2)lmundole history is kept after a save allowing the 
        lslmundo(2)le command to back-up changes beyond the last save. When clear 
        the undo history is discarded after the buffer is saved. This 
        indirectly sets bit 0x8000 of the lslm$system(5)le variable. 

    cGHide BackupscA 
        Enables hiding MicroEmacs generated backup files. On Windows and Dos 
        platforms the Hidden file attribute is used to hide the file, whereas 
        on UNIX the backup file name is prepended with a 'cG.cA'. This indirectly 
        sets bit 0x100000 of the lslm$system(5)le variable. 

    cGMain MenucA 
        Enables the top main menu bar. 

    cGAlt -> Main MenucA 
        If enabled the main menu Alt hot-key bindings are enabled. These are 
        dynamic bindings automatically generated from the main menu. Typically 
        the first item in the main menu is "cGFilecA" with a hot key of 'cDFcA', with 
        this enabled 'cGA-fcA' will open this menu item. Note that global and 
        local key bindings override these. This indirectly sets bit 0x2000 of 
        the lslm$system(5)le variable. 

    cGAlt -> Esc PrefxcA 
        If enabled the Alt key acts as a lsprefix(2)lmprefix 1le modifier key. By default 
        'cGA-ncA' is not bound, with this bit set the key is inferred to 'cGesc ncA' 
        which is bound to cDforward-paragraphcA. Note that global, local and menu 
        hot-key bindings override these. This indirectly sets bit 0x4000 of 
        the lslm$system(5)le variable. 

    cGTab To IndentcA 
        Sets the lslmtab(2)le behavior in a buffer which has lslmcmode(2m)le enabled or an 
        lsindent(2)lmindentationle method. This indirectly sets bits cG0x1000cA and cG0x200000cA of 
        the lslm$system(5)le variable. 

    cGShow ModescA 
        Selects which modes are to be displayed on the mode-line whenever a 
        "cG%ecA" token is used in the lslm$mode-line(5)le variable. This indirectly sets 
        the lslm$show-modes(5)le variable. 


cEPlatform - UNIX Setup cA


    Only present on UNIX platforms using the X interface, see below for the 
    Console setup. 

    cGFontcA 
        Sets the X font name to be used. This indirectly executes 
        lslmchange-font(2)le with the given font name. e.g. 

        cG"-misc-fixed-bold-r-normal--13-*-*-*-c-70-iso8859-1"cA 

    cGDisplay Char SetcA 
        Selects the display character set being used by the system to render 
        the MicroEmacs window, dependent on the cDFontcA being used. The setting 
        of this option effects the configuration of MicroEmacs's internal 
        character maps (using command lslmset-char-mask(2)le) enabling the character 
        sets of foreign languages to be correctly supported. It also changes 
        the definition of variables lslm$box-chars(5)le and lslm$window-chars(5)le to 
        their best values for the given font. 

    cGExtend Char SetcA 
        When enabled MicroEmacs replaces the display of characters cG0x00cA to 
        cG0x1fcA with forms which are useful for variables lslm$box-chars(5)le and 
        lslm$window-chars(5)le greatly improving the look of lslmosd(2)le dialogs, the 
        scroll bars etc. 

    cGUse FontscA 
        When enabled the bold, italic, light and underline characteristics of 
        the font will be used depending on their availability and the Color 
        Scheme being used. This indirectly sets bit cG0x10cA of the lslm$system(5)le 
        variable. 

    cGDraw White SpacescA 
        Enables the drawing of visible white spaces, i.e. space, tab and 
        new-line characters. This indirectly sets bit cG0x80000cA of the 
        lslm$system(5)le variable. 

    cGClient ServercA 
        The client/server enables the file based external macro command driver 
        to be enabled - see lsClient-Server(2)lmClient-Serverle. This by default is disabled, when 
        enabled it is used by lsme(1)lmcommand-linele options cD-mcA and cD-ocA. 

    cGDOS File NamescA 
        DOS has a restricted 8.3 file naming system (i.e. "cGBBBBBBBB.XXXcA"), if 
        this option is enabled the MicroEmacs '02 will adhere to this system 
        for auto-save and backup file names whenever possible. See 
        lslm$auto-time(5)le for more information on the naming convention used. This 
        indirectly sets bit 0x400 of the lslm$system(5)le variable. 

    cG# BackupscA 
        This option only has an effect when cDDOS File NamescA is disabled. 
        Setting this to a number greater than zero enables multiple backup 
        files to be created, the number determined by this value. If set to 
        zero (or less) then only a single backup file is created. This 
        indirectly sets the lslm$kept-versions(5)le variable. 

    cGIgnore FilescA 
        Sets a list extensions of files to be ignored in file completion, e.g. 
        MicroEmacs backup files (cG~cA). This indirectly sets the lslm$file-ignore(5)le 
        variable. 

    cGCursor Blink RatecA 
        Sets the cursor blink period in millisecond. The first entry box sets 
        the cursor visible time, a setting of zero disables blinking. The 
        second box sets the hidden time. A visible time of 600 and hidden time 
        of 200 gives a reasonable blink cycle. This indirectly sets the 
        lslm$cursor-blink(5)le variable. 

    cGFence DisplaycA 
        Sets the preferred method of displaying a matching fence, a fence is 
        one of the following brackets: 

        {...}   (...)   [...] 


    Jumping to the opening fence only occurs when the closing brace is typed, 
    whereas the drawing of matching fences occurs whenever the cursor is on an 
    open fence or one character past the close fence. When this option is set 
    to "cGNever DisplaycA" the lslmbuffer-setup(3)le setting is ignored. 

    cGScroll BarscA 
        Selects the scroll bar support required. When Splitter is enabled, the 
        first character of the scroll bar and mode-line is a split character 
        used for splitting the window into two using the mouse. This 
        indirectly sets the lslm$scroll-bar(5)le variable. 

    cGHorizontal ScrollcA 
        Selects the horizontal scrolling method used with the lslmscroll-left(2)le 
        and lslmscroll-right(2)le commands. This indirectly sets the lslm$scroll(5)le 
        variable. 

    cGVertical ScrollcA 
        Selects the vertical scrolling method used with the lslmforward-line(2)le 
        and lslmbackward-line(2)le commands. This indirectly sets the lslm$scroll(5)le 
        variable. 

    cGColor SchemecA 
        Sets the color scheme setup macro file name which is executed at 
        start-up. MicroEmacs by default comes with 4 color schemes. Color 
        schemes can be created and altered using the lslmscheme-editor(3)le dialog. 


cEPlatform - UNIX Console Setup cA


    Only present on UNIX platforms when using the termcap interface, all the 
    Console platform settings are kept independent of the X interface 
    settings. 

    cGTermcap ColorcA 
        This option determines whether Termcap based colors should be used. 
        These are typically the standard eight colors and may not be supported 
        on all terminals. If this option is disabled Termcap fonts (such as 
        bold) are used instead to create a primitive hi-lighting. This 
        indirectly sets bit 0x004 of the lslm$system(5)le variable. 

    cGUse FontscA 
        See cDPlatform UNIX SetupcA above. 

    cGDisplay Char SetcA 
        See cDPlatform UNIX SetupcA above. 

    cGDraw White SpacescA 
        See cDPlatform UNIX SetupcA above. 

    cGClient ServercA 
        See cDPlatform UNIX SetupcA above. 

    cGDOS File NamescA 
        See cDPlatform UNIX SetupcA above. 

    cG# BackupscA 
        See cDPlatform UNIX SetupcA above. 

    cGIgnore FilescA 
        See cDPlatform UNIX SetupcA above. 

    cGCursor Blink RatecA 
        See cDPlatform UNIX SetupcA above. 

    cGScroll BarscA 
        See cDPlatform UNIX SetupcA above. 

    cGHorizontal ScrollcA 
        See cDPlatform UNIX SetupcA above. 

    cGVertical ScrollcA 
        See cDPlatform UNIX SetupcA above. 

    cGColor SchemecA 
        See cDPlatform UNIX SetupcA above. 


cEPlatform - Win32 Setup cA


    Only present on Microsoft Windows based machines. 

    cGFont NamecA 
        Sets the windows font name and size. This indirectly executes 
        lslmchange-font(2)le with the given font name. MicroEmacs may only use a 
        Fixed Mono Font, either an OEM font as used by the MS-DOS command 
        line, or the more conventional ANSI fonts. The fonts are selected 
        using the cDChangecA cDFontcA button which invokes a dialog to allow the 
        available fonts to be selected. True-Type mono fonts such as cGCourier 
        NewcA or cGLucida ConsolecA are typically used. 

    cGWeight & SizecA 
        Allows the size and weight of the font to be selected, specified as 
        cCweightcA, cCwidthcA and cCheightcA. The cCweightcA is typically 4, this corresponds 
        to a regular weighting, 7 is bold. cCwidthcA is the width of the font in 
        pixels, this may be 0 when the height is specified as -ve. cCheightcA is 
        the height of the font, typically a -ve value (where the cCwidthcA is 0), 
        which produces a proportionally sized font, values of in the range -11 
        .. -14 generally produce reasonably sized fonts. The cChightcA and cCwidthcA 
        may be specified as +ve values and allow explicit font dimensions to 
        be specified, generally used to achieve a precise font size 
        requirement. 

    cGUse FontscA 
        See cDPlatform UNIX SetupcA above. 

    cGDisplay Char SetcA 
        See cDPlatform UNIX SetupcA above. 

    cGExtend Char SetcA 
        See cDPlatform UNIX SetupcA above. 

    cGChoose FontcA 
        Opens a windows dialog allowing the user to select a font, the 
        selection is used to configure the above font fields. 

    cGDraw White SpacescA 
        See cDPlatform UNIX SetupcA above. 

    cGCapture Alt SpacecA 
        Used to enable/disable the capture and interpretation of the 'cGA-spacecA' 
        key sequence. If this key sequence is not captured by MicroEmacs it is 
        passed back to Windows which opens the top left window menu, allow 
        keyboard access to Window commands like Maximize. 

    cGClient ServercA 
        See cDPlatform UNIX SetupcA above. Note that on windows based systems the 
        client/server is also used by lslmmemsdev(1)le to drive the editor from the 
        Microsoft Developer environment. 

    cGDOS File NamescA 
        See cDPlatform UNIX SetupcA above. Note that some early version of Windows 
        '95 have problems with cG~cA extensions. Service release 2 fixed these 
        problems - if you experience problems then return to 8.3 filename mode 
        - note that MicroEmacs will still store longer file names, only the 
        backup naming convention changes. 

    cG# BackupscA 
        See cDPlatform UNIX SetupcA above. 

    cGIgnore FilescA 
        See cDPlatform UNIX SetupcA above. 

    cGCursor Blink RatecA 
        See cDPlatform UNIX SetupcA above. 

    cGScroll BarscA 
        See cDPlatform UNIX SetupcA above. 

    cGHorizontal ScrollcA 
        See cDPlatform UNIX SetupcA above. 

    cGVertical ScrollcA 
        See cDPlatform UNIX SetupcA above. 

    cGColor SchemecA 
        See cDPlatform UNIX SetupcA above. 


cEPlatform - Win32 Console Setup cA


    Only present on Windows NT and Win95+ platforms when using the console 
    interface, all the Console platform settings are kept independent of the 
    Window interface settings. 

    cGDisplay Char SetcA 
        See cDPlatform UNIX SetupcA above. 

    cGDraw White SpacescA 
        See cDPlatform UNIX SetupcA above. 

    cGClient ServercA 
        See cDPlatform Win32 SetupcA above. 

    cGDOS File NamescA 
        See cDPlatform Win32 SetupcA above. 

    cG# BackupscA 
        See cDPlatform UNIX SetupcA above. 

    cGIgnore FilescA 
        See cDPlatform UNIX SetupcA above. 

    cGCursor Blink RatecA 
        See cDPlatform UNIX SetupcA above. 

    cGScroll BarscA 
        See cDPlatform UNIX SetupcA above. 

    cGHorizontal ScrollcA 
        See cDPlatform UNIX SetupcA above. 

    cGVertical ScrollcA 
        See cDPlatform UNIX SetupcA above. 

    cGColor SchemecA 
        See cDPlatform UNIX SetupcA above. 


cEPlatform - DOS Setup cA


    Only present on DOS machines. 

    cGGraphic Mode #cA and cGDouble LinescA 
        Sets the DOS graphics mode number and whether the number of text lines 
        can be doubled. This indirectly executes lslmchange-font(2)le with the given 
        font name. 

    cGDisplay Char SetcA 
        See cDPlatform UNIX SetupcA above. 

    cGDraw White SpacescA 
        See cDPlatform UNIX SetupcA above. 

    cGIgnore FilescA 
        See cDPlatform UNIX SetupcA above. 

    cGCursor Blink RatecA 
        See cDPlatform UNIX SetupcA above. 

    cGScroll BarscA 
        See cDPlatform UNIX SetupcA above. 

    cGHorizontal ScrollcA 
        See cDPlatform UNIX SetupcA above. 

    cGVertical ScrollcA 
        See cDPlatform UNIX SetupcA above. 

    cGColor SchemecA 
        See cDPlatform UNIX SetupcA above. 


cEMouse cA


    The mouse device creates keys in a similar way to regular keyboard keys 
    and, like keyboard keysm they must be bound before they are used. 
    MicroEmacs '02 does not have the mouse functionality hard coded into the 
    editor, it provides a macro interface to the mouse for ultimate 
    flexibility and a set of default functionality which can be bound to the 
    mouse in a variety of ways. 

    All the mouse controlling macros are stored in cGmouse.emfcA and cGmouseosd.emfcA 
    although some buffers have local functionality over-rides, such as 
    lslmfile-browser(3)le. The user can expand the range of mouse functionality but 
    how this is achieved is beyond the scope of this documentation. 

    The cDuser-setupcA dialog allows the user to configure the mouse to use the 
    default functionality, as follows:- 

    cGEnable MousecA 
        Enables or disables the mouse, when disabled the mouse can not be used 
        and will not generate any key events. This does not apply to UNIX 
        Termcap systems as the mouse cut and paste operation is performed by 
        the Xterm. This indirectly sets bit 0x010 of the lslm$mouse(5)le variable. 

    cGNumber ButtonscA 
        Sets the number of buttons on the mouse, may be 1, 2 or 3. MicroEmacs 
        usually obtains the correct number for the system, but sometimes this 
        can be wrong. This entry can be used to correct this problem. For one 
        button mice, the button is considered to be the cGleftcA mouse button, two 
        button mice have an cGleftcA and cGrightcA button. This indirectly sets the 
        lslm$mouse(5)le variable. 

    cGSwap ButtonscA 
        If enabled then the cGleftcA and cGrightcA buttons are swapped, i.e. when the 
        left button is pressed it executes the right button bindings. This 
        indirectly sets bit 0x020 of the lslm$mouse(5)le variable. 

    cGSimulate 3 ButtonscA 
        If enabled then pressing the cGleftcA and cGrightcA buttons together with 
        generate a middle button press event, this feature is for people with 
        a 2 button mouse who want more. The two buttons must be pressed or 
        release within 10 millisecond of each other. 

    The following four fields determine which mouse button binding the user 
    wishes to view and change:- 

    cGButtoncA 
        The mouse button, cGLeftcA, cGRightcA or cGMiddlecA for the normal buttons and 
        cGWhell UpcA or cGWhell DowncA for the pilot wheel events. 

    cGShift PressedcA 
        The action of the mouse can be different for every modifier key 
        setting, if this is enabled then the binding being modified is for the 
        cDButtoncA being pressed with the cDShiftcA key held down. 

    cGControl PressedcA 
        If enabled then modifying the action when the cDButtoncA is pressed with 
        the cDControlcA key held down. 

    cGAlt PressedcA 
        If enabled then modifying the action when the cDButtoncA is pressed with 
        the cDAltcA key held down. 

    The following two fields determine the functionality of the button defined 
    by the previous four fields:- 

    cGHandle ScrollcA 
        When enabled, if the button is pressed with the mouse on the main 
        menu, a scroll bar or mode-line the standard action is performed, such 
        as opening the main menu or scrolling up or down the window etc. The 
        cDbound TocA command is only called if the mouse is in a main window. If 
        disabled, the cDBound TocA command is always called. 

    cGBound TocA 
        The function to be performed. The functions available depend on the 
        type of button being bound, the following is a list of functions 
        available for normal buttons:- 

        cGNot boundcA 
            The Button is not bound. 

        cGDrag regioncA 
            lslmset-mark(2)le is called at the pick location, until the button is 
            dropped, the area of text between this point and the current mouse 
            position is hi-lighted. When the mouse button is dropped, if the 
            drop position is the same as the pick then the double click is 
            tested for, if a double click is entered then the cDSelect WordcA 
            function is executed, otherwise the cursor is simply moved to the 
            drop position. If the pick and drop position are different then 
            the enclosed text is copied to the kill buffer using 
            lslmcopy-region(2)le. Note this behaviour is altered by the setting of 
            cDMS Shift RegioncA on the cDStart-UpcA page. 

        cGSelect WordcA 
            Also executed from a double click bound to cDDrag RegioncA, cDSelect 
            WordcA copies the word under the mouse into the kill buffer using 
            lslmcopy-region(2)le, unless a double click is entered in which case the 
            whole line is copied. 

        cGDefault PancA 
            While the mouse button is pressed the current buffer pans with any 
            mouse movement. 

        cGMS PancA 
            MicroSoft style Pan; while the mouse button is pressed the current 
            buffer pans vertically according to the mouse position relative to 
            the point where the button was pressed. 

        cGFind TagcA 
            Executes lslmfind-tag(2)le with the word currently under the mouse. 

        cGFind ME HelpcA 
            Executes lslmhelp-item(2)le with the word currently under the mouse. 

        cGUndocA 
            Simply executes lslmundo(2)le without moving the cursor to the position 
            of the mouse. Subsequent calls to this binding will undo multiple 
            edits. 

        cGNo move yankcA 
            Simply executes lslmyank(2)le without moving the cursor to the position 
            of the mouse. 

        cGReplace yankcA 
            Simplar to "cGNo move yankcA" except when the is a current region 
            (typically defined by "cGDrag regioncA" above), in which case the 
            region is first deleted. 

        cGMove to yankcA 
            Moves the cursor to the current position of the mouse and executes 
            lslmyank(2)le. 

        cGReyankcA 
            Executes lslmreyank(2)le without moving the cursor. Note, to enable this 
            functionality some sanity checks have had to be removed, as a 
            result it should not be misused as seeming bizarre things can 
            occur. 

        cGFold currentcA 
            Toggles the fold status of the current block, only applicable in 
            buffers supporting lslmfold-current(3)le, such as c and emf files. 

        cGFold allcA 
            Toggles the fold status of the whole buffer, opening or closing 
            all found blocks. Only applicable in buffers supporting 
            lslmfold-all(3)le, such as c and emf files. 

        cGMain menucA 
            Simply opens the main menu from any where on the screen. 

        cGMulti-MenucA 
            Opens a context sensitive menu dependent on the position of the 
            mouse, i.e. opens the main menu if over it, opens a different menu 
            when executed on the mode-line etc. 

        The following is a list of functions available for pilot wheel 
        events:- 

        cGNot boundcA 
            The Button is not bound. 

        cGScroll Up 1 LinecA .... 
            Scrolls the current buffer by the specified amount. 

    cGDefaultscA 
        Rests the mouse configuration to the default settings. 


cEFile Types cA


    The file type list is used in two places, the main menu's cGFile => Quick 
    OpencA sub-menu list and the cGFile => Open => File TypecA list. In each case 
    the file type "cGAll FilescA" is automatically added. The user can add, remove 
    and change the list of file types by using this dialog. An entry can be 
    selected for editing or deletion by simply selecting it with the left 
    mouse button. A new entry may be added by simply filling in the 3 entry 
    boxes and selecting Add. Items in the Dialog are as follows. 

    cGNo.cA 
        The file type entry number. A new entry is always added to the end of 
        the list, ignoring this value. The position of an existing entry can 
        be changed by altering this field to the desired position and 
        selecting the cGChangecA button to move it to its new position. 

    cGNamecA 
        The file type name, the string printed in the sub-menus. 

    cGFile Mask ListcA 
        A comma ('cG,cA') separated list of file masks which match the file type, 
        e.g. for C and C++ source files use "cG*.c,*.cc,*.cppcA". 

    cGAddcA 
        Adds a new entry to the list, only the cDNamecA and cDFileMask ListcA fields 
        are used, the cDNo.cA field is ignored as the new entry is always added to 
        the end of the list. The position can be altered by using the cDChangecA 
        button. 

    cGChangecA 
        Alters an existing file type entry, all 3 fields must be set. 

    cGDeletecA 
        Deletes the current entry number, only the cDNo.cA entry is used. 


cETools cA


    The Tools dialog allows the user to configure up to 10 system commands, or 
    tools, which can be executed via MicroEmacs Main Tools Menu. The dialog 
    configures the user's registry for the command lslmexecute-tool(3)le to be used. 
    The execution of a tool can also be bound to a key, see cDexecute-toolcA for 
    more information. 

    The top half of the dialog consists of the 10 Tools (cG0cA-cG9cA) configuration 
    buttons. Selecting one of these selects the current tool to be configured, 
    the current tool is shown by the title in the middle of the dialog. 

    The lower half of the dialog configures the currently selected tool, as 
    follows:- 

    cGTool NamecA 
        Sets the displayed name of the tool. The tool name is used in the 
        buttons in the top half of this dialog and in the MicroEmacs Main 
        Tools Menu. 

    cGTool Command LinecA 
        Sets the system command-line to be launched whenever the tool is 
        executed, the following special tokens may be used in the command-line 
        which are substituted at execution:- 

        cD%ffcA 
            The current buffer's full file name, including the path. 

        cD%fpcA 
            The current buffer's file path. 

        cD%fncA 
            The current buffer's file name without the path. 

        cD%fbcA 
            The current buffer's file base name, i.e. the file name without 
            the path or the extension. 

        cD%fecA 
            The current buffer's file extension with the 'cC.cA' (e.g. "cC.emfcA"), 
            set to the empty string if the file name does not have an 
            extension. 

        Note that "cD%ffcA" is always the same as "cD%fp%fncA" and "cD%fp%fb%fecA". If any 
        of these tokens are used, the tool will fail to execute if the current 
        buffer does not have a file name. 

    cGSave Current BuffercA and cGPromptcA 
        If the current buffer has been edited, enabling cGSave Current BuffercA 
        will automatically save the current buffer before executing the tool. 
        This is particularly useful when the tool operates on the current 
        buffer's file (e.g. compiles the file). If cGPromptcA is also enabled the 
        user will be prompted before the file is saved. 

    cGSave All BufferscA and cGPromptcA 
        If cGSave All BufferscA is enabled, all edited buffers will be 
        automatically saved before executing the tool. This is particularly 
        useful when the tool may operate on multiple files (e.g. compilation 
        of a project). If cGPromptcA is also enabled the user will be prompted 
        before each file is saved. 

    cGCapture OutputcA 
        If enabled any output produced from the execution of the tool will be 
        captured and inserted into a new buffer. When enabled the following 
        two items, cGBuffercA and cGHidecA, may be specified. When disabled the 
        command used to execute the tool is lslmshell-command(2)le, otherwise the 
        command used is either lslmpipe-shell-command(2)le or lslmipipe-shell-command(2)le 
        depending on the setting of cGRun ConcurrentlycA. 

    cGBuffercA 
        Specifies the buffer name the captured output should be dumped to, 
        this option is only visible when cGCapture OutputcA is enabled. The 
        following special tokens may be used in the buffer name which are 
        substituted at execution:- 

        cD%fncA 
            The current buffer's file name without the path, set to the buffer 
            name if the current buffer does not have a file name. 

        cD%fbcA 
            The current buffer's file base name, i.e. the file name without 
            the path or the extension. Set to the buffer name if the current 
            buffer does not have a file name. 

        cD%fecA 
            The current buffer's file extension with the 'cC.cA' (e.g. "cC.emfcA"), 
            set to the empty string if the current buffer does not have a file 
            name or it does not have an extension. 
        Note that "cD%fncA" is always the same as "cD%fb%fecA". Default buffer name 
        when this field is left empty is "cC*command*cA", or "cC*icommand*cA" if cGRun 
        ConcurrentlycA is enabled. 

    cGHidecA 
        When enabled the tool output capture buffer is hidden, this option is 
        only visible when cGCapture OutputcA is enabled. 

    cGRun ConcurrentlycA 
        If enabled, when the tool is executed the command is launched and run 
        concurrently, allowing the user to continue working in MicroEmacs 
        during the tools execution. This option is not available for all 
        versions on MicroEmacs and forces the output to be captured. Enabling 
        this option will force the use of command lslmipipe-shell-command(2)le to 
        launch the tool. 


cEE-Mail cA


    MicroEmacs '02 provides a simple E-Mail manager, see lslmvm(3)le for more 
    information and example entries. It must be stressed that cDvmcA has only been 
    tested in one environment, caution should be used as system differences 
    may cause problems, such as loss of data, which the author does not except 
    any responsibility for. 

    The cDE-Mail SetupcA dialog configures a user to use part or all of the cDvmcA 
    E-Mail manager, as follows:- 


cEPlatform ALL Mail Setup cA


    The following field is used for both sending and receiving mail: 

    cGUser Mail DircA 
        Sets the user mail-box directory where all files are to be found and 
        stored (except usually the cDIncoming Mail boxcA). The value of this field 
        is platform independent and must be setup for each one. 

    The following fields are used for sending mail: 

    cGSend Mail SignaturecA 
        Sets the signature file name which is inserted at the bottom of every 
        out-going email message, if empty the no signature is inserted. The 
        value of this field is platform independent, is value use by all. The 
        file must be located in the cDUser Mail DircA and no path entered for it 
        to work across platforms. 

    cGCarbon-Copy FilecA 
        Sets the sent-mail carbon-copy file, creating the "cGFcc:cA" line of the 
        mail buffer. All out-going emails are appended to the end of this file 
        if the "cGFcc:cA" line is not altered. If this field is left empty then no 
        "cGFcc:cA" line is created. The value of this field is platform 
        independent, the file must be located in the cDUser Mail DircA. 

    cGInsert Data (^C^I)cA 
        Sets the first embedded data command line, bound to "cGC-c C-IcA". The 
        value of this field is platform dependent. 

    cGInsert Data (^C^Z)cA 
        Sets the second embedded data command line, bound to "cGC-c C-zcA". The 
        value of this field is platform dependent. 

    cGSend Mail CommandcA 
        Sets the command-line used for sending email messages. The value of 
        this field is platform dependent. 

    The following fields are used for receiving mail: 

    cGCheck for mailcA 
        Sets the time interval between the automatic checking for incoming 
        mail in seconds, when set to 0 the automatic checking is disabled. 
        When enabled, the check is performed by lslmmail-check(3)le which also sends 
        any queued mail and gets any new mail if the cDGet Mail CommandcA is used. 
        The value of this field is platform dependent. 

    cGGet Mail CommandcA 
        The command used to get new mail from the server, if empty it is 
        assumed the cDIncoming Mail BoxcA is automatically updated by the system. 
        If used the command must append new mail to the end of the cDIncoming 
        Mail BoxcA specified below. The value of this field is platform 
        dependent. 

    cGIncoming Mail BoxcA 
        Sets the incoming mail box file which new incoming mail is appended 
        to, either automatically by the system or by the cDGet Mail CommandcA. The 
        value of this field is platform dependent. 

    cGVM Main In BoxcA 
        Sets the main current mail box, or inbox. The value of this field is 
        platform independent, the file must be located in the cDUser Mail DircA. 

    cGVM Gets MailcA 
        When enabled, executing the command vm will not only create the mail 
        box windows, it will also get and process any new mail. When disabled 
        only the vm 'cGgcA' command can be used to get and process new mail. 

    cGMime Data ExtractcA 
        Sets the command-line used for extracting Mime encoded embedded data. 
        The value of this field is platform dependent. 

    cGUuencode ExtractcA 
        Sets the command-line used for extracting Uuencoded embedded data. The 
        value of this field is platform dependent. 

    cGAuto-Archive SetupcA 
        Sets up the auto-archive of messages in the current inbox to other 
        mail boxes. 


cEcENOTES cEcA


    cDuser-setupcA is a macro using lslmosd(2)le, defined in cGuserstp.emfcA. 


cEcESEE ALSO cEcA


    lsUserProfiles(2)lmUser Profilesle, lsCompanyProfiles(2)lmCompany Profilesle, lsInstallation(1)lmInstallationle, lslmbuffer-setup(3)le, 
    lslmscheme-editor(3)le. 

! 3 organizer
cEcENAME cEcA


    organizer - Calendar and address organizer 
$a


cEcESYNOPSIS cEcA


    cDorganizercA 


cEcEDESCRIPTION cEcA


    cDorganizercA is a calendar and address organizer, enabling notes to be stored 
    against the calendar days; addresses may be archived into an address book. 

    cDorganizercA uses the MicroEmacs '02 in-built registry to store information 
    within a registry file called cC<username>cAcG.eofcA. cDorganizercA may be entered 
    directly from the command line, or via the menu (via cDToolscA). 

    cDorganizercA is displayed within a single osd dialog box, tab selections at 
    the top of the window enable the different forms of information to be 
    displayed. Navigation is typically performed using the mouse, where the 
    mouse is absent then the cGTABcA key may be used to move between the fields. 
    The information presented is defined as follows:- 


cEMonth cA


    Shows the calendar month, starting with the current month, the current day 
    is hi-lighted and any notes that have been entered are displayed in the 
    cDNotescA entry box at the bottom of the page. 

    The default mode of operation is note entries for the current month, 
    however specifying the cC<year>cA as the wild card 'cD*cA' (star) enables annual 
    events to be entered into the organizer. Annual events are automatically 
    inserted into the calendar each year, typically used for birthdays etc. 

    The entry controls to the dialog are defined as follows:- 

    cD<-cA 
        Advances to the previous month. 

    cD->cA 
        Advances to the next month. 

    cC<Month>cA 
        A pull down dialog enabling month selection. 

    cC<year>cA 
        A text entry field specifying the current year as a 4 digit number. A 
        value of cD*cA is the wild card year for specifying annual events. 

    cDNotescA 
        A free form text entry box allowing a note to be attached to the 
        currently selected day. 

    cDSavecA 
        Saves the entry back to file. 

    cDMonth To BuffercA 
        Dumps a view of the month to the currently active buffer, any notes 
        are also dumped to the buffer. 

    cDExitcA 
        Exits the cDorganizercA. 


cEWeek cA


    Shows the calendar week in the current buffer, the days of the week are 
    shown in a column ordering. Note that selection of the week is typically 
    performed from the cDMonthcA view, moving to the cDWeekcA view (via the tab) 
    selects the week appropriate to the previously selected day within the 
    month view. 

    The entry controls on the dialog are defined as follows:- 

    cD<-cA 
        Advances to the previous week. 

    cD->cA 
        Advances to the next week. 

    cC<year>cA 
        A text entry field specifying the current year as a 4 digit number. 
        The value of cD*cA for viewing and setting annual events is not valid in 
        this view. 

    cDNotescA 
        A free form text entry box allowing a note to be attached to the 
        currently selected day. 

    cC<day>cA 
        Selecting a date in the cCdaycA column changes the view to the cDDaycA view. 

    cDSavecA 
        Saves the entry back to file. 

    cDWeek To BuffercA 
        Dumps a view of the week to the currently active buffer, any notes are 
        also dumped to the buffer. 

    cDExitcA 
        Exits the cDorganizercA. 

    cDNote:cA The start day in the week view may be configured to commence on a 
    day other than Sunday from the cDSetupcA tab. 


cEDay cA


    Shows an extended view of the notes attached to the current day, day 
    selection is typically performed from the cDMonthcA or cDWeekcA views. The entry 
    controls on the dialog are defined as follows:- 

    cD<-cA 
        Advances to the previous day. 

    cD->cA 
        Advances to the next day. 

    cC<year>cA 
        A text entry field specifying the current year as a 4 digit number. A 
        value of cD*cA is the wild card year for specifying annual events. 

    cC<month>cA 
        A pull down dialog enabling month selection. 

    cC<day>cA 
        A text entry enabling the current day to be entered. 

    cDNotescA 
        A free form text entry box allowing a note to be attached to the 
        currently selected day. 

    cDSavecA 
        Saves the entry back to file. 

    cDDay To BuffercA 
        Dumps a view of the day to the currently active buffer, any notes are 
        printed in the buffer. 

    cDExitcA 
        Exits the cDorganizercA. 


cELists cA


    The lists pane provides support for multiple list generation and 
    manipulation. Each list consists of zero or more ordered items each of 
    which has a text field in which the user can enter information. 

    Entry to the dialog is defined as follows:- 

    cDListcA 
        Selects a list. 

    cDNewcA 
        Creates a new list. 

    cDLines Per ItemcA 
        Sets the number of lines to use when displaying a list item. 

    cDNewcA 
        Creates a new list item at the end of the current list. 

    cDUpcA 
        Moves the currently selected item (left click on the item number) up 
        the list. 

    cDDowncA 
        Moves the currently selected item down the list. 

    cDInsertcA 
        Inserts a new list item before the currently selected item. 

    cDDeletecA 
        Deletes the currently selected item. 

    cDSavecA 
        Saves the entry back to file. 

    cDList To BuffercA 
        Dumps a view of the list to the currently active buffer. 

    cDExitcA 
        Exits the cDorganizercA. 


cEAddress cA


    The address pane provides entry to the address book, enabling personal and 
    business details to be retained against a single name, tabbed selection of 
    cDWorkcA or cDHomecA selects the information that is displayed. A search engine is 
    provide to locate names within the database, and provision is made to save 
    some text against a name. Entries in the database are, by default, 
    organized by record number, sorting may be explicitly performed from the 
    cDSortcA button. 

    Entry to the dialog is defined as follows:- 

    cC<Record No>cA 
        The identity number of the record, a value of cD*cA denotes that this is a 
        new record that is being inserted. 

    cD<<cA 
        Moves to the start of the database. 

    cD>>cA 
        Moves to the end of the database, showing record cD*cA, a new entry may be 
        entered. 

    cD<cA 
        Moves to the previous record. 

    cD>cA 
        Moves to the next record. 

    cDNamecA 
        The name of the individual, entered as cCfore-namecA and cCsurnamecA. 

    cDNicknamecA 
        A pseudo name assigned to an individual. 

    cDPartnercA 
        Shown in the cDHomecA view only. The cCforenamecA and cCsurnamecA of any partner. 

    cDChldcA 
        Shown in the cDHomecA view only in the cDExtended Address Book ModecA. The 
        names of any children (up to 3). 

    cDDOBcA 
        Date of Birth, shown in the cDHomecA view only in the cDExtended AddresscA 
        cDBook ModecA. The dates of birth of the parents, any children in addition 
        to an anniversary date. 

    cDCompanycA 
        Shown in the cDWorkcA view only. The name of the company. 

    cDAddresscA 
        The address of the individual/company. 

    cDTelcA/cDFaxcA/cDMobilecA 
        Telecommunication information. 

    cDEmailcA/cDWWWcA/cDFTPcA 
        Electronic communication information. 

    cDNotescA 
        Notes associated with the individual. 

    cDSavecA 
        Saves the address information to file. 

    cDDupcA 
        Duplicates the currently selected address entry, creating a new record 
        card. Typically used to construct a similar entry for a different 
        individual. 

    cDDeletecA 
        Deletes the currently selected entry. 

    cDAddr to BuffercA 
        Dumps the currently selected address to the current buffer. 

    cDExitcA 
        Exits the organizer. 

    cDFindcA 
        cDfindcA provides access to a search engine, enabling addresses to be 
        located in the address book. 

        cDSearch ForcA 
            The string to search for. 

        cDIn FieldcA 
            Pull-down menu allowing the selection of the field to be searched 
            in. 

        cDMatchcA 
            Selects how strict the search should be; typically cDAny PartcA is 
            used as this is the least in-exact search. The default mode is 
            configured in the cDSetupcA tab. 

        cDCasecA/cDmagiccA 
            Selects the search criteria. The default mode is configured in the 
            cDSetupcA tab. 

        cDFirstcA 
            Finds the first record that matches the search criteria 

        cDNextcA 
            Finds the next record that matches the search criteria, from the 
            currently displayed record. 

        cDReversecA 
            Searches in reverse order. 

        cDExitcA 
            Exits the search 

    cDSortcA 
        cDsortcA provides a mechanism to re-sort the data base into a different 
        order. The sort is performed on up to 3 different keys enabling 
        conflicting primary sort fields to be resolved by the secondary sort 
        criteria. The default sort order is cC<Record No>cA, cC<None>cA, cC<None>cA. 

        cDSort KeyscA 
            The cCPrimarycA, cCSecondarycA and cCTertiarycA sort fields are selected by a 
            pull down menu. The fields to be used for sorting are selected 
            from the list. 

        cDSortcA 
            Performs the sort, based on the settings of the cCSort KeyscA. 

        cDExitcA 
            Exits the sort dialog. 


cESetup cA


    The cDsetupcA pane configures a number of general settings of the organizer. 

    cDCurrent Organizer FilecA 
        The full pathname of the organizer file. By default this is set to 
        cC<userpath><userName>cAcD.eofcA and can be altered using lslmuser-setup(3)le. 

    cDChange NamecA 
        Allows the displayed name of the month and the day to be modified. 

    cDFirst Day of the weekcA 
        Selects the first day of the week, this sets the first day to be 
        displayed in the cDWeekcA view and the first column in the cDMonthcA view. 

    cDMin New Year DayscA 
        The number of days that must appear in the first week of the New Year 
        for the week to be considered week 1. Modifying the value of this 
        field modifies the week number. 

    The cDCalendarcA section allows the wordy representation of the calendar date 
    to be modified. Typically used to modify the names to the native language. 

    cDChange Month NamecA 
        Select the existing month representation from the left-hand box and 
        type in a new selection into the right-hand box. 

    cDChange Week Day NamecA 
        As cCChange Month NamecA, enables the day of the week representation to be 
        modified. 

    cDFirst Day Of The WeekcA 
        Selects the first day that appears in the cDWeekcA view. 

    cDMinimum Days of New Year in first weekcA 
        Specifies the number of days that must appear in the first week of the 
        New Year for the week to be designated as week 1. This value allows 
        the week number to be aligned with the calender weeks of standard 
        diaries. The default value is 7 days; but may be reduced to 5 or 6 for 
        typical alignment. 

    The cDAddress BookcA section allows the operation of the address book to be 
    modified. 

    cDUse Extended Address BookcA 
        The extended address book allows additional information to be added to 
        the personal address book. The extended information is limited to the 
        amount of personal information attributed to an individual, including 
        cCDate of BirthcA and cCChildcA information. 

    cDImport From FilecA 
        The cDImportcA from file allows the address book to be imported from a 
        file. The import data format is a single line per entry, comma cG,cA 
        separated. The field order is defined as follows, the cD*cA entries 
        indicate the cDExtendedcA cDAddresscA cDBookcA fields:- 

            cCRecord NocA, cCFirst NamecA, cCSurnamecA, cCNick NamecA, cCSelectedcA, cCNotescA, 
            cCPartner First NamecA, cCPartner SurnamecA, cCHome AddresscA, cCHome TelephonecA, 
            cCHome FaxcA, cCHome MobilecA, cCHome E-MailcA, cCHome WWW PagecA, cCHome FTP SitecA, 
            cCWork CompanycA, cCWork AddresscA, cCWork TelephonecA, cCWork FaxcA, cCWork MobilecA, 
            cCWork E-MailcA, cCWork WWW PagecA, cCWork FTP SitecA, cCDate-Of-Birth*cA, cCPartner 
            DOB*cA, cCDate-Of-Marriage*cA, cCChild1 Name*cA, cCChild1 DOB*cA, cCChild2 Name*cA, 
            cCChild2 DOB*cA, cCChild3 Name*cA, cCChild3 DOB*cA. 

    cDExport To FilecA 
        Exports the address book to a file, the address book is exported in 
        the current sort order, with the fields defined as above. The exported 
        address book may then be imported into a 3rd party package i.e. 
        Microsoft Access, etc. 

    The cDDefault Address Find SettingscA section defines the default search 
    criteria used in the address book search function. 

    cDWholecA/cDStartcA/cDAny PartcA 
        Radio buttons determine how the search is performed on the string. 

                * cDWholecA matches the whole string exactly. 
                * cDStartcA matches the first part of the string only (i.e. cGAb*cA). 
                * cDAny PartcA finds entries that include the search string at any 
                  position within the data base search field. 

    cDCase InsensitivecA 
        Checked, matches the strings regardless of case. (default). 

    cDMagic ModecA 
        Allows magic strings to be included in the search string. 


cEcENOTES cEcA


    cDorganizercA is a macro that is implemented in cGorganiz*.emfcA files. Organizer 
    uses lslmosd(2)le to create and manage the dialogs. 

    The maximum size of a text note is 1024 characters. 

    With an new address is created it is added to the end of the address list 
    regardless of the current sort criteria. 

    cDOrganizercA replaces the original cDCalendarcA utility. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmosd(2)le. 

! 3 spell-buffer
! 3 spell-word
! 3 spell-edit-word
! 3 find-word
cEcENAME cEcA


|spell-buffer
    spell-buffer - Spell check the current buffer 
|spell-word
    spell-word - Spell check a single word 
|spell-edit-word
    spell-edit-word - Edits a spell word entry 
|find-word
    find-word - Find a using spelling dictionaries 
$a


cEcESYNOPSIS cEcA


    cDspell-buffercA 
    cCncA cDspell-wordcA ["cCwordcA"] (cDesc $cA) 
    cDspell-edit-wordcA ["cCwordcA"] 
    cDfind-wordcA ["cCwordcA"] 


cEcEDESCRIPTION cEcA


    MicroEmacs '02 provides an integrated spell checker with the following 
    features:- 

        * Different languages. 
        * Dialog control of the speller. 
        * Best guess capability. 
        * cCReplacecA and cCReplace allcA, cCIgnorecA and cCIgnore AllcA 
        * Undo capability. 
        * Adding new words and endings to speller. 
        * Auto correct of commonly occurring mistakes. 
        * Word finder, allows words to be searched with wild cards. 

    cDspell-buffercA spell checks the current buffer, from the current position, 
    to the end of the buffer. On invocation, an lslmosd(2)le dialog is opened and 
    any corrections are made through this interface. If an error dialog opens 
    instead the current language is not setup, please see the Language setting 
    in lslmuser-setup(3)le and lslocaleSupport(2)lmLocale Supportle. 

    The dialog provides the user with an interface from which a new spelling 
    may be selected, in addition new words may be added to the spelling 
    dictionary. The dialog entries are defined as follows:- 

    cDWordcA 
        The cDwordcA entry contains the erroneous word, this is presented in a 
        text dialog box which may be manually edited to correct. If the word 
        is manually corrected, then it is spell checked prior to insertion, 
        and a new guess list is created. The user may elect to replace the 
        word, take one of the suggestions or re-edit the misspelled word. 

    cDMeaningcA 
        The meaning button provides a convenient interface to lslmdescribe-word(3)le 
        for looking up the meaning of the current word. The cDInsertcA button 
        within the describe-word dialog will replace the current word in the 
        spell-buffer. 

    cDSuggestionscA 
        The suggestions entry contains a list of suggestions as to the correct 
        spelling of the word. The list is ranked in order of the best match, 
        typically the misspelled word appears at (or near) the top of the 
        list, unless the word is unknown or there are gross errors in the 
        spelling. Selecting the word in the list with a single click of the 
        mouse selects the word as the replacement, the actual replacement is 
        performed by the cDReplacecA or cDReplace AllcA buttons. Alternatively, double 
        selecting a guess word replaces the word. 

    cDLanguagecA 
        The cDlanguagecA entry allows the user to select the current spelling 
        language. The new language is chosen from the dialog box. The language 
        may be changed at any time during the spell operation and is effective 
        immediately. The cDExtcA languages are extended dictionaries that contain 
        additional words, it is recommended that all spelling is performed 
        with the extended dictionaries (where available). 

    cDReplacecA 
        The cDreplacecA button is activated when a new word has been edited or 
        selected as a candidate for replacement. Selecting cDreplacecA modifies 
        the erroneous word in the buffer with the newly selected word. 

    cDReplace AllcA 
        The cDReplace AllcA button is similar to the cDReplacecA button, except that 
        it automatically replaces any subsequent occurrences of the erroneous 
        word with the newly selected word. The replacement words are retained 
        for the MicroEmacs edit session and are lost when the editor is 
        closed. 

    cDIgnorecA 
        The cDignorecA button requests that the speller ignore the erroneous word 
        and continue to spell the buffer. 

    cDIgnore AllcA 
        The cDIgnore AllcA button is similar to the cDIngorecA button, except that it 
        automatically ignores the erroneous word thereafter. The ignore words 
        are retained for the MicroEmacs edit session and are lost when the 
        editor is closed. 

    cDAddcA 
        cDAddcA adds the current erroneous word to the dictionary, thereafter the 
        word is recognized as a valid word. cDAddcA should only be used for words 
        which have no derivatives, it is generally better to add a new word 
        through the cDEditcA interface where a new cCbasecA word may be specified with 
        it's derivatives. 

    cDEditcA 
        The cDEditcA button executes cDspell-edit-wordcA giving the current erroneous 
        word. This allows new words and auto-corrections to be defined as well 
        as existing words to be altered, see full description below. 

    cDFindcA 
        The cDFindcA button executes cDfind-wordcA giving the current word as a 
        starting seed. This allows the user to search for the word using a 
        simple search criteria, see full description below. 

    cDUndo LastcA 
        The cDundo LastcA button restores the user to the previous spelling so 
        that it may be re-entered, any replacement text that was made is 
        restored to it's original spelling. 

    cDExitcA 
        Exits the speller and returns the user to the buffer. 

    cDspell-wordcA checks a single word which is either supplied by the user, or 
    if an argument is given, the word under (or to the left of) the cursor 
    position. If the word is correct, a simple message-line print-out is 
    given, otherwise the main spell cDosdcA dialog is opened and the user may 
    check the spelling within the context of the spell dialog as described 
    above. 

    The default key binding of "cGesc $cA" supplies an argument forcing cDspell-wordcA 
    to check the current buffer word. cDspell-wordcA is often used to check the 
    spelling of a word outside of the context of the editor (i.e. when working 
    on paper, or when doing at that prize crossword !!). 

    cDspell-edit-wordcA allows words in dictionaries to be altered as well as new 
    words and auto-corrections to be defined. On invocation, an cDosdcA dialog is 
    opened and changes are made through this interface, defined as follows:- 

    cDWordcA 
        The cDwordcA entry to be changed or added. If cDspell-edit-wordcA was executed 
        via spell-buffer cDEditcA button, this will be set to the current word. 

    cDNo word setcA 
        The word entry is empty, most of the functionallity will not be 
        available until a word is entered. 

    cDNew WordcA 
        To add a new word, the derivatives of the new word should be selected 
        using the prefix and suffix options. Note that not all derivatives are 
        listed, only one example derivative of each lsadd-spell-rule(2)lmspell rulele is given. 

        cDBE CAREFUL WITH THE CASE OF THE BASE WORD:cA new words that are entered 
        are case sensitive, as a general rule the cCwordcA in the cDWordcA text box 
        should be edited to it's base form and should be presented in lower 
        case characters (unless it is a proper name, in which case it should 
        be capitalized, or is an abbreviation or acronym when it might be 
        upper case). 

        When the appropriate derivatives of the new word have been selected, 
        it may be added to the dictionary using the cDAddcA button. This adds the 
        word to the users personal dictionary. Please note that if there are 
        numerous standard words missing then check that an cCextendedcA dictionary 
        (designated by cDExtcA in the language) is being used, the extended 
        dictionaries more than double the repertoire of words available. 

        Words added to the dictionary may be subsequently removed using the 
        cDDeletecA button, typing the existing word in the cDWordcA entry and 
        selecting cDDeletecA button removes the existing word. 

    cDAuto-CorrectcA 
        Selection of the cDAuto-CorrectcA button allows a replacement word to be 
        entered in the cDTocA text entry. Selecting cDAddcA adds the automatic 
        correction to the speller. Thereafter, whenever the erroneous word is 
        encountered the replacement word is always used to replace it, without 
        user intervention. 

        Entering an exiting cCauto-correctcA word into the dialog and selecting 
        cDDeletecA removes an existing auto-correct entry. 

    cDExitcA 
        Exits the cDEditcA dialog. 

    cDfind-wordcA opens the word finder dialog. This allows the user to search for 
    a word using a simple search criteria. (This is ideal for cheating at 
    crosswords !!). The word to be searched for is entered into the cDWordcA cDMaskcA 
    and may use wild cards cD*cA to represent any number of characters, cD?cA to 
    represent an unknown character and cD[cA..cD]cA for a range of characters. 

    For example, searching for cGt?e?ecA presents the list cCthemecA, cCtherecA and cCthesecA. 
    Searching for cGt*ncA lists all of the words beginning with cGtcA and ending in cGncA. 
    See lslm$find-words(5)le for a full discription of the format used by search 
    engine. 

    The words that match are returned in the scrolling dialog, and may be 
    selected with the mouse (or cursor keys). The cDInsertcA button inserts the 
    selected word into the current buffer or into the cDWordcA entry if executed 
    from the cDspell-buffercA dialog. Note that the list presented is limited to 
    200 words, selecting cDnextcA gets the next 200 words, and so on. The cDExitcA 
    button exits the dialog. 


cEcENOTES cEcA


    The words added to the speller during a MicroEmacs session are saved when 
    the editor is closed. The user is prompted to save the dictionary, if the 
    dictionary is not saved then any words added are lost. 

    All cCignorecA words accumulated during a spell session are lost when the 
    editor is closed. In order to retain cCignorecA words, it is suggested that 
    they are added to the personal dictionary rather than be ignored. 

    The personal spelling dictionary is typically called cC<user>cAcC<type>cA.edf, and 
    is stored in the default user location. The dictionary names are specified 
    in the lslmuser-setup(3)le dialog. 

    cDfind-wordcA may claim to have found more words than are actually listed. The 
    use of derivatives in the spell algorithm allows a single word to be 
    present several times. cDfind-wordcA counts each occurrence but it is only 
    listed once. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslocaleSupport(2)lmLocale Supportle, lslmosd(2)le, lslmspell(2)le, lslmdescribe-word(3)le, 
    lslm$find-words(5)le. 

! 3 symbol
cEcENAME cEcA


    symbol - Insert an ASCII character 
$a


cEcESYNOPSIS cEcA


    cDsymbolcA 


cEcEDESCRIPTION cEcA


    cDsymbolcA draws the ASCII character table to the screen, displaying decimal, 
    hexadecimal and character notations in a tabular form. A character is 
    selected using the mouse or cursor characters inserting the selected 
    character into the current buffer at the current position. 


cEcENOTES cEcA


    cDsymbolcA is a macro defined in cGmisc.emfcA. 

    The dialog is created using lslmosd(2)le. 


cEcESEE ALSO cEcA


    lslminsert-string(2)le, lslm&atoi(4)le, lslmosd(2)le. 

! 3 line-scheme-search
cEcENAME cEcA


    line-scheme-search - Search and annotate the current buffer 
$a


cEcESYNOPSIS cEcA


    cDline-scheme-searchcA 


cEcEDESCRIPTION cEcA


    cDline-scheme-searchcA provides a method of searching for text patterns within 
    the current buffer and annotating any matches through colored line 
    hilighting. A selection of line colors are provided to allow different 
    search patterns to be assigned their own color. 

    cDline-scheme-searchcA is generally used for annotating log files and alike, 
    where indevidual lines are of interest in addition to the context about 
    that line. The hilighting draws attention to the line, by providing a 
    visual cue, allowing the contents of the file to be breifly scanned. 

    On invocation of cDline-scheme-searchcA a lslmosd(2)le dialog is presented to the 
    user, search patterns and their associated hilighting assignment are 
    selected through this interface. The dialog entries are defined as 
    follows:- 

    cDSearch forcA 
        The text dialog entry box allows the search pattern to be entered. 
        This may be a regular expression or plain text. 

    cDColorcA 
        The cDColorcA allows the line hilighting color scheme to be selected from 
        a pop-up menu. The color cDRemovecA is special and allows previously 
        applied line hilighting to be removed. 

    cDCase SensitivecA 
        A check box that allows the search to be case sensitive or 
        insensitive. This modifies the lslmexact(2m)le mode. 

    cDMagic ModecA 
        A check box that enables/disables regular expression pattern matching. 
        This modifies the lslmmagic(2m)le mode. 

    cDBelowcA 
        Searches and hilights lines matching the search pattern from the 
        current cursor position to the end of the buffer. 

    cDAbovecA 
        Searches and hilights lines matching the search pattern from the 
        current cursor position to the top of the buffer. 

    cDAllcA 
        Searches and hilights lines matching the search pattern for the whole 
        buffer. 

    cDClear AllcA 
        Removes all line hilighting from the current buffer. 

    cDFirstcA 
        Moves to the top of the buffer and hilights the first line that 
        matches the search pattern. 

    cDNextcA 
        Hilights the next line that matches the search pattern. 

    cDReversecA 
        Hilights the previous line that matches the search pattern. 

    cDExitcA 
        Exits the hilighting search dialog. 


cEcENOTES cEcA


    cDline-scheme-searchcA is a macro implemented in cGhiline.emfcA. 


cEcESEE ALSO cEcA


    lslmosd(2)le, lslm$line-scheme(5)le. 

! 3 scheme-editor
cEcENAME cEcA


    scheme-editor - Color Scheme Editor 
$a


cEcESYNOPSIS cEcA


    cDscheme-editorcA 


cEcEDESCRIPTION cEcA


    cDscheme-editorcA is a color and font scheme editor that provides a dialog 
    interface to configure the display schemes used by the editor. The schemes 
    may be created or modified within the scheme editor and then committed to 
    the configuration files for general use. 

    The editor can be used to create both screen and printer color/font 
    schemes, they are typically stored in the cGmacroscA directory and are 
    executed as macro files at start up or when printing. The standard screen 
    schemes are called cGschemecAcCXcAcG.emfcA and printer ones cGprintcAcCXcAcG.emfcA. 

    The cDscheme-editorcA is displayed within a single dialog box, tab selections 
    at the top of the dialog box enable cDcolorcA and cDschemecA creation and/or 
    modification. Navigation is typically performed using the mouse, where the 
    mouse is absent then the cGTABcA key may be used to move between the fields. 
    The information presented is defined as follows:- 

    cDFile NamecA 
        The name of the color scheme to be modified. This is the name of the 
        cDschemecAcCXcAcD.emfcA file, omitting the file extension. See the cDFILEScA section 
        below for a list of standard screen and printer scheme supplied with 
        MicroEmacs '02. 

    cDTypecA 
        Defines whether the scheme is a screen or printer type. 

    cDDescriptioncA 
        An ASCII description of the color scheme, used to identify the color 
        scheme. 

    cDBuffer HilightcA 
        Available when scheme is a screen type. Defines whether buffer 
        hilighting should be enabled, when cCCompletely DisablecA all buffers are 
        displayed character for character in the standard text scheme, this 
        will ensure maximum update performance but some file formats such as 
        the on-line help will become unreadable so this option is really 
        selected. Similarly cCReformat OnlycA disables the majority of buffers, 
        hilighting is only enabled when the file would be unreadable without 
        it, such as the on-line help or man page files. The default cCFully 
        EnabledcA setting enables all buffer hilighting. 

    cDPrint OptioncA 
        Available when scheme is a printer type. Defines what components of a 
        scheme is to be used when printing. 


cEColors cA


    The cDcolorscA tab allows the basic palette colors of the editor to be created 
    and modified. The left-hand side of the dialog contains a scrolling window 
    containing the existing color entries. The right-hand side of the dialog 
    provides the controls to add and change the color assignment. The controls 
    operate on the currently selected palette entry. 

    cDAddcA 
        Creates and adds a new color entry into the palette. The new palette 
        entry is created with a default color that may be subsequently 
        modified. 

    cDChangecA 
        Commits the current selection color to the palette. 

    cDRedcA/cDGreencA/cDBluecA 
        The color entries allow the currently selected palette color entry to 
        be modified. The color values may be changed by direct numeric entry 
        (0..255) or via the ^/v controls; the color is committed to the 
        palette using the cDAddcA or cDChangecA button. 


cESchemes cA


    The cDschemescA tab allows the schemes to be edited. The left-hand side of the 
    dialog contains a scrolling window of the available color palette (created 
    from the cDColorscA tab). The right-hand side of the window shows the variants 
    of the scheme. 

    cDSelectioncA 
        The cDselectioncA item provides a pull-down menu containing gross scheme 
        categories used by the editor. 

    cDSchemecA 
        A pull-down menu containing the schemes of the selection, modifying 
        this entry shows the variants of the scheme in the cDNormalcA, cDCurrentcA, 
        cDSelectcA and cDSel-CurcA dialogs. 

    There are 4 variants, or styles, for a single scheme; each style is 
    comprised of a foreground and background color, and a row of toggle button 
    to enable/disable fonts, defined as follows. 

        cGBcA - Bold. 
        cGIcA - Italic. 
        cGLcA - Light (typically not supported). 
        cGRcA - Reverse video (fore/back-ground swapped). 
        cGUcA - Underline. 
        cGVcA - Toggle reverse video when inverted. 

    The last mode cDVcA needs a little more explanation; commands such as 
    lslmscreen-poke(2)le are able to invert the color scheme, i.e. use the fore 
    color for the background etc. Enabling this mode will toggle the reverse 
    video mode (cDRcA) when this feature is used. 

    The style displayed by a particular scheme depends upon the 
    selection/current status of the text: 

    cDNormalcA 
        The normal style, when the text object is not selected or current 
        (i.e. out of focus). 

    cDCurrentcA 
        The style used when the text object is current (i.e. in focus) 

    cDSelectcA 
        The style used when the text object is selected (i.e. by the mouse) 
        and is not current. 

    cDSel-CurcA 
        The style used when the text object is selected and is current. 

    Note that a printer scheme only uses the Normal style. 

    Setting of the cDselectioncA and cDschemecA shows the current scheme in the 
    cDNormalcA, cDCurrentcA, cDSelectcA and cDSel-CurcA dialogs. New colors are assigned by 
    selecting a color in the palette area and making it current. The current 
    color is applied by selecting the cDForecA / cDBackcA boxes of the scheme dialog. 
    The assigned color is displayed in the text box cCThe big brown fox...cA. 


cEControls cA


    The controls at the bottom of the dialog apply the edits to the 
    configuration files. 

    cDCurrentcA 
        Makes the changes to the palette and schemes current, they are applied 
        to the current editing session but are not committed to file. This 
        allows the palette changes to be used prior to commitment. Note that 
        all modifications are lost if they are not saved and the editing 
        session is terminated. 

    cDSavecA 
        Saves the scheme modifications to file, effectively making the changes 
        permanent. Note however that the scheme macro file will be saved in 
        the first directory in the lslm$search-path(5)le, regardless of the location 
        of the original. For network systems this typically means that the 
        changes will only effect the current user. 

    cDInstallcA 
        Installs the current color scheme into the configuration files, making 
        the color scheme accessible to the lslmuser-setup(3)le dialog. 

    cDExitcA 
        Quits the scheme editor without modifying the settings. 


cEcEFILES cEcA


    cGscheme.emfcA - Defines the standard scheme variables, including the 
    available scheme list, and associated text. 
    cGschemed.emfcA - Default white on black color scheme. 
    cGschemej.emfcA - Black on cream color scheme. 
    cGschemevicA - Sandy shores. 
    cGschemesfcA - Sherwood Forest. 
    cGschemebhcA - Blue Hue. 
    cGschemepdcA - Plain Black on Cream. 
    cGschemeplcA - Plain White on Black. 
    cGschemelcA - Black on grey. 
    cGschememdcA - Microsoft Developer Studio Colors. 
    cGprinters.emfcA - Defines the list of available printer schemes and drivers. 
    cGprintdcA - Default plain print-out. 
    cGprintfcA - Print using fonts. 
    cGprintepccA - Print using Epson base colors and fonts. 


cEcENOTES cEcA


    cDscheme-editorcA is a macro that is implemented in file cGschemosd.emfcA. The 
    scheme editor uses lslmosd(2)le to create and manage the dialogs. 

    Only the Normal scheme style is used by printer schemes. 

    The setting of cDBuffer HilightcA can effect the way buffer hooks are load so 
    changing from one scheme to another with differing Buffer Hilight settings 
    may not fully work. This can be rectified by restart MicroEmacs with the 
    new scheme as default. 

    The current screen scheme can effect the printing due to the cDBuffercA 
    cDHilightcA setting, e.g. if the screen scheme is set to completely disable 
    hilighting then any print-out will also have no hilighting. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmadd-color-scheme(2)le, lslmprint-scheme(2)le, lslmosd(2)le. 

! 3 MainMenu
cEcENAME cEcA


    Main Menu - The top main menu 
$a


cEcESYNOPSIS cEcA


    cCncA osd 


cEcEDESCRIPTION cEcA


    The main menu is provided to give an easier access to parts of MicroEmacs 
    functionality, the menu is not burnt into MicroEmacs but defined on 
    start-up in cGme.emfcA and cGosd.emfcA. The lslmuser-setup(3)le command can be used to 
    set whether the menu is always visible and if the Alt-Hotkeys are enabled 
    (i.e. 'cGA-fcA' to open the cDFilecA menu). 

    The main menu is lslmosd(2)le dialog number cG0cA so key bindings can be made which 
    will open the main menu, an argument of cG0cA will simply open the main menu, 
    an argument of cG0x0n0000cA will not only open the main menu but also the cGncAth 
    sub menu, e.g. to open the edit menu use: 

            0x020000 osd 


    Following is a brief description of the main menu items: 


cEFile Menu cA


    cGNewcA 
        Changes the current buffer to a new buffer. 

    cGOpencA 
        Opens a dialog enabling the user to select files for opening into 
        MicroEmacs. By default the dialog opens the selected file using 
        command lslmfind-file(2)le, but if the view option is selected the 
        lslmview-file(2)le command is used. The binary or encrypt options configure 
        whether the files are to be loaded with lslmbinary(2m)le or lslmcrypt(2m)le modes 
        enabled. 

    cGQuick OpencA 
        Opens a sub-menu list all user file types (defined in lslmuser-setup(3)le). 
        Selecting one will open another sub-dialog list all files of that type 
        in the current directory, selecting a file will open it using command 
        lslmfind-file(2)le. 

    cGFavoritescA 
        Opens a sub-menu enabling the user to add new favorite files, edit the 
        existing list of favorite files, or select an existing favorite file 
        in which case the file is opened using command lslmfind-file(2)le. The 
        favorite file using to store the list is "cD$MENAMEcAcG.effcA" and is saved in 
        the first path given in the lslm$search-path(5)le. Each favorite file takes 
        2 lines in the file, the first is the text displayed in the dialog 
        (note that characters 'cG\cA' and 'cG&cA' must be protected with a 'cG\cA' and the 
        'cG&cA' can be used to set the Hot key) and the second line is the file 
        name. A line with a single 'cG-cA' character creates a separater line in 
        the dialog. 

    cGFind TagcA 
        Only visible when a cGtagscA file is found in the current directory, the 
        command jumps to the current tag or if not on a tag or the tag is not 
        found, opens a dialog enabling the user to select a tag. See command 
        lslmfind-tag(2)le for more information. 

    cGFind FilecA 
        Executes command lslmfile-browser(3)le. 

    cGFTPcA 
        Executes command lslmftp(3)le. 

    cGClosecA 
        Executes a dialog form of the command lslmdelete-buffer(2)le. 

    cGAttributescA 
        Opens a dialog enabling the user to set the current buffers file 
        attributes. See command lslmfile-attrib(3)le for more information. 

    cGSavecA 
        Executes a dialog form of the command lslmsave-buffer(2)le. 

    cGSave AscA 
        Executes a dialog form of the command lslmwrite-buffer(2)le. 

    cGSave AllcA 
        Executes a dialog form of the command lslmsave-all(3)le. 

    cGPrinter SetupcA 
        Opens a dialog which enables the user to configure the printer driver, 
        output location and page layout (executes command lslmprint-setup(3)le). 

    cGPrintcA 
        Executes command lslmprint-buffer(2)le. 

    cGBuffercA 
        Opens a sub-menu listing all created buffers, selecting one will 
        change the current buffer to the selected one. 

    cGExitcA 
        Executes command lslmsave-buffers-exit-emacs(2)le. 


cEEdit Menu cA


    cGUndocA 
        Undoes the last edit in the current buffer (executes command lslmundo(2)le). 

    cGRedocA 
        Redo the last undo, only available immediately after an undo. This is 
        also done via the lslmundo(2)le command. 

    cGUndo AllcA 
        Undo all edits in the current buffer until the last save or no more 
        undo history is available. Executes the command lslmundo(2)le with a 0 
        numerical argument. 

    cGSet MarkcA 
        Executes command lslmset-mark(2)le. 

    cGCutcA 
        Executes command lslmkill-region(2)le. 

    cGCopycA 
        Executes command lslmcopy-region(2)le. 

    cGPastecA 
        Executes command lslmyank(2)le. 

    cGNarrow OutcA 
        Executes command lslmnarrow-buffer(2)le with a numeric argument of cG4cA. 

    cGNarrow TocA 
        Executes command lslmnarrow-buffer(2)le with a numeric argument of cG3cA. 

    cGRemove Single NarrowcA 
        Executes command lslmnarrow-buffer(2)le with a numeric argument of cG2cA. 

    cGRemove All NarrowscA 
        Executes command lslmnarrow-buffer(2)le with a numeric argument of cG1cA. 


cESearch Menu cA


    cGSearchcA 
        Executes a dialog form of the command lslmisearch-forward(2)le. 

    cGReplacecA 
        Executes a dialog form of the command lslmquery-replace-string(2)le. 

    cGHilight SearchcA 
        Opens another dialog which can be used to add and remove hilighting of 
        individual lines in the current buffer. Note that setting a line 
        hilight is a temporary change, it will not effect any files etc and 
        will be lost when the buffer is deleted. 

    cGGoto LinecA 
        Executes a dialog form of the command lslmgoto-line(2)le. 

    cGGoto FencecA 
        Executes command lslmgoto-matching-fence(2)le. 

    cGSet BookmarkcA 
        Executes command lslmset-alpha-mark(2)le. 

    cGGoto BookmarkcA 
        Executes command lslmgoto-alpha-mark(2)le. 


cEInsert Menu cA


    cGSymbolcA 
        Executes command lslmsymbol(3)le. 

    cGDate & TimecA 
        Opens a dialog with the current date and time in a selection of common 
        formats; selecting one of these will insert the string into the 
        current buffer at the current position. Note that the format text 
        strings depend on the current language (Default and American languages 
        use the order MM-DD-YY etc whereas the rest use DD-MM-YY). The names 
        used for the day and month names can be defined using the Setup page 
        of lsorganizer(3)lmOrganizer(3)le. 

    cGFilecA 
        Executes command lslminsert-file(2)le. 

    cGFile NamecA 
        Executes command lslminsert-file-name(2)le. 

    cGMacro...cA 
        Executes command lslminsert-macro(2)le. 


cEFormat Menu cA


    cGRestyle BuffercA 
        Executes command lslmrestyle-buffer(3)le. 

    cGRestyle RegioncA 
        Executes command lslmrestyle-region(3)le. 

    cGClean BuffercA 
        Executes command lslmclean(3)le. 

    cGChange Buffer Char SetcA 
        Executes command lslmcharset-change(3)le. 

    cGIQ Fill ParagraphcA 
        Executes command lslmifill-paragraph(3)le. 

    cGFill ParagraphcA 
        Executes command lslmfill-paragraph(2)le. 

    cGFill All ParagraphscA 
        Executes command lslmfill-paragraph(2)le with a very large positive 
        numerical argument. Note that this only effects paragraphs from the 
        current position onwards. 

    cGParagraph to LinecA 
        Executes command lslmparagraph-to-line(3)le. 

    cGAll Paragraphs to LinecA 
        Executes command lslmparagraph-to-line(3)le with a very large positive 
        numerical argument. Note that this only effects paragraphs from the 
        current position onwards. 

    cGSort LinescA 
        Executes command lslmsort-lines(2)le. 

    cGIgnore Case Sort LinescA 
        Executes command lslmsort-lines-ignore-case(3)le. 

    cGCapitalize WordcA 
        Executes command lslmcapitalize-word(2)le. 

    cGLower Case WordcA 
        Executes command lslmlower-case-word(2)le. 

    cGLower Case RegioncA 
        Executes command lslmlower-case-region(2)le. 

    cGUpper Case WordcA 
        Executes command lslmupper-case-word(2)le. 

    cGUpper Case RegioncA 
        Executes command lslmupper-case-region(2)le. 


cEExecute Menu cA


    cGExecute CommandcA 
        Executes command lslmexecute-named-command(2)le. 

    cGExecute BuffercA 
        Executes command lslmexecute-buffer(2)le. 

    cGExecute FilecA 
        Executes command lslmexecute-file(2)le. 

    cGStart Kbd MacrocA 
        Executes command lslmstart-kbd-macro(2)le. 

    cGQuery Kbd MacrocA 
        Executes command lslmkbd-macro-query(2)le. 

    cGEnd Kbd MacrocA 
        Executes command lslmend-kbd-macro(2)le. 

    cGExecute Kbd MacrocA 
        Executes command lslmexecute-kbd-macro(2)le. 

    cGName Kbd MacrocA 
        Executes command lslmname-kbd-macro(2)le. 

    cGIpipe commandcA 
        Executes command lslmipipe-shell-command(2)le. 

    cGShellcA 
        Executes command lslmshell(2)le. 


cETools Menu cA


    cGCurrent Buffer ToolscA 
        For some file formats MicroEmacs provides a file format specific set 
        of tools, see the lsMicroEmacs '02 - Supported File Typeslmfile typele help page for more specific information. 

    cGCount WordscA 
        Executes command lslmcount-words(2)le. 

    cGSpell WordcA 
        Executes command lslmspell-word(3)le. 

    cGSpell BuffercA 
        Executes command lslmspell-buffer(3)le. 

    cGWord CompletecA 
        Takes the incomplete word to the left of the cursor and attempts to 
        complete the word by using the users current language dictionary. 
        Executes command lslmspell-complete-word(3)le. 

    cGCompare WindowscA 
        Executes command lslmcompare-windows(2)le. 

    cGCompilecA 
        Executes command lslmcompile(3)le. 

    cGGrepcA 
        Executes command lslmgrep(3)le. 

    cGGraphical DiffcA 
        Executes command lslmgdiff(3)le. 

    cGDiffcA 
        Executes command lslmdiff(3)le. 

    cGDiff ChangescA 
        Executes command lslmdiff-changes(3)le. 

    cGOrganizercA 
        Executes command lslmorganizer(3)le. 

    cGMailcA 
        Executes command lslmmail(3)le. 

    cGView MailcA 
        Executes command lslmvm(3)le. 

    cGMore...cA 
        Opens a sub-menu with a collection of other useful miscellaneous 
        tools. 


cEWindow Menu cA


    cGSplit Window VcA 
        Executes command lslmsplit-window-vertically(2)le. 

    cGGrow Window VcA 
        Executes command lslmgrow-window-vertically(2)le. 

    cGShrink Window VcA 
        Executes command lslmshrink-window-vertically(2)le. 

    cGSplit Window HcA 
        Executes command lslmsplit-window-horizontally(2)le. 

    cGGrow Window HcA 
        Executes command lslmgrow-window-horizontally(2)le. 

    cGShrink Window HcA 
        Executes command lslmshrink-window-horizontally(2)le. 

    cGOne WindowcA 
        Executes command lslmdelete-other-windows(2)le. 

    cGDelete WindowcA 
        Executes command lslmdelete-window(2)le. 

    cGPrevious WindowcA 
        Executes command lslmprevious-window(2)le. 

    cGNext WindowcA 
        Executes command lslmnext-window(2)le. 


cEHelp Menu cA


    cGCurr Buffer HelpcA 
        For some file formats MicroEmacs provides a file format specific help 
        page giving details of key-bindings and tools specific to the current 
        buffers file type. 

    cGGeneral HelpcA 
        Executes command lslmosd-help(3)le. 

    cGHelp on CommandcA 
        Executes command lslmhelp-command(2)le. 

    cGHelp on VariablecA 
        Executes command lslmhelp-variable(2)le. 

    cGDescribe BindingscA 
        Executes command lslmdescribe-bindings(2)le. 

    cGDescribe keycA 
        Executes command lslmdescribe-key(2)le. 

    cGDescribe VariablecA 
        Executes command lslmdescribe-variable(2)le. 

    cGDescribe WordcA 
        Executes command lslmdescribe-word(3)le. 

    cGList BufferscA 
        Executes command lslmlist-buffers(2)le. 

    cGList CommandscA 
        Executes command lslmlist-commands(2)le. 

    cGList RegistrycA 
        Executes command lslmlist-registry(2)le. 

    cGList VariablescA 
        Executes command lslmlist-variables(2)le. 

    cGCommand AproposcA 
        Executes command lslmcommand-apropos(2)le. 

    cGBuffer SetupcA 
        Executes command lslmbuffer-setup(3)le. 

    cGUser SetupcA 
        Executes command lslmuser-setup(3)le. 

    cGScheme EditorcA 
        Executes command lslmscheme-editor(3)le. 

    cGGamescA 
        Opens a sub-menu listing all available games, see lsMicroEmacs '02 - GameslmGamesle for more 
        information. 

    cGProduct SupportcA 
        Opens on-line lslmContactle information. 

    cGAbout MicroEmacscA 
        Executes command lslmabout(2)le. 


cEcENOTES cEcA


    The main menu is defined using lslmosd(2)le in macro files me.emf and osd.emf. 

    General user extensions to the main menu can be added to the user file 
    cGmyosd.emfcA which is executed once when the main menu is first opened. The 
    macro file can add new items to any of the main sub menus and can delete 
    most existing items (some are dynamically added when appropriate, these 
    should not be deleted). See cGosd.emfcA for examples of how to add items to 
    the menu. 

    New sub-menus should be added in the company or user setup files as this 
    must be done at start-up. The content on the menu is not required until 
    the main menu is used so populating the new sub-menu can be done in 
    cGmyosd.emfcA. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le. 

! 3 osd-help
cEcENAME cEcA


    osd-help - GUI based on-line help 
$a


cEcESYNOPSIS cEcA


    cDosd-helpcA 


cEcEDESCRIPTION cEcA


    cDosd-helpcA provides a GUI front end to the on-line help manual, the dialog 
    consists of 3 pages which are defined as follows:- 


cEContents cA


    The contents page displays a list on contents similar to the lslmhelp(2)le high 
    level help page. Selecting an item will display the help page in a buffer, 
    selecting cDExitcA will exit the dialog. 


cEIndex cA


    The index page gives a list of help items, the cDScopecA menu can be used to 
    narrow the index list to the required item type. 


cESearch cA


    The search page provides a way of searching the on-line help for a given 
    topic. Similarly to the Index page, the cDScopecA menu is provided to narrow 
    the search to the required area. 

    The search strings is considered to be made up of items separated by 
    spaces, an item can be enclosed in quotes ('cG"cA') so that the item can 
    include a space. If the first letter of an item is a 'cG+cA' the given item 
    must be found in a page for it to match, if the character is a 'cG-cA' the 
    item must NOT be found on a page for it to match, or other items are 
    considered optional. At least one item must be found on a page for it to 
    be a match, the numbers to the right of each found page is the number of 
    items found. 


cEcENOTES cEcA


    See lslmHelp!le for help on the on-line help pages. 

    cDosd-helpcA is a macro using lslmosd(2)le, defined in osdhelp.emf. 


cEcESEE ALSO cEcA


    lslmhelp(2)le. 

! 3 file-attrib
cEcENAME cEcA


    file-attrib - Set the current buffers system file attributes 
$a


cEcESYNOPSIS cEcA


    cDfile-attribcA 


cEcEDESCRIPTION cEcA


    cDfile-attribcA opens a dialog enabling the user to change the system 
    properties of the current buffer's file. Top of the dialog give the 
    current buffer name and its file name. The cGSave ChangescA button writes the 
    current buffer out with any current edits and changes to its file 
    attributes. The cGOkcA button closes the file-attrib dialog, any changes made 
    to the file attributes will be applied next time the buffer is written. 

    The type allow the changing between UNIX, MS Windows and DOS text file 
    formats. UNIX has a single new line character ('cG\ncA') where as Windows and 
    Dos have a double new line character ('cG\r\ncA'). Also a Dos text file is 
    terminated with a cGC-zcA (0x1A) character which the other two do not. These 
    attribute are set in MicroEmacs by using buffer modes lslmcrlf(2m)le and 
    lslmctrlz(2m)le. 

    The central part of the dialog contains system dependent attributes which 
    are defined as follows: 

    cDUNIX PlatformscA 
        Allow the setting of user, group and global, read, write and execute 
        permissions, see man pages on cDchmod(1)cA for more information. This is a 
        front end to setting the variable lslm$buffer-fmod(5)le. 

    cDWin32 PlatformscA 
        Allow the setting of MS Windows file attributes, i.e. read-only, 
        hidden, archive etc. Note that the directory attribute is displayed 
        but cannot be altered. This is a front end to setting the variable 
        lslm$buffer-fmod(5)le. 

    cDDOS PlatformcA 
        Allow the setting of MS Dos file attributes, i.e. read-only, hidden, 
        archive etc. Note that the directory attribute is displayed but cannot 
        be altered. 


cEcENOTES cEcA


    cDfile-attribcA is a macro implemented in cGfattrib.emfcA. 


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmwrite-buffer(2)le, lslmcrlf(2m)le, lslmctrlz(2m)le, lslm$buffer-fmod(5)le. 

! 3 describe-word
cEcENAME cEcA


    describe-word - Display a dictionary definition of a word 
$a


cEcESYNOPSIS cEcA


    cDdescribe-wordcA "cCwordcA" 


cEcEDESCRIPTION cEcA


    cDdescribe-wordcA can be used to interface to an external dictionary to get a 
    definition of a given word. The interface has two modes of interface, the 
    first simply launches an external program which provides the definition in 
    its own user interface, e.g. MS Bookshelf. The second interface launches 
    an external program which prints out the definition to cGstdoutcA, MicroEmacs 
    can then pull out the definition and display it in cDdescribe-wordcA's own 
    GUI. 

    When executed cDdescribe-wordcA will use the current word under the cursor as 
    the initial cCwordcA or will prompt the user if the cursor is not in a word. 

    When cDdescribe-wordcA's dialog is used the information presented is defined 
    as follows: 

    cDWordcA 
        The word being defined, the entry can be edited and the new word will 
        be automatically looked-up when the edit is completed. 

    cDInsertcA 
        The effect of this button is dependent on where describe-word was 
        executed. If executed from the cDMeaningcA button within the lsspell-buffer(3)lmspell checkerle 
        the Word entry is changed to the current word. When executed outside 
        the spell checker the definition of the current word is inserted into 
        the current buffer. 

    cDExitcA 
        Closes the dialog. 

    Main definition box 
        Displays the definition of the current word. The user can select a new 
        word to describe by clicking the left mouse button on any word within 
        the current definition. 


cEcENOTES cEcA


    cDdescribe-wordcA is a macro implemented in cGword.emfcA. 

    Due to the size and availability of dictionaries etc. MicroEmacs is 
    released without describe-word set up, the user must setup it up. 

    cDdescribe-wordcA must be setup for each required language as follows: 

    cD1)cA 
        A command-line interface to a dictionary of the required language must 
        be found. This could simply be a text file containing one word 
        definition per line and using cDgrep(1)cA as the command-line interface. 
        In this example the text file could take the following form: 

            A () The first letter of the English... 
            Aam (n.) A Dutch and German measure of liquids... 
            Aardvark (n.) An edentate mammal... 
            . 
            . 


        The cDgrepcA command-line interface required to look-up the word 
        "cGaardvarkcA" would be: 

            grep -i "^aardvark (" words.txt 


        The output produced from this will be the single line giving the 
        required definition. A second common interface would be executing an 
        external dictionary program typically using a command-line option to 
        specify the word to define, e.g.: 

            mydict -d "aardvark" 


    cD2)cA 
        The MicroEmacs language name must be found, this can be done by first 
        using lslmuser-setup(3)le or lslmspell-buffer(3)le to ensure that the current 
        language is set the the require one and then running cDdescribe-wordcA. 
        The command will probably fail, but before it does it will set the 
        variable cG.describe-word.langcA, use the command lslmdescribe-variable(2)le to 
        get the value of this variable, this value is the internal language 
        name. For example, when the current language is cDAmericancA or cDAmerican 
        (Ext)cA the language name is cGamericancA. 

    cD3)cA 
        To execute the command-line interface the variable 
        cG.describe-word.cAcC<language>cAcG-commandcA must be set to the command-line 
        required to obtain a word definition with the string "cG%scA" used in 
        place of the word and "cG%%cA" using in place of a single "cG%cA". For the 
        first example in cD(1)cA above the following would be required: 
sB
            set-variable .describe-word.american-command ... 
                    ... "grep -i \"^%s (\" /tmp/words.txt" 

sA
        For the second example: 
sB
            set-variable .describe-word.american-command "mydict -d \"%s (\"" 

sA
    cD4)cA 
        Only required for the second mode, for use with cDdescribe-wordcA's own 
        GUI, the setting of another variable is required, the presence of this 
        variable determines which mode is to be used. 

        The variable cG.describe-word.cAcC<language>cAcG-searchcA must be set to a lsRegularExpressions(2)lmregexln
        lnsearch patternle which will match the required definition(s) in the 
        command out put, the first group ("cG\(...\)cA") must enclose the required 
        definition, again "cG%scA" can be used in place of the word and "cG%%cA" for a 
        single "cG%cA". cDdescribe-wordcA simply uses lslmregex-forward(3)le repeatedly to 
        find all definitions of the current word, it then uses the value of 
        the variable lslm@s1(4)le to get the individual definitions. For example for 
        the first example the following is required: 
sB
            set-variable .describe-word.american-search  "^\(%s (.*\)\n" 

sA
        Note that the word being defined should be kept in the definition if 
        possible as the lsadd-spell-rule(2)lmspell rulesle are used to look-up base words when a 
        derivitive of a word is not found, therefore the word being defined 
        may not be clear (e.g. cCdeactivatecA can be derived from cCactivatecA but 
        their meanings are very different). Also long text lines are 
        automatically wrapped by the GUI. 

    The required variables should be added to the user setup file. 


cEcESEE ALSO cEcA


    lslmspell-buffer(3)le. 

! 3 buffer-setup
cEcENAME cEcA


    buffer-setup - Configures the current buffer settings 
$a


cEcESYNOPSIS cEcA


    cDbuffer-setupcA 


cEcEDESCRIPTION cEcA


    cDbuffer-setupcA provides a dialog interface to configuring the setup of the 
    current buffer's file type within MicroEmacs. cDuser-setupcA may be invoked 
    from the main cChelpcA menu or directly from the command line using 
    lslmexecute-named-command(2)le. 

    The changes made to a configuration in cDbuffer-setupcA are maintained in 
    future MicroEmacs sessions by storing them within the user's setup 
    registry file, "cC<logname>cAcG.erfcA". Note that not all file types may be 
    supported by cDbuffer-setupcA, if not the help menu item will not be 
    available. 

    The contents of the dialog change, depending on the features the current 
    buffer's file type supports. These features are implemented and installed 
    within the lsfileHooks(2)lmbuffer's file hookle. The following buttons are always present at 
    the bottom of the dialog: 

    cGSavecA 
        Saves the changes made to the configuration back to the users registry 
        file, i.e. "cC<Log-Name>cAcG.erfcA" but does not re-initialize the current 
        buffer. No changes made will effect the current buffer unless the 
        cDCurrentcA button is pressed. Buffers of the same type created after the 
        save may inherrit some of the changes. 

    cGCurrentcA 
        Makes the current buffer reflect the changes made, dismissing the 
        cDbuffer-setupcA dialog. This also performs the above 'cDSavecA' operation. 
        Some changes such as dialog creation changes, will only take effect 
        when MicroEmacs is restarted. 

    cGExitcA 
        Quits buffer-setup, if changes where not cDSavecAd or made cDCurrentcA they 
        will be lost. 

    Following is a list of configurable features which may be available: 

    Create Help Page 
        Enables/disables the creation of a help page dialog for the tools 
        available for the current file type. 

    Create Tools Menu 
        Enables/disables the creation of a file type specific sub menu located 
        within the main menu's cDToolscA sub-menu. 

    Use Author Mode 
        For file types which have an automatic formatter/viewer (currently 
        only html) enabling this will simply load the file enabling the source 
        code to be viewed and edited. When disabled files of this type will be 
        automatically processed giving a more readable 'formatted' 
        representation. 

    Insert New Template 
        When creating a new buffer/file of this type, a default template will 
        be inserted if this is enabled. When disabled the buffer will remain 
        empty. 

    Fence Display 
        Enables or disables the displaying of matching fences for this file 
        type. Note that the way in which the matching fence is display is 
        determined by the cDFence DisplaycA option on the Platform page of 
        lslmuser-setup(3)le; the cDbuffer-setupcA option is ignored if this option is 
        set to "cGNever DisplaycA". 

    Setup Hilighting 
        Creates and enables the token lshilight(2)lmhilightingle for the current file type. 

    Setup Auto Indent 
        Enables automatic formating (indenting) for the current file type. The 
        indentation rules are either the built in 'C' indentation lslmcmode(2m)le or 
        created using the lslmindent(2)le command. When enabled the lslmtab(2m)le is still 
        adhered to, but the lslmindent(2m)le mode is ignored; when disabled the 
        indent mode can be used. 

    Setup Auto Spell 
        Enables the setting up of lslmauto-spell(3)le. When enabled the auto-spell 
        key bindings are created and auto-spell is enabled if enabled within 
        the user-setup dialog. 

    Setup Folding 
        Enables the setting up of section lsfold-current(3)lmfoldingle, when enabled the folding 
        key bindings are created. 

    Add Abbreviations 
        Adds the file type's abbreviation file to the buffer using 
        lslmbuffer-abbrev-file(2)le 

    Search Modes: Exact 
        Enables/disables the lslmexact(2m)le mode over-riding the setting within the 
        lslmuser-setup(3)le dialog. If this setting is changed the setting within 
        user-setup will be ignored for the current file type. 

    Search Modes: Magic 
        Enables/disables the lslmmagic(2m)le mode over-riding the setting within the 
        lslmuser-setup(3)le dialog. If this setting is changed the setting within 
        user-setup will be ignored for the current file type. 

    Buffer Modes: Auto 
        Enables/disables the lslmauto(2m)le mode. 

    Buffer Modes: Backup 
        Enables/disables the lslmbackup(2m)le mode. 

    Buffer Modes: Indent 
        Enables/disables the lslmindent(2m)le mode. 

    Buffer Modes: Justify 
        Enables/disables the lslmjustify(2m)le mode. 

    Buffer Modes: Tab 
        Enables/disables the lslmtab(2m)le mode over-riding the setting within the 
        lslmuser-setup(3)le dialog. If this setting is changed the setting within 
        user-setup will be ignored for the current file type. 

    Buffer Modes: Time 
        Enables/disables the lslmtime(2m)le mode. 

    Buffer Modes: Undo 
        Enables/disables the lslmundo(2m)le mode over-riding the setting within the 
        lslmuser-setup(3)le dialog. If this setting is changed the setting within 
        user-setup will be ignored for the current file type. 

    Buffer Modes: Wrap 
        Enables/disables the lslmwrap(2m)le mode. 


cEcENOTES cEcA


    cDbuffer-setupcA is a macro using lslmosd(2)le, defined in cGbuffstp.emfcA. 


cEcESEE ALSO cEcA


    lslmbuffer-help(3)le, lslmuser-setup(3)le. lsfileHooks(2)lmFile Hooksle. 

! 3 buffer-help
cEcENAME cEcA


    buffer-help - Displays help page for current buffer 
$a


cEcESYNOPSIS cEcA


    cDbuffer-helpcA 


cEcEDESCRIPTION cEcA


    cDbuffer-helpcA opens a dialog giving the user a brief help page on tools 
    available for the current buffer. The help page changes depending on the 
    type of the current buffer. 


cEcESEE ALSO cEcA


    lslmbuffer-setup(3)le. 

! 3 print-setup
cEcENAME cEcA


    print-setup - Configure MicroEmacs's printer interface 
$a


cEcESYNOPSIS cEcA


    cDprint-setupcA 


cEcEDESCRIPTION cEcA


    cDprint-setupcA provides a dialog interface for configuring MicroEmacs's 
    printing interface. cDprint-setupcA may be invoked from the main cCFilecA menu or 
    directly from the command line using lslmexecute-named-command(2)le. 

    The cDprint-setupcA dialog is broken down into three pages of configuration 
    options, on all pages the following buttons are available at the bottom of 
    the dialog:- 

    cGPrintcA 
        Prints the current buffer using the current configuration. 

    cGExitcA 
        Quits cDprint-setupcA, changes made to the configuration will be saved. 

    The following pages appear in the dialog:- 


cEPrinter cA


    The cDPrintercA page is used to configure the type, style and location of the 
    printer, the items on this page are defined as follows:- 

    cGDrivercA 
        Sets the printer type to be used, selecting this item creates a drop 
        down list of available printer drivers. The drivers inform MicroEmacs 
        which fonts and colors are available and how to enable/disable them, 
        these are usually special character sequences. The following special 
        drivers are defined:- 

        Default Plain Text 
            This driver does not use any special character sequences so the 
            output it produces is plain text. This should work with most 
            printers, but it does not support any colors or fonts. 

        HTML 
            This is a virtual printer driver as no printer uses HTML directly. 
            However the files produced by this driver can be loaded by a 
            web-browser and rendered with full color and font support so 
            provides an efficient way of testing printer schemes. In addition 
            may be used to convert the text rendered in MicroEmacs into HTML 
            content. 

        Windows 
            This utilizes MicroEmacs's built-in Windows printer interface 
            (Windows platforms only). When selected MicroEmacs communicates 
            directly to the MS Printer Manager. 

    cGPrint SchemecA 
        Sets the color and font scheme to be used, selecting this item creates 
        a drop down list of available printer schemes - choose one 
        appropriated for your printer. The Default Plain Text scheme does not 
        use any color or fonts so should work for all drivers. see the next 
        item for scheme creation and editing. 

    cGEditcA 
        Opens the lslmscheme-editor(3)le dialog box to edit the currently selected 
        printer scheme, the editor may also be used to create and install new 
        printer schemes. 

    cGDestinationcA 
        Specifies the resultant print output, when selected a drop down menu 
        appears containing the following items: 

        To buffer only 
            Creates a "cG*printer*cA" buffer and prints to the buffer. 

        To file only 
            Creates a new temporary file and prints to it. 

        To file & print 
            Prints to a temporary file and then executes the command-line (see 
            next item) to print the resultant file (option not available when 
            using the Windows printer driver). 

        Direct to printer 
            Output is sent directly to the printer, option only available when 
            using the Windows driver. 

    cGCommand-linecA 
        Sets the command-line required to print a generated print file (option 
        not available when the Windows driver is selected as printing is done 
        by talking to MS Print Manager directly). The command-line should be a 
        single shell command using "cG%fcA" whenever the name of the file to be 
        printed is required, e.g. on UNIX systems cDlp(1)cA or cDlpr(1)cA can usually 
        be used as follows:- 

            lp -s %f 


        On MS-DOS machines this can usually be achieved by copying the file to 
        the cGPRNcA device, as follows: 

            copy %f PRN 


    cGPage SizecA 
        Displays the currently configured page size in the form: 

            cCColumnscAcDxcAcCRowscA cCChars-WidecAcDxcAcCChars-HighcA 

        the field cannot be edited directly, the settings cDPage SetupcA affect 
        these values. 


cEPage Setup cA


    cGPaper SizecA 
        Sets the size of the printer paper, selecting this item will produce a 
        pop down menu listing all available paper sizes unless the Windows 
        printer driver is being used in which case this field cannot be 
        selected and the cDEditcA button must be used. 

    cGCharacter SizecA 
        Sets the size of a character within the page, expressed in terms of 
        the number of characters which will fit on the paper (cCwidthcAcDxcAcCheightcA). 
        When selected a drop down menu lists all available sizes for the 
        current paper size unless the Windows driver is selected in which case 
        this field cannot be selected and the cDEditcA button must be used. 

    cGEditcA (Windows only) 
        Opens a Windows printer dialog box allowing the user to specify the 
        windows printer, paper size and character size etc. 

    cGNo. of ColumnscA and cGRowscA 
        Sets the number of sub-columns and rows to divide the page into, 
        creating pages within a page. 

    cGLine NumberscA 
        When enabled, prints the line number at the left hand edge for each 
        line. 

    cGSplit Line IDcA 
        When enabled the last right hand text column is reserved for a split 
        identifier. Whenever a line is too long to fit on a single line it is 
        split over two or more lines, if this option is enabled the right edge 
        will be set to the split character (usually a 'cG\cA' char) to clearly 
        indicate that the line is split. 

    cGPage SizecA 
        As with the cDPrintercA cDPage SizecA it displays the current page size, the 
        field cannot be edited. 


cELayout cA


    cGMarginscA 
        Configures the top, bottom, left and right margins in characters. 

    cGHeadercA 
        Sets whether a header should be printed and if so what it should be, 
        the following special strings can be used: 

        cG%%cA 
            Print a 'cG%cA' character. 

        cG%bcA 
            Print the current buffer's name. 

        cG%DcA 
            Print the current day of the month. 

        cG%fcA 
            Print the current buffer's file name. 

        cG%hcA 
            Print the current hour. 

        cG%McA 
            Print the current month of the year. 

        cG%mcA 
            Print the current minute of the hour. 

        cG%pcA 
            Print the current page number. 

        cG%scA 
            Print the current seconds. 

        cG%YcA 
            Print the current year as a 2 digit number. 

        cG%ycA 
            Print the current year as a 4 digit number. 

    cGFootercA 
        Sets whether a footer should be printed and if so what it should be, 
        the same special strings can be used as for the header. 


cEcENOTES cEcA


    cDuser-setupcA is a macro using lslmosd(2)le, defined in cGprintstp.emfcA. 

    The list of available printer drivers and print schemes is stored in the 
    macro file cGprinters.emfcA. Using the cDInstallcA option of the lslmscheme-editor(3)le 
    automatically adds the new scheme to the print schemes list. To create a 
    new printer driver a new configuration registry file (cGerfcA file - see 
    cGprint*.erfcA for examples) must be created and added to the printer driver 
    lists within cGprinter.emfcA. 


cEcESEE ALSO cEcA


    lslmprint-buffer(2)le, lslmscheme-editor(3)le, lslmosd(2)le. 

! 4 &rep
!44 &irep
!44 &xrep
!44 &xirep
cEcENAME cEcA


    &rep, &irep, &xrep, &xirep - Replace string in string functions 


cEcESYNOPSIS cEcA


    cD&repcA cCstr1cA cCstr2cA cCstr3cA 
    cD&irepcA cCstr1cA cCstr2cA cCstr3cA 
    cD&xrepcA cCstr1cA cCstr2cA cCstr3cA 
    cD&xirepcA cCstr1cA cCstr2cA cCstr3cA 


cEcEDESCRIPTION cEcA


    These functions search for cCstr2cA in cCstr1cA, replacing it with cCstr3cA, returning 
    the resultant string. 

    The functions may all be abbreviated to their three letter abbreviation 
    (i.e. cD&xirepcA may be expressed as cD&xircA). In all cases the first argument is 
    completely evaluated before the second and third arguments. 

    cD&repcA cCstringcA cCsearchcA cCreplacecA 
        Searches for the cCsearchcA string in the given cCstringcA using a simple case 
        sensitive exact match algorithm. Any occurrences are removed from 
        cCstringcA and cCreplacecA is inserted in its place. Either of the 3 input 
        strings can be the empty string (cG""cA). 

    cD&irepcA cCstringcA cCsearchcA cCreplacecA 
        cD&irepcA is identical to cD&repcA except a case insensitive search algorithm 
        is used. 

    cD&xrepcA cCstringcA cCregex-searchcA cCregex-replacecA 
        cD&xrepcA can be used to access the more powerful regular expression 
        searching capabilities. The function is similar to cD&repcA except it 
        takes a regex search string and the replacement string may also refer 
        to all or part of the matched string. See lsRegularExpressions(2)lmRegular Expressionsle for 
        information on the cCregexcA format. 

    cD&xirepcA cCstringcA cCregex-searchcA cCregex-replacecA 
        cD&xirepcA is identical to cD&xrepcA except a case insensitive regex search is 
        used. 


cEcEEXAMPLE cEcA


    The following example turns a UNIX format file name (using a 'cG/cA' to divide 
    directories - like MicroEmacs) into an windows format name (using a 'cG\cA'): 
sB
        set-variable #l0 &rep #l0 "/" "\\" 

sA
    The following example replaces one or more white spaces in the variable 
    with a single space, this is an easy way to remove unnecessary spaces: 
sB
        set-variable #l0 "This   is   not   so    spacey    after   xrep" 
        set-variable #l0 &xrep #l0 "\\s +" " " 
        ml-write #l0 

sA

cEcESEE ALSO cEcA


    lslmOperating Modesle, lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sequal(4)le, lslm&sin(4)le. 

! 4 &abs
! 4 &add
! 4 &sub
!44 &multiply
!44 &divide
! 4 &mod
!44 &negate
! 4 &inc
! 4 &dec
!44 &pinc
!44 &pdec
cEcENAME cEcA


    &abs, &add, &sub, &mul, &div, &mod, &neg, &inc, &dec, &pinc, &pdec - 
    Numeric macro operators 


cEcESYNOPSIS cEcA


    cD&abscA cCnum1cA 
    cD&addcA cCnum1cA cCnum2cA 
    cD&subcA cCnum1cA cCnum2cA 
    cD&multiplycA cCnum1cA cCnum2cA 
    cD&dividecA cCnum1cA cCnum2cA 
    cD&modcA cCnum1cA cCnum2cA 
    cD&negatecA cCnumcA 

    cD&inccA cCvariablecA cCincrementcA 
    cD&deccA cCvariablecA cCdecrementcA 
    cD&pinccA cCvariablecA cCincrementcA 
    cD&pdeccA cCvariablecA cCdecrementcA 


cEcEDESCRIPTION cEcA


    The numeric operators operate on variables or integers to perform integer 
    computations, returning the integer result of the operation. The contents 
    of the variables are interpreted as signed integers typically with a 
    dynamic range of 2^31 <= cCnumcA <= 2^31-1. 

    The operators may all be abbreviated to their three letter abbreviation 
    (i.e. cD&multiplycA may be expressed as cD&mulcA). In all cases the first argument 
    is completely evaluated before the second argument. 

    cD&abscA cCnum1cA 
        Returns the absolute value of cCnum1cA i.e. if cCnum1cA is positive it returns 
        cCnum1cA, else -cCnum1cA 

    cD&addcA cCnum1cA cCnum2cA 
        Addition of two numbers cCnum1cA and cCnum2cA. i.e. cCnum1cA + cCnum2cA 

    cD&subcA cCnum1cA cCnum2cA 
        Subtract the second number cCnum2cA from the first cCnum1cA i.e. cCnum1cA - cCnum2cA. 

    cD&multiplycA cCnum1cA cCnum2cA 
        (Signed) Multiply cCnum1cA by cCnum2cA. i.e. cCnum1cA * cCnum2cA. cD&mulcA is the three 
        letter abbreviation. 

    cD&divcA cCnum1cA cCnum2cA 
        Divide the first number cCnum1cA by the second cCnum2cA, returning the integer 
        result. i.e. cCnum1cA / cCnum2cA. cD&divcA is the three letter abbreviation. 

    cD&modcA cCnum1cA cCnum2cA 
        Divide the first number cCnum1cA by the second cCnum2cA, returning the integer 
        remainder. i.e. cCnum1cA % cCnum2cA. 

    cD&negatecA cCnumcA 
        Negate the integer (multiply by -1) i.e. -cCnumcA. cD&negcA is the three 
        letter abbreviation. 

    Expression evaluation is prefix. Operators may be nested using a pre-fix 
    ordering, there is no concept of brackets (in-fix notation). The 
    expression cG(2 * 3) + 4cA is expressed as:- 
sB
        &add &mul 2 3 4 

sA
    conversely cG2 * (3 + 4)cA is expressed as:- 
sB
        &mul 2 &add 3 4 

sA
    The pre/post incrementing and decrementing operators provide a mechanism 
    for stepping through indexed information without incurring the overhead of 
    providing multiple statements to perform assignment operations. The 
    cCvariablecA argument MUST be the name of a variable, it cannot be an 
    expression or an indirection. The cCincrementcA may be any integer expression 
    (including another auto (dec)increment). Note that cCvariablecA is re-assigned 
    with it's new value within the operator, therefore use with care when 
    performing multiple (dec)increments within the same statement line. The 
    four operators are defined as follows: 

    cD&inccA cCvariablecA cCincrementcA 
        Pre-increment the cCvariablecA by cCincrementcA, returning the incremented 
        value i.e. cCvariablecA += cCincrementcA. 

    cD&deccA cCvariablecA cCdecrementcA 
        Pre-decrement the cCvariablecA by cCdecrementcA, returning the decrement value 
        i.e. cCvariablecA -= cCdecrementcA. 

    cD&pinccA cCvariablecA cCincrementcA 
        Post-increment the cCvariablecA by cCincrementcA, returning the pre-increment 
        value i.e. cCvariablecA++., where the ++ value is determined by cCincrementcA. 
        The return value is the value of cCvariablecA as passed by the caller, the 
        next reference to cCvariablecA uses the cCvariablecA+cCincrementcA value. 

    cD&pdeccA cCvariablecA cCdecrementcA 
        Post-decrement the cCvariablecA by cCdecrementcA, returning the pre-decrement 
        value i.e. cCvariablecA--, where the -- value is determined by cCdecrementcA. 


cEcEEXAMPLE cEcA


    Add two numbers together and assign to a variable:- 
sB
        set-variable %result &add %num1 %num2 

sA
    Increment cG%resultcA by 1 and add to cG%result2cA 
sB
        set-variable %result  &add %result 1 
        set-variable %result2 &add %result2 %result 

sA
    The previous example could have used the increment operators to achieve 
    the same result in a single operation e.g. 
sB
        set-variable %result2 &add %result2 &inc %result 1 

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&great(4)le. 

! 4 &cat
!44 &left
!44 &right
! 4 &mid
! 4 &len
!44 &slower
!44 &supper
!44 &trboth
!44 &trleft
!44 &trright
cEcENAME cEcA


    &cat, &lef, &rig, &mid, &len, &slo, &trb - String macro operators 


cEcESYNOPSIS cEcA


    cD&catcA cCstr1cA cCstr2cA 
    cD&lefcA cCstrcA cClencA 
    cD&rightcA cCstrcA cCindexcA 
    cD&midcA cCstrcA cCindexcA cClencA 

    cD&lencA cCstrcA 

    cD&slowercA cCstrcA 
    cD&suppercA cCstrcA 

    cD&trbothcA cCstrcA 
    cD&trleftcA cCstrcA 
    cD&trrightcA cCstrcA 


cEcEDESCRIPTION cEcA


    The string operators operate on character strings (cD%cA or cD$cA variables), 
    performing general string manipulation, returning a string result. 

    The operators may all be abbreviated to their three letter abbreviation 
    (i.e. cD&rightcA may be expressed as cD&rigcA). In all cases the first argument is 
    completely evaluated before the second argument. 

    cD&catcA cCstr1cA cCstr2cA 
        Concatenate two string cCstr1cA with cCstr2cA to form a new string. i.e. 
        cCstr1str2cA 

    cD&lefcA cCstrcA cClencA 
        Return cClencA leftmost characters from cCstrcA. If cCstrcA length is shorter than 
        cClencA then the string itself is returned. A cClencA of zero returns the 
        empty string. 

    cD&rigcA cCstrcA cCindexcA 
        Returns the rightmost characters of string cCstrcA from index cCindexcA. This 
        function causes some confusion, consider cD&lefcA and cD&rigcA to be the 
        string equivalents of their integer counterparts ls&abs(4)lm&divle and ls&abs(4)lm&modle; cD&rigcA 
        returns the remainder of the equivalent cD&lefcA function. Invocation with 
        cCindexcA set to zero returns cCstrcA. 

    cD&midcA cCindexcA cClencA 
        Extracts a sub-string from string cCstrcA, starting at position cCindexcA of 
        length cClencA. 

    cD&lencA cCstrcA 
        Returns the integer length of the string (number of characters). 

    cD&slowercA cCstrcA 
        Returns the given string with all upper case characters converted to 
        lower case. 

    cD&suppercA cCstrcA 
        Returns the given string with all lower case characters converted to 
        upper case. 

    cD&trbothcA cCstrcA 
        Returns the given string trimmed of white spaces (i.e. 'cG cA', 'cG\tcA', 
        'cG\rcA', 'cG\ncA', 'cG\ClcA' and 'cG\CkcA') from both sides of the string. 

    cD&trleftcA cCstrcA 
        Returns the given string trimmed of white spaces from the left side of 
        the string only. 

    cD&trrightcA cCstrcA 
        Returns the given string trimmed of white spaces from the right side, 
        or end, of the string only. 

    Evaluation of the strings is left to right, the leftmost argument is fully 
    evaluated before the next argument. The operator ordering is prefix 
    notation (see lslm&add(4)le for an example of prefix ordering). 


cEcEEXAMPLE cEcA


    Concatenate two strings cGabccA and cGdefcA together:- 
sB
        set-variable %result &cat "abc" "def" 

sA
    To concatenate three strings cGabccA, cGdefcA cGghicA together: 
sB
        set-variable %result &cat "abc" &cat "def" "ghi" 

sA
    or, a slightly different ordering: 
sB
        set-variable %result &cat &cat "abc" "def" "ghi" 

sA
    Retrieve the leftmost character of a string variable, modify the variable 
    to contain the remainder. 
sB
        set-variable %foo "abcdef" 
        set-variable %c   &lef %foo 1 
        set-variable %foo &rig %foo 1 

sA
    Where cG%ccA = "cGacA"; cG%foocA = "cGbcdefcA" following evaluation. 

    To retrieve the characters cGcdecA into variable cG%resultcA from the string 
    "cGabcdefcA" use: 
sB
        set-variable %result &mid "abcdef" 2 3 

sA
    To retrieve the rightmost character from the string: 
sB
        set-variable %foo "abcdef" 
        set-variable %result &rig %foo &sub &len %foo 1 

sA
    or the same result could be achieved using cD&midcA: 
sB
        set-variable %result &mid %foo &sub &len %foo 1 1 

sA
    To get an input string from the user which is free of spaces at the start 
    and end: 
sB
        set-variable %result &trb @ml "Enter string" 

sA

cEcENOTES cEcA


    The original cDMicroEMACScA "cD&rigcA cCstrcA cCncA" function returns the last cCncA 
    characters from the string cCstrcA this differs from the definition of cD&rigcA in 
    this implementation. As most string decomposition is performed left to 
    right, and to make cD&lefcA and cD&rigcA complement each other, the indexing of 
    the function has been modified. 


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sin(4)le, lslm&sequal(4)le, lslm&lget(4)le, lslm&sprintf(4)le. 

! 4 &and
! 4 &or
! 4 &not
!44 &equal
!44 &great
!44 &less
cEcENAME cEcA


    &and, &or, &not, &equal, &sequal - Logical macro operators 


cEcESYNOPSIS cEcA


    cD&andcA cClog1cA cClog2cA 
    cD&orcA cClog1cA cClog2cA 
    cD&notcA cClogcA 

    cD&equalcA cCnum1cA cCnum2cA 
    cD&greatcA cCnum1cA cCnum2cA 
    cD&lesscA cCnum1cA cCnum2cA 


cEcEDESCRIPTION cEcA


    The logical testing operators perform comparison tests, returning a 
    boolean value of cGTRUEcA (1) or cGFALSEcA (0). 

    The functions may all be abbreviated to their three letter abbreviation 
    (i.e. cD&greatcA may be expressed as cD&grecA). In all cases the first argument is 
    completely evaluated before the second argument. Logical operators 
    include:- 

    cD&and cAcClog1cA cClog2cA 
        cGTRUEcA if the logical arguments cClog1cA and cClog2cA are both cGTRUEcA. 

    cD&orcA cClog1cA cClog2cA 
        cGTRUEcA if either one of the logical arguments cClog1cA and cClog2cA are cGTRUEcA. 

    cD&notcA cClogcA 
        Logical NOT. Returns the opposite logical value to cClogcA. 

    The numerical logical functions operate with integer arguments: 

    cD&equalcA cCnum1cA cCnum2cA 
        cGTRUEcA. If numerical arguments cCnum1cA and cCnum2cA numerically equal. 
        Abbreviated form of the function is cD&equcA. 

    cDgreatcA cCnum1cA cCnum2cA 
        cGTRUEcA. If numerical argument cCnum1cA is greater than cCnum2cA. Abbreviated 
        form of the function is cD&grecA. 

    cD&lesscA cCnum1cA cCnum2cA 
        cGTRUEcA. If numerical argument cCnum1cA is less than cCnum2cA Abbreviated form of 
        the function is cD&lescA. 

    Evaluation of the logical operators are left to right, the leftmost 
    argument is fully evaluated before the next argument. The operator 
    ordering is prefix notation (see lslm&add(4)le for an example of prefix 
    ordering). 


cEcEEXAMPLE cEcA


    Test for integers in the range greater than 12: 
sB
        !if &great %i 12 
            ... 

sA
    Test for integers in the range 8-12, inclusive 
sB
        !if &and &great 7 &less 13 
            ... 

sA

cEcENOTES cEcA


    MicroEmacs always evaluates all arguments operators BEFORE the result is 
    obtained, this differs from most programming languages. Consider the 
    following example: 
sB
        !if &and &bmod "edit" &iseq @mc1 "Save buffer first [y/n]? " "nNyY" "y" 
            save-buffer 
        !endif 

sA
    This would not not work as the user may expect, the user would be prompted 
    to save every time regardless of whether the buffer has been changed. 
    Instead the following should be used: 
sB
        !if &bmod "edit" 
            !if &iseq @mc1 "Save buffer first [y/n]? " "nNyY" "y" 
                save-buffer 
            !endif 
        !endif 

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&add(4)le, lslm&sequal(4)le, lslm&sin(4)le, lslm&cond(4)le. 

!44 &sprintf
cEcENAME cEcA


    &sprintf - Formatted string construction 


cEcESYNOPSIS cEcA


    cD&sprintfcA cCformatcA cCargscA 


cEcEDESCRIPTION cEcA


    The cD&sprintfcA function (or cD&sprcA in it's abbreviated form) provides a 
    mechanism to generated a formatted string, similar to the 'C' programming 
    language cDsprintf(2)cA function. 

    The cD&sprintfcA function is generally used where a number of different 
    sources of information have to be converted and joined together to form a 
    new string. It is possible to do this using lslm&cat(4)le, but it does become 
    complicated if the number of strings to be spliced together is greater 
    than about 4, cDsprintfcA alleviates these problems and results in faster 
    execution. Where only two, or three strings are to be concatenated cD&catcA 
    provides better execution times. 

    The cD&sprintfcA function produces a string construct for the cCformatcA and a 
    caller determined number of arguments cCargscA (variable arguments). The 
    cCformatcA string may contain special 'cD%cA' formatting commands to insert 
    strings and numbers into the base cCformatcA string. The format for the 'cD%cA' 
    commands is "cD%nccA" where:- 

    cDncA 
        An optional numerical argument, the interpretation of the numeric 
        value is determined by the following command (cDccA). 

    cDccA 
        The command determines the interpretation of the next argument cCargcA 
        which are specified as follows: 

        cDdcA (Decimal integer) 
            Expects a single numeric argument cCargcA which is inserted into the 
            cCformatcA string as decimal text string. If cCncA is specified then the 
            inserted text string is fixed to cCncA character in length. 

        cDncA (Repeat String) 
            Expects two arguments cCargcA, the first is a numeric argument giving 
            the number of times to insert the given string (the second 
            argument). If cCncA is specified then the string is inserted cCncA * 
            cCnumeric-argumentcA times. 

        cDscA (String) 
            Expects a single argument cCargcA which is a string to be inserted 
            into the key. If cCncA is given then it is insertedcCncA times. 

        cDxcA (Hexadecimal integer) 
            Expects a single numeric argument cCargcA which is inserted into the 
            format string as hexadecimal text string. If cCncA is given then the 
            inserted text string will be fixed to cCncA character in length. 

        cD%cA 
            Inserts a single '%', cCncA has no effect. 

        The cD&sprintfcA function may be nested (i.e. a string argument to 
        cD&sprintfcA may be the result of another cD&sprintfcA invocation). Although 
        this type of construct is not generally required !! 


cEcEEXAMPLE cEcA


    The following examples show how the command may be used:- 
sB
        set-variable %result &sprintf "Foo [%s%s]" "a" "b" 

sA
    generates "cGFoo [ab]cA" 
sB
        set-variable %result &sprintf "Foo [%n%s]" 10 "a" "b" 

sA
    generates "cGFoo [aaaaaaaaaab]cA". 
sB
        set-variable %result &sprintf "[%d] [%3d] [%x] [%3x]" 10 11 12 13 

sA
    generates "cG[10] [ 11] [c] [  d]cA" 


cEcENOTES cEcA


    It is the callers responsibility to ensure that the correct number of 
    arguments is supplied to match the requested formatting string. The 
    results are undefined if an incorrect number of arguments are supplied. 


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&cat(4)le. 

!44 &atoi
!44 &itoa
!44 &gmode
!44 &bmode
!44 &nbmode
!44 &inword
!44 &indirect
!44 &exist
cEcENAME cEcA


    &ato, &gmod, &bmo, &ind, &inw, &exi - Miscellaneous functions 


cEcESYNOPSIS cEcA


    cD&atoicA cCcharcA 
    cD&itoacA cCnumcA 

    cD&gmodecA cCmodecA 
    cD&bmodecA cCmodecA 
    cD&nbmodecA cCbuffercA cCmodecA 
    cD&inwordcA cCcharcA 

    cD&indirectcA cCstrcA 

    cD&existcA cCstrcA 


cEcEDESCRIPTION cEcA


    These are a selection of miscellaneous functions providing tests and 
    exchanging of information. 

    The functions may all be abbreviated to their three letter abbreviation 
    (i.e. cD&indirectcA may be expressed as cD&indcA). In all cases the first argument 
    is completely evaluated before the second argument. 

    cD&atoicA cCcharcA 
        Converts the given character cCcharcA to it's ASCII number which is 
        returned. (see cD&itoacA). Abbreviated command is cD&atocA. 

    cD&itoacA cCnumcA 
        Converts an integer cCnumcA to it's ASCII character representation which 
        is returned to the caller. Abbreviated command is cD&itocA. 

    cD&gmodecA cCmodecA 
        Returns cG1cA if the given mode cCmodecA is globally enabled. Allows macros to 
        test the global mode state (see lslmOperating Modesle). Abbreviated command 
        is cD&gmocA. 

    cD&bmodecA cCmodecA 
        Returns cG1cA if the mode cCmodecA is enabled in the current buffer. Allows 
        macros to test the state of the buffer mode. Abbreviated command is 
        cD&bmocA. 

    cD&nbmodecA cCbuffercA cCmodecA 
        Returns cG1cA if the mode cCmodecA is enabled in buffer cCbuffercA . Allows macros 
        to test the state of a buffer mode other than the current. Abbreviated 
        command is cD&nbmcA. 

    cD&inwordcA cCcharcA 
        cGTRUEcA. If the given character cCcharcA is a 'word' character, see 
        lslmforward-word(2)le for a description of a 'word' character. Abbreviated 
        command is cD&inwcA. 

    cD&indirectcA cCstrcA 
        Evaluate cCstrcA as a variable. The cCstrcA argument is evaluated and takes 
        the resulting string, and then uses it as a variable name. i.e. a 
        variable may reference another variable which contains the data to be 
        referenced. Abbreviated command is cD&indcA. 

    cD&existcA cCstrcA 
        Tests for the existance of cCstrcA which may be a variable or a 
        command/macro name, returning cGTRUEcA if the variable or command does 
        currently exist. Abbreviated command is cD&exicA. 


cEcEEXAMPLE cEcA


    The cD&exicA function is etremely useful in initializing, for example: 
sB
        !if &not &exi %my-init 
            ; %my-init is not yet defined so this is the first call 
            set-variable %my-init 1 
            . 
            . 

sA
    Or in all the lsfileHooks(2)lmfile hooksle a user defined extension is checked for and 
    executed if defined: 
sB
        define-macro fhook-c 
            . 
            . 
            ; execute user extensions if macro is defined 
            !if &exi my-fhook-c 
                my-fhook-c 
            !endif 
        !emacro 

sA
    The cD&indcA function deserves more explanation. cD&indcA evaluates its string 
    argument cCstrcA, takes the resulting string and then uses it as a variable 
    name. For example, given the following code sequence: 
sB
        ; set up reference table 

        set-variable  %one "elephant" 
        set-variable  %two "giraffe" 
        set-variable  %three "donkey" 

        set-variable  %index "%two" 
        insert-string &ind %index 

sA
    the string "cGgiraffecA" would have been inserted at the point in the current 
    buffer. 

    The cD&bmodecA invocation allows a calling macro to determine the buffer mode 
    state (see lslmOperating Modesle). Consider the following example which is a 
    macro to perform a case insensitive alphabetic sort using the 
    lslmsort-lines(2)le function. cDsort-listcA sorts according to the state of the 
    lslmexact(2m)le mode, hence the macro has to determine the buffer state in order 
    to be able to do the sort. 
sB
        define-macro sort-lines-ignore-case 
            set-variable #l0 &bmod exact 
            -1 buffer-mode "exact" 
            !if @? 
                @# sort-lines 
            !else 
                sort-lines 
            !endif 
            &cond #l0 1 -1 buffer-mode "exact" 
        !emacro 

sA
    The cD&inwordcA function is shown in the following example. In this case the 
    mouse is positioned over a word. The cD&inwordcA function is used to determine 
    if the cursor is on a valid word character, if so the cursor is placed at 
    the start of the word. 
sB
        define-macro mouse-control-drop-left 
            set-cursor-to-mouse 
            !if &inword @wc 
                backward-word 
                set-mark 
                forward-word 
            !else 
                ... 
            !endif 
            copy-region 
            set-cursor-to-mouse 
        !emacro 

sA

cEcESEE ALSO cEcA


    lslmOperating Modesle, lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sprintf(4)le, lslm&equal(4)le. 

!44 !emacro
!44 !ehelp
cEcENAME cEcA


|!emacro
    !emacro - Terminate a macro definition 
|!ehelp
    !ehelp - Terminate a help definition 


cEcESYNOPSIS cEcA


    lsdefine-macro(2)lmdefine-macrole cCmacro-namecA 

        cC... macro body ...cA 

    cD!emacrocA 
    lsdefine-help(2)lmdefine-helple cCitem-namecA 

        cC... help body ...cA 

    cD!ehelpcA 


cEcEDESCRIPTION cEcA


    cD!emacrocA terminates the storage of an open macro, (opened with 
    lslmdefine-macro(2)le). Only the lines between cDdefine-macrocA and the cD!emacrocA 
    directive comprise the new macro cCmacro-namecA. 

    Similarly cD!ehelpcA terminates the storage of an open help definition, 
    (opened with lslmdefine-help(2)le). Only the lines between cDdefine-helpcA and the 
    cD!ehelpcA directive comprise the new help text for item cCitem-namecA. 

    cD!emacrocA and cD!ehelpcA may not be used in any other context. 


cEcEEXAMPLE cEcA


    For example if a file is being executed contains the text: 
sB
        ; 
        ; Read in a file in view mode, and make the window red 
        ; 
        define-macro view-a-file 
            find-file @ml"File to view: " 
            1 buffer-mode "view" 
            set-variable $buffer-bcol %red 
        !emacro 

        define-help view-a-file 
            This is the help text for the macro view-a-file. 
        !ehelp 

        ml-write "[view-a-file macro has been loaded]" 

sA
    then only the lines between the cDdefine-macrocA command and the cD!emacrocA 
    directive are stored in macro cCview-a-filecA and the lines between the 
    cDdefine-helpcA command and the cD!ehelpcA directive are stored as help for 
    cCview-a-filecA. The lsml-write(2)lmml-writele line is executed when the file is loaded, and 
    the message will appear on the message line, this does not however form 
    part of the macro or help. 


cEcESEE ALSO cEcA


    lslmOperating Modesle, lslmdefine-macro(2)le, lslmdefine-help(2)le. 

!44 !force
cEcENAME cEcA


    !force - Ignore command or macro status 


cEcESYNOPSIS cEcA


    cD!forcecA [cCncA] cCcommandcA 


cEcEDESCRIPTION cEcA


    cD!forcecA ignores the return status of a cCcommandcA while executing a macro. 
    When MicroEmacs '02 executes a macro, if any command fails, the macro is 
    terminated at that point. If a line is preceded by a cD!forcecA directive, 
    execution continues whether the command succeeds or not. lslm$status(5)le may be 
    used following cD!forcecA to determine if the command failed or not. 

    A double cD!forcecA can be used to catch a user termination (via the 
    lslmabort-command(2)le bound to cGC-gcA). A macro command aborted by the user will 
    be terminated even with a single !force directive, but not with two. See 
    the example below. 

    When specifying a numerical argument with a cCcommandcA, it is placed after 
    the cC!forcecA directive and before the cCcommandcA i.e. 
sB
        !force 1 forward-char 

sA

cEcEEXAMPLE cEcA


    The following example shows how cD!forcecA is used in conjunction with 
    cD$statuscA. 
sB
        ; Merge the top two windows 

        push-position           ;remember where we are 
        1 next-window           ;go to the top window 
        delete-window           ;merge it with the second window 
        !force pop-position     ;This will continue regardless 
        !if $status 
            ml-write "Call PASSED" 
        !else 
            ml-write "Call FAILED" 
        !endif 


    The following example creates an infinite loop that can only be broken out 
    of by a user abort. The calling macro catches this by using a double 
    cD!forcecA and continues. This concept is used by commands which take a 
    considerable amount of time yet cannot be simply aborted by the user such 
    as the spell-checker's best guess list generator. 

        define-macro infinite-loop 
            set-variable #l0 1 
            !while 1 
                ml-write &cat "In loop, C-g to exit: " &pinc #l0 1 
            !done 
        !emacro 

        define-macro catch-abort 
            !force !force infinite-loop 
            ml-write "You will see this" 
        !emacro 

sA

cEcESEE ALSO cEcA


    lslm$status(5)le. 

! 4 !if
!44 !else
!44 !elif
!44 !endif
cEcENAME cEcA


    !if, !elif, !else, !endif - Conditional statements 


cEcESYNOPSIS cEcA


    cD!ifcA cCconditioncA 
        cC... condition body ...cA 
    [cD!elifcA cCconditioncA 
        cC... condition body ...cA 
    ] 
    [cD!elsecA 
        cC... condition body ...cA 
    ] 
    cD!endifcA 


cEcEDESCRIPTION cEcA


    The conditional directives allow statements to be executed only if a 
    condition specified in the directive is met, as follows:- 

        * Every line following the cD!ifcA directive, until the first cD!elifcA, cD!elsecA 
          or cD!endifcA directive, is only executed if the expression following 
          the cD!ifcA directive evaluates to a cGTRUEcA value (non-zero). 

        * If the cD!ifcA evaluates to cGFALSEcA and a cD!elifcA directive is next then the 
          expression following the cD!ifcA is evaluated and following statements 
          are executed if cGTRUEcA. 

        * If no cD!ifcA or cD!elifcA is found to be cGTRUEcA and a cD!elsecA is found then the 
          statements following it are executed. 

    The cCconditioncA may be any logical condition as evaluated by the lsIntroduction to Variable Functionslmvariableln
    lnfunctionsle (e.g. lslm&equal(4)le) returning cGTRUEcA or cGFALSEcA. An integer value, 
    non-zero evaluates cGTRUEcA, zero evaluates to cGFALSEcA. A non-numerical 
    argument, such as a string is always cGFALSEcA. 

    The cCconditional bodycA may be any cDMicroEmacs '02cA function, macro or 
    directive with the exception of cDdefine-macrocA and cD!emacrocA. All directives 
    that alter the execution of the macro are handled correctly within the cD!ifcA 
    statement (e.g. ls!goto(4)lm!gotole, ls!return(4)lm!returnle etc. 


cEcEEXAMPLE cEcA


    The following macro segment creates the portion of a text file 
    automatically. (yes believe me, this will be easier to understand then 
    that last explanation....) 
sB
        !if &sequal %curplace "timespace vortex" 
            insert-string "First, rematerialize\n" 
        !endif 
        !if &sequal %planet "earth" ;If we have landed on earth... 
            !if &sequal %time "late 20th century"  ;and we are then 
                ml-write "Contact U.N.I.T." 
            !elif &sequal %time "pre 20th century" 
                ml-write "start praying for a miracle" 
            !else 
                insert-string "Investigate the situation....\n" 
                insert-string "(SAY 'stay here Sara')\n" 
            !endif 
        !else 
            set-variable %conditions @ml"Atmosphere conditions outside? " 
            !if &sequal %conditions "safe" 
                insert-string &cat "Go outside......" "\n" 
                insert-string "lock the door\n" 
            !else 
                insert-string "Dematerialize..try somewhere else" 
                newline 
            !endif 
        !endif 

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Fuctionsle, lslm!goto(4)le, lslm&equal(4)le, lslm!return(4)le, lslm$status(5)le. 

!44 !goto
!44 !tgoto
cEcENAME cEcA


|!goto
    !goto - Unconditional labeled jump 
|!tgoto
    !tgoto - Conditional labeled jump 


cEcESYNOPSIS cEcA


    cD!gotocA cClabelcA 
        ... 
    cD*cAcClabelcA 

    cD!tgotocA cCconditioncA cClabelcA 
        ... 
    cD*cAcClabelcA 


cEcEDESCRIPTION cEcA


    Flow can be controlled within a MicroEmacs '02 macro using the cD!gotocA 
    directive. It takes as an argument a cClabelcA. A cClabelcA consists of a line 
    starting with an asterisk (cD*cA) and then an alphanumeric label. Only labels 
    in the currently executing macro can be jumped to, trying to jump to a 
    non-existing label terminates execution of a macro. cClabelscA may be located 
    at any position within the macro (forwards or backwards from the cD!gotocA). 

    A conditional jump may be implemented with a cD!tgotocA, this takes an 
    additional argument cCconditioncA, which may be a literal numeric value, a 
    variable or an evaluated expression (see lsIntroduction to Variable FunctionslmVariable Functionsle). If the 
    cCconditioncA evaluates to TRUE (or non-zero) then the branch is taken and 
    control continues from the cClabelcA. 

    cD!tgotocA is an ideal replacement for lslm!while(4)le and lslm!repeat(4)le where nested 
    loops are required. 


cEcEEXAMPLE cEcA


    For example, create a block of DATA statements for a BASIC program: 
sB
                insert-string "1000 DATA " 
                set-variable %linenum 1000 
        *nxtin 
                screen-update           ;make sure we see the changes 
                set-variable %data @ml"Next number: " 
                !if &equal %data 0 
                    !goto finish 
                !endif 
                !if &greater $curcol 60 
                    2 backward-delete-char 
                    newline 
                    set-variable %linenum &add %linenum 10 
                    insert-string &cat %linenum " DATA " 
                !endif 
                insert-string &cat %data ", " 
                !goto nxtin 
        *finish 
                2 backward-delete-char 
                newline 

sA
    Not that any of us are writing basic programs these days !! 


cEcENOTES cEcA


    cD!gotocA and cD!tgotocA are expensive operations because a symbolic name lookup 
    is performed in the macro file. For time critical macros then the lslm!jump(4)le 
    and lslm!tjump(4)le directives should be used as these do not perform a symbolic 
    name search. The cCjumpcA equivalents are source sensitive since a line 
    displacement rather than a cClabelcA is used - this makes them a little 
    dangerous to use. 


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm!if(4)le, lslm!jump(4)le, lslm!repeat(4)le, lslm!return(4)le, lslm!tjump(4)le, 
    lslm!while(4)le. 

!44 !return
!44 !abort
cEcENAME cEcA


    !return, !abort - Exit macro 


cEcESYNOPSIS cEcA


    cD!returncA [cCncA] 
    cD!abortcA [cCncA] 


cEcEDESCRIPTION cEcA


    The cD!returncA directive causes the current macro to exit with a cGTRUEcA status, 
    either returning to the caller (if any) or to interactive mode. If an 
    argument cCncA is specified then the return status is determined by the value 
    of cCncA. 

    cD!abortcA has the same effect as cD!returncA only always returning a cGFALSEcA status 
    to halt the execution of any calling macro. If an argument cCncA is given to 
    cD!abortcA the bell is also rung, the valid values of cGncA are the same as for 
    the lslm!bell(4)le directive. 


cEcEEXAMPLE cEcA


    The following example checks the current language and warns if it has not 
    be set, i.e. cGDefaultcA. 
sB
        ; Check the current language 

        !if &not &seq %language "Default" 
            !return 
        !endif 
        ml-write "Warning - you have not setup the Language - use user-setup" 

sA
    The following example is shows the logic of the cD!returncA directive:- 

sB        ; !return example 
        define-macro i-will-return 
            ml-write "you will see me" 
            !return 
            ml-write "you wont see me" 
        !emacro 

        define-macro test-return 
            ml-write "you will see me" 
            i-will-return 
            ml-write "you will see me" 
        !emacro 

sA
    Similarly, for the cD!abortcA directive 
sB
        ; !abort example 
        define-macro i-will-abort 
            ml-write "you will see me" 
            !abort 
            ml-write "you wont see me" 
        !emacro 

        define-macro test-abort 
            ml-write "you will see me" 
            i-will-abort 
            ml-write "you wont see me" 
        !emacro 

sA
    For the last two examples above, all the "cDwillcA"s are displayed and none of 
    the "cDwontcA"s are. 


cEcESEE ALSO cEcA


    lslmdefine-macro(2)le, lslm!bell(4)le, lslm!if(4)le, lslm!goto(4)le. 

!44 !while
!44 !continue
!44 !done
cEcENAME cEcA


    !while, !continue, !done - Conditional loop 


cEcESYNOPSIS cEcA


    cD!whilecA cCconditioncA 
        ... loop body ... 
        [cD!continuecA] 
    cD!donecA 


cEcEDESCRIPTION cEcA


    The cD!whilecA directive allows statements only to be executed if a cCconditioncA 
    specified in the directive is met. Every line following the cD!whilecA 
    directive, until the first cD!donecA directive, is only executed if the 
    expression following the cD!whilecA directive evaluates to a cGTRUEcA value. 

    A cD!continuecA may be used in the loop, this immediately returns control to 
    the cD!whilecA statement and skips the rest of the section. 

    cD!while statement may not be nested.cA That is, only one cD!whilecA statement may 
    be outstanding at a time, a lslm!repeat(4)le statement may be used within the 
    cD!whilecA to create an inner loop if required. Alternatively the lslm!goto(4)le 
    used in conjunction with the lslm!if(4)le statement may be used to construct 
    loops. 


cEcEEXAMPLE cEcA


    For example, the following macro segment fills to the fill column with 
    spaces. 
sB
        !while &less $curcol $fill-col 
            insert-string " " 
            !if &equal %example "1"     ; Silly to show continue 
                !continue               ; Goto !while 
            !endif 
            ml-write "You wont see me if %example = 1" 
        !done 

sA

cEcESEE ALSO cEcA


    lslm!if(4)le, lslm!goto(4)le, lslm!repeat(4)le. 

!44 !repeat
!44 !until
cEcENAME cEcA


    !repeat, !until - Conditional loop (post testing) 


cEcESYNOPSIS cEcA


    cD!repeatcA 
        ... loop body ... 
    cD!untilcA cCconditioncA 


cEcEDESCRIPTION cEcA


    Th cD!repeatcA command operates in a similar fashion to ls!while(4)lm!while/!donele except 
    the condition is tested at the end. Control finishes if the condition is 
    met. As with the lslm!while(4)le there is no nesting of multiple cD!repeatcA 
    statements. 


cEcEEXAMPLE cEcA


    For example, the following macro segment fills to the fill column with 
    spaces. 
sB
        !repeat 
            insert-string " " 
        !until &equal $curcol $fill-col 

sA

cEcESEE ALSO cEcA


    lslm!if(4)le, lslm!goto(4)le, lslm!repeat(4)le. 

!44 !bell
cEcENAME cEcA


    !bell - Sound audio alarm 


cEcESYNOPSIS cEcA


    cD!bellcA [cCncA] 


cEcEDESCRIPTION cEcA


    cD!bellcA gives a warning (audible or visual) to alert the user of a problem. 
    cD!bellcA honors the lslmquiet(2m)le mode, as such if cDquietcA mode is disabled an 
    audible warning is given, otherwise a visual warning is given to the user 
    (usually the message "cC[BELL]cA" in the bottom left hand corner). 

    The optional numerical argument cCncA can be used to over-ride the current 
    setting of the cDquitecA, a value of cG0cA specifies a quite bell, cG2cA an audible 
    one, when omitted the default is cG1cA for honoring the quite mode. 

    cD!bellcA is generally used in conjunction with ls!return(4)lm!abortle, the !bell function 
    warning the user and the !abort function to quit the macro. 


cEcEEXAMPLE cEcA


    The following example checks for incoming mail and is taken from mail.emf. 
    If any mail has arrived an audible warning is assured by toggling the 
    cDquietcA mode. 
sB
        ; 
        ; Mail checker 
        define-macro mail-check 
            !if &seq &set %vm-mail-src &reg "/history" &cat $platform "/mail-src" "" "" 
                ml-write "[Incoming mail file not setup! Use Help/User setup]" 
                !abort 
            !endif 
            600000 create-callback mail-check 
            ml-write &spr "Checking for mail in %s..." %vm-mail-src 
            set-variable #l0 &cond &gre &stat "s" %vm-mail-src 0 "M" "-" 
            !if &not &seq &mid $mode-line 2 1 #l0 
                set-variable #l1 &rig $mode-line &cond &seq &mid $mode-line 2 1 "%" 4 3 
                set-variable $mode-line &cat &cat &lef $mode-line 2 #l0 #l1 
                screen-update 
                !if &seq #l0 "M" 
                    ; use no argument to the global-mode so it toggles it back to its original state 
                    !bell 
                    global-mode "quiet" 
                    !bell 
                    global-mode "quiet" 
                !endif 
            !endif 
            ml-clear 
        !emacro 

sA

cEcESEE ALSO cEcA


    lslm!abort(4)le, lslmabort-command(2)le, lslmquiet(2m)le. 

! 4 MacroArguments
! 4 @?
! 4 @#
! 4 @0
! 4 @1
! 4 @2
! 4 @p
cEcENAME cEcA


    @?, @#, @0, @1, @2, @3, ... @p - Macro arguments 


cEcESYNOPSIS cEcA


    cD@?cA - Boolean flagging if a numeric argument was supplied 
    cD@#cA - The value of the numeric argument 

    cD@0cA - The name of the macro 
    cD@1cA - The first argument of macro 
    cD@2cA - The second argument of macro 
    cD@3cA ... cD@cAcCncA 

    cD@pcA - The name of the calling (or parent) macro. 


cEcEDESCRIPTION cEcA


    Macros may be passed arguments, allowing a macro to be used by other 
    macros. The cD@?cA and cD@#cA are used to determine the numeric argument given to 
    the command. The cD@cAcCncA variable (where cCncA is an integer) used in the context 
    of a macro allows the macro body to determine it's arguments. 

    From a macro all commands are called in the following form 

        [num] <macro-name> "arg1" "arg2" .... 


    When executed macros do not have to be given an argument, in this case cD@?cA 
    will be cC0cA and cD@#cA will be cC1cA (the default argument). If an argument is given 
    then cD@?cA will be cC1cA and cD@#cA will be set to the numeric argument given. 

    The current macro command name cC<macro-name>cA can be obtain by using the cD@0cA 
    variable, e.g. 
sB
        define-macro Test-it 
            ml-write @0 
        !emacro 

sA
    When executed, writes the message "cGTest-itcA" which is the name of the 
    macro. 

    Arguments may be passed into macro commands in the same way as standard 
    commands are given arguments. The macro being called can access these by 
    the cD@1cA to cD@ncA variables, where cCncA is a positive integer. Any variables given 
    as arguments are evaluated so if the variable name is required then 
    enclose it in quotes, e.g. 
sB
        set-variable %test-var "Hello World" 

        efine-macro Test-it 
            ml-write &cat &cat &cat &cat @0 " " @1 " = " &ind @1 
            set-variable  @1 @2 
        !emacro 

        Test-it "%test-var" "Goodbye World" 

sA
    On execution the macro writes the message 

        "cGTest-it %test-var = Hello WorldcA" 

    and will set variable cG%test-varcA to "cGGoodbye WorldcA". 

    The cD@pcA variable can be used to obtain the name of the macro which is 
    executing the current macro, i.e. the value of the parent's cD@0cA variable. 
    If the macro was executed directly by the user then there is no parent 
    macro and the value of cD@pcA is an empty string (""). 


cEcEDIAGNOSTICS cEcA


    If an attempt is made to access an argument which has not been given then 
    a error occurs. This error can be trapped using the lslm!force(4)le directive, 
    enabling the macro to take appropriate action, see example. 


cEcEEXAMPLE cEcA


    Consider the implementation of lslmreplace-all-string(3)le macro defined in 
    search.emf: 
sB
        define-macro replace-all-string 
            !force set-variable #l0 @3 
            !if &not $status 
                set-variable #l1 @ml05 "Replace all" 
                set-variable #l2 @ml05 &spr "Replace [%s] with" #l1 
                set-variable #l0 @ml00 "In files" 
            !else 
                set-variable #l1 @1 
                set-variable #l2 @2 
            !endif 
            . 
            . 
            . 
        !emacro 

sA
    In this example if the 3rd argument is not given then the macro gets all 
    arguments from the user. 

    The cD@pcA variable having a value of "" when a macro is called directly by 
    the user can be useful when determining the amount of information to 
    feed-back to the user. For example, executing the lsclean(3)lmcleanle macro is an easy 
    way to remove surplus white characters, so it is often used by other 
    macros as well as by the user. When called directly cDcleancA refreshes the 
    display and prints a message of completion, but when called by other 
    macros this would cause an unwanted screen-update and message, so clean 
    only does this when executed by the user. This is done as follows: 
sB
        define-macro clean 
            ; 
            ; Prepare to clean up file. 
            . 
            . 
            . 
            !if &seq @p "" 
                screen-update 
                ml-write "[Cleaned up buffer]" 
            !endif 
        !emacro 

sA

cEcENOTES cEcA


    The parsing of arguments can be inefficient because of the way the 
    arguments have to be parsed; to get the 4th argument the 1st, 2nd and 3rd 
    arguments must be evaluated. This is because each argument is not 
    guaranteed to be only one element, it could be an expression which needs 
    to be evaluated. Consider the following invocation of our Test-it macro 
sB
        Test-it &cat "%test" "-var" "Goodbye World" 

sA
    The 2nd argument is not cC"%test"cA as this is part of the first argument, the 
    2nd argument is in fact the 4th element and the invocation will have the 
    same effect except slower. 


cEcESEE ALSO cEcA


    lsMacroNumericArguments(4)lmMacroNumericArgumentsle, lslmdefine-macro(2)le, lslmreplace-all-string(3)le, lslm!force(4)le. 

! 4 MessageLineVaraibles
! 4 @mn
! 4 @mna
! 4 @ml
! 4 @mc
! 4 @mx
! 4 @mxa
cEcENAME cEcA


    @mn, @mna, @ml, @mc, @mx, @mxa - Message line input 


cEcESYNOPSIS cEcA


    cD@mncA 
    cD@mnacA 
    cD@mlcA[cCfcA][cChcA] "cCpromptcA" ["cCdefaultcA"] ["cCinitialcA"] ["cCcom-listcA"] ["cCbuffer-namecA"] 
    cD@mccA[cCfcA] cCpromptcA [cCvalid-listcA] 
    cD@mxcA "cCcommand-linecA" 
    cD@mxacA "cCcommand-linecA" 


cEcEDESCRIPTION cEcA


    The cDMessage Line VariablescA provide a method to prompt the user for an 
    input returning the data to the caller. The cD@mncA variable cause MicroEmacs 
    to input data from the user in the default way for that command's 
    argument, i.e. the normal prompt with the normal history and completion 
    etc. Similarly cD@mnacA causes MicroEmacs to input the current argument and 
    any subsequent arguments in the default way. 

    The cD@mlcA variable can be used to get a string (or Line) of text from the 
    user using the message-line in a very flexible way. The first optional 
    flag cDfcA is a bitwise flag where each bit has the following meaning 

    cG0x01cA 
        The cCdefaultcA value will be specified and this will be returned by 
        default. 

    cG0x02cA 
        The cCinitialcA value will be specified and this will be initial value 
        given on the input line. 

    cG0x04cA 
        Auto-complete using the initial value, usually used with bit cG0x02cA. 

    cG0x08cA 
        Hide the input string, the characters in the current input string are 
        all displayed as cG'*'cAs. 

    If no value is specified then default value is 0 and cDhcA can not be 
    specified. The cCdefaultcA value is returned when the user enters an empty 
    string. If the cCinitialcA string is specified the the input buffer will be 
    initialized to the given string instead of and empty one. 

    The flag cDhcA specifies what type of data is to be entered, this specifies 
    the history to be used and the semantics allowed, cDhcA can have the following 
    values 

        cG0cA For a general string input using the general history. 
        cG1cA For an absolute file name, with completion and history. 
        cG2cA For a MicroEmacs '02 buffer name, with completion and history. 
        cG3cA For a MicroEmacs '02 command name, with completion and history. 
        cG4cA For a file name, with completion and history. 
        cG5cA For a search string, with history. 
        cG6cA For a MicroEmacs '02 mode name, with completion and history. 
        cG7cA For a MicroEmacs '02 variable name, with completion and history. 
        cG8cA For a general string using no history. 
        cG9cA For a user supplied completion list (cGcom-listcA). 
        cGacA For a user supplied completion list (cGbuffer-namecA). 

    A default value of 0 is used if no value is specified. At first glance 
    type 1 and 4 appear to be the same. They differ only when a non absolute 
    file name is entered, such as "foobar". Type 1 will turn this into an 
    absolute path, i.e. if the current directory is "/tmp" then it will return 
    "/tmp/foobar". Type 4 however will return just "foobar", this is 
    particularly useful with the lslm&find(4)le directive to then find the file 
    "foobar". 

    When a value of cG9cA is used the argument cCcom-listcA must be given which 
    specifies a list of completion values in the form of a MicroEmacs list 
    (see help on lslm&lget(4)le for further information on lists). The user may 
    enter another value which is not in the list, which will be returned. 

    Alternatively a completion list may be given in the form of a buffer using 
    a value of cGacA. The argument cCbuffer-namecA must be given to specify the buffer 
    name from which to extract the completion list; each line of the buffer is 
    taken as a completion value. This option is particularly useful for large 
    completion lists as there is no size restrictions. 

    The cD@mccA variable can be used to get a single character from the user using 
    the message-line. The optional flag cDfcA is a bitwise flag where each bit has 
    the following meaning 

    cG0x01cA 
        The cCvalid-listcA specifies all valid letters. 

    cG0x02cA 
        Quote the typed character, this allows keys such as 'cGC-gcA' which is 
        bound to the abort command to be entered. 

    The default value for cDfcA is 0. When cD@mccA is used, the user is prompted, with 
    the given prompt, for a single character. If a cCvalid-listcA is specified 
    then only a specified valid character or an error can be returned. For 
    example, a yes/no prompt can be implemented by the following 
sB
        !if &iseq @mc1 "Are you bored [y/n]? " "yYnN" "y" 
            save-buffers-exit-emacs 
        !endif 

sA
    By using the lslm&isequal(4)le operator a return of "Y" or "y" will match with 
    "y". 

    When the cD@mxcA variable is used MicroEmacs sets the system variable 
    lslm$result(5)le to the input prompt, it will then execute the given 
    cGcommand-linecA. If this command aborts then so does the calling command, if 
    it succeeds then the input value is taken from the cD$resultcA variable. 
    Similarly cD@mxacA causes MicroEmacs to get the current and any subsequent 
    arguments in this way. 

    These variables are useful when trying to use existing commands in a 
    different way, such as trying to provide a GUI to an existing command. See 
    the cDdelete-buffercA example below. 


cEcEEXAMPLE cEcA


    The following example can be used to prompt the user to save any buffer 
    changes, the use of cD@mnacA ensures the user will be prompted as usual 
    regardless of the number of buffers changed: 
sB
        save-some-buffers @mna 


    The following example sets cG%languagecA to a language supplied by the user 
    from a given list, giving the current setting as a default 
sB
        set-variable %languages "|American|British|French|Spanish|" 
        set-variable %language "American" 

        set-variable %language @ml19 "Language" %language %languages 

sA
    The following example is taken from cGdiff-changescA in tools.emf, it uses cD@mccA 
    to prompt the user to save the buffer before continuing:- 
sB
        define-macro diff-changes 
            !if &seq $buffer-fname "" 
                ml-write "[Current buffer has no file name]" 
                !abort 
            !endif 
            !if &bmod "edit" 
                !if &iseq @mc1 "Save buffer first [y/n]? " "nNyY" "y" 
                    save-buffer 
                !endif 
            !endif 
                . 
                . 

sA
    Note that the input is case insensitive. The following version would not 
    work as the user may expect when the buffer has not been edited: 
sB
                . 
                . 
            !if &and &bmod "edit" &iseq @mc1 "Save buffer first [y/n]? " "nNyY" "y" 
                save-buffer 
                . 
                . 

sA
    Unlike cDCcA and other similar languages MicroEmacs macro language always 
    evaluates both cD&andcA arguments. This means that the user will be prompted 
    to save the buffer regardless of whether the buffer has been edited. 

    The cD@mxcA variables are useful when using existing commands in a new 
    environment. For example, consider providing a GUI for the 
    lslmdelete-buffer(2)le command, when executed the calling GUI may not be aware 
    that changes could be lost or a process may still be active. These 
    variables can be used as a call back mechanism to handle this problem: 
sB
        define-macro osd-delete-buffer-callback 
            !if &sin "Discard changes" $result 
                2 osd-xdialog "Delete Buffer" "  Dicard changes?  " 2 10 6 "&Yes" "&No" 
                set-variable $result &cond &equ $result 1 "y" "n" 
            !elif &sin "Kill active process" $result 
                2 osd-xdialog "Delete Buffer" "  Kill active process?  " 2 10 6 "&Yes" "&No" 
                set-variable $result &cond &equ $result 1 "y" "n" 
            !else 
                1000 ml-write &spr "[Unknown prompt %s]" $result 
                !abort 
            !endif 
        !emacro 

        define-macro osd-delete-buffer 
            . 
            . set #l0 to buffer name to be deleted 
            . 
            delete-buffer #l0 @mxa osd-delete-buffer-callback 
        !emacro 

sA

cEcESEE ALSO cEcA


    lslmdefine-macro(2)le. 

! 4 CurrentBufferVariables
! 4 @wc
! 4 @wl
cEcENAME cEcA


    @wc, @wl - Extract characters from the current buffer 


cEcESYNOPSIS cEcA


    cD@wlcA 
    cD@wccA 


cEcEDESCRIPTION cEcA


    Buffer variables are special in that they can only be queried and cannot 
    be set. Buffer variables allow text to be taken from the current buffer 
    and placed into a variable. Two types of extraction are provided cD@wlcA 
    provides a line extraction method, cD@wccA provides a character extraction 
    method. 

    For example, if the current buffer contains the following text: 

        Richmond 
        Lafayette 
        <*>Bloomington                (where <*> is the current point) 
        Indianapolis 
        Gary 
        =* me (BE..) == rigel2 == (c:/data/rigel2.txt) =================== 


    The cD@wlcA variable allows text from the current buffer to be accessed, a 
    command such as:- 
sB
        set-variable %line @wl 

sA
    would start at the current point in the current buffer and grab all the 
    text up to the end of that line and pass that back. Then it would advance 
    the point to the beginning of the next line. Thus, after the lsset-variable(2)lmset-variablele 
    command executes, the string "cGBloomingtoncA" is placed in the variable cD%linecA 
    and the buffer rigel2 now looks like this: 

        Richmond 
        Lafayette 
        Bloomington 
        <*>Indianapolis               (where <*> is the current point) 
        Gary 
        =* me (BE..) == rigel2 == (c:/data/rigel2.txt) =================== 


    The buffer command cD@wccA gets the current character in the buffer, it does 
    not change the buffer position. It is important to stress that the cursor 
    position is not modified, in general a macro will interrogate the 
    character under the cursor and then affect the buffer (i.e. by moving the 
    cursor, deleting the character etc.) dependent upon the value of the 
    character returned. 


cEcEEXAMPLE cEcA


    The cD@wccA variable provides the most useful mechanism to modify the current 
    buffer. The following example is a macro called cDsuper-deletecA which is 
    bound to cG<CTRL-del>cA. The macro deletes characters under the cursor in 
    blocks. If a white space character is under the cursor then all characters 
    up until the next non-white space character are deleted. If a non-white 
    space character is under the cursor then all non-white space characters up 
    until the next white space character are deleted, then the white space is 
    deleted. White space in this context is a cGSPACEcA, cGtabcA or cGCRcA character. 
sB
        ; 
        ;---    Macro to delete the white space, or if an a word all of the 
        ;       word until the next word is reached. 
        ; 
        define-macro super-delete 
            !while &not &sin @wc " \t\n" 
                forward-delete-char 
            !done 
            !repeat 
                forward-delete-char 
            !until &or &seq @wc "" &not &sin @wc " \t\n" 
            !return 
        !emacro 

        global-bind-key super-delete "C-delete" 

sA

cEcESEE ALSO cEcA


    lslmdefine-macro(2)le. 

! 4 CommandVariables
! 4 @clk
! 4 @cl
! 4 @cck
! 4 @cc
! 4 @cgk
! 4 @cg
! 4 @cqk
! 4 @cq
cEcENAME cEcA


    @clk, @cl - Last key or command name 
    @cck, @cc - Current key or command name 
    @cgk, @cg - Get a key or command name from the user 
    @cqk, @cq - Get a quoted key or command name from the user 


cEcESYNOPSIS cEcA


    cD@clkcA 
    cD@clcA 
    cD@cckcA 
    cD@cccA 
    cD@cgkcA 
    cD@cgcA 
    cD@cqkcA 
    cD@cqcA 


cEcEDESCRIPTION cEcA


    The Command Variables allow macros to obtain MicroEmacs '02 input commands 
    and keystrokes from the user. The general format of the command is:- 

        cD@ccAcCicA[cDkcA] 

    Where, 

    cCicA 
        Determines the source of the input as follows:- 

        cDlcA 
            The last input entered. 

        cDccA 
            The current input entered. 

        cDqcA 
            Provides a low level character input mechanism, obtaining a single 
            raw character input from the user. The input fetch does not 
            interact with the message line and the user is NOT prompted for 
            input (use lslmml-write(2)le to create your own message). cD@cqcA is very 
            low level, it is generally preferable to use cD@cgcA which provides a 
            more intelligent binding. 

        cDgcA 
            Like cD@cqcA, cD@cgcA[cDkcA] gets a single character input, however if the 
            input is bound to a function then the function name is returned 
            instead of the character e.g. if cG^FcA or cG<left-arrow>cA is depressed 
            then cDforward-charcA is returned. This has distinct advantages over 
            cD@cqcA as the binding becomes device independent and executes on all 
            platforms. In addition, it honors the users bindings, however 
            bizarre. 

    cDkcA 
        When, omitted command input is returned to the caller (i.e. the name 
        of the command, such as "cGforward-charcA"). When present, the raw 
        keystroke is returned to the caller, i.e. "cG^FcA (control-F). 

    The cD@clcA, cD@clkcA, cD@cccA and cD@cckcA variables can also be set, this feature can be 
    used by macros to change the command history. While setting the current 
    command is limited in use, setting the last command can be immensely 
    useful, consider the following macro code:- 
sB
        kill-line 
        forward-line 
        set-variable @cl kill-line 
        kill-line 

sA
    Without the setting of the cD@clcA variable, the current kill buffer will 
    contain only the last line. But the setting of cD@clcA to kill-line fools 
    MicroEmacs into thinking the last command was a kill command so the last 
    kill line as appended to the current yank buffer, i.e. the kill buffer 
    will have both lines in it. 

    This feature can be used for any command whose effect depends on the 
    previous command. Such commands include lslmforward-line(2)le, lslmkill-region(2)le, 
    lslmreyank(2)le and lslmundo(2)le. This feature should not be abused as unexpected 
    things may happen. 


cESummary cA


    cD@clcA 
        Get or set the last command. 

    cD@clkcA 
        Get or set the last key stroke. 

    cD@cccA 
        Get or set the current command. 

    cD@cckcA 
        Get or set the current keystroke. 

    cD@cgcA 
        Get a command name from the user. 

    cD@cgkcA 
        Get a keystroke from the user. 

    cD@cqcA 
        Get a quoted command name from the user. 

    cD@cqkcA 
        Get a quoted keystroke from the user. 


cEcEEXAMPLE cEcA


    The following example shows how the cD@cccA and cD@clcA commands are used:- 
sB
        define-macro current-last-command 
            insert-string &spr "Last key [%s] name [%s]\n" @clk @cl 
            insert-string &spr "Current key [%s] name [%s]\n" @cck @cc 
        !emacro 

sA
    Pressing the up key and then executing this macro using 
    execute-named-command (esc x) will insert the lines:- 

        Last key [up] name [backward-line] 
        Current key [esc x] name [execute-named-command] 


    cD@cgcA like cD@cqcA gets a single character input, however if the keyboard input 
    is bound to a function then the function name is returned instead of the 
    character e.g. if cG^FcA or cG<left-arrow>cA is depressed then cDforward-charcA is 
    returned. This has distinct advantages over cD@cqcA as the binding becomes 
    device independent and executes on all platforms, additionally it honors 
    the users bindings, however bizarre. 

    cD@cqcA provides a low level character input mechanism, obtaining a single raw 
    character input from the user. This does not interact with the message 
    line and the user is not prompted for input (use lslmml-write(2)le to create 
    your own message). cD@cqcA is very low level, it is generally preferable to 
    use cD@cgcA which provides a more intelligent binding. 


cEcEEXAMPLE cEcA


    The following example is taken from cGdraw.emfcA which uses cD@cgcA to obtain 
    cursor movements from the user. Note how the input from cD@cgcA (stored in 
    variable cD%dw-commcA) is compared with the binding name rather than any 
    keyboard characters. 
sB
            !repeat 
                0 screen-update 
                !force set-variable #l0 @cg 
                !if &seq #l0 "abort-command" 
                    !if &iseq @mc1 "Really quit [y/n]? " "nNyY" "y" 
                        find-buffer :dw-buf 
                        0 delete-buffer "*draw*" 
                        -1 buffer-mode "view" 
                        !abort 
                    !endif 
                !elif &seq #l0 "newline" 
                    . 
                    . 
                !elif &seq #l0 "forward-line" 
                    1 draw-vert 
                !elif &seq #l0 "backward-line" 
                    -1 draw-vert 
                !elif &seq #l0 "forward-char" 
                    1 draw-horz 
                !elif &seq #l0 "backward-char" 
                    -1 draw-horz 
                !elif &seq #l0 "osd" 
                    .osd.draw-help osd 
                !elif &set #l1 &sin #l0 "mdeu-=" 
                    !if &les #l1 5 
                        set-variable :dw-mode &sub #l1 1 
                        set-variable :dw-modes #l0 
                        draw-setmode-line 
                    !elif &sin #l0 "-=" 
                        set-variable :dw-char #l0 
                        draw-setmode-line 
                    !endif 
                !else 
                    ml-write "[Invalid command]" 
                !endif 
            !until 0 

sA

cEcESEE ALSO cEcA


    lslm@wc(4)le, lslm&kbind(4)le, lslmdefine-macro(2)le. 

! 4 Variables
! 4 RegisterVariables
! 4 CmdVariables
! 4 BufferVariables
!24 #g0..#g9 - Global register variables
!24 #p0..#p9 - Parent register variables
!24 #l0..#l9 - Local register variables
cEcENAME cEcA


    Variables - Macro variables 


cEcESYNOPSIS cEcA


    cD#cAcCtncA 
    cD$cAcCvariableNamecA 
    cD%cAcCvariableNamecA 
    cD.cAcCvariableNamecA 
    cD.cAcCcommandNamecAcD.cAcCvariableNamecA 
    cD:cAcCvariableNamecA 
    cD:cAcCbufferNamecAcD:cAcCvariableNamecA 


cEcEDESCRIPTION cEcA


    Variables are part of MicroEmacs macro language and may be used wherever 
    an argument is required. The variable space comprises:- 

        cD#cA - Register Variable 
        cD$cA - System Variable 
        cD%cA - Global Variable 
        cD.cA - Command Variable 
        cD:cA - Buffer Variable 

    All variables hold string information, the interpretation of the string 
    (numeric, string or boolean) is determined when the variable is used 
    within the context of the command. There are five types of variable, 
    cDRegistercA cDVariablescA (prefixed with a hash cD#cA), cDSystem VariablescA (prefixed 
    with a dollar cD$cA), cDGlobal VariablescA (prefixed with a percentage cD%cA), cDBuffer 
    VariablescA (prefixed with a colon cD:cA) and cDCommand VariablescA (prefixed with a 
    period cD.cA). 


cERegister Variables cA


    Register Variables provide a set of 10 prefixed global (cD#g0cA .. cD#g9cA), 
    parent (cD#p0cA .. cD#p9cA) and local (cD#l0cA .. cD#l9cA) register variables. The 
    interpreted decode time of the register variables is significantly smaller 
    than other variable types as no name space search is performed. 

    Register variables are assigned using lslmset-variable(2)le, their value may be 
    queried with lslmdescribe-variable(2)le, unlike Global Buffer or Command 
    variables they cannot be deleted. 

    Register variables are implemented like a stack, where the global 
    registers are the top of the stack and every executing macro gets its own 
    set of resister variables (cD#l?cA). The macro also has access to the global 
    registers (cD#g?cA) and its calling, or parent macro (cD#p?cA). If the macro has 
    no parent macro then the global registers are also the parent registers. 
    Outside macros, i.e. using cDset-variablecA manually, the global parent and 
    local registers are the same. 

    Register variables are typically used for retaining short term state, 
    computation steps etc. As with the User Variables, the global register 
    variables are global and care must be taken with nested macro invocations 
    to ensure that the register usage does not conflict. 


cESystem Variables cA


    MicroEmacs defines many System variables which are used to configure many 
    aspects of the editors environment. The functionality of each system 
    variable has been documented, they can be set and described but cannot be 
    unset. If the user attempts to set or describe a non-existent MicroEmacs 
    system variable (e.g. cD$PATHcA) the system environment is used instead, 
    allowing the user to query and alter the system environment. 


cEGlobal, Command and Buffer Variables cA


    The Global variables are denoted by an initial cD%cA character followed by the 
    name of the variable cCvariableNamecA. The cCvariableNamecA may be any ASCII 
    character string up to 127 characters in length, all characters of the 
    name are significant. Shorter names are preferred as this speeds up 
    execution. Global Variables exist in a global context which all macros 
    have access to. 

    Command variables exist within the scope of a command, they are denoted by 
    the period (cD.cA) character. They can be accessed by one of two forms, either 
    cD.cAcCvariableNamecA or cD.cAcCcommandNamecAcD.cAcCvariableNamecA. The first form, without the 
    command name, assumes the scope to be the current command, as such may 
    only be used to access internal variables. The second form qualifies the 
    scope by specifying the command, this form is much more versatile and may 
    be used to access any command variable from any other command, e.g. 
sB
        define-macro foo 
            set-variable .foo "Hello world" 
            1000 ml-write &cat "foo1: " .foo 
            1000 ml-write &cat "foo2: " .foo.foo 
        !emacro 
        define-macro bar 
            foo 
            1000 ml-write &cat "bar1: " .foo 
            1000 ml-write &cat "bar2: " .foo.foo 
        !emacro 

        bar 

sA
    When cDbarcA is executed the following messages may be observed:- 

        foo1: Hello World 
        foo2: Hello World 
        bar1: ERROR 
        bar2: Hello World 


    When a macro file or buffer is executed, they are executed within their 
    own scope so local scope command variables (form 1) may be created and 
    used in that scope. Any such variables created are automatically deleted 
    at the end of execution. For example, the default color scheme generator 
    macro file, cGschemed.emfcA, creates command variables for the created colors 
    to aid readability:- 
sB
        add-color &set .green     3 0   200 0 
        a0dd-color &set .lgreen   11 0   255 0 

        ... 

        add-color-scheme .scheme.cardback   .lgreen   .green   .lgreen ... 

sA
    The variables only exist as a file or buffer is being executed, they are 
    not accessible by another command once the command or buffer execution has 
    finished. 

    Buffer variables are similar to Command variable in function and behaviour 
    except that their scope is of a buffer and are denoted by the colon (cD:cA) 
    character. Access can be in one of two forms, either cD:cAcCvariableNamecA where 
    the scope is assumed to be the current buffer or cD:cAcCbufferNamecAcD:cAcCvariableNamecA, 
    where the scope is explicitly given allowing access to any buffer 
    variable, e.g. 
sB
        find-buffer "foo" 
        set-variable :foo "Hello world" 
        find-buffer "bar" 
        set-variable :bar "Hello world" 
        1000 ml-write &cat ":foo     " :foo 
        1000 ml-write &cat ":foo:foo " :foo:foo 
        1000 ml-write &cat ":bar     " :bar 
        1000 ml-write &cat ":bar:bar " :bar:bar 

sA
    When the above is executed the following messages may be observed:- 

        :foo     ERROR 
        :foo:foo Hello World 
        :bar     Hello World 
        :bar:bar Hello World 


    Global, Buffer and Command variables are automatically defined when they 
    are used. A variable is assigned with lslmset-variable(2)le and may be 
    subsequently deleted with lslmunset-variable(2)le. The current assignment of a 
    variable may be queried from the command line using lslmdescribe-variable(2)le. 
    e.g. 
sB
        define-macro foo 
        !emacro 
        set-variable %foo "Some string" 
        set-variable :bar "Some string" 
        set-variable .foo.bar "Some string" 

        ... 

        ml-write &spr "%s %s %s" %foo :bar .foo.bar 

        ... 

        unset-variable :bar 
        unset-variable %foo 
        unset-variable .foo.bar 

sA
    An undefined variable returns the string cGERRORcA, this known state is used 
    to advantage with the lshilight(2)lmhilightingle initialization, e.g. 
sB
        !if &sequal .hilight.c "ERROR" 
            set-variable .hilight.c &pinc .hilight.next 1 
        !endif 
        ; 
        ; Hi-light C Mode 
        ; 
        0 hilight .hilight.c  2 50             $global-scheme 

sA
    In this case the variable cD.hilight.ccA is explicitly tested for definition, 
    if it is undefined then it is assigned a new value. 

    Conventionally, names are separated with a minus sign character (cD-cA) e.g. 
    cGfoo-barcA. It is strongly advised that the name space is kept reasonably 
    clean, since there are no restrictions on the number of macros that may be 
    defined, problems will arise if different macros use the same variables in 
    different contexts. Where possible, Command or Buffer Variables are 
    preferable to Global Variables since they have no side effects on other 
    macros or buffers. It is advised that all variable names associated with a 
    particular macro set are prefixed with short identifier to make the 
    variable name space unique. e.g. the cDMetriscA macro prefixes all variables 
    with cD:met-cA; the cDdrawcA macro uses cD:dw-cA, the cDpatiencecA macro cD:pat-cA etc. 

    Macro writers should endeavor to use the minimal number of variables, 
    obviously the more variables that exist in the system, the greater the 
    lookup time to find a variable. Use Register Variables in preference to 
    Command, Global or Buffer variables for intimidate computation steps, 
    temporary state etc. 

    Note that Buffer Variables are automatically deleted when the buffer is 
    deleted. 


cEcEEXAMPLE cEcA


    The following example is the macro to convert tabs to spaces, it is shown 
    in two forms, with User Variables and with Register Variables, the 
    register variable implementation is obviously preferable since no new 
    variables have been defined. 


cEUser Variable Implementation cA

sB

        ; 
        ; tabs-to-spaces. 
        ; Convert all of the tabs to spaces. 
        define-macro tabs-to-spaces 
            set-variable %curline $window-line        ; Remember line 
            beginning-of-buffer 
            !force search-forward "\t" 
            !while $status 
                3 drop-history 
                set-variable %curcol $window-acol 
                backward-delete-char 
                &sub %curcol $window-acol insert-space 
                !force search-forward "\t" 
            !done 
            3 drop-history 
            goto-line %curline 
            update-screen 
            ml-write "Converted tabs!" 
        !emacro 

sA

cERegister Variable Implementation cA

sB

        ; 
        ; tabs-to-spaces. 
        ; Convert all of the tabs to spaces. 
        define-macro tabs-to-spaces 
            ; Remember line 
            set-variable #l0 $window-line 
            beginning-of-buffer 
            !force search-forward "\t" 
            !while $status 
                set-variable #l1 $window-acol 
                backward-delete-char 
                &sub #l1 $window-acol insert-space 
                !force search-forward "\t" 
            !done 
            goto-line #l0 
            screen-update 
            ml-write "[Converted tabs]" 
        !emacro 

sA

cEcESEE ALSO cEcA


    lslm@wc(4)le, lslmdefine-macro(2)le, lslmdescribe-variable(2)le, lslmset-variable(2)le, 
    lslmunset-variable(2)le. 

! 4 MacroNumericArguments
cEcENAME cEcA


    @#, @? - Macro numeric arguments 


cEcESYNOPSIS cEcA


    cD@#cA - The numerical argument to a macro 
    cD@?cA - The truth of the numerical argument to a macro 


cEcEDESCRIPTION cEcA


    All built-in commands and macros are invoked with a numerical argument. 
    The argument is obtained from either the command line when the user 
    invokes a command line such as: 

        cDesc 5 esc x forward-charcA 

    where the argument is entered after lsprefix(2)lmprefix 1le (cDesccA). In this case, causing 
    the cursor to be moved forward 5 characters. Within a macro file the same 
    operation is defined as:- 

        cD5 forward-charcA 

    In both cases the numerical argument 5 is passed to the command requesting 
    that the resultant operation is performed 5 times in succession before 
    returning. The command itself is invoked once, it is the responsibility of 
    the command to iterate if requested. 

    The command determines how the numerical argument is interpreted, in the 
    case of lsspell-buffer(3)lmspell-wordle the argument identifies the type of word that is being 
    spelled and NOT the number of words to spell. 

    The invocation of named macros operate in the same way, the macro may use 
    the variables cD@?cA and cD@#cA to determine the status of the numerical argument 
    passed to it. The variables are interpreted as follows: 

    cD@?cA 
        A logical value defined as cGTRUEcA (1) if a numerical argument has been 
        specified, otherwise cGFALSEcA (0). 

    cD@#cA 
        A signed integer value of the supplied numeric argument. If no 
        argument is supplied (i.e. cD@?cA==cGFALSEcA) then cD@#cA is set to 1. 

    The cD@?cA and cD@#cA are only valid for the current macro invocation. Other 
    macros or commands that are invoked have their own values of cD@?cA and cD@#cA. 


cEcEEXAMPLE cEcA


    Consider the following example, which sorts lines into alphabetical order 
    using the lslmsort-lines(2)le function. A new command cDsort-lines-ignore-casecA is 
    created using a macro to sort lines case insensitively regardless of the 
    current buffer mode. The command cDsort-linescA takes an optional argument 
    which determines which column should be used to perform the sort. 
sB
        ; 
        ; sort-lines-ignore-case 
        ; Sort lines case insensitively regardless of the current 'exact' mode 
        ; setting. 
        define-macro sort-lines-ignore-case 
            set-variable #l0 &bmod exact 
            -1 buffer-mode "exact" 
            !if @? 
                @# sort-lines 
            !else 
                sort-lines 
            !endif 
            &cond #l0 1 -1 buffer-mode "exact" 
        !emacro 

sA
    cD@?cA is used to test the presence of the argument, if it is false cDsort-linescA 
    is invoked without an argument. When true the numeric argument is 
    propagated e.g. cD@# sort-linescA. 

    This particular macro highlights an important consideration when passing 
    the numerical argument to other functions, had the macro been implemented 
    as: 
sB
        ; INCORRECT IMPLEMENTATION 
        define-macro sort-lines-ignore-case 
            set-variable #l0 &bmod exact 
            -1 buffer-mode "exact" 
            @# sort-lines 
            &cond #l0 1 -1 buffer-mode "exact" 
        !emacro 

sA
    then when cDsort-lines-ignore-casecA is invoked with no arguments cD@#cA is 
    defined as 1, this is would be incorrectly propagated to cDsort-linescA 
    causing it to sort on column 1 rather than column 0 as expected. 


cEcESEE ALSO cEcA


    lsMacroArguments(4)lmMacroArgumentsle, lslmdefine-macro(2)le. 

! 4 @y
cEcENAME cEcA


    @y - Yank buffer variable 


cEcESYNOPSIS cEcA


    cD@ycA - Yank buffer variable 


cEcEDESCRIPTION cEcA


    The cCYank Buffer VariablecA cD@ycA retrieves the current lslmyank(2)le string from the 
    kill buffer and returns it to the caller. 


cEcEEXAMPLE cEcA


    The current contents of the yank buffer can be obtained using cD@ycA, so to 
    set variable cG#l1cA to the current or last word if the cursor is not in a 
    word, simply use: 
sB
            forward-char 
            backward-word 
            set-mark 
            forward-word 
            copy-region 
            set-variable #l1 @y 

sA

cEcESEE ALSO cEcA


    lslmyank(2)le, lsMacroArguments(4)lmMacroArgumentsle, lsMacroNumericArguments(4)lmMacroNumericArgumentsle, lslmdefine-macro(2)le. 

!44 &band
! 4 &bor
!44 &bxor
!44 &bnot
cEcENAME cEcA


    &band, &bor, &bnot, &bxor - Bitwise macro operators 


cEcESYNOPSIS cEcA


    cD&bandcA cCnum1cA cCnum2cA 
    cD&borcA cCnum1cA cCnum2cA 
    cD&bxorcA cCnum1cA cCnum2cA 
    cD&bnotcA cCnumcA 


cEcEDESCRIPTION cEcA


    The bitwise operators perform bit operations on numeric values returning a 
    numerical result of the operation. 

    The functions may all be abbreviated to their three letter abbreviation 
    (i.e. cD&bandcA may be expressed as cD&bancA). In all cases the first argument is 
    completely evaluated before the second argument. 

    cD&band cAcCnum1cA cCnum2cA 
        Bitwise AND of cCnum1cA and cCnum2cA i.e. cCnum1cA & cCnum2cA. 

    cD&borcA cCnum1cA cCnum2cA 
        Bitwise (inclusive) OR of cCnum1cA and cCnum2cA i.e. cCnum1cA | cCnum2cA. 

    cD&bxorcA cCnum1cA cCnum2cA 
        Bitwise (exclusive OR) XOR of cCnum1cA and cCnum2cA i.e. cCnum1cA ^ cCnum2cA. 

    cD&notcA cCnumcA 
        Bitwise NOT operator of cCnumcA, inverts the state of all bits i.e. ~cCnumcA. 

    Evaluation of the bitwise operators are left to right, the leftmost 
    argument is fully evaluated before the next argument. The operator 
    ordering is prefix notation (see lslm&add(4)le for an example of prefix 
    ordering). 


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&add(4)le, lslm&and(4)le, lslm&negate(4)le, lslm&or(4)le. 

!44 &cond
cEcENAME cEcA


    &cond - Conditional expression operator 


cEcESYNOPSIS cEcA


    cD&condcA cClogcA cCexpr1cA cCexpr2cA 


cEcEDESCRIPTION cEcA


    The conditional expression cD&condcA provides an alternative way to write 
    ls!if(4)lm!if-!else-!endifle constructs, e.g.:- 
sB
        !if &gre %a %b 
            set-variable %z %a 
        !else 
            set-variable %z %b 
        !endif 

sA
    may be replaced with a conditional expression, breaking down the 
    components then 

        cClogcA is cD&gre %a %bcA 
        cCexpr1cA is cD%acA 
        cCexpr2cA is cD%bcA 

    rewriting the expression we get: 
sB
        set-variable %z &cond &gre %a %b %a %b 

sA
    This is far more concise, albeit a little less readable, but does improve 
    the performance of macros as there is less information to interpret. 

    The cD&condcA operator accepts three fields, ALL fields are evaluated although 
    only one of the results cCexpr1cA or cCexpr2cA is used. The cClogcA field is a logical 
    value, if it is non-zero (cGTRUEcA) then the result of the cCexpr1cA evaluation is 
    used, otherwise the result of cCexpr2cA is used. 

    It should be noted that the conditional expression may be used in any 
    construct i.e. lslm&add(4)le, lslm&cat(4)le, etc. the cCexprcA arguments may be strings, 
    numbers or booleans the resultant value of the cCexprcA arguments is simply 
    returned to the calling expression. 


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&add(4)le, lslm&great(4)le. 

! 4 &set
cEcENAME cEcA


    &set - In-line macro variable assignment 


cEcESYNOPSIS cEcA


    cD&setcA cC<var>cA cC<expr>cA 


cEcEDESCRIPTION cEcA


    cD&setcA performs an in-line macro variable assignment assigning a variable 
    cC<var>cA the value of the expression cC<expr>cA, returning the evaluated result 
    to the caller. cC<expr>cA may be numeric, boolean or a string expression. 

    cD&setcA is typically used for defining (and simultaneously using) indices 
    e.g. as with lslmadd-color(2)le or lslmadd-color-scheme(2)le. This is a short-hand of 
    lslmset-variable(2)le. 


cEcEEXAMPLE cEcA


    The following example usescD&setcA to define new colors (see cGcolor.emfcA): 
sB
        ; Standard colors 
        add-color &set %white     0 200 200 200 
        add-color &set %black     1 0   0   0 
        add-color &set %red       2 200 0   0 
        add-color &set %green     3 0   200 0 
        add-color &set %yellow    4 200 200 0 
        add-color &set %blue      5 0   0   200 
        add-color &set %magenta   6 200 0   200 
        add-color &set %cyan      7 0   200 200 

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&inc(4)le, lslmset-variable(2)le. 

!44 &find
!44 &which
cEcENAME cEcA


|&find
    &find - Find a file on the search path 
&which

    &which - Find a program on the path 
$a


cEcESYNOPSIS cEcA


    cD&findcA cC<basename>cA cC<extension>cA 
    cD&whichcA cC<progname>cA 


cEcEDESCRIPTION cEcA


    cD&findcA searches for a named file cC<basename><extension>cA on the MicroEmacs 
    '02 search path defined by the variable lslm$search-path(5)le (initialized from 
    the environment variable lslm$MEPATH(5)le). Each path component defined in 
    cD$search-pathcA is prepended to the constructed file name and it's existence 
    is tested. If the file exists, then the FULL path name of the file is 
    returned to the caller, otherwise cGERRORcA. 

    cC<basename>cA 
        The base name of the file, excluding any extension. 

    cC<extension>cA 
        The extension of the file name, this must be specified with the 
        extension delimiter, typically dot ('cG.cA'). A cGNULLcA string (e.g. 'cG""cA') 
        may be specified if no extension is required. 

    cD&whichcA searches for the given executable program cC<progname>cA on the system 
    program search path defined the the environment variable cD$PATHcA. 


cEcEUSAGE cEcA


    cD&findcA is typically used with lslminsert-file(2)le and lslmfind-file(2)le within macro 
    scripts, and is used to locate user specific files. 


cEcEEXAMPLE cEcA


    The following example uses cD&findcA to locate the uses 'C' template file. 
    Given a cD$search-pathcA setting of cG/usr/bob/emacs:/usr/local/microemacscA:- 
sB
        insert-file &find "c" ".etf" 

sA
    Would insert the file cG/usr/bob/emacs/c.etfcA if it existed, else the file 
    cG/usr/local/microemacs/c.etfcA if it exists. 


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslmfind-file(2)le, lslm$search-path(5)le, lslminsert-file(2)le. 

!44 !nmacro
cEcENAME cEcA


    !nmacro - Execute line as if not in a macro 


cEcESYNOPSIS cEcA


    cD!nmacrocA cCcommandcA 


cEcEDESCRIPTION cEcA


    cD!nmacrocA causes cCcommandcA to be executed as if it were initiated from the 
    command line by the user, rather than from the macro context. When 
    MicroEmacs '02 executes a macro, by default any input the command requires 
    is expected on the same line immediately following the command. If a line 
    is preceded by a cD!nmacrocA (or cD!nmacA) directive, the command is executed as 
    if it was invoked from the command line by the user, as such, the rest of 
    the line is ignored and all input is obtained directly from the user, as 
    per normal command interaction. 


cEcEEXAMPLE cEcA


    The following example is taken from macro file cGmeme3_8.emfcA and shows how 
    to add a buffer mode. 
sB
        ; Add a buffer mode 
        define-macro add-mode 
            ; Has the require mode been given as an argument, if so add it 
            !force 1 buffer-mode @1 
            !if &not $status 
                ; No - use 1 buffer-mode to add a mode 
                !nma 1 buffer-mode 
            !endif 
        !emacro 

sA
    The first line checks that the mode to add has not already been given as a 
    macro argument, e.g. by executing the following line 
sB
        buffer-add-mode "view" 

sA
    If this line fails then the argument was not specified and must be 
    obtained from the user as normal. 


cEcENOTES cEcA


    Individual arguments may be obtained from the user using the lslm@mn(4)le 
    interactive macro variables. 


cEcESEE ALSO cEcA


    lslm@mn(4)le. 

!44 &cbind
!44 &kbind
!44 &nbind
cEcENAME cEcA


    &cbind, &kbind, &nkind - Command/key binding operators 


cEcESYNOPSIS cEcA


    cD&cbindcA cCkeycA 
    cD&kbindcA cCncA cCcommandcA 
    cD&nbindcA cCkeycA 


cEcEDESCRIPTION cEcA


    cD&cbindcA returns the command bound to the given key sequence, cD&kbindcA can be 
    abbreviated to cD&kbicA. If the key is not bound then cD&kbindcA returns the 
    string "cCERRORcA". 

    cD&nbindcA returns the numerical argument associated with the given key 
    binding, cD&nbindcA can be abbreviated to cD&nbicA. If the key is not bound then 
    cD&nbindcA returns the string "cCERRORcA", if the binding has no argument then an 
    empty string (cG""cA) is returned. 

    cD&kbindcA returns a key sequence bound to the given cCcommandcA with the given 
    numerical argument cCncA. If no binding can be found then cD&kbindcA returns an 
    empty string (cG""cA). 


cEcEEXAMPLE cEcA


    The following example waits for the user to press a key, then prints what 
    command the key is bound to. 
sB
        ml-write "Enter key: " 
        set-variable #l0 @cgk 
        ml-write &spr "%s is bound to %s" #l0 &cbin #l0 

sA

cEcENOTES cEcA


    In March 2001 cD&kbindcA was renamed cD&ckindcA and a new cD&nkindcA and cD&kbindcA added. 


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslmglobal-bind-key(2)le. 

!44 &stat
cEcENAME cEcA


    &stat - Retrieve a file statistic 


cEcESYNOPSIS cEcA


    cD&statcA cC<stat>cA cC<filename>cA 


cEcEDESCRIPTION cEcA


    cD&statcA returns the specified cC<stat>cA on the given cC<filename>cA. Valid cC<stat>cA 
    values are:- 

    cDacA 
        Returns the absolute file name, corrects relative paths and symbolic 
        links, i.e. on unix if the filename is a symbolic link it returns the 
        file name the link points to (recursive), otherwise returns the file 
        name. 

    cDdcA 
        Returns the file's modification time stamp. The value returned is an 
        integer, larger values indicate a later time. 

    cDrcA 
        Returns a non-zero value if the user has permission to read the given 
        file. 

    cDscA 
        Returns the size of the file in bytes. 

    cDtcA 
        Returns the type of the file, where values returned are 

            X   File does not exist. 
            R   File is a regular file. 
            D   File is a directory. 
            H   File is a http URL link (see note). 
            F   File is an ftp URL file (see note). 
            N   File is an untouchable system file. 


        Note that a URL type is determined from the file name, e.g. 
        http://..., and its existence is not verified. 

    cDwcA 
        Returns a non-zero value if the user has permission to write to the 
        given file. 

    cDxcA 
        Returns a non-zero value if the user has permission to execute the 
        given file. 


cEcEEXAMPLE cEcA


    The following example is a macro which, given a file name, uses cD&statcA to 
    check that file file is regular: 
sB
        define-macro test-file 
            !force set-variable #l0 @1 
            !if &not $status 
                set-variable #l0 @ml04 "File name" 
            !endif 
            !if &not &equ &stat "t" #l4 1 
                ml-write &spr "[%s is not a regular file]" #l0 
                !abort 
            !endif 
        !emacro 

        test-file "foobar" 

sA
    The macro can be passed a file name and aborts if the file is not regular, 
    there by returning the state. 

    The follow example checks that a file is not empty, this is used by 
    cDmail-checkcA to test for any incoming mail. 
sB
            !if &gre &stat "s" %incoming-mail-box 
                ml-write "[You have new mail]" 
            !endif 

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslmfind-file(2)le. 

! 4 &reg
cEcENAME cEcA


    &reg - Retrieve a registry value (with default) 


cEcESYNOPSIS cEcA


    cD&regcA cCrootcA cCsubkeycA cCdefaultcA 


cEcEDESCRIPTION cEcA


    cD&regcA retrieves the value of a node defined by cCrootcA/cCsubkeycA from the 
    registry. The node name is specified in two components, typically required 
    when iterating over a registry tree, where the cCrootcA component is static 
    and the cCsubkeycA is dynamic, cCsubkeycA may be specified as the null string (cG""cA) 
    if an absolute registry path is specified. 

    The cCdefaultcA value is the value of the node to return if the registry node 
    does not exist. 


cEcEEXAMPLE cEcA


    The following example is taken from cGme.emfcA and uses the registry to 
    retrieve some of the default configuration files: 
sB
        ; Load in the color setup 
        !force execute-file &reg "/history" &cat $platform "/color" "color" 
        ; execute company setup 
        !if &not &seq &set #l0 &reg "/history" "company" "" "" 
            !force execute-file #l0 
        !endif 

sA

cEcESEE ALSO cEcA


    lslmget-registry(2)le, lslmset-registry(2)le. 

!44 &ldel
!44 &lfind
!44 &lget
!44 &linsert
!44 &lset
cEcENAME cEcA


    &ldel, &lfind, &lget, &linsert, &lset - List manipulation functions 


cEcESYNOPSIS cEcA


    cD&ldelcA cClistcA cCindexcA 
    cD&lfindcA cClistcA cCvaluecA 
    cD&lgetcA cClistcA cCindexcA 
    cD&linsertcA cClistcA cCindexcA cCvaluecA 
    cD&lsetcA cClistcA cCindexcA cCvaluecA 


cEcEDESCRIPTION cEcA


    The list manipulation functions perform operations on specially formatted 
    strings called lists. A list is defined as: 

        "|value1|value2|.....|valueN|" 


    Where 'cG|cA' is the dividing character, this is not fixed to a 'cG|cA', but is 
    defined by the first character of the string. Following are all valid 
    lists. 

        "cG|1|2|3|4|5|cA" 
        "cGX1X2X3X4X5XcA" 
        "cG\CAHello\CAWorld\CAcA" 
        "cG??cA" 

    The functions may all be abbreviated to their three letter abbreviation 
    (i.e. cD&linsertcA may be expressed as cD&lincA). In all cases the first argument 
    is completely evaluated before the second or third argument. 

    cD&ldelcA cClistcA cCindexcA 
        Creates a new list from deleting item cCindexcA from cClistcA. If cCindexcA is out 
        of cClistcA's range (0 < index <= # items in list) then cClistcA is returned 
        unchanged. 

    cD&lfindcA cClistcA cCvaluecA 
        Returns the index whose item is the same as cCvaluecA in cClistcA. If cCvaluecA is 
        not found in cClistcA then "cG0cA" is returned. 

    cD&lgetcA cClistcA cCindexcA 
        Returns the value of item cCindexcA in cClistcA. If cCindexcA is out of cClistcA's 
        range (0 < index <= # items in list) then an empty string is returned. 

    cD&linsertcA cClistcA cCindexcA cCvaluecA 
        Creates a new list from inserting cCvaluecA into cClistcA at point cCindexcA, 
        thereby pushing item cCindexcA to cCindexcA+1 etc. If cCindexcA is 0 the cCvaluecA is 
        inserted at the beginning of the list, if cCindexcA is less than 0 or 
        greater that the number of items in cClistcA then cCvaluecA is inserted at the 
        end of the list. 

    cD&lsetcA cClistcA cCindexcA cCvaluecA 
        Creates a new list from setting cCindexcA of cClistcA to cCvaluecA. If cCindexcA is 
        out of cClistcA's range (0 < index <= # items in list) then cD&lsetcA behaves 
        like cD&linsertcA. 


cEcEEXAMPLE cEcA


    The following example moves item 4 in a list to position 2: 
sB
        set-variable #l0 &lget %list 4 
        set-variable #l1 &ldel %list 4 
        set-variable %list &lins #l1 2 #l0 

sA
    The following example is taken from vm.emf, it firstly checks where the 
    user has entered a vm command, if not then the key is execute as normal, 
    otherwise the appropriate vm command is executed. 
sB
        define-macro vm-input 
            set-variable #l2 @cck 
            set-variable #l3 @cc 
            !if &not &set #l0 &lfi "|esc h|delete|space|return|A|a|C|c|....|z|" #l2 
                !if &not &seq #l3 "ERROR" 
                    execute-line &spr "!nma %s %s" &cond @? @# "" #l3 
                    !return 
                !endif 
                ml-write &spr "[Key \"%s\" not bound - \"esc h\" to view help]" #l2 
                !abort 
            !endif 
            set-variable #l1 &lget "|%osd-vm-help osd|vm-del-windows|scroll-down|.... 
                               ....vm-goto-list|vm-Archive-box|vm-archive-box|.... 
                               vm-cut-all-data|0 vm-extract-data|...|vm-forward|" #l0 
            execute-line #l1 
        !emacro 

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&mid(4)le, lslm&cat(4)le. 

!44 &sequal
!44 &isequal
!44 &sless
!44 &sgreat
!44 &xsequal
!44 &xisequal
cEcENAME cEcA


    &seq, &iseq, &sle, &sgre, &xseq, &xiseq - String logical macro operators 


cEcESYNOPSIS cEcA


    cD&sequalcA cCstr1cA cCstr2cA 
    cD&isequalcA cCstr1cA cCstr2cA 
    cD&slesscA cCstr1cA cCstr2cA 
    cD&sgreatcA cCstr1cA cCstr2cA 

    cD&xsequalcA cCstr1cA cCregexcA 
    cD&xisequalcA cCstr1cA cCregexcA 


cEcEDESCRIPTION cEcA


    The string logical testing operators perform string comparison tests, 
    returning a boolean value of cGTRUEcA (1) or cGFALSEcA (0). 

    The functions may all be shortened to their three letter abbreviation 
    (i.e. cD&sequalcA may be expressed as cD&seqcA). In all cases the first argument 
    is completely evaluated before the second argument. String logical 
    operators include:- 

    cD&sequalcA cCstr1cA cCstr2cA 
        cGTRUEcA if the two strings cCstr1cA and cCstr2cA are the same. Abbreviated form 
        of the function is cD&seqcA. 

    cD&slesscA cCstr1cA cCstr2cA 
        cGTRUEcA if string cCstr1cA alphabetically less than cCstr2cA. Abbreviated form of 
        the function is cD&slecA. 

    cD&sgreatcA cCstr1cA cCstr2cA 
        cGTRUEcA if string cCstr1cA alphabetically larger than cCstr2cA. Abbreviated form 
        of the function is cD&sgrcA. 

    cD&isequalcA cCstr1cA cCstr2cA 
        cGTRUEcA if the two strings cCstr1cA and cCstr2cA are the same ignoring letter 
        case. Abbreviated form of the function is cD&isecA. 

    cD&xsequalcA cCstr1cA cCregexcA 
        cGTRUEcA if the string cCstr1cA matches the cCregexcA (case sensitive). 
        Abbreviated form of the function is cD&xsecA. See lsRegularExpressions(2)lmRegular Expressionsle for 
        information on the cCregexcA format. 

    cD&xisequalcA cCstr1cA cCregexcA 
        cGTRUEcA if the string cCstr1cA matches the cCregexcA (case insensitive). 
        Abbreviated form of the function is cD&xiscA. See lsRegularExpressions(2)lmRegular Expressionsle for 
        information on the cCregexcA format. 

    Evaluation of the string logical operators are left to right, the leftmost 
    argument is fully evaluated before the next argument. The operator 
    ordering is prefix notation (see lslm&add(4)le for an example of prefix 
    ordering). 


cEcEEXAMPLE cEcA


    Test for variable lslm$buffer-bname(5)le is equal to cG*scratch*cA: 
sB
        !if &seq $buffer-bname "*scratch*" 
            ... 

sA
    The following example tests a character is in the range cGacA-cGzcA: 
sB
        !if &not &and &sle %c "a" &sgr %c "z" 
            ... 

sA
    The following example inserts the string "cGccA" into the alphabetically order 
    string list cD%test-listcA: 
sB
        set-variable %test-list "|a|b|d|e|" 
        set-variable %test-insert "c" 

        set-variable #l0 1 
        !while &and &not &seq &lget %test-list #l0 "" ... 
                ... &sle &lget %test-list #l0 %test-insert 
            set-variable #l0 &add #l0 1 
        !done 
        set-variable %test-list &lins %test-list #l0 %test-insert 

sA
    The first test on the cD!while &andcA conditional checks that the current item 
    in the list is not an empty string (""). If it is the end of the list has 
    been reached. 

    The following example tests the current buffers file name for a ".c" 
    extension: 
sB
        !if &xse $buffer-fname ".*\\.c" 
            ... 

sA
    Note the 'cG\cA' character is needed to protect the second 'cG.cA', i.e. so that 
    it does not match any character and the second 'cG\cA' is required as the 
    string is first parsed by the macro interpreter which changes it to 
    "cG.*\.ccA" which is then interpreted as a regex. 


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sin(4)le, lslm&slower(4)le, lslm&rep(4)le, lslm&add(4)le, lslm&equal(4)le, 
    lslm&cond(4)le, lsRegularExpressions(2)lmRegular Expressionsle. 

! 4 &sin
!44 &isin
!44 &rsin
!44 &risin
cEcENAME cEcA


    &sin, &isin, &rsin, &risin - String in string test functions 


cEcESYNOPSIS cEcA


    cD&sincA cCstr1cA cCstr2cA 
    cD&isincA cCstr1cA cCstr2cA 
    cD&rsincA cCstr1cA cCstr2cA 
    cD&risincA cCstr1cA cCstr2cA 


cEcEDESCRIPTION cEcA


    These functions test for the existence of cCstr1cA in cCstr2cA, returning the 
    position of the string in cCstr2cA or 0 if not found. 

    The functions may all be abbreviated to their three letter abbreviation 
    (i.e. cD&risincA may be expressed as cD&riscA). In all cases the first argument is 
    completely evaluated before the second argument. 

    cD&sincA cCstr1cA cCstr2cA 
        Returns cG0cA if string cCstr1cA does not exists in string cCstr2cA. Otherwise the 
        function returns the character position + 1 of the location of the 
        first character of the first occurrence of cCstr1cA. 

    cD&isincA cCstr1cA cCstr2cA 
        Returns cG0cA if case insensitive string cCstr1cA does not exists in string 
        cCstr2cA. Otherwise the function returns the character position + 1 of the 
        location of the first character of the first occurrence of cCstr1cA. 

    cD&rsincA cCstr1cA cCstr2cA 
        Returns cG0cA if string cCstr1cA does not exists in string cCstr2cA. Otherwise the 
        function returns the character position + 1 of the location of the 
        first character of the last occurrence of cCstr1cA. 

    cD&risincA cCstr1cA cCstr2cA 
        Returns cG0cA if case insensitive string cCstr1cA does not exists in string 
        cCstr2cA. Otherwise the function returns the character position + 1 of the 
        location of the first character of the last occurrence of cCstr1cA. 


cEcEEXAMPLE cEcA


    The cD&sincA and similar functions are useful for two different purposes. 
    Consider the following example, this utilizes cD&sincA in two different 
    contexts. cG!while &not &sin @wc " \t\n"cA is a test for the end of the 
    number, i.e. a white space character (cG<tab>cA, cG<SPACE>cA or cG<NL>cA). 

    The invocation cGset-variable #l1 &isin @wc "0123456789abcdef"cA is subtly 
    different. In this case the return value is used to convert the character 
    to it's integer hex value by using the value returned by cD&isincA. 
sB
        ; 
        ; calc-hexnum 
        ; Convert the sting from the current position in the buffer 
        ; to a hexadecimal number. 
        define-macro calc-hexnum 
            forward-delete-char 
            forward-delete-char 
            set-variable #l0 0 
            !while &not &sin @wc " \t\n" 
                set-variable #l1 &isin @wc "0123456789abcdef" 
                !if &not #l1 
                    ml-write "Bad Hex number found" 
                    !abort 
                !endif 
                set-variable #l0 &mul #l0 16 
                set-variable #l0 &add #l0 &sub #l1 1 
                forward-delete-char 
            !done 
            insert-string #l0 
        !emacro 

sA
    The cD&rsincA function is very similar to sin except the value return is the 
    position of the last occurrence of the string in the given string instead 
    of the first. This is particularly useful when extracting the path or file 
    name from a complete file name. For example, given a UNIX style file name 
    such as cG"/usr/local/bin/me"cA the path can be obtained using cGset-variable 
    %path &lef %pathfile &rsincA cG"/" %pathfilecA and the file name by using 
    cGset-variable %file &rig %pathfile &rsincA cG"/" %pathfilecA 


cEcESEE ALSO cEcA


    lslmOperating Modesle, lsIntroduction to Variable FunctionslmVariable Functionsle, lslm&sequal(4)le, lslm&rep(4)le. 

!44 !jump
!44 !tjump
cEcENAME cEcA


|!jump
    !jump - Unconditional relative branch 
|!tjump
    !tjump - conditional relative branch 


cEcESYNOPSIS cEcA


    cD!jumpcA cCoffsetcA 
    cD!tjumpcA cCconditioncA cCoffsetcA 


cEcEDESCRIPTION cEcA


    Flow can be controlled within a MicroEmacs '02 macro using the cD!jumpcA 
    directive. It takes as a numerical argument cCoffsetcA. The cCoffsetcA is a signed 
    relative displacement, it may be a literal numeric value, a variable or an 
    evaluated expression (see lsIntroduction to Variable FunctionslmVariable Functionsle). The displacement to jump 
    starts from the current cD!jumpcA line. (i.e. cD0 gotocA) would loop forever as it 
    jumps to itself). Negative cCoffsetcA branches backwards, positive cCoffsetcA 
    forwards. 

    A conditional relative branch, with a numerical displacement is specified 
    using cD!tjumpcA. This has an additional argument cCconditioncA which is evaluated 
    and if TRUE (Non-zero) then the branch is taken. The cCconditioncA may be a 
    variable or an evaluated expression. 

    cD!jumpcA and cD!tjumpcA are fast equivalents of lslm!goto(4)le and lslm!tgoto(4)le, 
    respectively. cD!jumpcA should be used with care as these calls are source 
    sensitive and unexpected results may be obtained if the cCoffsetcA's are 
    specified incorrectly. 


cEcEWARNING cEcA


    Comments are not counted as valid lines within the relative displacement, 
    these are stripped out when the macro is loaded. When using a relative 
    branch ensure that ONLY the cCcodecA lines are counted. 


cEcEEXAMPLE cEcA


    For some seriously dirty macro tricks then the cD!jumpcA directive becomes 
    very useful. The following example is taken from the cDMetriscA macro (which 
    is packed with goodies if you can find time to work out what it does !!). 
    The following example uses the random number generator lslm$random(5)le to 
    generate a random number which scaled and used as a cD!jumpcA offset, thereby 
    creating a cCswitchcA type statement. 
sB
        0 define-macro met-select-piece 
            !jump &mul 5 &add 1 &div &mod $random 71 10 
            set-variable :met-np1 " X "  ; 1st 3 lines are dummies to get offset right 
            set-variable :met-np1 " X " 
            set-variable :met-np1 " X " 
            set-variable :met-np1 " X " 
            set-variable :met-np1 " X " 
            set-variable :met-np2 "XX " 
            set-variable :met-np3 " X " 
            set-variable :met-ncol %lyellow 
            !return 
            set-variable :met-np1 "XX " 
            set-variable :met-np2 "XX " 
            set-variable :met-np3 "   " 
            set-variable :met-ncol %yellow 
            !return 
            set-variable :met-np1 "X  " 
            set-variable :met-np2 "XX " 
            set-variable :met-np3 " X " 
            set-variable :met-ncol %lmagenta 
            !return 
            set-variable :met-np1 "  X" 
            set-variable :met-np2 " XX" 
            set-variable :met-np3 " X " 
            set-variable :met-ncol %lgreen 
            !return 
            set-variable :met-np1 " X " 
            set-variable :met-np2 " X " 
            set-variable :met-np3 " XX" 
            set-variable :met-ncol %magenta 
            !return 
            set-variable :met-np1 " X " 
            set-variable :met-np2 " X " 
            set-variable :met-np3 "XX " 
            set-variable :met-ncol %green 
            !return 
            set-variable :met-np1 " X " 
            set-variable :met-np2 " X " 
            set-variable :met-np3 " X " 
            set-variable :met-ncol %lblue 
            !return 
            set-variable :met-np1 " X " 
            set-variable :met-np2 " X " 
            set-variable :met-np3 "X X" 
            set-variable :met-ncol %lred 
        !emacro 

sA

cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Fuctionsle, lslm!goto(4)le, lslm!if(4)le, lslm!repeat(4)le, lslm!return(4)le, lslm!tgoto(4)le, 
    lslm!while(4)le. 

! 4 SearchGroups
! 4 @s0
! 4 @s1
! 4 @s2
cEcENAME cEcA


    @s0, @s1, @s2, ... @s9 - Last search group values 


cEcESYNOPSIS cEcA


    cD@s0cA - Last search's whole match string 
    cD@s1cA - Last search's first group value 
    cD@s2cA - Last search's second group value 
    ... 
    cD@s9cA - Last search's nineth group value 


cEcEDESCRIPTION cEcA


    The search group variables cD@scAcCncA return the string matches of the last 
    regular expression search i.e. lslmsearch-forward(2)le (in lslmmagic(2m)le mode) or 
    lslmregex-forward(3)le. 

    cD@s0cA returns the whole of the matched string, cD@scAcCncA, cCncA = 1..9, returns the 
    bracket matches corresponding to the group demarkation points indicated by 
    cG\(cA and cG\)cA in the search regular expression. 


cEcEDIAGNOSTICS cEcA


    An error is generated if an attempt is made to access these variables and 
    the last search failed or the last search did not have the specified 
    group. 

    The value returned for an unused group, e.g. @s2 for the regex string 
    "cG\(a\)\|\(b\)cA" if "cGacA" was matched, is an empty string (""). 


cEcEEXAMPLE cEcA


    The following macro code gives a simple example of their potential use: 
$emf-scheme

        forward-search "Token *{\\(Start\\|End\\)}" 
        !if $status 
            ml-write "[found \"%s\"]" @s0 
            if &seq @s1 "Start" 
               . 
               . 

sA

cEcENOTES cEcA


    Remember that the regular expression escape character '\' has to be 
    duplicated within a macro file as '\' is also the macro file escape 
    sequence. 


cEcESEE ALSO cEcA


    lslmmagic(2m)le, lslmsearch-forward(2)le, lslmregex-forward(3)le. 

! 4 @fs
cEcENAME cEcA


    @fs - Frame store variable 


cEcESYNOPSIS cEcA


    cD@fscA cCrowcA cCcolumncA 


cEcEDESCRIPTION cEcA


    The frame store variable cD@fscA gives macros a way of obtaining the character 
    currently being drawn on the screen at the given location. If the given 
    value of cCrowcA or cCcolumncA is out range, i.e. less than zero or greater than 
    or equal to the screen size (see lslm$screen-width(5)le) then the value returned 
    is the empty string (i.e. cG""cA). 

    This variable cannot be set and is only updated during a screen update, 
    this means that macros that change the cursor position will need to redraw 
    the screen before using this variable. 


cEcEEXAMPLE cEcA


    The following example gets the word under the current mouse position, this 
    may not be the current cursor position: 
sB
        define-macro word-under-mouse 
            set-variable #l0 $mouse-y 
            set-variable #l1 $mouse-x 
            !if &not &inw @fs #l0 #l1 
                ml-write "[mouse not over a word]" 
                !return 
            !endif 
            set-variable #l2 @fs #l0 #l1 
            set-variable #l1 &sub #l1 1 
            !if &inw @fs #l0 #l1 
                set-variable #l2 &cat @fs #l0 #l1 #l2 
                !jump -3 
            !endif 
            set-variable #l1 $mouse-x 
            set-variable #l1 &add #l1 1 
            !if &inw @fs #l0 #l1 
                set-variable #l2 &cat #l2 @fs #l0 #l1 
                !jump -3 
            !endif 
            ml-write &spr "[mouse is over the word \"%s\"]" #l2 
        !emacro 

sA

cEcESEE ALSO cEcA


    lslm$screen-width(5)le, lslmscreen-update(2)le, lsMacroArguments(4)lmMacroArgumentsle, lsMacroNumericArguments(4)lmMacroNumericArgumentsle, 
    lslmdefine-macro(2)le. 

! 5 $auto-time
cEcENAME cEcA


    $auto-time - Automatic buffer save time 
$a


cEcESYNOPSIS cEcA


    cD$auto-timecA cCsecondscA; Default is cG300cA seconds 

    0 <= cCsecondscA <= t 


cEcEDESCRIPTION cEcA


    Sets the number of seconds to wait until an edited buffer is auto-saved to 
    temporary file to t seconds. A setting of 0 disables the auto-saving 
    command. Auto-saving can be enabled and disabled on a per buffer basis 
    using buffer mode lslmautosv(2m)le. 

    The auto-save file naming convention is the same as the backup name only 
    using hash ('cG#cA') instead of tilde ('cG~cA') and is automatically removed on 
    saving a buffer. 

    On unlimited length file name systems (UNIX), the following file naming 
    conventions are used for file cGxxxxxcA: 

        cGxxxxx -> xxxxx#cA 

    On systems with an cGxxxxxxxx.yyycA file name (DOS etc), the following file 
    naming conventions are used: 

        cGxxxxxxxx     -> xxxxxxxx.###cA 
        cGxxxxxxxx.y   -> xxxxxxxx.y##cA 
        cGxxxxxxxx.yy  -> xxxxxxxx.yy#cA 
        cGxxxxxxxx.yyy -> xxxxxxxx.yy#cA 


cEcENOTES cEcA


    The user is warned to be extra careful if files ending in 'cG~cA' or 'cG#cA's are 
    used, it is advisable to disable backup creation (see lslmglobal-mode(2)le) and 
    auto-saving (cG$auto-time = 0cA). The author denies all responsibility (yet 
    again) for any loss of data! Please be careful. 

    Auto-save files of URL files (i.e. "cGftp://...cA" and "cGhttp://...cA") are 
    written to the system's temporary directory. This avoids potentially slow 
    auto-saves. This can however lead to recovery problems as the buffer name 
    must be used to avoid auto-saving conflict with other buffers with the 
    same base file name but different paths. 


cEcESEE ALSO cEcA


    lslmautosv(2m)le, lslmbackup(2m)le, lslmbuffer-mode(2)le lslmfind-file(2)le, lslmftp(3)le. 

! 5 $buffer-scheme
cEcENAME cEcA


    $buffer-scheme - Buffer color scheme. 
$a


cEcESYNOPSIS cEcA


    cD$buffer-schemecA cCschemeNumcA; Default is cG0cA 


cEcEDESCRIPTION cEcA


    cD$buffer-schemecA sets the current buffer's color scheme to cCschemeNumcA, where 
    cCschemeNumcA is a color scheme defined with lslmadd-color-scheme(2)le, which 
    identifies the foreground and background color schemes of the buffer. The 
    color scheme is initialized to the global color scheme settings (see 
    lslm$global-scheme(5)le) when the buffer is created. 


cEcESEE ALSO cEcA


    lslm$buffer-hilight(5)le, lslm$cursor-color(5)le, lslm$trunc-scheme(5)le, lslm$global-scheme(5)le, 
    lslm$ml-scheme(5)le, lslm$mode-line-scheme(5)le, lslm$scroll-bar-scheme(5)le, lslm$system(5)le. 

! 5 $buffer-fhook
! 5 $buffer-dhook
! 5 $buffer-bhook
! 5 $buffer-ehook
cEcENAME cEcA


|$buffer-fhook
    $buffer-fhook - Buffer macro hook command name (buffer creation) 
|$buffer-dhook
    $buffer-dhook - Buffer macro hook command name (buffer deletion) 
|$buffer-bhook
    $buffer-bhook - Buffer macro hook command name (buffer current) 
|$buffer-ehook
    $buffer-ehook - Buffer macro hook command name (buffer swapped) 
$a


cEcESYNOPSIS cEcA


    cD$buffer-fhookcA cCFunctionNamecA 
    cD$buffer-dhookcA cCFunctionNamecA 
    cD$buffer-bhookcA cCFunctionNamecA 
    cD$buffer-ehookcA cCFunctionNamecA 


cEcEDESCRIPTION cEcA


    Sets the buffer create, delete, begin and end hook command which are 
    executed: 

    cDbuffer-fhookcA 
        When the buffer is created. 

    cDbuffer-dhookcA 
        When the buffer is deleted. 

    cDbuffer-bhookcA 
        When the buffer becomes the current buffer. 

    cDbuffer-ehookcA 
        When the buffer is swapped out from being the current buffer. 

    The variable cD$buffer-fhookcA is largely redundant as the file hook is 
    executed only once and before it can be sent. Its main use is within 
    macros which wish to ascertain what type of buffer it is executing on, 
    i.e. if a command was to be executed only on c file then the follow 
    ensures that this is the case: 
sB
        !if &not &seq $buffer-fhook "fhook-cmode" 
            !abort 
        !endif 

sA
    Where the command cCfhook-cmodecA is the c file hook. 

    cDdhookscA are executed when a buffer is deleted, but before the contents of 
    the buffer are lost. Note that dhooks will not be called if the buffer 
    never becomes active, or if MicroEmacs '02 quits due to the receipt of a 
    panic signal. 

    cDbhookscA and cDehookscA are usually used to set and restore global variables 
    which require different setting in the current buffer. 

    The order of The default settings of these variable are determined by the 
    command lslmadd-file-hook(2)le. 


cEcESEE ALSO cEcA


    lslmadd-file-hook(2)le. 

! 5 $buffer-bname
! 5 $buffer-fname
cEcENAME cEcA


|$buffer-bname
    $buffer-bname - Name of the current buffer 
|$buffer-fname
    $buffer-fname - Name of the current buffer's file name 
$a


cEcESYNOPSIS cEcA


    cD$buffer-bnamecA cCBufferNamecA 
    cD$buffer-fnamecA cCFileNamecA 


cEcEDESCRIPTION cEcA


    cD$buffer-bnamecA the string name of the current buffer. Buffer names are 
    unrestricted in length, but must be unique. By default the buffer name is 
    derived from the buffer's file name without the path. But this can lead to 
    conflicts, caused by identical file names but different paths. In these 
    situations a counter is appended to the end of the buffer name and is 
    incremented until a unique buffer name is created. For example: 

        File Name               Buffer Name 
        _______________________________________ 

        /etc/file.c             file.c 
        /tmp/file.c             file.c<1> 
        /usr/file.c             file.c<2> 


    cD$buffer-fnamecA contains the name of the current buffer's file name complete 
    with path. 


cEcESEE ALSO cEcA


    lslmchange-buffer-name(2)le. 

! 5 $buffer-hilight
cEcENAME cEcA


    $buffer-hilight - Define current buffer hilighting scheme. 
$a


cEcESYNOPSIS cEcA


    cD$buffer-hilightcA cChilightNumcA; Default is cG0cA 

    0 <= cChilightNumcA <= 255 


cEcEDESCRIPTION cEcA


    cD$buffer-hilightcA Sets the current buffer's hi-lighting scheme (see 
    lslmhilight(2)le for a full description of hi-lighting). The default setting is 
    0 which specifies no hi-lighting, when set to a non-zero, the hi-light 
    scheme of that number MUST already be defined. 

    Terminals that cannot display color directly may still be able to take 
    benefit from hi-lighting. A terminal that has fonts can use them in the 
    same way using the lslmadd-color-scheme(2)le command. The hi-light scheme is 
    also used in printing (see lslmprint-buffer(2)le). If, however, your terminal 
    cannot display color in any way, it is recommended that hi-lighting is 
    disabled (except when printing) as it does take CPU time. 


cEcESEE ALSO cEcA


    lslmhilight(2)le, lslmprint-buffer(2)le, lslm$buffer-scheme(5)le, lslm$buffer-indent(5)le. 

! 5 $buffer-input
cEcENAME cEcA


    $buffer-input - Divert buffer input through macro. 
$a


cEcESYNOPSIS cEcA


    cD$buffer-inputcA cCcommandNamecA 


cEcEDESCRIPTION cEcA


    cD$buffer-inputcA allows the buffer input mechanism to be diverted through a 
    command macro defined by cCcommandNamecA. If this variable is set to a valid 
    command, which may be a user defined macro, this command will be called 
    instead. The command can access the actual key-code typed by the user via 
    the command variable lslm@cc(4)le, e.g. the following macro prints out the name 
    of the command that the user presses until the lslmabort-command(2)le is 
    executed. 
sB
        define-macro test-input 
            ml-write &spr "Current command: %s" @cc 
            !if &seq @cc "abort-command" 
                set-variable $buffer-input "" 
            !endif 
        !emacro 

        set-variable $buffer-input test-input 

sA

cEcEWARNING cEcA


    Caution is advised when using this, if there is no way of reseting the 
    variable then cDMicroEmacs '02cA must be killed. 


cEcESEE ALSO cEcA


    lslmabort-command(2)le, lslm@cc(4)le. 

! 5 $buffer-ipipe
cEcENAME cEcA


    $buffer-input - Divert buffer incremental pipe input through macro. 
$a


cEcESYNOPSIS cEcA


    cD$buffer-ipipecA cCcommandNamecA 


cEcEDESCRIPTION cEcA


    cD$buffer-ipipecA allows the buffer incremental pipe input mechanism to be 
    diverted through a command macro defined by cCcommandNamecA. On a buffer 
    running an lslmipipe-shell-command(2)le the command, set by this variable, will 
    be called whenever new text has been inserted by the executing process. 
    Two cCalpha-markscA will be set in the buffer, 'cGicA' denotes the start of the 
    newly inserted text and 'cGIcA' denotes the end. 


cEcESEE ALSO cEcA


    lslmgoto-alpha-mark(2)le, lslmipipe-shell-command(2)le. 

! 5 $buffer-mask
cEcENAME cEcA


    $buffer-mask - Current buffer word class mask. 
$a


cEcESYNOPSIS cEcA


    cD$buffer-maskcA cDstringcA; Default is cGluhcA 


cEcEDESCRIPTION cEcA


    cD$buffer-maskcA sets the current buffer word class mask. MicroEmacs '02 has 
    an internal word lookup table which defines whether a given letter is 
    considered to be part of a word. This functionality is used in many areas 
    such as lslmforward-word(2)le, lslmforward-kill-word(2)le hilighting etc. The mask is 
    composed with any combination of the following flags, the order in which 
    the flags are specified is not important: 

    cDlcA 
        All lower case letters. 

    cDucA 
        All upper case letters. 

    cDhcA 
        All hexadecimal characters (used to include numerical digits). 

    cDscA 
        Spell extended characters, typically set to accent (cG'cA), hyphen (cG-cA) and 
        period (cG.cA). 

    cD1cA 
        User set cD1cA, usually set to just underscore (cG_cA) for many system and 
        programming files such as 'C'. 

    cD2cA 
        User set cD2cA, usually set to 'cG-cA', 'cG$cA', 'cG&cA', 'cG#cA', 'cG!cA', 'cG%cA', 'cG:cA' and 'cG@cA' 
        for MicroEmacs files. 

    cD3cA 
        User set cD3cA, not usually defined. 

    cD4cA 
        User set cD4cA, not usually defined. 

    The character sets may be modified using the lslmset-char-mask(2)le command. 


cEcESEE ALSO cEcA


    lslmset-char-mask(2)le, lslmforward-word(2)le. 

! 5 $buffer-mode-line
cEcENAME cEcA


    $buffer-mode-line - Buffer mode line string 
$a


cEcESYNOPSIS cEcA


    cD$buffer-mode-linecA "cCstringcA" 


cEcEDESCRIPTION cEcA


    Sets the buffer mode line, unique to this buffer, see lslm$mode-line(5)le use, 
    description and syntax. If this variable is NOT set for a buffer and 
    cD$mode-linecA is changed, then the buffer's mode line will also change to the 
    new value. If this variable is set, then then buffer's mode line will be 
    unaffected by any setting of cD$mode-linecA. 


cEcESEE ALSO cEcA


    lslm$mode-line(5)le. 

! 5 $osd-scheme
cEcENAME cEcA


    $osd-scheme - OSD color scheme 
$a


cEcESYNOPSIS cEcA


    cD$osd-schemecA cCschemeNumcA; Default is cG1cA 


cEcEDESCRIPTION cEcA


    cD$ml-schemecA defines the color scheme by default on an lslmosd(2)le dialog, the 
    color scheme cCschemeNumcA identifies the foreground and background color and 
    is defined by an invocation to lslmadd-color-scheme(2)le. Every osd dialog can 
    over-ride this value by using the 'cCScA' flag. 


cEcESEE ALSO cEcA


    lslmosd(2)le, lslmadd-color-scheme(2)le, lslm$global-scheme(5)le, lslm$ml-scheme(5)le, 
    lslm$mode-line-scheme(5)le, lslm$scroll-bar-scheme(5)le, lslm$system(5)le. 

! 5 $cursor-blink
! 5 $cursor-color
cEcENAME cEcA


|$cursor-blink
    $cursor-blink - Cursor blink rate 
|$cursor-color
    $cursor-color - Cursor foreground color 
$a


cEcESYNOPSIS cEcA


    cC$cursor-blinkcA cCintegercA; Default is cG0cA 

    cC$cursor-colorcA cCcolorNumcA; Default is cG0cA 

    0 <= cCcolorNumcA <= cCncA 


cEcEDESCRIPTION cEcA


    cD$cursor-blinkcA sets the cursor's flash rate, i.e. the period in which the 
    cursor is drawn, hidden and then redrawn. The default setting of 0 
    disables cursor blinking. When set to a none zero value the variable is 
    split into two componants, the first 16 bits, or lower short, sets the 
    cursor visible time in milliseconds, and the higher short sets the hidden 
    time. If the hidden time is set to 0 then the cursor will be hidden for 
    the same length of time it is visible. 

    The cursor blink rate can be setup in the platform section of 
    lslmuser-setup(3)le. 

    cD$cursor-colorcA sets the cursor's fore-ground color, and can greatly improve 
    cursor visibility. cCcolorNumcA is a integer palette number created using 
    lslmadd-color(2)le, the default is 0. 


cEcEPLATFORM cEcA


    UNIX termcap interface does not support cD$cursor-colorcA. 


cEcEEXAMPLE cEcA


    The following example sets the cursor visible time to 600 ms (0x258) and a 
    hidden time to 200 ms (0xc8): 
sB
        set-variable $cusror-blink 0x00c80258 

sA

cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmadd-color(2)le, lslm$global-scheme(5)le, lslm$ml-scheme(5)le, 
    lslm$mode-line-scheme(5)le, lslm$system(5)le. 

! 5 $debug
cEcENAME cEcA


    $debug - Macro debugging flag 
$a


cEcESYNOPSIS cEcA


    cD$debugcA cCdebugLevelcA; Default is cG0cA 

    -2 <= cCdebugLevelcA <= 2 


cEcEDESCRIPTION cEcA


    cD$debugcA is a flag to trigger macro debugging. A setting of 1 or 2 enables 
    debugging, 0 disables debugging (default). A cD$debugcA setting of 2 debugs 
    all macro lines encountered, whereas a setting of 1 debugs only the lines 
    executed, i.e. if a false cD!ifcA was encountered the lines within the cD!ifcA 
    would not be printed. Problems arise with cD!elifcA and cD!elsecA and a cCdebugLevelcA 
    setting of 1 as the cD!elifcA and cD!elsecA lines are never printed. 

    A -ve setting disables debugging and has no immediate effect. However as 
    soon as the bell is rung the value is inverted (-1 to 1, -2 to 2) enabling 
    debugging. This can be invaluable when tracing problems, for example the 
    following macro code will loop infinitely:- 
sB
        !repeat 
            beginning-of-line 
            backward-char 
            !force forward-line 
        !until &not $status 

sA
    This is a fairly obvious bug, but if buried in a thousand lines of macro 
    code it could be very difficult to spot and to find it during execution 
    would be very tedious if not impossible. But by setting cD$debugcA to -1 the 
    macro can be executed as normal and as soon as the macro is stuck the user 
    can simply press "cGC-gcA" (cDabort-commandcA) which rings the bell and starts 
    macro debugging at the current execution point. 


cEcESEE ALSO cEcA


    lslmexecute-file(2)le. 

! 5 $fill-eos
! 5 $fill-eos-len
cEcENAME cEcA


|$fill-eos
    $fill-eos - Paragraph filling; end of sentence fill characters 
|$fill-eos-len
    $fill-eos-len - Paragraph filling; end of sentence padding length 
$a


cEcESYNOPSIS cEcA


    cD$fill-eoscA "cCstringcA"; Default is "cG.!?cA" 

    cD$fill-eos-lencA cCintegercA; Default is cG1cA 
    0 <= cCintegercA <= cCncA 


cEcEDESCRIPTION cEcA


    cD$fill-eoscA defines the end of sentence character set. Sentences ending in 
    these characters are padded with additional cCend-of-sentencecA spaces, as 
    defined by cD$fill-eos-lencA. 

    cD$fill-eos-lencA sets the number of spaces inserted after a full stop during 
    paragraph filling. The default is 1 space. 


cEcESEE ALSO cEcA


    lslmfill-paragraph(2)le. 

! 5 $c-brace
cEcENAME cEcA


    $c-brace - C-mode; brace indentation 
$a


cEcESYNOPSIS cEcA


    cD$c-bracecA cCintegercA; Default is cG-4cA 

    cC-ncA <= cCintegercA <= cCncA 


cEcEDESCRIPTION cEcA


    cD$c-bracecA is part of the lslmcmode(2m)le environment for C programmers. 

    Sets the indent of a 'cG{cA' and a 'cG}cA' on a new line, from the current indent. 
    For example, using the default settings, if the current indent was 20 then 
    a line starting with a 'cG{cA' or a 'cG}cA' would be indented to 16, i.e. 

                            xxxxxxxxxxx 
                            xxxxxxxxxxx 
                        { xxxxxxxxxxx 
                            xxxxxxxxxxx 
                        } xxxxxxxxxxx 
                            xxxxxxxxxxx 


    This may seem strange, but the current indent is the indent of the last 
    'cG{cA' (or "cGifcA", "cGelsecA" etc.) plus lslm$c-statement(5)le which is 4, so this brings 
    it back into line with 'cG{cA''s, "cGifcA"'s and "cGelsecA"'s etc., e.g. 

                        if(xxxxxx) 
                        { 
                            xxxxxxxxxx 
                            xxxxxxxxxx 
                        } 


    With a setting of -2, this would become:- 

                        if(xxxxxx) 
                          { 
                            xxxxxxxxxx 
                            xxxxxxxxxx 
                          } 


    This works in conjunction with lslm$c-statement(5)le, a change to cD$c-statementcA 
    will change the position of 'cG{cA's. 


cEcESEE ALSO cEcA


    lslmcmode(2m)le, lslm$c-statement(5)le. 

! 5 $c-case
! 5 $c-switch
cEcENAME cEcA


|$c-case
    $c-case - C-mode; case indentation 
|$c-switch
    $c-switch - C-mode; switch indentation 
$a


cEcESYNOPSIS cEcA


    cD$c-casecA cCintegercA; Default is cG-4cA 
    cC-ncA <= cCintegercA <= cCncA 

    cD$c-switchcA cCintegercA; Default is cG0cA 
    cC-ncA <= cCintegercA <= cCncA 


cEcEDESCRIPTION cEcA


    cD$c-casecA and cD$c-switchcA are part of the lslmcmode(2m)le environment for C 
    programmers. 

    cD$c-switchcA sets the offset of a "cGcasecA" entry statement from the opening 
    brace left margin position. The default value is zero. e.g. 

                        switch(xxxxxxxxx) 
                        { 
                        case 1: 
                            xxxxxxxxxx 
                            xxxxxxxxxx 
                        case 2: 
                            xxxxxxxxxx 
                        } 


    Setting the value to 4, increases the leading space on the "cGcasecA" 
    statement, e.g. 

                        switch(xxxxxxxxx) 
                        { 
                            case 1: 
                                xxxxxxxxxx 
                                xxxxxxxxxx 
                            case 2: 
                                xxxxxxxxxx 
                        } 


    cD$c-casecA sets the offset of the lines following a "cGcasecA" statement, from 
    the current indent. For example, using the default settings, if the 
    current indent was 20 then a line starting with a "cGcasecA" would be indented 
    to 16, i.e. 

                            xxxxxxxxxx 
                        case xxxxxxxxxx 
                            xxxxxxxxxx 


    This is used inside "cGswitchcA" statements, the default setting give the 
    following lay-out:- 

                        switch(xxxxxxxxxx) 
                        { 
                        case 1: 
                            xxxxxxxxxx 
                            xxxxxxxxxx 
                        case 2: 


    This works in conjunction with the lslm$c-statement(5)le, a change to 
    cD$c-statementcA will change the position of 'cG{cA's. 


cEcESEE ALSO cEcA


    lslmcmode(2m)le, lslm$c-statement(5)le. 

! 5 $c-contcomm
cEcENAME cEcA


    $c-case - C-mode; comment continuation string 
$a


cEcESYNOPSIS cEcA


    cD$c-contcommcA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cD$c-contcommcA is part of the lslmcmode(2m)le environment for C programmers. 

    This defines the string which is inserted when a new line is started while 
    in a comment. The string is only inserted if the cursor is at the end of 
    the line when the lslmnewline(2)le command is given. For example, for the 
    default settings, if a cDnewlinecA was entered at the end of the first line, 
    the second line would initialize to:- 

                        /* xxxxxxxxxx 
                           @ 


    where 'cG@cA' is the current cursor position. With a setting of "cG * cA", then:- 

                        /* xxxxxxxxxx 
                         * @ 


cEcESEE ALSO cEcA


    lslmcmode(2m)le. 

! 5 $c-margin
cEcENAME cEcA


    $c-margin - C-mode; trailing comment margin 
$a


cEcESYNOPSIS cEcA


    cD$c-margincA cCintegercA; Default is cG-1cA 

    -1 <= cCintegercA <= cCncA 


cEcEDESCRIPTION cEcA


    cD$c-margincA is part of the lslmcmode(2m)le environment for C programmers. 

    If inserting a comment at the end of a C line, it is tedious typing cCxcA 
    number of spaces to the comment column (by default tab doesn't insert a 
    tab when lslmcmode(2m)le is enabled, it reformats the indentation of the line 
    regardless of the cursor position). This variable sets the indent column 
    of these comments. So with the default settings and the following line, 

                xxxxxx ;/ 


    when a '*' is type the line becomes 

                xxxxxx ;                /* 


    The indenting of the "cG/*cA" occurs only if there is text on the line before 
    it, and none after it. If the current column is already past cD$c-margincA 
    then it is indented to the next tab stop. 

    A value of -1 disables this feature. 


cEcESEE ALSO cEcA


    lslmcmode(2m)le. 

! 5 $c-statement
cEcENAME cEcA


    $c-statement - C-mode; statement indentation 
$a


cEcESYNOPSIS cEcA


    cD$c-statementcA cCintegercA; Default is cG4cA 

    cC-ncA <= cCintegercA <= cCncA 


cEcEDESCRIPTION cEcA


    cD$c-statementcA is part of the lslmcmode(2m)le environment for C programmers. 

    The indent of the current line is derived from cD$c-statementcA plus the 
    indent of the last c token (cCifcA, cCelsecA, cCwhilecA etc.) or the last 'cG{cA' (which 
    ever was found first). i.e. if the last 'cG{cA' was found at column 16 then 
    the current line will be indented to 20:- 

                { 
                    xxxxxxxxxx 
                    xxxxxxxxxx 


    or 

                if(xxxxx) 
                    xxxxxxxxxx 


    C tokens are only used to indent the next line, whereas 'cG{cA' are used in 
    indenting every line to it's partnering 'cG}cA'. 


cEcESEE ALSO cEcA


    lslmcmode(2m)le. 

! 5 $c-continue
! 5 $c-contmax
cEcENAME cEcA


|$c-continue
    $c-continue - C-mode; line continuation indent 
|$c-contmax
    $c-contmax - C-mode; line continuation maximum indent 
$a


cEcESYNOPSIS cEcA


    cD$c-continuecA cCintegercA; Default is cG10cA 
    -n <= cCintegercA <= cCncA 

    cD$c-contmaxcA cCintegercA; Default is cG16cA 
    -n <= cCintegercA <= cCncA 


cEcEDESCRIPTION cEcA


    cD$c-continuecA and cD$c-contmaxcA are part of the lslmcmode(2m)le environment for C 
    programmers. 

    cD$c-continuecA sets the indent to be added to a split line, i.e. for an 
    indent of 20, a continued statement would be indented to 30. A continued 
    statement is a single c statement which is spread over 2 or more lines, 
    the 2nd and any following lines would be indented to 30. For example 

                thisIsAVeryLongVariableWhichMeansAssignmentsAreSplit = 
                          ThisIsTheFirstContinuedStatementLine + 
                          ThisIsTheSecondContinuedStatementLine + etc ; 


    The indent is changed if there is an open bracket, continued statements 
    are indented to the depth of the open bracket plus one, e.g. 

                func(firstFuncArg, 
                     secondFuncArg, 
                     anotherBracketForFun(firstAnotherBracketForFunArg, 
                                          secondAnotherBracketForFunArg), 
                     thirdFuncArg) ; 


    cD$c-contmaxcA sets an upper limit of the indentation where an open bracket is 
    encountered, in the case where the leading indent of the function name and 
    open bracket exceeds cD$c-contmaxcA, then the continuation is reduced to the 
    continuation indent. 

    The effect of cD$c-contmaxcA is described as follows; if cD$c-contmaxcA is set to 
    a large value then the default open brace offset appearence is:- 

        longVariable = LongFunctionNameWhichMeans(isSoFar, 
                                                  OverAndYouRunOutOfRoom) ; 


    Setting cD$c-contmaxcA to 16 gives: 

        longVariable = LongFunctionNameWhichMeans(isSoFar, 
                        overAndYouRunOutOfRoom) ; 


    Where by the second argument indent has been artificially reduced because 
    of it's length. 


cEcESEE ALSO cEcA


    lslmcmode(2m)le. 

! 5 $show-modes
cEcENAME cEcA


    $mode-line - Select buffer modes to display 
$a


cEcESYNOPSIS cEcA


    cD$show-modescA "cCbit-stringcA"; Default is "cGcA" 


cEcEDESCRIPTION cEcA


    cD$show-modescA defines which buffer modes are displayed on the mode-line. 


cEcESEE ALSO cEcA


    lsuser-setup(3)lm$user-setup(3)le, lslm$mode-line(5)le. 

! 5 $file-template
cEcENAME cEcA


    $file-template - Regular expression file search string 
$a


cEcESYNOPSIS cEcA


    cD$file-templatecA "cCstringcA"; Default is "" 


cEcEDESCRIPTION cEcA


    cD$file-templatecA defines a regular expression search string used to identify 
    a file in the lslmgrep(3)le and lslmcompile(3)le buffers. The format of the string is 
    the same as magic mode search strings (see lslmsearch-forward(2)le). 


cEcEEXAMPLE cEcA


    A UNIX file name may be considered to contain any ASCII character except a 
    space or a 'cG:cA' (used as a divider in many programs). Thus cD$file-templatecA 
    should be: 
sB
        set-variable $file-template "[!-9;-z]+" 

sA
    This will correctly identify "cGfoo.ccA" in the following example. 

        foo.c: 45:      printf("hello world\n") ; 


cEcESEE ALSO cEcA


    lslm$line-template(5)le, lslmcompile(3)le, lslmget-next-line(2)le, lslmgrep(3)le, 
    lslmsearch-forward(2)le. 

! 5 $fill-col
cEcENAME cEcA


    $fill-col - Paragraph Mode; right fill column 
$a


cEcESYNOPSIS cEcA


    cD$fill-colcA cCcolumnNumbercA; Default is cG78cA 

    -1 <= cCcolumnNumbercA <= 32767 


cEcEDESCRIPTION cEcA


    cD$fill-colcA defines the current fill column number. cCcolumnNumbercA defaults to 
    78 when undefined. This value is used in conjunction with lslmjustify(2m)le and 
    lslmwrap(2m)le modes. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslmfill-paragraph(2)le, lslmjustify(2m)le, lslmwrap(2m)le. 

! 5 $box-chars
cEcENAME cEcA


    $box-chars - Characters used to draw lines 
$a


cEcESYNOPSIS cEcA


    cD$box-charscA "cCstringcA"; Default is "cG|+++++++++-cA" 


cEcEDESCRIPTION cEcA


    cD$box-charscA is a fixed length string that defines the set of characters 
    used to render lines to the screen. lsosd(2)lmOsd(2)le, lslmdirectory-tree(2)le, 
    lslmlist-registry(2)le and many macros use these characters as a platform 
    independent method of drawing lines. The characters have fixed indices 
    defined as follows:- 

    Index 0 
        Line joining north to south (vertical line). 

    Index 1 
        Line joining south to east. 

    Index 2 
        Line joining south to west. 

    Index 3 
        Line joining north to east. 

    Index 4 
        Line joining north to west. 

    Index 5 
        Line joining east to south to west. 

    Index 6 
        Line joining north to east to south. 

    Index 7 
        Line joining north to east to south to west. 

    Index 8 
        Line joining north to south to west. 

    Index 9 
        Line joining north to east to south. 

    Index 10 
        Line joining east to west. 


cEcEEXAMPLE cEcA


    The cD$box-charscA is typically platform dependent, it's setting is determined 
    by the characters available in character set of the hosting platform. 
    MS-DOS and Microsoft Windows environments might use a string such as:- 

        "\xB3\xDA\xBF\xC0\xD9\xC2\xC3\xC5\xB4\xC1\xC4" 


    X-Windows environments might use a string such as:- 

        "\x19\x0D\x0C\x0E\x0B\x18\x15\x0F\x16\x17\x12" 


    Both utilize platform specific characters. 


cEcESEE ALSO cEcA


    lsosd(2)lmOsd(2)le, lslmdirectory-tree(2)le, lslmlist-registry(2)le lslm$window-chars(5)le. 

! 5 $fmatchdelay
cEcENAME cEcA


    $fmatchdelay- Fence matching delay time 
$a


cEcESYNOPSIS cEcA


    cD$fmatchdelaycA cCdelayTimecA; Default is cG2000cA 

    0 <= cCdelayTimecA <= cCncA 


cEcEDESCRIPTION cEcA


    The number of milliseconds to wait in a fence match operation. When a 
    closing fence 'cG)cA' 'cG]cA' or 'cG}cA' is added the opening fence is searched for, 
    scrolling the screen up where necessary, this is the time that the opening 
    fence is displayed, interruptible by typing any key. 

    When lslmcmode(2m)le is enable the search algorithm used is 'cCCcA' aware and if a 
    matching fence is not found then the bell is rung as a warning. The 
    automatic matching of fences can be enabled/disabled via the lslmfence(2m)le 
    mode. 

    A cursor can be moved to the matching fence using the 
    lslmgoto-matching-fence(2)le command. 


cEcESEE ALSO cEcA


    lslmfence(2m)le, lslmcmode(2m)le, lslmgoto-matching-fence(2)le. 

! 5 $global-scheme
cEcENAME cEcA


    $global-scheme - Default global buffer color scheme. 
$a


cEcESYNOPSIS cEcA


    cG$global-schemecA cGschemeNumcA; Default is cG0cA 


cEcEDESCRIPTION cEcA


    cD$global-schemecA defines the default buffer color scheme to cCschemeNumcA, a 
    color scheme defined by lslmadd-color-scheme(2)le. 


cEcESEE ALSO cEcA


    lslmadd-color(2)le, lslmadd-color-scheme(2)le, lslm$buffer-hilight(5)le, lslm$buffer-scheme(5)le, 
    lslm$cursor-color(5)le, lslm$trunc-scheme(5)le, lslm$ml-scheme(5)le, lslm$osd-scheme(5)le, 
    lslm$mode-line-scheme(5)le, lslm$scroll-bar-scheme(5)le, lslm$system(5)le. 

! 5 %grep-com
cEcENAME cEcA


    %grep-com - Grep command line 
$a


cEcESYNOPSIS cEcA


    cG%grep-comcA "cCstringcA"; Default is "cGgrep cA" 


cEcEDESCRIPTION cEcA


    Sets the command line used to execute a cDgrep(1)cA system command. The output 
    of the lslmgrep(3)le execution should include both file and line number 
    information so that the command lslmget-next-line(2)le can be used properly. 
    This is not defined by default and the cDgrepcA command will not execute until 
    it is defined. 

    cDgrep(1)cA is typically used with the cD-ncA option which produced line numbering 
    information which drives the lslmget-next-line(2)le command. 


cEcEEXAMPLE cEcA


    The following example shows how the cDgrepcA strings are defined. 
sB
        set-variable %grep-com "grep -n " 
        0 add-next-line "*grep*" 
        add-next-line "*grep*" "%f:%l:" 

sA
    This definition corresponds to a cDgrepcA output such as:- 

        m5var000.5:13:Sets the  number of seconds to wait 
        m5var000.5:14:temporary file to t seconds. A 
        m5var000.5:15:Note than the  temporary 
        m5var000.5:17:saving a buffer.  Backup  files are 
        m5var000.5:24:On unlimited  length  file  name  systems 


    where cDgrepcA produces file and line number information for every match. 

    Use lslmadd-next-line(2)le to define the line pattern produced by cDgrepcA. Some 
    versions of cDgrepcA place the file name on a single line matches within the 
    file occur on subsequent lines. In this case additional cCadd-next-linecA 
    patterns may be defined to cater for the cDgrepcA output as follows: 
sB
        set-variable %grep-com "grep /n " 
        0 add-next-line "*grep*" 
        add-next-line "*grep*" "File: %f:" 
        add-next-line "*grep*" "%l:" 

sA
    This definition would be used with a cDgrepcA output such as:- 

        File:m5var000.5: 
        13:Sets the  number of seconds to wait 
        14:temporary file to t seconds. A 
        15:Note than the  temporary 
        17:saving a buffer.  Backup  files are 
        24:On unlimited  length  file  name  systems 
        File:m5var001.5: 


cEcENOTES cEcA


    cDgrep(1)cA is a standard utility on UNIX systems. For Windows 95/NT a version 
    of GNU cDgrepcA may be found at: 

        cC<ftp.winsite.com/ftp/pub/pc/winnt/misc/gnugrep.zip>cA 

    For MS-DOS users, a DJGPP port of cDgrepcA is also available on the net. A 
    commercial version of cDgrepcA is also available from MKS. 


cEcESEE ALSO cEcA


    lslmadd-next-line(2)le, cDgrep(1)cA, lslmgrep(3)le, lslmadd-next-line(2)le. 

! 5 $home
cEcENAME cEcA


    $home - Users `home' directory location 
$a


cEcESYNOPSIS cEcA


    cD$homecA cCdirectorycA 


cEcEDESCRIPTION cEcA


    The file naming convention utilizes tilde ('cG~cA') to identify the users home 
    directory (cG$HOMEcA). When entering a file name: 

        ~/xxx    -> $home/xxx 
        ~yyy/xxx -> $home/../yyy/xxx 


    On most systems this is automatically set to the environment variable 
    "HOME" if it is defined or may be defined explicitly in the start-up file. 
    'cG~cA' may be used in the cGme.emfcA files but must be specified as 'cG~cA'. It may 
    be picked up in command files as cD$homecA. 

! 5 $scroll
cEcENAME cEcA


    $scroll - Screen scroll control 
$a


cEcESYNOPSIS cEcA


    cG$scrollcA cCscrollNumcA; Default is cG1cA 

    0 <= cCscrollNumcA <= n 


cEcEDESCRIPTION cEcA


    cD$scrollcA controls the horizontal and vertical scrolling method used to 
    display long lines and buffers. The variable is split into two componants, 
    the first nibble (cG0x0fcA) sets the horizontal scroll, and the second nibble 
    (cG0xf0cA) sets the vertical. For the purpose of documentation these parts are 
    kept separate, but when setting the variable a single combined value must 
    be given. 

    The horizontal settings are defined as follows: 

    cG0x00cA 
        Scroll method 0 will only scroll the current line, this is the fastest 
        method in execution time. 

    cG0x01cA 
        Scroll method 1 (the default) will scroll the whole page horizontally 
        when the lslmscroll-left(2)le and lslmscroll-right(2)le commands are used. 
        However, when the current line must be scrolled to display the cursor 
        due to a lslmforward-char(2)le type cursor movement, only the current line 
        is scrolled and the rest are reset. 

    cG0x02cA 
        Scroll method 2 always scrolls the whole page horizontally, keeping 
        the cursor in the current column range. If the cursor moves out of 
        this range then all the page is scrolled to the new position. This is 
        particularly useful when editing long lined tables. 

    cG0x03cA 
        Scroll method 3 fixes the scroll column using the cDscroll-leftcA and 
        cDscroll-rightcA functions. If the current cursor position is not visible 
        in the column range then only the current line is scrolled to the new 
        position. 

    The vertical settings are defined as follows: 

    cG0x00cA 
        Scroll method 0 (the default) will scroll the current line to the 
        middle of the current window whenver it is moved off screen, this is 
        the fastest method in execution time. 

    cG0x10cA 
        Scroll method 1 will scroll the current line to the the top of the 
        window whenver the current line is moved off the screen using 
        lslmbackward-line(2)le and to the bottom of the window when lslmforward-line(2)le 
        is used. This creates the effect of a smooth scroll. 


cEcEEXAMPLE cEcA


    The following example sets the scrolling method to be the default 
    horizontally (cG0x01cA) and smooth method (cG0x10cA) vertically : 
sB
        set-variable $scroll 0x11 

sA

cEcESEE ALSO cEcA


    lslmscroll-left(2)le, lslmforward-line(2)le, lslm$window-x-scroll(5)le, lslm$window-y-scroll(5)le. 

! 5 $fill-mode
cEcENAME cEcA


    $fill-mode - Paragraph mode; justification method 
$a


cEcESYNOPSIS cEcA


    cD$fill-modecA cCjustificationcA; Default is cGNcA 

    cCjustificationcA cGbcA | cGccA | cGlcA | cGncA | cGocA | cGrcA | cGBcA | cGCcA | cGLcA | cGNcA | cGRcA 


cEcEDESCRIPTION cEcA


    cD$fill-modecA defines the justification mode i.e. cCleftcA/cCrightcA/cCbothcA/... The 
    default value is none automatic (cDNcA). The modes available are:- 

    cDbcA Both 
        Enables left and right margin justification. 

    cDccA Center 
        Enables center justification. 

    cDlcA Left 
        Enables left justification. 

    cDncA None 
        No filling is performed, adjacent lines are not merged into a single 
        line. This subtly different from cCleftcA justification which fills lines 
        to the lslm$fill-col(5)le. 

    cDocA One Line 
        Enables the filling of the paragraph to a single line. Typically used 
        to prepare a file for transfer to a word processing package. 

    cDrcA Right 
        Enables right justification. 

    cDBcA Both (automatic) 
        Automatically determines the mode, defaulting to left and right (both) 
        justification. 

    cDCcA Center (automatic) 
        Automatically determines the mode, defaulting to center justification. 

    cDLcA Left (automatic) 
        Automatically determines the mode, defaulting to left justification. 

    cDNcA None (automatic) 
        Automatically determines the mode, defaults to cCbothcA and not cCnonecA. 

    cDRcA Right (automatic) 
        Automatically determines the mode, defaulting to right justification. 

    The lines are automatically justified only when the justification mode 
    lslmjustify(2m)le is enabled. Justification is performed between the left and 
    right margins, defined as 0 and lslm$fill-col(5)le respectively. 


cEAutomatic Filling cA


    Automatic filling is performed when the mode cD$fill-modecA is specified in 
    upper case. The format of the line (and adjacent lines) is interrogated 
    and an cCinformedcA guess is made as to the expected formating which is then 
    adopted. The criteria for automatic formatting is defined as follows:- 

    cCcentercA 
        If the left and right margins contain approximately the same amount of 
        white space +/-1 character then the paragraph is centered. 

    cCrightcA 
        If the text commences past half of the lslm$fill-col(5)le (i.e. first half 
        of the line comprises white space) AND the line extends to, or past, 
        the cG$fill-colcA then the paragraph is assumed to be right justified. 

    cCnonecA 
        If the text commences in column 0 and occupies less than half of the 
        line then the paragraph is assumed to be not justified. (i.e. left 
        justified, but consecutive lines of the paragraph are not filled) 

    cCdefaultcA 
        If none of the above criteria are met then the default mode is 
        adopted, as determined by the lower-case value of the cD$fill-modecA 
        value. 


cEcESEE ALSO cEcA


    lslm$fill-col(5)le, lslmbuffer-mode(2)le, lslmfill-paragraph(2)le, lslmjustify(2m)le. 

! 5 $line-template
cEcENAME cEcA


    $line-template - Command line regular expression search string 
$a


cEcESYNOPSIS cEcA


    cD$line-templatecA "cCstringcA"; Default is "" 


cEcEDESCRIPTION cEcA


    cD$line-templatecA defines a regular expression search string used to identify 
    a line number in the lslmgrep(3)le and lslmcompile(3)le buffers. The format of the 
    string is the same as magic mode search strings (see lslmsearch-forward(2)le). 


cEcEEXAMPLE cEcA


    The line number may be considered to contain any numeric number, thus 
    cD$line-templatecA is defined as: 
sB
        set-variable $line-template "[0-9]+" 

sA
    This correctly identifies "45" in the following cD*grep*cA output example: 

        foo.c: 45:      printf("hello world\n") ; 


cEcESEE ALSO cEcA


    lslm$file-template(5)le, lslmcompile(3)le, lslmget-next-line(2)le, lslmgrep(3)le, 
    lslmsearch-forward(2)le. 

! 5 $ml-scheme
cEcENAME cEcA


    $ml-scheme - Message line color scheme 
$a


cEcESYNOPSIS cEcA


    cD$ml-schemecA cCschemeNumcA; Default is cG0cA 


cEcEDESCRIPTION cEcA


    cD$ml-schemecA defines the color scheme to be used on the message line, the 
    color scheme cCschemeNumcA identifies the foreground and background color and 
    is defined by an invocation to lslmadd-color-scheme(2)le. 

    The background color is always defined by lslm$global-scheme(5)le. 


cEcESEE ALSO cEcA


    lslm$global-scheme(5)le, lslm$osd-scheme(5)le, lslm$mode-line-scheme(5)le, 
    lslm$scroll-bar-scheme(5)le, lslm$system(5)le, lslmadd-color-scheme(2)le. 

! 5 $mode-line
cEcENAME cEcA


    $mode-line - Mode line format 
$a


cEcESYNOPSIS cEcA


    cD$mode-linecA "cCstringcA"; Default is "cG%s%r%u me (%e) - %l %b (%f) cA" 


cEcEDESCRIPTION cEcA


    cD$mode-linecA defines the format of the mode line printed for every window, 
    where the character following a percent ('cG%cA') has the following effect:- 

        cGDcA Prints the current day. 
        cGMcA Prints the current month. 
        cGYcA Prints the current year (2 digits). 
        cGycA Prints the current year (4 digits). 
        cGbcA Prints the current buffer's name. 
        cGccA Prints the current buffer's column number. 
        cGecA Prints the current buffer's editing modes. 
        cGfcA Prints the current buffer's file name. 
        cGhcA Prints the current hour of the day. 
        cGkcA Prints the current keyboard macro status. 
        cGlcA Prints the current buffer's line number. 
        cGmcA Prints the current minute of the hour. 
        cGncA Prints the current buffer's total number of lines. 
        cGrcA Prints the current root user status (UNIX only). 
        cGscA Prints the horizontal window split character. 
        cGucA Prints the current buffer's (un)changed or view mode flag. 
        cG%cA Prints a percentage escape character. 
        cG-cA Prints a literal minus character ('cG-cA') - see NOTES. 
        cG*cA All other characters are printed literally. 


cEcENOTES cEcA


        * Refer to lslm$window-chars(5)le for the characters utilized in the mode 
          line. Typically a the 'cG-cA' character is changed to a 'cG=cA' if it is the 
          current window. If a 'cG-cA' is always required, use "cG%-cA". 
        * A buffer can have its own mode-line, and be uneffected be the global 
          mode line, see lslm$buffer-mode-line(5)le. 


cEcESEE ALSO cEcA


    lslm$buffer-mode-line(5)le, lslm$mode-line-scheme(5)le, lslm$window-chars(5)le. 

! 5 $mode-line-scheme
cEcENAME cEcA


    $mode-line-scheme - Mode line color scheme 
$a


cEcESYNOPSIS cEcA


    cD$mode-line-schemecA cCschemeNumcA; Default is cG1cA 


cEcEDESCRIPTION cEcA


    Sets the window mode-line color scheme, defining the foreground and 
    background colors. The cCschemeNumcA is defined by a previous invocation to 
    lslmadd-color-scheme(2)le. 


cEcESEE ALSO cEcA


    lslmadd-color-scheme(2)le, lslm$global-scheme(5)le, lslm$ml-scheme(5)le, 
    lslm$scroll-bar-scheme(5)le, lslm$system(5)le. 

! 5 $mouse-x
! 5 $mouse-y
cEcENAME cEcA


|$mouse-x
    $mouse-x - Mouse X (horizontal) position 
|$mouse-y
    $mouse-y - Mouse Y (vertical) position 
$a


cEcESYNOPSIS cEcA


    cD$mouse-xcA cCintegercA 

    0 <= cCintegercA <= ls$screen-depth(5)lm$screen-widthle - 1 

    cD$mouse-ycA cCintegercA 

    0 <= cCintegercA <= ls$screen-depth(5)lm$screen-depthle - 1 


cEcEDESCRIPTION cEcA


    cD$mouse-xcA and cD$mouse-ycA are automatically set to the position of the mouse 
    at the last mouse event, where an event is a button press or release. 
    Initialized to 0,0. The top left character of the screen is coordinate 0,0 
    bottom right is ls$screen-depth(5)lm$screen-widthle, ls$screen-depth(5)lm$screen-depthle. 


cEcENOTES cEcA


    These variables can not be set. Any attempt to set them will result in an 
    error. 


cEcESEE ALSO cEcA


    lslmset-cursor-to-mouse(2)le, lslm$mouse-pos(5)le, lslm$cursor-x(5)le, lslm$screen-depth(5)le, 
    lslm$screen-width(5)le. 

! 5 $platform
cEcENAME cEcA


|$platform
    $platform - MicroEmacs host platform identifier 
|%platform
    %platform - MicroEmacs host platform type identifier 
$a


cEcESYNOPSIS cEcA


    cD$platformcA "cCstringcA"; Default is platform specific 
    cD%platformcA "cCstringcA"; Default is platform specific 


cEcEDESCRIPTION cEcA


    The cD$platformcA variable is a fixed ASCII string used to identify the 
    current working platform, attempts to set this variable result in an error 
    returned from lslmset-variable(2)le. 

    Possible values are: 

    "cDaixcA" 
        All IBM AIX O/S. 

    "cDdoscA" 
        All IBM-PCs and compatibles running MS-DOS. 

    "cDfreebsdcA" 
        All FreeBSD O/S. 

    "cDhpuxcA" 
        All Hewlett Packard's with HP-UX O/S. 

    "cDirixcA" 
        All Silicon Graphics (SGI) IRIX platforms 4.x, 5.x, 6.x. 

    "cDlinuxcA" 
        All LINUX O/S. 

    "cDsunoscA" 
        All Sun's with SUNOS O/S. 

    "cDunixwr1cA" 
        PC based UNIX platform (Consensus and Unixware). 

    "cDwin32cA" 
        Microsoft Windows based systems including Windows 3.x (with Win32s), 
        Windows '95 and NT. 

    cD$platformcA is often used in cD.emfcA files to allow portability of macro files 
    across platforms, allowing macro files to perform platform specific 
    operations. lslm$system(5)le is also often used for this purpose as its value is 
    easier to assess. 

    cD%platformcA is created at start-up when cGme.emfcA is executed, its value is 
    identical to cD$platformcA except when the platform is a console in which case 
    a 'cGccA' is appended to the $platform value, e.g. for MicroEmacs running a 
    termcap version on LINUX the value will be "cGlinuxccA". The variable is used 
    when the console and window based versions need to be distinguish, e.g. 
    some of the lsuser-setup(3)lmuser-setuple settings. 


cEcEEXAMPLE cEcA


    The following example is taken from the cDme.emfcA file which uses the 
    cD$platformcA variable to load the platform specific initialization files. 
sB
        ; 
        ; load in the platform specific stuff 
        execute-file $platform 

sA
    This could be more explicitly done by: 
sB
        ; 
        ; load in the platform specific stuff 
        !if   &seq $platform "dos"            ; is it an IBM-PC running dos ? 
            execute-file "dos" 
        !elif &seq $platform "irix"           ; is it an sgi ? 
            execute-file "irix" 
        !elif &seq $platform "hpux"           ; is it an hp ? 
            execute-file "hpux" 
            . 
            . 
        !endif 

sA

cEcENOTES cEcA


    The cD$platformcA variable can not be set. Any attempt to set it will result 
    in an error. 


cEcESEE ALSO cEcA


    lslm$system(5)le, lslmset-variable(2)le. 

! 5 $random
cEcENAME cEcA


    $random - Generate a random number 
$a


cEcESYNOPSIS cEcA


    cG$randomcA cCintegercA 

    0 <= cCintegercA <= 65535 


cEcEDESCRIPTION cEcA


    The cD$randomcA variable returns a unique random number in the range 0 - cCncA on 
    reference to the variable. 

    The random number is derived from the system's random number generator 
    (the quality of which is often dubious so try to avoid using the bottom 
    bits). Setting this variable with any value resets the random sequence 
    using the system time as the seed. 

    The range of the random number generator is system dependent. The value is 
    typically capped using the lslm&mod(4)le arithmetic operator. 


cEcEEXAMPLE cEcA


    The variable may be assigned to generate a new seed as follows:- 
sB
        set-variable $random 0        ; Set it so we get a new seed 

sA
    The returned value is used with the cD&modcA operator to limit the value to a 
    desired range:- 
sB
        set-variable %random0to9 &mod $random 10 

sA

cEcESEE ALSO cEcA


    lslm&mod(4)le. 

! 5 $rcs-file
! 5 $rcs-ci-com
! 5 $rcs-cif-com
! 5 $rcs-co-com
! 5 $rcs-cou-com
! 5 $rcs-ue-com
cEcENAME cEcA


|$rcs-file
    $rcs-file - RCS (and SCCS) file name 
|$rcs-ci-com
    $rcs-ci-com - RCS (and SCCS) check in command 
|$rcs-cif-com
    $rcs-cif-com - RCS (and SCCS) check in first command 
|$rcs-co-com
    $rcs-co-com - RCS (and SCCS) check out command 
|$rcs-cou-com
    $rcs-cou-com - RCS (and SCCS) check out unlock command 
|$rcs-ue-com
    $rcs-ue-com - RCS (and SCCS) unedit file command 
$a


cEcESYNOPSIS cEcA


    cD$rcs-filecA "cCstringcA"; Default is "" 
    cD$rcs-ci-comcA "cCstringcA"; Default is "" 
    cD$rcs-cif-comcA "cCstringcA"; Default is "" 
    cD$rcs-co-comcA "cCstringcA"; Default is "" 
    cD$rcs-cou-comcA "cCstringcA"; Default is "" 
    cD$rcs-ue-comcA "cCstringcA"; Default is "" 


cEcEDESCRIPTION cEcA


    RCS (Revision Control System) and SCCS (Source Code Control System) are 
    programmers source code history data-bases. RCS introduces a system in 
    which only one programmer can edit a source file at any one time, 
    enforcing some form of stability in the global environment. The fact that 
    this interface was developed for the RCS system is irrelevant, and should 
    be usable under any other control systems such as SCCS. 

    When using RCS, finding a file (see lslmfind-file(2)le) checks for the existence 
    of the actual file. If this is not found then it checks for the existence 
    of an RCS cD$rcs-filecA variable, and if present then it constructs the RCS 
    file name and checks for its existence. If this file does not exist then 
    it really is a new file and an new buffer is created. If the file does 
    exist then the file is checked out using the cD$rcs-co-comcA which executes to 
    create a file with the original file name, ready for loading. 

    cD$rcs-filecA is the name of the file when it is fully check in, as opposed to 
    when it is ready to be viewed or edited. In RCS, this is usually in the 
    cGRCScA directory with an appended "cG,vcA", i.e. for the file cGfoo.ccA in the cG/testcA 
    directory, when fully checked in, the file will not be found at 
    "cG/test/foo.ccA", but at "cG/test/RCS/foo.c,vcA". When testing for an RCS file, 
    the file name is split into two parts, the path name and the file name, 
    the path is always inserted at the start, and the file name can inserted 
    in the rcs string by using the special "cG%fcA" token, thus if cD$rcs-filecA is 
    set to "cGRCS/%f,vcA", the RCS file name is constructed from "cG/test/cA" + "cGRCS/cA" 
    + "cGfoo.ccA" + "cG,vcA". 

    If the RCS file is found then the cD$rcs-co-comcA (RCS cDCcAheck cDOcAut cDCOMcAmand) 
    which is a simple system command line with the exception for cG%fcA which is 
    replaced by the file name, is executed. This is expected to create the 
    file (with the correct file name) ready for viewing. 

    Once a file is loaded, then the lslmrcs-file(2)le command has one of two 
    effects:- 

        If the file is in view mode then the cD$rcs-cou-comcA (RCS cDCcAheck cDOcAut 
        cDUcAnlock cDCOMcAmand) is executed (system command line using the "%f" as the 
        file name). If the RCS file does not exist then is simply toggles the 
        view mode, allowing editing. 

        If the file is not in view mode MicroEmacs attempts to check the file 
        back into RCS using either cD$rcs-ci-comcA (if the RCS file already 
        exists) or the the cD$rcs-cif-comcA (RCS cDCcAheck cDIcAn cDFcAirst cDCOMcAmand). The "cG%fcA" 
        is again used for the file name, the "cG%mcA" can also be used to get a 
        comment from the user at check in time which will be inserted (without 
        quotes) into the cD$rcs-ci-comcA command line. For example, one possible 
        cD$rcs-ci-comcA setting is "cGci -m\"%m\" %fcA" which uses the cDci(1)cA program 
        with the cD-mcA option to give a check in message. 

    If cDrcs-filecA is given a -ve argument instead of checking in or out the 
    current buffer's file it executes the command specified by cD$rcs-ue-comcA to 
    unedit or abort any changes made to the file. After the command has been 
    executed the file is reloaded. 


cEcENOTES cEcA


    The RCS variables are by default undefined and must be explicitly enabled 
    in the start-up files. 


cEcEEXAMPLE cEcA


    The following are typical variable definitions for the RCS interface:- 
sB
        set-variable $rcs-file     "RCS/%f,v" 
        set-variable $rcs-co-com   "co %f" 
        set-variable $rcs-cou-com  "co -l %f" 
        set-variable $rcs-ci-com   "ci -u -m\"%m\" %f" 

sA
    Note that the cD$rcs-cif-comcA variable is usually left unassigned and 
    cD$rcs-ci-comcA is used by default. 

    The following are typical variable definitions for the SCCS interface:- 
sB
        set-variable $rcs-file     "SCCS/s.%f" 
        set-variable $rcs-co-com   "sccs get %f" 
        set-variable $rcs-cou-com  "sccs edit %f" 
        set-variable $rcs-ci-com   "sccs delget -y\"%m\" %f" 
        set-variable $rcs-ci-com   "sccs create %f" 
        set-variable $rcs-ue-com   "sccs unedit %f" 

sA
    The following variable definitions can be used for MicroSoft's Visual 
    Source Safe:- 
sB
        set-variable $rcs-file    "%f" 
        set-variable $rcs-cou-com "ss.exe checkout %f" 
        set-variable $rcs-co-com  "ss.exe checkout %f" 
        set-variable $rcs-ci-com  "ss.exe checkin %f \"-c%m\"" 

sA
    The above definitions can check a file out for edit and commit changes 
    back. 


cEcESEE ALSO cEcA


    lslmfind-file(2)le, lslmrcs-file(2)le. 

! 5 $screen-depth
! 5 $screen-width
cEcENAME cEcA


|$screen-depth
    $screen-depth - Number of character lines on the screen canvas 
|$screen-width
    $screen-width - Number of character columns on the screen canvas 
$a


cEcESYNOPSIS cEcA


    cD$screen-depthcA cCintegercA 

    3 <= cCintegercA <= 400 

    cD$screen-widthcA cCintegercA 

    8 <= cCintegercA <= 400 


cEcEDESCRIPTION cEcA


    These variables allow the viewable size of the screen canvas to be 
    determined. 

    cD$screen-depthcA identifies number of screen lines currently used. This is 
    the whole screen not the window length. The value returned is in the range 
    3 - cCncA, cCncA is system dependent but no greater than 400. 

    cD$screen-widthcA identifies the number of screen columns currently used 
    (whole screen). The value returned is in the range 8 - cCncA, cCncA is system 
    dependent but no greater than 400. 


cEcESEE ALSO cEcA


    lslmchange-screen-depth(2)le, lslmchange-screen-width(2)le. 

! 5 $mouse-pos
cEcENAME cEcA


    $mouse-pos - Mouse position information 
$a


cEcESYNOPSIS cEcA


    cD$mouse-poscA cCintegercA 


cEcEDESCRIPTION cEcA


    cD$mouse-poscA is generated by invocation of the command 
    lslmset-cursor-to-mouse(2)le. The variable is set to a value that indicates the 
    position of the mouse within a window. The values to the mouse 
    intersection are interpreted as follows:- 

    cD0 - Text areacA 
        Intersection with the window text area. 

    cD1 - Message LinecA 
        Intersection with the message line. 

    cD2 - Mode LinecA 
        Intersection with the mode line. 

    cD3 - Horizontal SeparatorcA 
        Intersection with the horizontal window separator. This value is only 
        set if a scroll bar is not present. 

    cD4 - Up ArrowcA 
        Intersection with the scroll bar up-arrow character. 

    cD5 - Upper ShaftcA 
        Intersection with the scroll bar upper shaft (above the scroll box). 

    cD6 - Scroll BoxcA 
        Intersection with the scroll bar scroll box. 

    cD7 - Lower ShaftcA 
        Intersection with the scroll bar lower shaft (below the scroll box). 

    cD8 - Down ArrowcA 
        Intersection with the scroll bar down-arrow character. 

    cD9 - CornercA 
        Intersection with the window corner, that is the character at the 
        intersection of the scroll bar (or separator) and the mode line. 

    cD10 - Menu LinecA 
        Intersection with the menu line. 

    cD255 - ErrorcA 
        The position of the mouse could not be determined. This value should 
        not arise, if it does then it is an indication that the window 
        structure is probably corrupted. A lslmdelete-other-windows(2)le is 
        suggested or rapid exit from the editor after a lslmsave-some-buffers(2)le 
        command to save any edits (latter option is preferred). 

    cDBit 4 - 2nd ColumncA 
        Bit 4 (16) is set if 2 character column scroll bar or vertical window 
        separator is in effect and the cursor exists in the second column This 
        value is bitwise OR'ed with the aforementioned intersection values. 


cEcEEXAMPLE cEcA


    The following macro can be used to print out the current position of the 
    mouse, try binding the macro to the "cGmouse-movecA" key: 
sB
        define-macro print-mouse-position 
            !force set-cursor-to-mouse 
            set-variable #l0 &band $mouse-pos 15 
            !if &equ #l0 0 
                ml-write "Mouse in text window" 
            !elif &equ #l0 1 
                ml-write "Mouse on message line" 
            !elif &equ #l0 2 
                ml-write "Mouse on Mode line" 
            !elif &and &gre #l0 2 &les #l0 10 
                ml-write "Mouse on scroll bar" 
            !elif &equ #l0 10 
                ml-write "Mouse on corner" 
            !elif &equ #l0 11 
                ml-write "Mouse on menu line" 
            !endif 
        !emacro 

        global-bind-key print-mouse-position mouse-move 

sA
    cD$mouse-poscA is utilized by the mouse picking code, found in macro file 
    cGmouse.emfcA. 


cEcESEE ALSO cEcA


    lslm$mouse-x(5)le, lslm$mouse-y(5)le, lslmset-cursor-to-mouse(2)le, 
    lslmset-scroll-with-mouse(2)le. 

! 5 %compile-com
cEcENAME cEcA


    %compile-com - Default system compile command line 
$a


cEcESYNOPSIS cEcA


    cD%compile-comcA "cCstringcA"; Default is "cGmakecA" 


cEcEDESCRIPTION cEcA


    Sets the default command-line inserted into the message line when the 
    lslmcompile(3)le command is executed. cD%compile-comcA does not need to be defined 
    to run the cDcompilecA command. 


cEcESEE ALSO cEcA


    lslmcompile(3)le, lslm%grep-com(5)le. 

! 5 $status
cEcENAME cEcA


    $status - Macro command execution status 
$a


cEcESYNOPSIS cEcA


    cD$statuscA cCbooleancA 

    cCbooleancA cGTRUEcA (1) | cGFALSEcA (0) 


cEcEDESCRIPTION cEcA


    cD$statuscA contains the return status of the last command executed (cGTRUEcA or 
    cGFALSEcA). cD$statuscA is generally used with the ls!force(4)lm!forcele directives in macros. 


cEcENOTES cEcA


    This variable can not be set, any attempt to set it will result in an 
    error. 


cEcEEXAMPLE cEcA


    The following example shows how the variable is used within a macro 
    construct, it converts all tab characters to their SPACE equivalent. 
sB
        ; 
        ; tabs-to-spaces. 
        ; Convert all of the tabs to spaces. 
        define-macro tabs-to-spaces 
            ; Remember line 
            set-variable #l0 $window-line 
            beginning-of-buffer 
            !force search-forward "\t" 
            !while $status 
                set-variable #l1 $window-acol 
                backward-delete-char 
                &sub #l1 $window-acol insert-space 
                !force search-forward "\t" 
            !done 
            goto-line #l0 
            screen-update 
            ml-write "[Converted tabs]" 
        !emacro 

sA
    In this case cD$statuscA monitors the lssearch-forward(2)lmsearch-forwardle command which is 
    searching for a tab character. The command returns a status value of cGTRUEcA 
    if a tab is found, otherwise cGFALSEcA. 

    The cD!forcecA statement prevents the macro from terminating when a cGFALSEcA 
    condition is detected, if omitted the macro would terminate with an error 
    as soon as the cGFALSEcA status is encountered. The definition of 
    lslmtabs-to-spaces(3)le can be found in format.emf. 


cEcESEE ALSO cEcA


    lslmexecute-file(2)le, lslm!force(4)le, lslm$result(5)le, lslmtabs-to-spaces(3)le. 

! 5 $result
cEcENAME cEcA


    $result - Various command return values 
$a


cEcESYNOPSIS cEcA


    cD$resultcA cCreturnValuecA 


cEcEDESCRIPTION cEcA


    cD$resultcA is used to return the results of several commands: 

    lslmbuffer-info(2)le cD$resultcA is set to the same output string as printed to the 
    message-line by this command. 

    lslmchange-font(2)le 
        cD$resultcA is used to return the user select font when hte windows font 
        selection dialog is used (Windows systems only). 

    lslmcount-words(2)le 
        cD$resultcA is set to the same output string as printed to the 
        message-line by this command. 

    lslmfind-registry(2)le 
        cD$resultcA is used to return the name of a registry child node given the 
        parent and index from the user. 

    lslmget-registry(2)le 
        cD$resultcA is used to return the current value of a user supplied 
        registry entry. 

    lslmmark-registry(2)le 
        cD$resultcA is used to return the full name of the given registry node. 

    lslmosd(2)le 

        cD$resultcA is used to give and return information to osd item commands, 
        information depends on the type of cDosdcA item. 

    lslmosd-dialog(3)le 
        lslmosd-xdialog(3)le 

        cD$resultcA is used to return the button pressed by the user. 

    lslmshell-command(2)le 

        cD$resultcA is set to the exit status of the cDsystemcA call. The combination 
        of cDshell-commandcA calls and return value checking can be used in a 
        variety of ways, for example, to test the existence of a file: 
sB
        set-variable %filename @ml"Enter file name" 
        shell-command &cat "test -f " %filename 
        !if &equ $result 0 
            ml-write "file exists" 
        !else 
            ml-write "file does not exists" 
        !endif 

sA
    lslmshow-region(2)le 

        cD$resultcA is set to the current status of the region when an argument of 
        cC0cA is given to cDshow-regioncA. 

    lslmspell(2)le 

        cD$resultcA is used to return information on the current word, the 
        information depends on the argument given to cDspellcA. 

    lslm$file-names(5)le 

        cD$resultcA is set to the absolute path of the cD$file-namescA query directory 
        when the variable is set. 

    For more information see the help pages on referenced commands and 
    variables. 


cEcENOTES cEcA


    The current value of cD$resultcA is lost on the next command call which uses 
    it. As a call to lslmcreate-callback(2)le can cause the execution of a macro to 
    interrupt another which is waiting for user input, the value of cD$resultcA 
    should be copied before getting user input. 


cEcESEE ALSO cEcA


    lslmbuffer-info(2)le, lslmchange-font(2)le, lslmcount-words(2)le, lslmfind-registry(2)le, 
    lslmget-registry(2)le, lslmmark-registry(2)le, lslmosd(2)le, lslmshell-command(2)le, 
    lslmshow-region(2)le, lslmspell(2)le, lslm$file-names(5)le. lslmcreate-callback(2)le, lslm$status(5)le. 

! 5 $tabsize
cEcENAME cEcA


    $tabsize - Tab character width 
$a


cEcESYNOPSIS cEcA


    cD$tabsizecA cCintegercA; Default is cG4cA 

    -0 < cCintegercA <= cCncA 


cEcEDESCRIPTION cEcA


    cD$tabsizecA defines the width of a tab character. 

    Setting tabs to arbitrary widths is possible in MicroEmacs '02 but you 
    must be aware of a subtle difference that it makes to your file and hence 
    to your editing. When you start MicroEmacs '02, the tab width is set to 
    the default (usually every 8th column) for the tab character (cGCTRL-IcA). As 
    long as you stay with the default, every time you insert the tab 
    character, a CTRL-I get inserted. Hence, you logically have a single 
    character which might appear to be several spaces on the screen (or the 
    output) depending upon the column location of the tab character. This 
    means that to remove the spacing you have to delete a cCsinglecA character -- 
    the tab character. 

    On the other hand, the moment you explicitly set the tab interval (even if 
    it is to the default value), MicroEmacs '02 handles the tab character by 
    expanding the character into the required number of spaces to move you to 
    the appropriate column. In this case, to remove the spacing you have to 
    delete the appropriate number of spaces inserted by M-e to get you to the 
    right column. 

    The operating mode of the tab expansion is controlled by the lslmtab(2m)lemode. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le lslmtab(2m)le, lslm$tabwidth(5)le. 

! 5 $tabwidth
cEcENAME cEcA


    $tabwidth - Tab character interval 
$a


cEcESYNOPSIS cEcA


    cD$tabwidthcA cGintegercA; Default is cG8cA 

    -0 < cCintegercA <= cCncA 


cEcEDESCRIPTION cEcA


    cD$tabwidthcA defines the interval of a tab character. 

    The tab interval is set to the given numeric argument. As always, the 
    numeric argument precedes the command. Hence to get tabs every 4 spaces 
    you would set the cD$tabwidthcA to 4. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le lslmtab(2m)le, lslm$tabsize(5)le. lslmtabs-to-spaces(3)le. 

! 5 %tag-file
! 5 %tag-template
! 5 %tag-option
cEcENAME cEcA


|%tag-file
    %tag-file - Tags file name 
|%tag-template
    %tag-template - Tag file search string 
|%tag-option
    %tag-option - Tag file search option 
$a


cEcESYNOPSIS cEcA


    cD%tag-filecA "cCfileNamecA" 
    cD%tag-templatecA "cCstringcA" 
    cD%tag-optioncA "cCstringcA" 


cEcEDESCRIPTION cEcA


    The cD%tag-filecA and cD%tag-templatecA variables must be defined for lslmfind-tag(2)le 
    to work, they define the information required to locate tag references. 

    cD%tag-filecA is the name of the tag file to be used, usually set to "cDtagscA". 
    cD%tag-templatecA is a regular expression search string used to identify tags 
    in a tag file. For example, a tag usually consists of a name "cG%[^\t]cA" 
    followed by a tab "cG\tcA" followed by the file name that contains the 
    function "cG%[^\t]cA" followed by another tab, followed by the search string 
    and end of line "cG%[^\n]\ncA", i.e. 
sB
        set-variable %tag-template  "%[^\t]\t%[^\t]\t%[^\n]\n" 

sA
    This would match a cDvi(1)cA tag string definition, as created by the UNIX 
    utility cDctags(1)cA. The tags file typically contains entries such as:- 

        $auto-time    m5var000.5 /^.XI $auto-time - "Automatic buffer"$/ 
        $buffer-bhook m5var002.5 /^.XI $buffer-bhook - "Buffer macro"$/ 
        $buffer-ehook m5var002.5 /^.XI $buffer-ehook - "Buffer macro"$/ 


    The cDtag-templatecA definition is modified to match the output of the 
    cDctags(1)cA utility. The format of the tags file may differ from platform to 
    platform, typically the differences are encountered in the line contents 
    field which is usually defined as cG/ .... /cA for a forward search tag and cG? 
    .... ?cA for a reverse search tag. Note that a tag's search string typically 
    starts with the character 'cG^cA' and ends with 'cG$cA' which indicate the start 
    and end of the line. The variable fields are expected to be in 
    conventional order of cClabelcA, cCfilenamecA and cClineTextcA. 

    cD%tag-optioncA is a user defined variable that modifies the behavior of 
    lslmfind-tag(2)le. This is defined as a string, where each character identifies 
    an option, when undefined then default behavior is assumed. The options 
    are defined as:- 

    cDmcA - Enable multiple tags support 
        Allows a single tag to be present multiple times in the tag file, 
        typically used when a function is defined multiple times. When enabled 
        cDfind-tagcA can be used to loop through all definitions of a given tag. 

    cDrcA - recursive tags file 
        By default, the cDtagscA file is assumed to reside in the current 
        directory location. The cDrcA option enables an ascending search up the 
        directory hierarchy from the current directory position in search of a 
        recursively generated tags file. 

    cDccA - Continue recursive tag search 
        Used in conjunction with flag cDrcA; when not specified, the recursive 
        searching of a tag stops at the first tag file found, regardless of 
        whether the given tag was located in the found tag file. If this flag 
        is given and the tag was not found in the first tag file, the 
        recursive search continues. This allows local tag files to be created 
        and regularly maintained, yet still being able to access a higher 
        level tag file when required. 

    Modifications to this variable should be made in the cCusercA.emf file, e.g. 
    To enable multi recursive ascent tag searching define:- 
sB
        set-variable %tag-option  "mrc" 

sA

cEcENOTES cEcA


    Note that GNU Emacs uses it's own tag file format generated by cDetags(1)cA 
    which does not contain the appropriate information to drive the MicroEmacs 
    '02 cDfind-tagcA command. 

    The above settings should support the extended version 2 tag file format 
    which has an extra tag type field at the end of each line. 


cEcESEE ALSO cEcA


    cDctags(1)cA, lslmctags(3f)le, lslmfind-tag(2)le, cDvi(1)cA. 

! 5 $timestamp
cEcENAME cEcA


    $timestamp - Time stamp string 
$a


cEcESYNOPSIS cEcA


    cD$timestampcA "cCstringcA"; Default is "cG<%Y%M%D.%h%m>cA" 


cEcEDESCRIPTION cEcA


    cD$timestampcA defines the file time-stamping string. MicroEmacs '02 searches 
    for, and modifies, the string to the current time and date whenever the 
    file is saved (written to disk) and lslmtime(2m)le mode is enabled. 

    Time stamp string is defined, by default, as "cG<%Y%M%D.%h%m>cA". The first 
    occurrence of the string in the file is up-dated with the time and date 
    information when the buffer is written. The cD$timestampcA string may contain 
    any text, and includes the following, magic characters escaped by a 
    percentage (`cG%cA') character:- 

        cGDcA - Day. 
        cGMcA - Month. 
        cGYcA - Year. 
        cGhcA - Hour. 
        cGmcA - Minute. 
        cGscA - Second. 

    The format string may be redefined into any format. The 'cG%cA' character has 
    to be delimited by another 'cG%cA' if it is to be used in the text (i.e. 
    "cG%%cA"). 

    The year component (cG%YcA) may be a 2 or 4 digit string, depending whether it 
    includes the century. When the time stamping searches for the cG%YcA component 
    it searches for either variant and replaces appropriately. 


cEcEEXAMPLE cEcA


    The startup file may define the time stamp required as follows:- 
sB
        set-variable $timestamp "Last Modified : %Y/%M/%D %h:%m:%s" 

sA
    Time stamping is performed on the string :- 

        Last Modified : 90/11/23 10:12:01 


    Where the time stamp is modified according to the file (buffer) type then 
    the time stamp string may be modified within the buffer hooks. This allows 
    different files to utilize different time stamping strings. The following 
    example shows how the entry and exit buffer hooks are defined to modify 
    the string: 
sB
        0 define-macro bhook-nroff 
            set-variable .timestamp $timestamp 
            ; Buffer specific time stamp string. 
            set-variable $timestamp "[%Y/%M/%D %h:%m:%s]" 
        !emacro 
        0 define-macro ehook-nroff 
            ; Restore the existing time stamp. 
            set-variable $timestamp .bhook-nroff.timestamp 
        !emacro 

sA
    On entry to the buffer (buffer becomes current) the buffer hook 
    cDbhook-nroffcA is executed which stores the current setting and then modifies 
    the time stamp string. On exit from the buffer the buffer hook cDehook-nroffcA 
    is executed restoring the time stamp string. 


cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le lslmtime(2m)le. 

! 5 $window-mode-line
! 5 $window-scroll-bar
cEcENAME cEcA


|$window-mode-line
    $window-mode-line - Window mode line position 
|$window-scroll-bar
    $window-scroll-bar - Window scroll bar (or separator) position 
$a


cEcESYNOPSIS cEcA


    cD$window-mode-linecA cCintegercA 

    1 <= cCintegercA <= ls$screen-depth(5)lm$screen-depthle - 2 

    cD$window-scroll-barcA cCintegercA 

    0 <= cCintegercA <= ls$screen-depth(5)lm$screen-widthle - 1 


cEcEDESCRIPTION cEcA


    cD$window-mode-linecA stores the screen line of the current windows mode-line, 
    where screen lines are counted from 0 at the top of the screen. Often used 
    in conjunction with lslmset-cursor-to-mouse(2)le and lslm$mouse-y(5)le to add more 
    complex mouse functionality. 

    cD$window-scroll-barcA stores the screen position of the right-hand horizontal 
    window separator line or scroll-bar (see lslmsplit-window-horizontally(2)le and 
    lslm$scroll-bar(5)le). A value of greater than lslm$screen-width(5)le indicates that 
    there is no right-hand separator column or scroll bar present. Often used 
    in conjunction with lslm$mouse-x(5)le. 


cEcEEXAMPLE cEcA


    In the following example the position of the mouse is checked to see if it 
    is on the mode line of the window, if so then a different action is taken. 
sB
        set-cursor-to-mouse 
        ;   If we are on the mode line then interpret position of 
        ;   the cursor on line to control the screen. 
        !if &equal $window-mode-line $mouse-y 
            !if &less $mouse-x "2" 
                menu-main     ; Inform buffer to pop up menu. 
            !elif &equal $mouse-x "2" 
                delete-window 
            !elif &equal $mouse-x "3" 
                delete-other-windows 
            !elif &equal $mouse-x "4" 
                backward-page 
            !elif &equal $mouse-x "5" 
                forward-page 
            !elif &equal $mouse-x "6" 
                recenter 
            !elif &equal $mouse-x "7" 
                undo 
            !endif 
        !else 
            ..... 
        !endif 

sA

cEcESEE ALSO cEcA


    lslm$mode-line(5)le, lslm$mouse-x(5)le, lslm$mouse-y(5)le, lslm$scroll-bar(5)le, lslm$mouse-pos(5)le, 
    lslmset-cursor-to-mouse(2)le, lslmsplit-window-horizontally(2)le. 

! 5 $system
cEcENAME cEcA


    $system - System configuration variable 
$a


cEcESYNOPSIS cEcA


    cD$systemcA cCbitmaskcA; Default is system dependent 


cEcEDESCRIPTION cEcA


    The cD$systemcA is used to define and configure the MicroEmacs environment, it 
    is a bit based flag where:- 

    cD0x001cA 
        This bit is set if MicroEmacs is running in Console mode. On UNIX 
        systems the default is to use X whenever possible, in which case this 
        bit will be clear. If X is not used then a TERMCAP base interface is 
        used instead and this bit will be set (see notes below on how to set 
        which interface to use). On all other systems this bit will be clear. 

    cD0x002cA 
        If this bit is set then the current system supports definable RGB 
        colors allowing any color to be created and used in a lsadd-color(2)lmcolor schemele. 
        This bit cannot be set, typically Windows and UNIX X-Windows systems 
        support this. 

    cD0x004cA 
        If this bit is set then the current system supports ANSI colors (8 
        colors, black, red, green, yellow, blue, magenta, cyan & white), bits 
        0x002 and 0x004 are mutually exclusive. On UNIX systems if the TERMCAP 
        interface is being used then this bit can be changed to (de)select the 
        used of color. Many unix terminals do not support color so this should 
        be set appropriately. On all other systems this bit cannot be changed 
        and MS-DOS is currently the only other system to use ANSI colors. 

    cD0x008cA 
        If this bit is set then the current system supports Extended ANSI 
        colors, brighter versions of the 8 ANSI colors doubling the number of 
        colors available to 16. On UNIX systems if the TERMCAP interface is 
        being used then this bit can be changed to (de)select the used of bold 
        with color to create this extended color set for foreground colors. 
        But many UNIX terminals do not support this use of color with the bold 
        font so this should be set appropriately. On all other systems this 
        bit cannot be changed and MS-DOS is currently the only other system to 
        support this. 

    cD0x010cA 
        If this bit is set then the current system supports the use of fonts 
        (bold, italic, light and underline). Whether these fonts can be 
        successfully utilized depends upon the platform and the system font 
        being used, for UNIX TERMCAP systems it will also depend on the 
        terminal being used. This option is not supported on MS_DOS. 

    cD0x080cA 
        This bit is set if the current system is a UNIX based system such as 
        LINUX or HPUX. This bit cannot be altered, its use is within macros. 

    cD0x100cA 
        This bit is set if the current system is a Microsoft based system such 
        as DOS or Windows '95. This bit cannot be altered, its use is within 
        macros. 

    cD0x200cA 
        If this bit is set then the current system uses the concept of drives 
        (i.e. cGc:/cA on DOS systems). This bit cannot be altered, its use is 
        within macros. 

    cD0x400cA 
        If this bit is set then a DOS style cG8.3cA file naming system should be 
        used (i.e. "cGBBBBBBBB.XXXcA"), otherwise an unlimited file name length is 
        used. This effects the backup and auto-save file names generated by 
        MicroEmacs, the bit can be altered on systems that support unlimited 
        file name length. 

    cD0x800cA 
        If this bit is set then the current system supports and uses 
        lslmipipe-shell-command(2)le when required. For systems such as DOS which 
        cannot support ipipes, this bit will be clear and cannot be altered. 
        For systems which do support ipipes, this bit can be cleared to 
        disable their use. 

    cD0x1000cA 
        If this bit set, the then execution of the lslmtab(2)le command (bound to 
        cGtabcA) always checks and adjusts the indentation of the current line 
        when the current buffer is in lslmcmode(2m)le or has an lsindent(2)lmindentationle method. 
        If the bit is clear then the cGtabcA may only checks the indentation when 
        the cursor is in column zero depending on the setting of bit cD0x200000cA. 

    cD0x2000cA 
        If this bit is set the main menu Alt hot-key bindings are enabled. 
        These are dynamic bindings automatically generated from the main menu. 
        Typically the first item in the main menu is "cGFilecA" with a hot key of 
        'cDFcA', with this bit set 'cGA-fcA' will open this menu item. Note that 
        global and local key bindings override these. Also see bit cD0x4000cA. 

    cD0x4000cA 
        If this bit is set the Alt key acts as a lsprefix(2)lmprefix 1le modifier key. By 
        default 'cGA-ncA' is not bound, with this bit set the key is inferred to 
        'cGesc ncA' which is bound to cDforward-paragraphcA. Note that global, local 
        and menu hot-key bindings override these. Also see bit 0x2000. 

    cD0x8000cA 
        If this bit is set the lsundo(2)lmundole history is kept after a save allowing the 
        lslmundo(2)le command to back-up changes beyond the last save. When clear 
        the undo history is discarded after the buffer is saved. 

    cD0x10000cA 
        Enable box character rendering fix, supported on Win32 and XTerm 
        interfaces only. Windows ANSI fonts and many XTerm ISO-8859-1 fonts do 
        not have well formed box characters which are used by lslmosd(2)le and other 
        commands to create a better looking interface. When this bit is 
        enabled MicroEmacs traps the printing of characters with an ASCII 
        value of less than 32 and renders them directly. Following is a table 
        of supported characters, other characters in the range of cG0x00cA to cG0x1fcA 
        not listed are rendered as a space: 

            cG0x09cA 
                Special Character; Tab 

            cG0x0bcA 
                Box Character; Bottom right 

            cG0x0ccA 
                Box Character; Top right 

            cG0x0dcA 
                Box Character; Top left 

            cG0x0ecA 
                Box Character; Bottom left 

            cG0x0fcA 
                Box Character; Center cross 

            cG0x10cA 
                Arrows; Right 

            cG0x11cA 
                Arrows; Left 

            cG0x12cA 
                Box Character; Horizontal line 

            cG0x15cA 
                Box Character; Left Tee 

            cG0x16cA 
                Box Character; Right Tee 

            cG0x17cA 
                Box Character; Bottom Tee 

            cG0x18cA 
                Box Character; Top Tee 

            cG0x19cA 
                Box Character; Vertical Line 

            cG0x1ecA 
                Arrows; Up 

            cG0x1fcA 
                Arrows; Down 

    cD0x20000cA 
        Enables the client server, default is disabled (UNIX and Win32 NT or 
        Win95+ platforms only). When enabled a hidden "cG*server*cA" buffer is 
        created which monitors commands written to the server, the socket 
        "cG/tmp/mesrvcAcDuidcA" on UNIX systems and the command input file 
        "cD$TEMPcAcG/mecAcD$MENAMEcAcG.cmdcA" on Win32 systems. Commands can be written out 
        using the command lslmipipe-write(2)le while in the "*server*" buffer, the 
        command is written to the same socket on UNIX systems and to the 
        response file and response file "cD$TEMPcAcG/mecAcD$MENAMEcAcG.rspcA" on Win32 
        systems. This functionality is used by the cD-mcA and cD-ocA lsme(1)lmcommand-linele 
        options and by the lsmemsdev(1)lmMicroSoft DevStudiole interface. 

    cD0x40000cA 
        Enables the capture of the Alt space key ("cGA-spacecA"), default is 
        enabled (Win32 platform only). In the Windows environment the Alt 
        Space key is used to activate the main window's pull down menu at the 
        top left. if this bit is set MicroEmacs captures this key and executes 
        it as normal, thereby disabling this standard windows binding. 

    cD0x80000cA 
        Enables the drawing of visible white spaces, i.e. space, tab and 
        new-line characters. When disabled (default) white spaces are drawn 
        using spaces ('cG cA') which means the user cannot distinguish between a 
        tab and spaces or determine the last character of the line by merely 
        looking at the display. When enabled MicroEmacs uses visible 
        characters to draw the white spaces, the characters used are set with 
        the variable lslm$window-chars(5)le. 

    cD0x100000cA 
        Enables hiding MicroEmacs generated backup files. On Windows and Dos 
        platforms the Hidden file attribute is used to hide the file, whereas 
        on UNIX the backup file name is prepended with a 'cG.cA'. 

    cD0x200000cA 
        If this bit set, the then execution of the lslmtab(2)le command (bound to 
        cGtabcA) checks and adjusts the indentation of the current line when the 
        cursor is in column zero and current buffer is in lslmcmode(2m)le or has an 
        lsindent(2)lmindentationle method. The setting of this bit has no effect if bit 
        cD0x1000cA is set. If this and bit cD0x1000cA are clear then the cGtabcA will not 
        check the indentation. 

    cD0x400000cA 
        When this bit is set the external cut buffer (Windows & XTerm 
        platforms) will never be set to empty, if the current yank buffer is 
        the empty string the cut buffer will be set to a space (i.e. " "). 
        This feature has been added to avoid problems with other software 
        (e.g. cDexceed(1)cA which can crash if given an empty cut buffer). 


cEcEEXAMPLE cEcA


    The follow example works out the current buffer's backup file name using 
    cD$systemcA to determine the naming system being used by MicroEmacs:- 
sB
        set-variable #l0 &stat "a" $buffer-fname 
        ; Is an 8.3 dos style naming system being used? 
        !if &band $system 0x400 
            !if &not &set #l1 &sin "." #l0 
                set-variable #l1 &cat #l0 ".~~~" 
            !elif &gre &set #l1 &sub &len #l0 #l1 2 
                set-variable #l1 &cat &lef #l0 &sub &len #l0 1 "~" 
            !else 
                set-variable #l1 &spr "%s%n" #l0 &sub 3 #l1 "~" 
            !endif 
        !elif $kept-versions 
            set-variable #l1 &cat #l0 ".~0~" 
        !else 
            set-variable #l1 &cat #l0 "~" 
        !endif 

sA
    The following macro can be used to toggle the visible drawing of white 
    spaces: 
sB
        define-macro toggle-visible-white-spaces 
            set-variable $system &bxor $system 0x80000 
            screen-update 
        !emacro 

sA

cEcENOTES cEcA


    Most of the cD$systemcA functionality can be set using the lsuser-setup(3)lm$user-setup(3)le 
    dialog. 


cEUNIX X verses Termcap cA


    By default, on X supporting systems MicroEmacs creates a new X window. 
    This feature may be disabled in one of two ways: 

        * The environment variable cG$TERMcA is set to "cGvt...cA", in this case it is 
          assumed that the machine is a server, and the host cannot support X. 
        * The cG-ncA option is used on the command line (see lslmme(1)le) to disable the 
          windowing interface. 

    If X is disabled then the cDtermcapcA interface is used instead, still 
    allowing the use of colors through the ANSI standard, or the use of fonts 
    (see bits cD0x004cA and cD0x008cA). 

    X provides the following features over and above a cDtermcapcA based version 
    of MicroEmacs '02: 

        * R,G,B style color creator giving access to up to 256 different 
          colors for the ultimate hilighting schemes (see bit cD0x002cA and 
          lslmadd-color(2)le). 
        * Full mouse support, allowing user definable bindings to every mouse 
          event (see lslmglobal-bind-key(2)le). 
        * Copy from and pasting to X's selection buffer (see lslmyank(2)le). 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslm$mouse(5)le, lslm$platform(5)le, lslmadd-color(2)le, lslmadd-color-scheme(2)le, 
    lslmipipe-shell-command(2)le, lslm$global-scheme(5)le. 

! 5 $window-col
! 5 $window-line
! 5 $window-acol
! 5 $window-aline
! 5 $window-wcol
! 5 $window-wline
cEcENAME cEcA


|$window-col
    $window-col - Window cursor column (no expansion) 
|$window-line
    $window-line - Window cursor line (with narrows) 
|$window-acol
    $window-acol - Window cursor actual column (expansion) 
|$window-aline
    $window-aline - Window cursor actual line (ignore narrows) 
$a


cEcESYNOPSIS cEcA


    cD$window-colcA cCintegercA 

    0 <= cCintegercA <= 65535 

    cD$window-linecA cCintegercA 

    1 <= cCintegercA <= n 

    cD$window-acolcA cCintegercA 

    0 <= cCintegercA <= n 

    cD$window-alinecA cCintegercA 

    1 <= cCintegercA <= n 


cEcEDESCRIPTION cEcA


    cD$window-colcA is defined as the current position of the cursor in the 
    current line in the current window. Column zero is the left hand edge. 
    This differs from cD$window-acolcA in that tab and special characters only 
    count for 1 character. cD$window-colcA is valid in the range 0 - cCncA. 

    cD$window-linecA is defined as the current buffer line number the cursor is on 
    in the current window. Line numbering starts from 1. cD$window-linecA is valid 
    in the range 1 - cCncA. 

    cD$window-alinecA is identical to cD$window-linecA except when the current buffer 
    contains narrowed out sections before the current line. In this case 
    cD$window-linecA will be set to the line number without counting the number of 
    lines in the narrow, whereas cD$window-alinecA will return the current line 
    number including all lines narrowed out before it. When this variable is 
    set, the line required may lie in a narrowed out section in which case the 
    narrow is automatically removed. See lslmnarrow-buffer(2)le for more information 
    on narrowing. 

    cD$window-acolcA is defined as the current column of the cursor in the current 
    window. Column zero is the left hand edge. This differs from cD$window-colcA 
    in that tab and special characters may not count for 1 character. 


cEcENOTES cEcA


    Variable cD$window-wcolcA was renamed to cD$window-acolcA in June 2000. Variable 
    cD$window-wlinecA was also removed and a new variable cD$window-y-scrollcA 
    introduced at this time. The following macro code can be used to calculate 
    the value of the original cD$window-wlinecA variable: 
sB
        &sub &sub $window-line $window-y-scroll 1 

sA

cEcESEE ALSO cEcA


    lslm$screen-depth(5)le, lslm$window-depth(5)le, lslm$window-width(5)le, lslm$window-y-scroll(5)le, 
    lslmnarrow-buffer(2)le. 

! 5 %ftp-flags
! 5 %http-flags
cEcENAME cEcA


|%ftp-flags
    %ftp-flags - "Configure the FTP console" 
|%http-flags
    %http-flags - "Configure the HTTP console" 
$a


cEcESYNOPSIS cEcA


    cD%ftp-flagscA "[cGccA|cGscA|cGpcA]" ; Default is undefined. 
    cD%http-flagscA "[cGccA|cGscA|cGpcA]" ; Default is undefined. 


cEcEDESCRIPTION cEcA


    The cD%ftp-flagscA and cD%http-flagscA modify the behavior of the editor during 
    FTP and HTTP file transfers, respectively. (see lslmftp(3)le and lslmfind-file(2)le). 

    By default, the flags are disabled, the facilities outlined below are 
    enabled by setting the variable in the user configuration. The flag values 
    for both flags are defined as follows:- 

    cDccA 
        Create a console buffer (cG*ftp-console*cA for ftp, cG*http-console*cA for 
        http) into which the FTP/HTTP command interactions with the remote 
        server are logged. 

    cDscA 
        Show the console whenever a FTP/HTTP operation is performed. The 
        console is popped into the display pane and shows the current 
        interaction status. 

    cDpcA 
        Show the download progress within the console window ('cG#cA' for every 
        2Kb downloaded) 

    Typically the following flags are enabled in the cCusercA.emf file:- 
sB
        set-variable %ftp-flags "csp" 
        set-variable %http-flags "csp" 

sA
    Once familiar with this facility the console pop-up becomes inconvenient 
    and the flags are typically reduced to:- 
sB
        set-variable %ftp-flags "cp" 
        set-variable %http-flags "cp" 

sA
    This disables the pop-up feature of the console. Enabling the limited flag 
    set allows some post mortem debugging to be performed if anything goes 
    wrong. The console buffers are manually selected when these flags are set. 


cEcENOTES cEcA


    Note that ftp and http facilities are available on UNIX by default, but 
    must be compiled in for Windows versions. 


cEcESEE ALSO cEcA


    lslm%http-proxy-addr(5)le, lslmfind-file(2)le, lslmftp(3)le. 

! 5 $scroll-bar-scheme
cEcENAME cEcA


    $scroll-bar-scheme - Scroll bar color scheme 
$a


cEcESYNOPSIS cEcA


    cD$scroll-bar-schemecA cCschemeNumcA; Default is cG1cA 


cEcEDESCRIPTION cEcA


    Sets the horizontal window scroll bar color scheme, assigning the 
    foreground, background and selection colors which are used to render the 
    vertical separator / scroll bars (see lslmadd-color-scheme(2)le. The separator 
    is rendered in reverse video, i.e. the foreground color of the color 
    scheme is used as the background color, and vice versa. 

    The separator is rendered in the standard colors when the associated 
    buffer is not active, and in the current color when the buffer is active. 

    The scroll-bar is the window separator constructed by 
    lslmsplit-window-horizontally(2)le or when the scroll bars are enabled via 
    lslm$scroll-bar(5)le. 


cEcESEE ALSO cEcA


    lslm$global-scheme(5)le, lslm$ml-scheme(5)le, lslm$mode-line-scheme(5)le, lslm$scroll-bar(5)le, 
    lslm$system(5)le, lslm$window-chars(5)le, lslmsplit-window-horizontally(2)le. 

! 5 $window-chars
cEcENAME cEcA


    $window-chars - Character set used to render the windows 
$a


cEcESYNOPSIS cEcA


    cD$window-charscA "cCstingcA"; Default is 
    "cG=-#*%=^|#|v*==^^||##||vv**|<-#->*||<<--##-->>** x*[]>\.cA" 


cEcEDESCRIPTION cEcA


    cD$window-charscA is a fixed length string that defines the set of characters 
    used to render the windows. The characters have fixed indices defined as 
    follows:- 

    Index 0 
        The active window mode line separator character, This replaces all 
        cCIndex 1cA characters when the window is current. Default is 'cD=cA'. 

    Index 1 
        The inactive window mode line separator character. This character is 
        replaced by cCIndex 0cA characters when the window becomes current. 
        Default is 'cD-cA'. 

    Index 2 
        UNIX based platforms only. The cDrootcA or cDsuperusercA indicator character 
        that appears on the mode line. Default is 'cD#cA'. 

    Index 3 
        The buffer changed indicator character that appears on the mode line. 
        Default is 'cD*cA'. 

    Index 4 
        The buffer in lslmview(2m)le mode indicator character that appears in the 
        mode line. Default is 'cD%cA'. 

    Index 5 
        Single column vertical scroll bar split window horizontally character. 
        Default is 'cD=cA'. 

    Index 6 
        Single column vertical scroll bar up-arrow character. Default is 'cD^cA'. 

    Index 7 
        Single column vertical scroll bar upper-shaft character. Default is 
        'cD|cA'. 

    Index 8 
        Single column vertical scroll box character. Default is 'cD#cA'. 

    Index 9 
        Single column vertical scroll bar lower-shaft character. Default is 
        'cD|cA'. 

    Index 10 
        Single column vertical scroll bar down-arrow character. Default is 
        'cDvcA'. 

    Index 11 
        Single column vertical scroll bar corner character. Default is 'cD*cA'. 

    Index 12-13 
        Double column vertical scroll bar split window horizontally character. 
        Default is 'cD==cA'. 

    Index 14-15 
        Double column vertical scroll bar up-arrow characters. Default is "cD^cA". 

    Index 16-17 
        Double column vertical scroll bar upper-shaft characters. Default is 
        "cD||cA". 

    Index 18-19 
        Double column vertical scroll box characters. Default is "cD##cA". 

    Index 20-21 
        Double column vertical scroll bar lower-shaft characters. Default is 
        "cD||cA". 

    Index 22-23 
        Double column vertical scroll bar down-arrow characters. Default is 
        "cDvvcA". 

    Index 24-25 
        Double column vertical scroll bar corner characters. Default is "cD**cA". 

    Index 26-32 
        Single column horizontal scroll bar. Default is "cD|<-#->*cA". 

    Index 33-46 
        Double column horizontal scroll bar. Default is "cD||<<--##-->>**cA". 

    Index 47 
        Osd title bar blank character. Default is 'cD cA'. 

    Index 48 
        Osd title bar right corner kill character. Default is 'cDxcA'. 

    Index 49 
        Osd open button character. Default is 'cD cA'. 

    Index 48 
        Osd close button character. Default is 'cD cA'. 

    Index 49 
        Displayed tab character (used when lslm$system(5)le bit 0x80000 is set). 
        Default is 'cD>cA'. 

    Index 50 
        Displayed new-line character (used when lslm$system(5)le bit 0x80000 is 
        set). Default is 'cD\cA'. 

    Index 51 
        Displayed space character (used when lslm$system(5)le bit 0x80000 is set). 
        Default is 'cD.cA'. 


cEcEEXAMPLE cEcA


    The cD$window-charscA is typically platform dependent, it's setting is 
    determined by the characters available in character set of the hosting 
    platform. MS-DOS and Microsoft Windows environments might use a string 
    such as:- 

        "=-#*%\x1E\xB1\xDB\xB1\x1F\x04 \x1E\xB1\xB1\xDB\xDB\xB1\xB1 \x1F\x1B\x1A\xaf\xfb\xfa" 


    X-Windows environments might use a string such as:- 

        "=-#*%^\x02 \x02v\x01 ^\x02\x02  \x02\x02 v\xAB\xBB>\\." 


    Both utilize platform specific characters to render some of the window 
    components. 


cEcENOTES cEcA


        * lslm$scroll-bar(5)le allows the scroll box to be rendered in reverse video 
          allowing a space to be used for the scroll box. 
        * Use lslmsymbol(3)le to determine the displayable characters on the host 
          platform. 


cEcESEE ALSO cEcA


    lslmsplit-window-horizontally(2)le, lslmsymbol(3)le, lslm$box-chars(5)le, lslm$global-scheme(5)le, 
    lslm$mode-line(5)le, lslm$mode-line-scheme(5)le, lslm$scroll-bar(5)le, 
    lslm$scroll-bar-scheme(5)le, lslm$system(5)le. 

! 5 $window-depth
! 5 $window-width
cEcENAME cEcA


|$window-depth
    $window-depth - Number of text lines in a window 
|$window-width
    $window-width - Number of character columns in a window 
$a


cEcESYNOPSIS cEcA


    cD$window-depthcA cCintegercA 

    1 <= cCintegercA <= ls$screen-depth(5)lm$screen-depthle 

    cD$window-widthcA cCintegercA 

    0 <= cCintegercA <= ls$screen-depth(5)lm$screen-widthle - 1 


cEcEDESCRIPTION cEcA


    cD$window-depthcA returns the depth (height) of the current window, excluding 
    the mode line, specified in text lines. (i.e. the number of lines of text 
    in the window). The returned value is an integer in the range: 

        cD0cA - ( ls$screen-depth(5)lm$screen-depthle - cD3cA ) 

    cD$window-widthcA returns the width, in characters, of the current window. The 
    returned value is an integer in the range: 

        cD0cA - ls$screen-depth(5)lm$screen-widthle. 


cEcENOTES cEcA


    These variables can not be set, any attempt to set them results in an 
    error. 


cEcESEE ALSO cEcA


    lslm$screen-depth(5)le, lslm$screen-width(5)le, lslm$window-scroll-bar(5)le, 
    lslm$window-mode-line(5)le, 

! 5 $fill-bullet
! 5 $fill-bullet-len
cEcENAME cEcA


|$fill-bullet
    $fill-bullet - Paragraph filling bullet character set 
|$fill-bullet-len
    $fill-bullet-len - Paragraph filling bullet search depth 
$a


cEcESYNOPSIS cEcA


    cD$fill-bulletcA "cCstringcA"; Default is "cG*)].-cA" 
    cD$fill-bullet-lencA cClengthcA; Default is cG5cA 

    0 <= cClengthcA <= ls$fill-col(5)lm$fill-colle 


cEcEDESCRIPTION cEcA


    cD$fill-bulletcA contains the set of characters which are classified as bullet 
    markers for lslmfill-paragraph(2)le. If these characters are encountered in the 
    first cD$fill-bullet-lencA characters of the paragraph AND the character is 
    followed by a cGSPACEcA or a cGtabcA character then the user is given the option 
    to indent to the right of the bullet. 

    cD$fill-bullet-lencA determines the maximum depth into the paragraph (in 
    characters) the filling routines should search for a bullet character. The 
    default value is 15. Note that the paragraph starts at the first non-white 
    space character. e.g. to detect "cGxviii) cA" as a bullet then the bullet 
    length must be set to at least 6 to detect the bullet character "cG)cA". 


cEcEEXAMPLE cEcA


    Examples of filled bullet paragraphs are shown as follows, based on the 
    default cD$fill-bulletcA character set. 

        a) This is an  example of a  fill-paragraph.  The  closing 
           bracket is classified as a bullet character and filling 
           optionally takes place to the right of the bullet. 

        a] Another paragraph 

        *  A bullet paragraph 

        1. A numbered paragraph. 

        item - A dashed bullet. 


cEcESEE ALSO cEcA


    lslm$fill-col(5)le, lslm$fill-ignore(5)le, lslm$fill-mode(5)le, lslmfill-paragraph(2)le, 
    lslmjustify(2m)le. 

! 5 $fill-ignore
cEcENAME cEcA


    $fill-ignore - Ignore paragraph filling character(s) 
$a


cEcESYNOPSIS cEcA


    cD$fill-ignorecA "cCstringcA"; Default is "cG>_@cA" 


cEcEDESCRIPTION cEcA


    cD$fill-ignorecA describes a set of characters used by lslmfill-paragraph(2)le which 
    disable paragraph filling when they appear at the start of a paragraph. An 
    obvious example is an inserted mail message which is usually quoted with 
    "cG>cA" characters. Any attempt to fill the paragraph causes cDfill-paragraphcA to 
    skip to the end of it. 


cEcEEXAMPLE cEcA


    This is an example of an ignored paragraph when encountered by 
    cDfill-paragraphcA with the default ignore character set. 

        > This is an example of a paragraph that 
        > is ignored. 


cEcESEE ALSO cEcA


    lslm$fill-col(5)le, lslm$fill-bullet(5)le, lslm$fill-mode(5)le, lslmfill-paragraph(2)le, 
    lslmjustify(2m)le. 

! 5 $scroll-bar
cEcENAME cEcA


    $scroll-bar - Scroll bar configuration 
$a


cEcESYNOPSIS cEcA


    cD$scroll-barcA "cCbitmaskcA"; Default is platform specific 


cEcEDESCRIPTION cEcA


    cD$scroll-barcA defines the configuration of the scroll bar and/or the 
    horizontal window separator for both main text windows and lslmosd(2)le dialogs. 
    The variable is interpreted as a bit mask and defines which components of 
    the scroll bar (or separator) should be rendered in a window. The 
    characters used to render the scroll bar or separator are defined by 
    lslm$window-chars(5)le. The bit mask is defined as follows:- 

    cD0x001cA - Vertical Scroll Bar Width 
        Bit 0 controls the width of the vertical scroll bar (or separator). A 
        value of 0 corresponds to a single column width, a value of 1 is a 
        double column width. 

    cD0x002cA - Upper end cap 
        Bit 1 set indicates that the scroll bar has an upper end cap. This is 
        the up arrow character at the top of a scroll bar. 

    cD0x004cA - Lower end cap 
        Bit 2 set indicates that the scroll bar has a lower end cap. This is 
        the down arrow character at the bottom of a scroll bar. 

    cD0x008cA - Corner 
        Bit 3 set indicates that separate corner character is used at the 
        intersection of the mode line and the separator. 

    cD0x010cA - Scroll Box Enable 
        Bit 4 determines if the scroll bar has a scrolling box, when the bit 
        is set each scroll bar will have a scroll box. When clear, scroll bars 
        are rendered according to bits 0-3 & 7 only and the main area of the 
        bar is left empty. 

    cD0x020cA - Reverse Video Box 
        Bit 5 when set enables the scroll box to be rendered in reverse video, 
        that is the background and foreground/hilight scroll colors are 
        interchanged. This bit is typically set on X-Window platforms allowing 
        the scroll box to comprise of cGSPACEcA characters allowing a solid box to 
        be rendered in the foreground color. 

        Bit 5 is only enacted if scroll boxes are enabled. 

    cD0x040cA - Horizontal Scroll Bar Width 
        Bit 6 controls the width of the horizontal scroll bar, used only by 
        lslmosd(2)le. A value of 0 corresponds to a single column width, a value of 
        1 is a double column width. 

    cD0x080cA - Splitter 
        Bit 7 set indicates that the scroll bar has a splitter. This is the 
        split bar character at the top of a scroll bar. 

    cD0x100cA - Enable window Scroll Bars 
        When Bit 8 is clear, scroll bars are not present on windows. If a 
        horizontal split has been performed then the window separator is 
        rendered plain. This is useful when performance is important, as 
        scroll bars require constant up-date. 

    cD0x200cA - Horizontal Scroll Bar Width 
        Bit 9 enables scroll bars, when the bit is set each window is assigned 
        a scroll bar in the right-hand column(s) of the window with a scroll 
        box. 


cEcESEE ALSO cEcA


    lslm$mouse-pos(5)le, lslm$scroll-bar-scheme(5)le, lslmset-scroll-with-mouse(2)le, 
    lslm$window-chars(5)le. 

! 5 $line-scheme
cEcENAME cEcA


    $line-scheme - Set the current line color scheme 
$a


cEcESYNOPSIS cEcA


    cD$line-schemecA cCschemeNumcA; Default is cG-1cA 


cEcEDESCRIPTION cEcA


    cD$line-schemecA sets the color scheme to be used for the current line of the 
    current window. The given cCschemeNumcA can be any scheme number previously 
    defined by the function lslmadd-color-scheme(2)le. 

    A line's $line-scheme setting is removed by setting the variable to -1. 

    A $line-scheme setting takes precedence over the buffer's color scheme ( 
    lslm$buffer-scheme(5)le) and the buffer's hilighting scheme ( 
    lslm$buffer-hilight(5)le). 


cEcEEXAMPLE cEcA


    lslmc-hash-eval(3)le greys out lines of text by doing: 
sB
        set-variable $line-scheme %lblack 

sA
    The lines are rest by doing 
sB
        set-variable $line-scheme -1 

sA
    The lslmgdb(3)le interface hilights the current line of source by doing: 
sB
        set-variable $line-scheme %yellow-lblack 

sA

cEcENOTES cEcA


    Due to line storage restrictions, only 15 different color schemes can be 
    used in a buffer at any one time. When the 16th color scheme is used it 
    replaces the first color scheme, all lines using the first color scheme 
    will be colored using the new color scheme. 


cEcESEE ALSO cEcA


    lslmadd-color-scheme(2)le, lslmc-hash-eval(3)le, lslm$buffer-scheme(5)le, 
    lslm$buffer-hilight(5)le, lslm$mode-line-scheme(5)le, lslm$scroll-bar-scheme(5)le, 
    lslm$system(5)le. 

! 5 $search-path
! 5 $MEPATH
cEcENAME cEcA


|$seach-path
    $search-path - MicroEmacs search path 
|$MEPATH
    $MEPATH - MicroEmacs search path 
$a


cEcESYNOPSIS cEcA


    cD$search-pathcA cCstringcA 

    cC[Microsoft Windows/MS-DOS]cA 
    cDMEPATH=cA cC<path1>cAcD;cAcC<path2>cAcD;cA....cD;cAcC<pathn>cA 

    cC[UNIX]cA 
    cDMEPATH=cA cC<path1>cAcD:cAcC<path2>cAcD:cA....cD:cAcC<pathn>cA 


cEcEDESCRIPTION cEcA


    cD$search-pathcA is initialized to the environment variable cD$MEPATHcA, and 
    identifies the search paths which are searched to locate editor specific 
    files. Multiple search paths may be specified, separated by the platform 
    path separator (semi-colon ('cD;cA') on Microsoft Windows or MS-DOS 
    environments and a colon ('cD:cA') on UNIX environments). Where multiple 
    search paths are defined then they are search left to right. 

    The search paths are generally ordered from highest priority to lowest 
    priority and might be arranged such as:- 

        cDMEPATH=cAcC<user>cA:cC<company>cA:cC<me>cA 

    where cC<user>cA represents the users path; cC<company>cA is the company file path 
    (e.g. template files) and cC<me>cA are the standard MicroEmacs '02 files. 

    This would correspond to a directory installation, of user cDfoocA such as:- 

        /usr/foo/microemacs   - User files. 
        /usr/group/microemacs - Company wide files 
        /usr/local/microemacs - MicroEmacs installation directory 


    and a cD$MEPATHcA such as:- 

        MEPATH=/usr/foo/microemacs:/usr/group/microemacs:/usr/local/microemacs 


cEcEUSAGE cEcA


    The current working directory is checked first for the location of a file. 

    cD$search-pathcA is used to locate all macro files, and other files located 
    with operators such as lslm&find(4)le. 


cEcENOTES cEcA


    If cD$MEPATHcA is not set then cD$search-pathcA is initialized to the environment 
    variable cD$PATHcA. 

    On UNIX systems the path cC/usr/local/microemacscA is automatically added to 
    the end of cD$MEPATHcA, or if not defined, to the beginning of cD$PATHcA. 


cEcESEE ALSO cEcA


    lsIntroduction to Variable FunctionslmVariable Functionsle, lslmexecute-file(2)le, lslm$MENAME(5)le, lslm&find(4)le. 

! 5 $file-ignore
cEcENAME cEcA


    $file-ignore - File extensions to ignore 
$a


cEcESYNOPSIS cEcA


    cD$file-ignorecA "cCstringcA"; Default is "" 


cEcEDESCRIPTION cEcA


    cD$file-ignorecA specifies a space separated list of file endings which the 
    file completion is to ignore. This is used by any function which prompts 
    the user for a file name, such as lslmfind-file(2)le. A file ending in this case 
    is NOT the extension but the last cCncA characters where cCncA is the number of 
    characters in the specified ignore file. 


cEcEEXAMPLE cEcA


    To ignore all files which have the extension "cGocA", using: 
sB
        set-variable $file-ignore "o" 

sA
    would not only ignore "cGfoo.ocA", but also "cGfoo.oocA", "cGfoo.pocA" and "cGfoocA" as 
    well as any file that ends in an "cGocA". What is really required is 
sB
        set-variable $file-ignore ".o" 

sA
    It is useful to ignore the "cG./cA" and "cG../cA" directories so that a directory 
    containing one file will auto-complete to that one file. This is achieved 
    by using: 
sB
        set-variable $file-ignore "./" 

sA
    To ignore MicroEmacs '02 backup files ("cG~cA"), C object files ("cG.ocA"), "cG./cA" 
    and "cG../cA" directories try using: 
sB
        set-variable $file-ignore "~ .o ./" 

sA

cEcENOTES cEcA


    The file completion only completes further than the first non-unique point 
    in the current list of possibles if and only if it can ignore all but one 
    file, so if the current directory contains: 

        ./ ../ foo foo.c foo.c~ foo.o 


    using the above ignore list, completing with "" has no effect as "cGfoocA" and 
    "cGfoo.ccA" cannot be ignored; completing with "cGfoo.cA" will however complete to 
    "cGfoo.ccA". 


cEcESEE ALSO cEcA


    lslmfind-file(2)le. 

! 5 $show-region
cEcENAME cEcA


    $show-region - Enable the hilighting of regions 
$a


cEcESYNOPSIS cEcA


    cD$show-regioncA cCflagcA; Default is cG1cA 


cEcEDESCRIPTION cEcA


    cD$show-regioncA enables or disables the current region hilighting, normally 
    associated with mouse interaction in a buffer. Region hilighting occurs 
    between the cCmarkcA (see lslmset-mark(2)le) and cCpointcA (current cursor) positions 
    within the current buffer. An argument cCncA of 0 disables region hilighting, 
    an argument of 1 enables region hilighting between the two positions. If 
    it is set to 3 then region hilighting will be enabled and a defined region 
    (created using lslmcopy-region(2)leor lslmyank(2)le) will continue to be hilighted 
    until the region is changed. 

    A defined region can be redisplayed (if still valid) using the command 
    lslmshow-region(2)le. The color of the region hilighting is defined by 
    lslmadd-color-scheme(2)le and is determined by lslm$buffer-scheme(5)le, 
    lslm$global-scheme(5)le or lslm$buffer-hilight(5)le. 


cEcESEE ALSO cEcA


    lslmshow-region(2)le, lslm$buffer-hilight(5)le, lslm$buffer-scheme(5)le, lslm$global-scheme(5)le, 
    lslm$buffer-scheme(5)le, lslmadd-color-scheme(2)le, lslmset-mark(2)le. 

! 5 $time
cEcENAME cEcA


    $time - The current system time 
$a


cEcESYNOPSIS cEcA


    cD$timecA "cCstringcA" 


cEcEDESCRIPTION cEcA


    cD$timecA is a constantly changing variable which is set to the current system 
    time. The format of cD$timecA is "cGYYYYCCCMMDDWhhmmssSSScA", where:- 

    cDYYYYcA 
        The current year (full 4 digits so should be millennium bug free). 

    cDCCCcA 
        Day of the year (0-366). 

    cDMMcA 
        The month of the year (1-12). 

    cDDDcA 
        The day of the month (1-31). 

    cDWcA 
        The day of the week (0-6 Sunday=0). 

    cDhhcA 
        The hour (0-23). 

    cDmmcA 
        The minute (0-59). 

    cDsscA 
        The second (0-59). 

    cDSSScA 
        The millisecond (0-999). 

    cD$timecA can be set to an integer value which is a time offset in seconds, 
    for example if the following was executed;- 
sB
        set-variable $time "3600" 
        ml-write &cat "$time is " $time 
        set-variable $time "0" 

sA
    The written time would one hour ahead of the system time. 


cEcEEXAMPLE cEcA


    The following macro times the time taken to execute a user command:- 
sB
        define-macro time 
            !force set-variable #l2 @1 
            !if &not $status 
                set-variable #l2 @ml00 "Time command" 
            !endif 
            set-variable #l0 $time 
            !force execute-line #l2 
            set-variable #l1 $time 
            set-variable #l2 &add &mid #l0 16 2 &mul 60 &add &mid #l0 14 2 &mul 60 &mid #l0 12 2 
            set-variable #l3 &add &mid #l1 16 2 &mul 60 &add &mid #l1 14 2 &mul 60 &mid #l1 12 2 
            !if &les &set #l4 &sub &rig #l1 18 &rig #l0 18 0 
                set-variable #l2 &add #l2 1 
                set-variable #l4 &add 1000 #l4 
            !endif 
            ml-write &spr "Command took %d sec %d msec" &sub #l3 #l2 #l4 
        !emacro 

sA
    lslmtime(3)le is a macro defined in misc.emf. 

    lslmorganizer(3)le uses cD$timecA to work out the current month. 


cEcESEE ALSO cEcA


    lslmtime(3)le, lslmorganizer(3)le. 

! 5 $buffer-names
cEcENAME cEcA


    $buffer-names - Filtered buffer name list 


cEcESYNOPSIS cEcA


    cD$buffer-namescA cCBufferNamecA 


cEcEDESCRIPTION cEcA


    cD$buffer-namescA must first be set to the required filter string, if the 
    variable is evaluated before it is initialized the value will be set to 
    "cCABORTcA" and the command will fail. The filter takes the form of a lsRegularExpressions(2)lmregexle. 

    Once initialized, evaluating cD$buffer-namescA returns the name of the next 
    buffer which matches the filter until no more buffers are found, in which 
    case an empty string is returned. 


cEcEEXAMPLE cEcA


    The following example prints out the name of all buffers to the massage 
    line one at a time. Note that lslm&set(4)le is used on the lslm!while(4)le statement 
    to avoid evaluating cD$buffer-namescA twice per loop. 
sB
        set-variable $buffer-names ".*" 
        !while &not &seq &set #l0 $buffer-names "" 
            100 ml-write &cat "buffer: " #l0 
        !done 

sA
    The following example is the same except it lists only the buffers which 
    are not directory listings 
sB
        set-variable $buffer-names ".*[^/]" 
        !while &not &seq &set #l0 $buffer-names "" 
            100 ml-write &cat "buffer: " #l0 
        !done 

sA

cEcENOTES cEcA


    The list of buffers is evaluated when the variable is initialized, buffers 
    created after the initialization will not be included in the list. 

    Deleting buffers which are in the list, before they are evaluated, will 
    have undefined effects. 


cEcESEE ALSO cEcA


    lslmlist-buffers(2)le, lslm$buffer-bname(5)le, lslm$file-names(5)le, lslm$command-names(5)le, 
    lslm$mode-names(5)le, lsRegularExpressions(2)lmRegular Expressionsle. 

! 5 $command-names
cEcENAME cEcA


    $command-names - Filtered command name list 


cEcESYNOPSIS cEcA


    cD$command-namescA cCCommandNamecA 


cEcEDESCRIPTION cEcA


    cD$command-namescA must first be initialized to the required filter string, if 
    the variable is evaluated before it is initialized the value will be set 
    to "cCABORTcA" and the command will fail. The filter takes the form of a 
    lsRegularExpressions(2)lmregexle. 

    Once initialized, evaluating cD$command-namescA returns the name of the next 
    command which matches the filter until no more commands are found, in 
    which case an empty string is returned. 


cEcEEXAMPLE cEcA


    The following example prints out the name of all commands to the massage 
    line one at a time. Note that lslm&set(4)le is used on the lslm!while(4)le statement 
    to avoid evaluating cD$command-namescA twice per loop. 
sB
        set-variable $command-names ".*" 
        !while &not &seq &set #l0 $command-names "" 
            100 ml-write &cat "command: " #l0 
        !done 

sA
    The following example is an alternative implementation of 
    lslmcommand-apropos(2)le. 
sB
        define-macro alt-commad-apropos 
            set-variable #l1 @ml "Apropos string" 
            set-variable $command-names &cat &cat ".*" #l1 ".*" 
            !force 0 delete-buffer "*commands*" 
            1 popup-window "*commands*" 
            !while &not &seq &set #l0 $command-names "" 
                insert-string &spr "    %s\n" #l0 
            !done 
            beginning-of-buffer 
            -1 buffer-mode "edit" 
            1 buffer-mode "view" 
        !emacro 

sA

cEcENOTES cEcA


    cD$command-namescA does not differentiate between built in commands and 
    macros. 

    The list of commands is evaluated when the variable is initialized, macros 
    created after the initialization will not be included in the list. 


cEcESEE ALSO cEcA


    lslmlist-commands(2)le, lslmcommand-apropos(2)le, lslm$buffer-names(5)le, lslm$file-names(5)le, 
    lslm$mode-names(5)le, lslm$variable-names(5)le, lsRegularExpressions(2)lmRegular Expressionsle. 

! 5 .calc.result
cEcENAME cEcA


    .calc.result - Last calc calculation result 
$a


cEcESYNOPSIS cEcA


    cD.calc.resultcA cCintegercA 


cEcEDESCRIPTION cEcA


    cD.calc.resultcA is used to store the result of the last calculation made by 
    lslmcalc(3)le. 

    The "cCLRcA" (Last Result) in the next calculation is substituted with this 
    value. 


cEcESEE ALSO cEcA


    lslmcalc(3)le. 

! 5 $file-names
cEcENAME cEcA


    $file-names - Filtered file name list 


cEcESYNOPSIS cEcA


    cD$file-namescA cCFileNamecA 


cEcEDESCRIPTION cEcA


    cD$file-namescA must first be initialized to the required filter string, if 
    the variable is evaluated before it is initialized the value will be set 
    to "cCABORTcA" and the command will fail. 

    The filter takes the form of a lsRegularExpressions(2)lmregexle. The filter string should also 
    contain the path to the required directory, the path many not contain 
    wild-cards. If no path is specified the the path of the current buffers 
    file name is taken, if the current buffer has no file name then the 
    current working directory is used. 

    On initialization, lslm$result(5)le is set to the absolute path of the directory 
    being evaluated. 

    Once initialized, evaluating cD$file-namescA returns the name of the next 
    buffer which matches the filter until no more buffers are found, in which 
    case an empty string is returned. 


cEcEEXAMPLE cEcA


    The following example creates a list of all files in the current directory 
    to a fixed buffer "cC*files*cA". Note that lslm&set(4)le is used on the lslm!while(4)le 
    statement to avoid evaluating cD$file-namescA twice per loop. 
sB
        set-variable $file-names ".*" 
        !force 0 delete-buffer "*files*" 
        1 popup-window "*files*" 
        insert-string &spr "Directory listing of %s\n\n" $result 
        !while &not &seq &set #l0 $file-names "" 
            insert-string &spr "    %s\n" #l0 
        !done 
        beginning-of-buffer 
        -1 buffer-mode "edit" 
        1 buffer-mode "view" 

sA

cEcENOTES cEcA


    Unlike MS-DOS and Windows systems, to match every file a filter of just 
    "cC*cA" is required. A filter of "cC*.*cA" only matches file names with a 'cC.cA' in 
    them. 

    The list of files is evaluated when the variable is initialized, files 
    created after the initialization will not be included in the list. 


cEcESEE ALSO cEcA


    lslm$result(5)le, lslmfind-file(2)le, lslm$buffer-fname(5)le, lslm$buffer-names(5)le, 
    lslm$command-names(5)le, lslm$mode-names(5)le, lsRegularExpressions(2)lmRegular Expressionsle. 

! 5 $mode-names
cEcENAME cEcA


    $mode-names - Filtered mode name list 


cEcESYNOPSIS cEcA


    cD$mode-namescA cCModeNamecA 


cEcEDESCRIPTION cEcA


    cD$mode-namescA must first be initialized to the required filter string, if 
    the variable is evaluated before it is initialized the value will be set 
    to "cCABORTcA" and the command will fail. The filter takes the form of a 
    lsRegularExpressions(2)lmregexle. 

    Once initialized, evaluating cD$mode-namescA returns the name of the next mode 
    which matches the filter until no more modes are found, in which case an 
    empty string is returned. 


cEcEEXAMPLE cEcA


    The following example prints out the name of all modes to the massage line 
    one at a time. Note that lslm&set(4)le is used on the lslm!while(4)le statement to 
    avoid evaluating cD$mode-namescA twice per loop. 
sB
        set-variable $mode-names "*" 
        !while &not &seq &set #l0 $mode-names "" 
            100 ml-write &cat "mode: " #l0 
        !done 

sA

cEcESEE ALSO cEcA


    lslmbuffer-mode(2)le, lslm&bmode(4)le, lslm$buffer-names(5)le, lslm$command-names(5)le, lsRegularExpressions(2)lmRegularln
    lnExpressionsle. 

! 5 $progname
cEcENAME cEcA


    $progname - Program file name 
$a


cEcESYNOPSIS cEcA


    cD$prognamecA cCstringcA 


cEcEDESCRIPTION cEcA


    cD$prognamecA is set the the MicroEmacs '02 program file name currently being 
    run. This can be used by macros for many purposes, from spawning another 
    MicroEmacs '02 session to working out where MicroEmacs '02 is running 
    from. 


cEcEEXAMPLE cEcA


    The following example is used to spawn of another MicroEmacs '02 command 
    to create a C tags file:- 

        shell-command &cat $progname " \"@ctags\" *.c *.h" 


cEcESEE ALSO cEcA


    lslmme(1)le. 

! 5 $find-words
cEcENAME cEcA


    $find-words - Filtered word list 


cEcESYNOPSIS cEcA


    cD$find-wordscA cCwordcA 


cEcEDESCRIPTION cEcA


    cD$find-wordscA must first be initialized to the required filter string, if 
    the variable is evaluated before it is initialized the value will be set 
    to "cCABORTcA" and the command will fail. 

    The filter string can contain wild-card characters compatible with most 
    file systems, namely:- 

    cD?cA 
        Match any character. 

    cD[abc]cA 
        Match character only if it is cCacA, cCbcA or cCccA. 

    cD[a-d]cA 
        Match character only if it is cCacA, cCbcA, cCccA or cCdcA. 

    cD[^abc]cA 
        Match character only if it is not cCacA, cCbcA or cCccA. 

    cD*cA 
        Match any number of characters. 

    Note that these are not the same characters used by lslmexact(2m)le mode. 

    Once initialized, evaluating cD$find-wordscA returns the next word found in 
    the main spell dictionaries which matches the filter until no more words 
    are found, in which case an empty string is returned. 


cEcEEXAMPLE cEcA


    The following example finds all the words with "cCfoocA" in it (e.g. 
    "cCfootnotecA"), printing them to the massage line one at a time. Note that 
    lslm&set(4)le is used on the lslm!while(4)le statement to avoid evaluating cD$find-wordscA 
    twice per loop. 
sB
        set-variable $find-words "*foo*" 
        !while &not &seq &set #l0 $find-words "" 
            100 ml-write &cat "Word: " #l0 
        !done 

sA

cEcENOTES cEcA


    The order of the words is undefined. 

    Due to the way words are derived, it is possible to have two or more 
    copies of a word in the dictionary. If this is a matching word cD$find-wordscA 
    will return the word two or more times. 


cEcESEE ALSO cEcA


    lslmspell(2)le. 

! 5 $variable-names
cEcENAME cEcA


    $variable-names - Filtered variable name list 


cEcESYNOPSIS cEcA


    cD$variable-namescA cCVariableNamecA 


cEcEDESCRIPTION cEcA


    cD$variable-namescA must first be initialized to the required filter string, 
    if the variable is evaluated before it is initialized the value will be 
    set to "cCABORTcA" and the command will fail. 

    The filter string can contain wild-card characters compatible with most 
    file systems, namely:- 

    cD?cA 
        Match any character. 

    cD[abc]cA 
        Match character only if it is cCacA, cCbcA or cCccA. 

    cD[a-d]cA 
        Match character only if it is cCacA, cCbcA, cCccA or cCdcA. 

    cD[^abc]cA 
        Match character only if it is not cCacA, cCbcA or cCccA. 

    cD*cA 
        Match any number of characters. 

    Note that these are not the same characters used by lslmexact(2m)le mode. 

    Once initialized, evaluating cD$variable-namescA returns the name of the next 
    variable which matches the filter until no more variables are found, in 
    which case an empty string is returned. 


cEcEEXAMPLE cEcA


    The following example prints out the name of all variables to the massage 
    line one at a time. Note that lslm&set(4)le is used on the lslm!while(4)le statement 
    to avoid evaluating cD$variable-namescA twice per loop. 
sB
        set-variable $variable-names "*" 
        !while &not &seq &set #l0 $variable-names "" 
            100 ml-write &cat "variable: " #l0 
        !done 

sA

cEcENOTES cEcA


    The list of variables is evaluated when the variable is initialized, 
    variables defined after the initialization will not be included in the 
    list. The list can contain the current buffer's buffer variables (See 
    lslmVariables(4)le for more information on the different types of variables). 

    Using lslmunset-variable(2)le to delete a variable which are in the list, before 
    it has be evaluated, will have undefined effects. 


cEcESEE ALSO cEcA


    lslmlist-variables(2)le, lslm$command-names(5)le. 

! 5 $temp-name
cEcENAME cEcA


    $temp-name - Temporary file name 
$a


cEcESYNOPSIS cEcA


    cD$temp-namecA cCFileNamecA 


cEcEDESCRIPTION cEcA


    cD$temp-namescA is automatically set to a nonexistent file name in the systems 
    temporary file directory. On UNIX systems the temporary directory is fixed 
    to "cG/tmp/cA", on other systems the temporary directory is set by the cD$TEMPcA 
    environment variable. 


cEcEEXAMPLE cEcA


    The following example uuencodes a given file into a temporary file and 
    then inserts this file into the current buffer. 
sB
        set-variable #l0 @ml04 "Uuencode and insert file" 
        set-variable #l1 $temp-name 
        !force shell-command &spr "uuencode %s < %s > %s" #l0 #l0 #l1 
        insert-file #l1 
        !force shell-command &cat "rm " #l1 

sA

cEcENOTES cEcA


    This variable can not be set, any attempt to set it will result in an 
    error. 

    The returned file name is not guaranteed to be unique between calls, only 
    that the file does not currently exist. 


cEcESEE ALSO cEcA


    lslmshell-command(2)le, lslmfile-op(2)le. 

! 5 $buffer-fmod
! 5 $global-fmod
cEcENAME cEcA


|$buffer-fmod
    $buffer-fmod - Buffer file modes (or attributes) 
|$global-fmod
    $global-fmod - Global file modes (or attributes) 
$a


cEcESYNOPSIS cEcA


    cD$buffer-fmodcA cCFileModecA 
    cD$global-fmodcA cCFileModecA 


cEcEDESCRIPTION cEcA


    cD$buffer-fmodcA is bit based variable setting the buffers file system modes 
    or attributes. If the buffer was loaded from an existing file then the 
    value of cD$buffer-fmodcA is taken directly from the file. But if the buffer 
    was created then the buffer inherits the default file modes, cD$global-fmodcA, 
    which is determined from the users umask on UNIX or a default on others. 

    The definition of the file mode bits are platform specific and are 
    considered independently, as follows: 


cEUNIX cA


    The file modes of Unix are the standard read, write and execute 
    permissions for user, group and global. See cDchmod(1)cA for a full 
    description of their use and effect. 

    The variable is displayed in octal. 


cEMicrosoft Windows and DOS cA


    On Microsoft platforms each file attribute (see cDattrib(1)cA) is assigned a 
    bit, on windows 95 and NT the new file attributes such as compressed are 
    also represented. The bits are assigned as follows 

        Bit     Attrib Flag     Attribute 
        0x001       R           Rad Only 
        0x002       H           Hidden 
        0x004       S           System 
        0x010                   Directory 
        0x020       A           Archive 
        0x080                   Normal 
        0x100                   Temporary 
        0x800                   Compressed 


cEcEEXAMPLE cEcA


    The following example changes the $buffer-fmod so that the file will be 
    executable (UNIX only), useful when writing a shell script. 
sB
        set-variable $buffer-fmod 0775 

sA

cEcESEE ALSO cEcA


    lslmcrlf(2m)le, lslmctrlz(2m)le, lslmauto(2m)le. 

! 5 $delay-time
! 5 $repeat-time
cEcENAME cEcA


|$delay-time
    $delay-time - Mouse time event delay time 
|$repeat-time
    $repeat-time - Mouse time event repeat time 
$a


cEcESYNOPSIS cEcA


    cD$delay-timecA cCmillisecondscA; Default is cG500cA 
    cD$repeat-timecA cCmillisecondscA; Default is cG25cA 

    10 <= cCmillisecondscA <= t 


cEcEDESCRIPTION cEcA


    cD$delay-timecA sets the time waited between the user picking a mouse button 
    and the generation of a cGmouse-time-?cA key event. 

    When user presses the left button (say) a cGmouse-pick-1cA key event is 
    generated, If this key is bound then the command it is bound to is 
    executed. If the user then holds down the button for cD$delay-timecA or more 
    milliseconds then MicroEmacs checks the binding of the special 
    cGmouse-time-1cA key, if this pseudo key is bound then the command it is bound 
    to will be executed. 

    If the user continues to hold down the button for a further cD$repeat-timecA 
    milliseconds another cDmouse-time-1cA key event will be generated. A 
    cDmouse-time-1cA key event will be generated after every cD$repeat-timecA 
    milliseconds until the user releases the button, at which point a 
    cGmouse-drop-1cA key event is generated. 


cEcEEXAMPLE cEcA


    The following example implements the vertical scroll-bar up and down 
    scrolling arrows for a buffer window:- 
sB
        define-macro mouse-pick-command 
            set-cursor-to-mouse 
            !if &equ &band $mouse-pos 15 5 
                ml-write "Mouse on up-arrow" 
                1 scroll-up 
                1 global-bind-key scroll-up "mouse-time-1" 
            !elif &equ &band $mouse-pos 15 9 
                ml-write "Mouse on down-arrow" 
                1 scroll-down 
                1 global-bind-key scroll-down "mouse-time-1" 
            !endif 
        !emacro 

        define-macro mouse-drop-command 
            !force global-unbind-key "mouse-time-1" 
        !emacro 

        global-bind-key mouse-pick-command "mouse-pick-1" 
        global-bind-key mouse-drop-command "mouse-drop-1" 

sA

cEcESEE ALSO cEcA


    lslm$idle-time(5)le, lslmset-cursor-to-mouse(2)le, lslm$mouse-pos(5)le. 

! 5 $idle-time
cEcENAME cEcA


    $idle-time - System idle event delay time 
$a


cEcESYNOPSIS cEcA


    cD$idle-timecA cCmillisecondscA; Default is cG1000cA 

    10 <= cCmillisecondscA <= t 


cEcEDESCRIPTION cEcA


    cD$idle-timecA sets the time waited between the last user event and the 
    generation of a cGidle-pickcA key event. When user input stops for cD$idle-timecA 
    milliseconds MicroEmacs checks the binding of the special cGidle-pickcA key, 
    if this pseudo key is bound then the command it is bound to will be 
    executed. MicroEmacs will then cycle, generating a cGidle-pickcA every 
    cD$idle-timecA milliseconds until user activity starts. At this point a 
    cGidle-dropcA key event is generated, if this pseudo key is bound then the 
    command it is bound to will be executed. 

    This system is useful for things which can be done in the background. 


cEcEEXAMPLE cEcA


    The following example is taken from cGssaver.emfcA and implements a simple 
    screen saver:- 
sB
        set-variable %screen-saver 0 
        define-macro screen-saver 
            !if &not &pinc %screen-saver 1 
                !if &seq @cck "idle-pick" 
                    ; default is to switch on in 5 minutes time 
                    &cond @? @# 300000 create-callback screen-saver 
                !else 
                    !if &seq @cck "callback" 
                        @# create-callback screen-saver 
                    !elif @? 
                        ; user has suppled argument, install or remove 
                        !if &gre @# 0 
                            &mul @# 60000 global-bind-key screen-saver "idle-pick" 
                        !else 
                            !force global-unbind-key "idle-pick" 
                        !endif 
                        set-variable %screen-saver &sub %screen-saver 1 
                        !return 
                    !endif 
                    set-variable @# $screen-depth 
                    !while &dec @# 1 
                        2 screen-poke @# 0 $global-scheme &spr "%n" $screen-width " " 
                    !done 
                    0 screen-poke 0 0 $global-scheme &spr "%n" $screen-width " " 
                    -1 show-cursor 
                    ; must set this to stop recursion when waiting for a key! 
                    set-variable %screen-saver 0 
                    set-variable @# @cg 
                    set-variable %screen-saver 1 
                    1 show-cursor 
                    screen-update 
                    ml-clear 
                !endif 
            !endif 
            set-variable %screen-saver &sub %screen-saver 1 
        !emacro 

sA

cEcENOTES cEcA


    Care must be taken to ensure that a recursive loop is not created, 
    consider the following example:- 
sB
        define-macro bored 
            !if &iseq @mc1 "Are you bored (y/n)? " "nNyY" "y" 
                ml-write "Play a silly game!" 
            !endif 
        !emacro 
        global-bind-key bored idle-pick 

sA
    If this was executed MicroEmacs would very quickly crash! As soon as a 
    second past cDboredcA would execute, which will prompt the user and wait for 
    input. If a second passes without input cDboredcA will be executed again and 
    again and again until stack memory runs out! To avoid this cGidle-pickcA 
    should be unbound before waiting for user input, i.e.:- 
sB
        define-macro bored 
            global-unbind-key idle-pick 
            !if &iseq @mc1 "Are you bored (y/n)? " "nNyY" "y" 
                ml-write "Play a silly game!" 
            !endif 
            global-bind-key bored idle-pick 
        !emacro 
        global-bind-key bored idle-pick 

sA

cEcESEE ALSO cEcA


    lslm$delay-time(5)le. 

! 5 $mouse
cEcENAME cEcA


    $mouse - Mouse configuration variable 
$a


cEcESYNOPSIS cEcA


    cD$mousecA cCbitmaskcA; Default is system dependent 


cEcEDESCRIPTION cEcA


    The cD$mousecA is used to define and configure the MicroEmacs mouse support, 
    it is a bit based flag where:- 

    cD0x00fcA 
        Defines the number of button the mouse has, only values 1, 2 & 3 are 
        useful. By default MicroEmacs uses the system information to determine 
        the number of buttons on the mouse, this is not fool proof so the user 
        can set these bits to the appropriate number if the initial value is 
        incorrect. 

    cD0x010cA 
        If set the mouse is enabled, if clear the mouse will not function. On 
        systems which do not support mice (such as UNIX Termcap) this bit will 
        be clear and can not be altered. 

    cD0x020cA 
        If set the buttons are reversed, i.e. the left button becomes the 
        right and vice versa. By default this bit is clear. 

    cD0xf0000cA 
        Defines the current mouse icon to used, valid values are as follows: 

            cD0x00000cA - Set mouse to default icon. 
            cD0x10000cA - Set mouse to arrow icon. 
            cD0x20000cA - Set mouse to text I-beam icon. 
            cD0x30000cA - Set mouse to crosshair icon. 
            cD0x40000cA - Set mouse to the grab icon. 
            cD0x50000cA - Set mouse to the wait icon. 
            cD0x60000cA - Set mouse to the stop icon. 

        This feature is not supported on some systems and on others some icons 
        are not obvious due to platform limitations. 


cEcEEXAMPLE cEcA


    The following example checks that the mouse is currently available, if 
    not, it aborts. 
sB
        !if &not &band $mouse 0x10 
            ml-write "[Mouse support is not currently available]" 
            !abort 
        !endif 

sA

cEcENOTES cEcA


    The mouse can be easily configured using lslmuser-setup(3)le. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslm$system(5)le, lslm$platform(5)le. 

! 5 $kept-versions
cEcENAME cEcA


    $kept-versions - Number of backups to be kept 
$a


cEcESYNOPSIS cEcA


    cD$kept-versionscA cCintegercA; Default is 0 

    0 <= cCintegercA <= n 


cEcEDESCRIPTION cEcA


    cD$kept-versionscA allows the user to specify the number of backup versions 
    that are required for each file. For file "cGXXXXcA", each backup version is 
    renamed to "cGXXXX.~?~cA", where cG?cA is the backup number. If cD$kept-versionscA is 
    set to 0 this feature is disabled and the default single backup file is 
    created. 

    The most recent backup will always be cG.~0~cA and the last version will be 
    cG.~n~cA where cGncA is cD$kept-versionscA - 1. when the file is next saved the cG.~0~cA 
    backup file is moved to cG.~1~cA, cG.~1~cA to cG.~2~cA etc, backup cG.~n~cA is removed. 
    Evidently if cD$kept-versionscA it set to a large number this can effect 
    performance. 


cEcERESTRICTIONS cEcA


    cD$kept-versionscA may only be used when DOS file name restrictions are not 
    enabled. This means that some systems (such as DOS) cannot use this 
    functionality, see lslm$system(5)le for more information. Backup files are only 
    created when buffer mode lslmbackup(2m)le is enabled. 


cEcENOTES cEcA


    This feature is not supported when writing ftp files, a single backup file 
    is created when backup files are enabled. 


cEcESEE ALSO cEcA


    lslm$system(5)le, lslmautosv(2m)le, lslmbackup(2m)le, lslmftp(3)le, lslmsave-buffer(2)le. 

! 5 $buffer-indent
cEcENAME cEcA


    $buffer-indent - Current buffer indentation scheme. 
$a


cEcESYNOPSIS cEcA


    cD$buffer-indentcA cCindentNumcA; Default is cG0cA 

    0 <= cCindentNumcA <= 255 


cEcEDESCRIPTION cEcA


    cD$buffer-indentcA sets the current buffers indentation scheme. cCindentNumcA is 
    the identity of the indentation scheme, as defined by lslmindent(2)le, which is 
    typically the same value as the buffers hilighting scheme number (see 
    lslm$buffer-hilight(5)le). 

    The default setting is 0 which specifies no indentation scheme is present 
    (with the exception of lslmcmode(2m)le). When non-zero, the value identifies the 
    indentation scheme. 

    A buffer assigned an indentation method, MicroEmacs performs automatic 
    line re-styling, by moving the left indentation, according to the defined 
    indentation method. The cGtabcA key is typically disabled. This behavior can 
    be altered using bit cG0x1000cA of the lslm$system(5)le variable, which can be 
    changed using lslmuser-setup(3)le. 

    The use of tab characters to create the required indentation is determined 
    by the setting of the buffers lslmtab(2m)le mode. If the mode is disabled tab 
    characters are used wherever possible, otherwise spaces are always used. 


cEcENOTES cEcA


    The commands lslmrestyle-region(3)le and lslmrestyle-buffer(3)le use the indentation 
    method when defined. 

    The buffer indentation scheme is typically assigned in the cCfhookcA macro, 
    see lslanguageTemplates(2)lmLanguage Templatesle. 


cEcEEXAMPLE cEcA


    The following example sets up an indentation scheme for a buffer within 
    the cCfhookcA macro. 
sB
        !if &sequal .hilight.foo "ERROR" 
            set-variable .hilight.foo &pinc .hilight.next 1 
        !endif 

        .... 

        ; Define the indentation scheme 
        0 indent  .hilight.foo 2 10 
        indent .hilight.foo n "then" 4 
        indent .hilight.foo s "else" -4 
        indent .hilight.foo o "endif" -4 

        .... 

        ; File hook - called when new file is loaded. 
        define-macro fhook-foo 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                etfinsrt "foo" 
            !endif 
            ; Assign the hilighting 
            set-variable $buffer-hilight .hilight.foo 
            ; Assign the buffer indentation 
            set-variable $buffer-indent .hilight.foo 
            ; Set the abbreviation file 
            buffer-abbrev-file "foo" 
            ; Temporary comment to make sure that it works. 
            ml-write "Loaded a foo file" 
        !emacro 

sA
    This provides an indentation of the form:- 

        if condition 
        then 
            XXXX 
        else 
            if condition 
            then 
                XXXX 
            endif 
        endif 


cEcESEE ALSO cEcA


    lslmindent(2)le, lslmtab(2m)le, lslm$system(5)le, lslmuser-setup(3)le, lslmrestyle-buffer(3)le, 
    lslmrestyle-region(3)le, lslm$buffer-hilight(5)le. 

! 5 $MENAME
! 5 $LOGNAME
cEcENAME cEcA


|$MENAME
    $MENAME - MicroEmacs user name 
|$LOGNAME
    $LOGNAME - System user name (UNIX) 
$a


cEcESYNOPSIS cEcA


    cD$MENAMEcA cCstringcA; Default is cGguestcA 

    cD$LOGNAMEcA cCstringcA 


cEcEDESCRIPTION cEcA


    cD$MENAMEcA is an environment variable used to initialize the MicroEmacs '02 
    environment for a given user. At start-up, if cD$MENAMEcA is defined then the 
    user's configuration and history file "cGnamecAcC.erfcA" is located and read, 
    where cGnamecA is the variable value. 

    If at start-up cD$MENAMEcA is not defined then cD$MENAMEcA is assigned the value 
    of cD$LOGNAMEcA, if cD$LOGNAMEcA is not defined the file cGdefault.emfcA is located 
    and executed. This macro file is created by lslmuser-setup(3)le to set cD$MENAMEcA 
    to the default user. If this fails then cD$MENAMEcA defaults to cGguestcA and a 
    default configuration is used. 

    The user configuration and history file has many uses, see lslmuser-setup(3)le 
    and lslmread-history(2)le for more information. 


cEMicrosoft Windows Environments cA


    Within Microsoft Windows environments, if cClogincA is enabled then the users 
    login name is automatically used as the first choice login name. No 
    environment variables need to be set. If login is not enabled then one of 
    the aforementioned methods should be used. 


cEUNIX cA


    In UNIX environments, cD$LOGNAMEcA is typically defined. 


cEcENOTES cEcA


    The three variables must be defined before start-up for them to have any 
    effect. 

    cD$LOGNAMEcA is often defined by the system and should not be altered. If a 
    different user name is required, setting of cD$MENAMEcA is preferable. 


cEcESEE ALSO cEcA


    lslmuser-setup(3)le, lslmread-history(2)le, lslm$MEPATH(5)le. 

! 5 $recent-keys
cEcENAME cEcA


    $recent-keys - Recent key history. 
$a


cEcESYNOPSIS cEcA


    cD$recent-keyscA cCstringcA 


cEcEDESCRIPTION cEcA


    cD$recent-keyscA is a system variable that displays the last 100 keys entered 
    into the system in reverse order. This variable is typically used to solve 
    keyboard mapping problems when keys are not bound etc. allowing a visual 
    inspection of the input into the editor. 


cEcESEE ALSO cEcA


    lslmbuffer-bind-key(2)le, lslmglobal-bind-key(2)le, lslmtranslate-key(2)le. 

! 5 $cursor-x
! 5 $cursor-y
cEcENAME cEcA


|$cursor-x
    $cursor-x - Cursor X (horizontal) position 
|$cursor-y
    $cursor-y - Cursor Y (vertical) position 
$a


cEcESYNOPSIS cEcA


    cD$cursor-xcA cCintegercA 

    0 <= cCintegercA <= ls$screen-depth(5)lm$screen-widthle - 1 

    cD$cursor-ycA cCintegercA 

    0 <= cCintegercA <= ls$screen-depth(5)lm$screen-depthle - 1 


cEcEDESCRIPTION cEcA


    cD$cursor-xcA and cD$cursor-ycA are automatically set to the position of the 
    cursor at the last screen update (i.e. the variables are not updated 
    between screen updates). The top left character of the screen is 
    coordinate 0,0 bottom right is ls$screen-depth(5)lm$screen-widthle, ls$screen-depth(5)lm$screen-depthle. 


cEcENOTES cEcA


    These variables can not be set. Any attempt to set them will result in an 
    error. 


cEcESEE ALSO cEcA


    lslm$mouse-x(5)le, lslm$screen-depth(5)le, lslm$screen-width(5)le. 

! 5 %http-proxy-addr
! 5 %http-proxy-port
cEcENAME cEcA


|%http-proxy-addr
    %http-proxy-addr - Set HTTP proxy server address 
|%http-proxy-port
    %http-proxy-port - Set HTTP proxy server port 
$a


cEcESYNOPSIS cEcA


    cD%http-proxy-addrcA "cCproxy-addrcA" 
    cD%http-proxy-portcA "cCport-numbercA"; Default is cG80cA 


cEcEDESCRIPTION cEcA


    If the cD%http-proxy-addrcA variable is set all HTTP file loading requests, 
    using commands like lslmfind-file(2)le, are sent via the given proxy server. 
    cD%http-proxy-portcA should be set to the proxy servers port number, 
    defaulting to cG80cA if not set. These variables are typically set in your 
    cG<user>.emfcA setup file, e.g.: 
sB
        set-variable %http-proxy-addr "proxy.foobar.com" 
        set-variable %http-proxy-port "8080" 

sA

cEcENOTES cEcA


    Note that http is available on UNIX by default, but must be compiled in 
    for win32 versions. 


cEcESEE ALSO cEcA


    lslm%http-flags(5)le, lslmfind-file(2)le, lslmftp(3)le. 

! 5 $trunc-scheme
cEcENAME cEcA


    $trunc-scheme - Truncation color scheme. 
$a


cEcESYNOPSIS cEcA


    cD$trunc-schemecA cCschemeNumcA; Default is cG0cA 


cEcEDESCRIPTION cEcA


    cD$trunc-schemecA sets the color scheme used when drawing a line truncation 
    indicator (a 'cG$cA' character). A '$' character drawn at the start of the 
    line indicates that the line has been scrolled to the right and therefore 
    the start of the line has been truncated. A '$' at the end of the line 
    indicates the remainder of the line is too long to fit onto the width of 
    the window so the end has been truncated and the indicator drawn. 

    The cCschemeNumcA selected must be a color scheme defined with 
    lslmadd-color-scheme(2)le, which identifies the foreground and background color 
    schemes. A hilight scheme can define its own truncation color scheme, see 
    lslmhilight(2)le for more information. 


cEcESEE ALSO cEcA


    lslm$buffer-scheme(5)le, lslm$global-scheme(5)le, lslmadd-color-scheme(2)le, lslmhilight(2)le. 

! 5 $window-x-scroll
! 5 $window-xcl-scroll
! 5 $window-y-scroll
cEcENAME cEcA


|$window-x-scroll
    $window-x-sroll - Current window X scroll 
|$window-xcl-scroll
    $window-xcl-sroll - Current window current line X scroll 
|$window-y-scroll
    $window-y-sroll - Current window Y scroll 
$a


cEcESYNOPSIS cEcA


    cD$window-x-srollcA cCintegercA 
    cD$window-xcl-srollcA cCintegercA 

    0 <= cCintegercA <= 65535 

    cD$window-y-srollcA cCintegercA 

    0 <= cCintegercA <= n 


cEcEDESCRIPTION cEcA


    cD$window-x-srollcA defines the horizontal scroll position in the current 
    window for all lines except the current line, cD$window-xcl-srollcA defines 
    the scroll position for the current line. The variables set how many 
    characters are scrolled off the left hand edge of the current window, the 
    variables are indirectly set by commands such as lslmscroll-left(2)le, 
    lslmforward-char(2)le etc. 

    cD$window-y-srollcA defines the vertical scroll position in the current 
    window. It sets the number of lines are scroll up off the top of the 
    current window, it is indirectly set by commands such as lslmscroll-up(2)le, 
    lslmforward-line(2)le etc. 


cEcEEXAMPLE cEcA


    The following example first stores the current window's buffer position 
    and the window layout. The middle 'cG...cA' section could be replaced with 
    macro code performing any number of operations before the last section 
    which restores the initial position: 
sB
            set-variable #l0 $window-line 
            set-variable #l1 $window-col 
            set-variable #l2 $window-xcl-scroll 
            set-variable #l3 $window-x-scroll 
            set-variable #l4 $window-y-scroll 
                . 
                . 
                . 
            set-variable $window-line #l0 
            set-variable $window-col #l1 
            set-variable $window-xcl-scroll #l2 
            set-variable $window-x-scroll #l3 
            set-variable $window-y-scroll #l4 

sA

cEcENOTES cEcA


    If these variables are set by the user or a macro the value is validated 
    against the lslm$scroll(5)le method and the current cursor position which may 
    lead to the variable being reset if found to be invalid. For example, if 
    the current line is 10 when the cD$window-y-scrollcA is set to 20 the variable 
    will be reset to 0 as a value of 20 will mean the current line is not 
    displayed in the current window. 


cEcESEE ALSO cEcA


    lslmscroll-left(2)le, lslmscroll-up(2)le, lslm$scroll(5)le, lslm$window-line(5)le, lslm$window-col(5)le, 
    lslm$window-acol(5)le. 

! 5 $buffer-backup
! 5 $MEBACKUPPATH
! 5 $MEBACKUPSUB
cEcENAME cEcA


    $buffer-backup - Buffer backup file name 
$a


cEcESYNOPSIS cEcA


    cD$buffer-backupcA cCFileNamecA 


cEcEDESCRIPTION cEcA


    cD$buffer-backupcA is automatically set to the file name the current buffer's 
    file would be backed up to if required. If the current buffer has no file 
    name the variable will be set to "". 

    The value depends on whether DOS compliant file names are being used (see 
    lslm$system(5)le), whether multiple backups are being kept (see 
    lslm$kept-versions(5)le) and the setting of the environment variables 
    cD$MEBACKUPPATHcA and cD$MEBACKUPSUBcA. The variable does not take into 
    consideration the current setting of the buffer's lslmbackup(2m)le mode which 
    determine whether a backup will be made. 

    The environment variable cD$MEBACKUPPATHcA can be used to change the location 
    of the backup files, it can also be used to prepend the backup filename 
    with a string. cD$MEBACKUPPATHcA can specify an absolute path (e.g. 
    "cGc:/temp/mebackup/cA") or a relative path (e.g. "cGmebackup/cA" which will move 
    all backup files into a sub-directory automatically in the files 
    directory). 

    The trailing 'cG/cA' is important as the file name is simple appended, i.e. is 
    creating a backup for "c:/foo/bar.txt" and $MEBACKUPPATH is set the 
    "backup" the backup file name will be "c:/foo/backupbar.txt". 

    The environment variable cD$MEBACKUPSUBcA can be used to substitute strings 
    within the backup filename for another. The format of the value is a list 
    of cDsed(1)cA string substitutions, i.e. 

        $MEBACKUPSUB="s/from1/to1/ s/from2/to2/ s/fr..." 


    The 3 divide characters do not have to be '/'s, they can be any character 
    as long as they are the same, e.g. "sXfrom1Xto1X". When define MicroEmacs 
    performs a simple search for string "cGfrom1cA" (i.e. no regex support) and 
    replaces any match with the string "cGto1cA" etc. 


cEcEEXAMPLE cEcA


    The following example compares the differences between the current version 
    and the bucked up version using the lslmdiff(3)le macro. The cDdiff-changescA macro 
    is defined in cGtools.emfcA. 
sB
        define-macro diff-changes 
            !if &seq $buffer-fname "" 
                ml-write "[Current buffer has no file name]" 
                !abort 
            !endif 
            !if &bmod "edit" 
                !if &iseq @mc1 "Save buffer first [y/n]? " "nNyY" "y" 
                    save-buffer 
                !endif 
            !endif 
            ; get the real file name - this only has effect on unix, copes with symbolic links 
            set-variable #l0 &stat "a" $buffer-fname 
            ; get the backup name 
            set-variable #l1 $buffer-backup 
            diff #l1 #l0 
        !emacro 

sA

cEcENOTES cEcA


    The variable cD$buffer-backupcA can not be set, any attempt to set it will 
    result in an error. 

    On Windows and DOS platforms if the $MEBACKUPPATH and $MEBACKUPSUB 
    variables are used all remaining 'cG:cA' characters are changed to 'cG/cA's as 
    these are illegal in the middle of a filename. 


cEcESEE ALSO cEcA


    lslmbackup(2m)le, lslm$system(5)le, lslm$kept-versions(5)le. 

! 5 $version
cEcENAME cEcA


    $version - MicroEmacs version date-code 
$a


cEcESYNOPSIS cEcA


    cD$versioncA "cCYYYYMMDDcA" 


cEcEDESCRIPTION cEcA


    cD$versioncA is a system variable which is defined as the MicroEmacs build 
    date code. This value is fixed at compile time and cannot be changed. The 
    variable may be used in macros to identify incompatibility issues. 


cEcEEXAMPLE cEcA


    Given a macro that only operates with a MicroEmacs executable built on or 
    after 1st August 2001 then this macro should check that cG$versioncA is not 
    less than cG20010801cA. The check may be performed as follows: 
sB
        !if &les $version "20010801" 
            ml-write "[Error: MicroEmacs executable is incompatible]" 
            !abort 
        !endif 

sA

cEcENOTES cEcA


    This variable was introduced in 2001-08-01, evaluating this variable on an 
    earlier version of MicroEmacs would return the string "cGERRORcA" unless an 
    environment variable $version has been defined. "cGERRORcA" evaluates to cG0cA 
    hence the test still operates correctly. 

    This variable is used in the macro file cGme.emfcA to check for any macro - 
    executable incompatibility issues. 

! 8 eaf
cEcENAME cEcA


    eaf - MicroEmacs abbreviation file format 


cEcESYNOPSIS cEcA


    cC<pattern> <insertionString>cA 
    cC<pattern> <insertionString>cA 
    cC<pattern> <insertionString>cA 
    cC<pattern> <insertionString>cA 


cEcEDESCRIPTION cEcA


    The MicroEmacs '02 abbreviation file, typically given the extension cD.eafcA, 
    defines a set of shorthand expansion strings which are used by the command 
    lslmexpand-abbrev(2)le. lslmbuffer-abbrev-file(2)le defines the abbreviation file. 

    The abbreviation file line based, with one abbreviation per line, with no 
    intervening blank lines. Each line comprises of two columns, the first 
    column cC<pattern>cA identifies the source pattern to be expanded, the second 
    column cC<insertionString>cA defines the replacement text. The two text 
    columns are separated by a space character. 

    When lslmexpand-abbrev(2)le is invoked and the expansion cC<pattern>cA is 
    recognized, then cC<pattern>cA is deleted from the buffer and replaced with 
    cC<insertionString>cA. 

    The fields are defined as follows:- 

    cC<pattern>cA 
        The source pattern to be expanded. The data commences in text column 0 
        and spans to the first white space character (cGSPACEcA or cGtabcA). The 
        pattern may not include any white space characters. 

    cC<insertionString>cA 
        The replacement string exists from the first non-white space character 
        following the cC<pattern>cA to the end of the line. The replacement string 
        may include special tokens, delimited by a backslash ('cG\cA') character 
        which are interpreted as follows:- 

        cD\bcA Move cursor backwards 
            A positioning control. Allows the cursor to be moved backwards 1 
            character. 

        cD\dcA Delete cGtabcA backwards 
            Back tab. Deletes a tab character backwards. 

        cD\m"cAcC<string>cAcD"cA Macro execution 
            Takes the remainder of the line as a keyboard macro definition. 
            The macro cCstringcA is generated using lslminsert-macro(2)le and must be 
            contained in double quotes. When invoked the keyboard macro is 
            executed and the appropriate text is inserted into a buffer. This 
            is typically only used for more complex operations. 

        cD\pcA Position 
            The resultant position of the cursor following the expansion. If 
            the cursor position is not specified, the cursor is placed at the 
            end of the expansion string by default. 

        cD\rcA Carriage Return (Newline) 
            A newline in the replacement text. Note while lslmindent(2m)le is 
            enabled a sequence a single "\r" retains the indent on the next 
            line, however a sequence of two "\r\r" characters does not retain 
            the tab position and returns the cursor to the start of the second 
            line. If blank lines are required retaining tab positioning then a 
            keyboard macro string should be used instead. (see "\m" above). 

        cD\tcA Tab 
            A cGtabcA character in the replacement text. 


cEcEEXAMPLE cEcA


    The following example provides abbreviations for the 'C' programming 
    language, found in file cDc.eafcA. All cursor positions in the examples are 
    shown by cD<@>cA. 

        #i #include <\p>\r 
        #d #define \p 
        if if(\p)\r{\r\r}\r 
        ef else if(\p)\r{\r\r}\r 
        el else\r{\r\p\r}\r 
        wh while(\p)\r{\r\r}\r 
        sw switch(\p)\r{\rcase :\rdefault :\r}\r 


    Given that the abbreviation file has been declared then expansion of: 

        #d<@>       =>      #define <@> 

        if<@>       =>      if(<@>) 
                            { 

                            } 

        sw<@>       =>      switch(<@>) 
                            { 
                            case : 
                            default : 
                            } 


    Note, in all of the examples, the abbreviation replacement strings specify 
    a resultant cursor position, typically where the next edit will take 
    place. 

    The macros may alternatively be defined using keyboard macros. The 
    aforementioned macros could have been re-written with the following 
    definitions which are equivalent:- 

        #i \m"#include <\CX\CAP>\CM\CXaP\CX)" 
        #d \m"#define \CX)" 
        if \m"if(\CX\CAP)\CM{\CM}\CXaP\CX)" 
        ef \m"else if(\CX\CAP)\CM{\CM\CM}\CM\CXaP\CX)" 
        el \m"else\CM{\CM\CX\CAP\CM}\CM\CXaP\CX)" 
        wh \m"while(\CX\CAP)\CM{\CM\CM}\CM\CXaP\CX)" 
        sw \m"switch(\CX\CAP)\CM{\CMcase :\CMdefault:\CM}\CM\CXaP\CX)" 


    Within a macro, the cursor positioning is generally achieved by setting a 
    mark where the resultant cursor is to be positioned (see lslmset-mark(2)le), 
    when the macro is finished then an lslmexchange-point-and-mark(2)le is initiated 
    to move the cursor to the correct position; alternatively a sequence of 
    cursor movements may be used. 

    The "\b" and "\d" are typically used for positioning the cursor on 
    subsequent lines. "\d" is the inverse of "\t". Consider the following 
    Pascal definition for an cCelsecA, cCbegincA and cCendcA sequence:- 

        el else\rbegin\r\t\p;\r\dend; 


    with lslmindent(2m)le mode enabled generates:- 

                else 
                begin 
                    <@>; 
                end; 


    Similarly the "\b" is typically used when lslmindent(2m)le is enabled, but when 
    the tab spacing is known. Consider the following example used in the 
    MicroEmacs '02 cD.emfcA files to define a help entry. In this case the indent 
    is known to be 5 characters. Hence to move the cursor back 5 characters 
    then a sequence of cD\bcA's are used:- 

        !h def .. \rSEE ALSO\r     <cross references>\r\b\b\b\b\b!ehelp 


    the expansion in this case is:- 

        define-help "<@>" 

        ... 

        SEE ALSO 
             <cross references> 
        !ehelp 


cEcEFILES cEcA


    The default abbreviation files are located in the MicroEmacs '02 cChomecA 
    directory. 

    User's may specify their own abbreviation files by shadowing the cChomecA 
    directory file with their own file located in a personal MicroEmacs '02 
    directory. See lslm$MEPATH(5)le. 


cEcESEE ALSO cEcA


    lslmexpand-abbrev(2)le, lslmbuffer-abbrev-file(2)le, lslmglobal-abbrev-file(2)le, 
    lslmiso-accents-mode(3)le. 

! 8 etf
cEcENAME cEcA


    etf - MicroEmacs template file format 


cEcESYNOPSIS cEcA


    cC<Free Form Text>cA 


cEcEDESCRIPTION cEcA


    The MicroEmacs '02 template file, typically given the extension cD.etfcA, is a 
    file template for a new file and defines common text that is automatically 
    included when a new file is created. 

    The file inclusion is usually performed by macro lslmetfinsrt(3)le, called from 
    the lsfileHooks(2)lmFile Hooksle. The template file has no specific format, although 
    cDetfinsrtcA replaces key strings with relevant information. 


cEcEEXAMPLE cEcA


    The template file is inserted with the file hooks. If a file hook is 
    called with an argument of cG0cA then the buffer has been created and the 
    template file is inserted. 
sB
        define-macro fhook-c 
            ; if arg is 0 this is a new file so add template 
            !if &not @# 
                ; Is it an include h file or a c file? 
                !if &seq &mid $buffer-bname &rsin "." $buffer-bname 1 "h" 
                    etfinsrt "h" 
                !else 
                    etfinsrt "c" 
                !endif 
            !endif 
            1 buffer-mode "cmode" 
            1 buffer-mode "time" 
            . 
            . 
        !emacro 

sA
    See lslmetfinsrt(3)le for more information on how the template file is located 
    and inserted into the buffer. 

    The default MicroEmacs '02 'C' mode template is defined as follows, but 
    may be replaced with any other text:- 

        /* -*- C -*- **************************************************************** 
         * 
         *     Copyright $YEAR$ $COMPANY_NAME$. 
         *         All Rights Reserved 
         * 
         * 
         *  System        : 
         *  Module        : 
         *  Object Name   : m8fil001.8 
         *  Created By    : $USER_NAME$ 
         *  Created       : $ASCII_TIME$ 
         *  Last Modified : <000719.1013> 
         * 
         *  Description  
         * 
         *  Notes 
         * 
         *  History 
         *  
         **************************************************************************** 
         * 
         *  Copyright (c) $YEAR$ $COMPANY_NAME$. 
         * 
         *  All Rights Reserved. 
         * 
         * This  document  may  not, in  whole  or in  part, be  copied,  photocopied, 
         * reproduced,  translated,  or  reduced to any  electronic  medium or machine 
         * readable form without prior written consent from $COMPANY_NAME$. 
         * 
         ****************************************************************************/ 

        static const char rcsid[] = "@(#) : $Id$"; 



cEcEFILES cEcA


    The default template files are located in the MicroEmacs '02 cChomecA 
    directory. 

    User's may specify their own template files by shadowing the cChomecA 
    directory file with their own file located in a personal MicroEmacs '02 
    directory. See lslm$MEPATH(5)le. 


cEcESEE ALSO cEcA


    lsfileHooks(2)lmFile Hooksle. 
    lslmetfinsrt(3)le, lslm&find(4)le. 

! 8 edf
cEcENAME cEcA


    edf - MicroEmacs spelling dictionary file 


cEcESYNOPSIS cEcA


    cDlsdmenus.edfcA 
    cCusercAcD.edfcA 


cEcEDESCRIPTION cEcA


    The spelling dictionary files are given the extension cD.edfcA. These are 
    binary files read by MicroEmacs '02 and cannot be edited directly. 

    MicroEmacs '02 is supplied with a dictionaries for various languages. It 
    is recommended that these dictionaries are not modified, a personal 
    dictionary is used and modified instead. 

    A personal dictionary, cCusercAcD.edfcA, is automatically created in the users 
    directory for additional spelling information. 


cEcEFILES cEcA


    The standard dictionary files lsdmcC<language><country>cAcD.edfcA are located in 
    the MicroEmacs '02 cChomecA directory. 

    User's may create their own dictionary files by shadowing the cChomecA 
    directory file with their local dictionary(s) located in a personal 
    MicroEmacs '02 directory. See lslm$search-path(5)le. 


cEcESEE ALSO cEcA


    lslmspell(2)le, lslmadd-dictionary(2)le, lslm$search-path(5)le. 

! 8 emf
cEcENAME cEcA


    emf - MicroEmacs macro file 


cEcESYNOPSIS cEcA


cEcEDESCRIPTION cEcA


    The MicroEmacs '02 macro files are ASCII text files, given the file 
    extension cD.emfcA. A number of special macro files exist as follows:- 

    cDme.emfcA 
        The start-up macro file. This file is the first macro file to be 
        invoked and is used to bootstrap MicroEmacs '02 into the correct 
        configuration. 

    cDhkcAcC<name>cAcD.emfcA 
        Macro files prefixed with cDhkcA generally denote lsfileHooks(2)lmFile Hookle macro files 
        which are automatically invoked when known file types are loaded. 

    cC<logname>cAcD.emfcA 
        The users start-up configuration file, typically used to configure the 
        environment with the users preferences. 

    cC*cAcDterm.emfcA 
        Platform specific configuration files, used to configure the 
        environment for a specific platform. 

    Macro files may be any name, the more prominent macro files are:- 

    cDcolor.emfcA 
        Color definitions for the buffers. 

    cDmouse.emfcA 
        Mouse interaction macros. 

    cDosd.emfcA 
        OSD Menu configuration file. 


cEcEFILES cEcA


    The default start-up file cDme.emfcA is located in the MicroEmacs '02 cChomecA 
    directory. 

    User's may create their own start-up and files in their local MicroEmacs 
    '02 directory. The users start-up file is called cC$LOGNAMEcAcD.emfcA, and may be 
    used to execute other macro files defined by the user. 


cEcESEE ALSO cEcA


    lsfileHooks(2)lmFile Hooksle, lslmemftags(3f)le, lslm$MEPATH(5)le, lslmexecute-file(2)le. 

! 8 erf
cEcENAME cEcA


    erf - MicroEmacs registry file 


cEcESYNOPSIS cEcA


    cC; Comment to the end of the linecA 
    cC<command>cA ::= cD"cAcC<identifier>cAcD"cA [ cD=cA cD"cAcC<string>cAcD"cA ][ cD{cA cC<command>cA cD}cA ] * 


cEcEDESCRIPTION cEcA


    MicroEmacs '02 registry files are ASCII text files, given the file 
    extension cD.erfcA. The registry file is a simple syntax that allows an 
    cCidentifiercA to be associated with a cCstringcA. The cCidentifierscA are unique and 
    allow a cCstringcA value to be found when a search for a cCidentifiercA is made. 
    The cCstringcA component is optional. 

    The syntax allows the cCidentifiercA's to be hierarchically nested, children 
    of the cCidentifiercA node are enclosed in a set of curly braces cD{cA ... cD}cA. The 
    enclosure itself comprises a number of cCidentifierscA, which may have their 
    own enclosures, and so on. 

    The backslash character `cG\cA' is the escape character, the following 
    sequences of escape character are recognized:- 

        cG\\cA - Literal backslash 
        cG\"cA - Double quote (used within a quoted string) 
        cG\ncA - New line character. 
        cG\tcA - Tab character. 

    The semi-colon character `cG;cA' introduces a comment which exists to the end 
    of the line. 


cEcEEXAMPLE cEcA


    The following is an example of a registry file:- 

        ; -!- erf -!- 
        ; Comment on this line 
        "dos" 
        { 
            "file-ignore" = "~ ./ .o" 
            "font" = "85" 
            "mail-dir" = "c:/mail/" 
            "mail-send" = "echo from \"%f\" file \"%o\"" 
            "mail-src" = "c:/mail/jon" 
            "nested"="value" 
            { 
                "foo"="bar" 
            } 
        } 


    The history file cCusername.erfcA is a good example of the use of the 
    registry. This file retains historical session information in The history 
    registry file is automatically written at the end of a editing session 
    when the editor is closed down (or may be saved explicitly using 
    lslmsave-history(2)le). 

    Every user should have their own personal history file in their personal 
    MicroEmacs directory. The history file is located from the MicroEmacs '02 
    search path defined by lslm$MEPATH(5)le, and is named by the environment 
    variable lslm$LOGNAME(5)le. 


cEcENOTES cEcA


        * The registry files are not currently written with a backup. 
        * Special care should be taken when editing registry files when they 
          are loaded into MicroEmacs. It is recommended that the registry file 
          is not loaded as a registry item when editing the registry text 
          file. 

    To edit the history registry file within MicroEmacs then the following 
    sequence of steps should be followed:- 

        * Save the current history lslmsave-history(2)le. 
        * Load the history registry file cCusernamecA.erf. 
        * Edit the file. 
        * Save edits back to the file. 
        * Re-install the history lslmread-history(2)le. This flushes the current 
          session history and restores it from the file. The new edits should 
          now be in the registry. 
        * Examine the loaded registry using lslmlist-registry(2)le. 


cEcESEE ALSO cEcA


    lslmlist-registry(2)le, lslmread-history(2)le, lslmread-registry(2)le, lslmsave-history(2)le, 
    lslmsave-history(2)le, lslm$MEPATH(5)le. 

! 8 ehf
cEcENAME cEcA


    ehf - MicroEmacs help file 


cEcESYNOPSIS cEcA


    cD!cAcC<helpTag>cA 
    cC<Text Description>cA 
    ... 
    cD|cAcC<helpId>cA 
    cC<Text Description Line>cA 
    ... 
    cD$cAcC?cA 
    ... 
    cC<Text Description>cA 
    cD!cAcC<helpTag>cA 
    cD!cAcC<helpTag>cA 
    cC<Text Description>cA 
    ... 


cEcEDESCRIPTION cEcA


    The on-line help information is retained in the file cDme.ehfcA, this is an 
    ASCII text file which holds all of the on-line help information. The help 
    file comprises of formatted text cC<Text Description>cA which is literally 
    displayed to the user when help information is requested. Each text 
    description is delimited into pages with a cD!cAcC<helpTag>cA which identifies the 
    block of text with a help label. 

    The cD!cAcC<helpTag>cA is placed before the text description and is identified by 
    a exclamation mark (`cD!cA') placed at the beginning of the line. The 
    cC<helpTag>cA is the identifying name used by the help system and takes the 
    following form: 

        cGLSSNNNN...cA 

    Where: 

    cDLcA 
        Is the length of the "cGNNNN...cA" name which must be matched, a value of 
        'cG cA' indicates that the whole name must be matched, otherwise the value 
        must be in the range 'cG1cA' - 'cG9cA' indicating the number of characters to 
        be match. 

    cDSScA 
        Is the section number of the page, the first character should be a 
        numeric (i.e. 'cG3cA' for a macro) and the second is an optional section 
        letter. A value of 'cG cA' indicates no section number and/or letter. 

    cDNNNN...cA 
        The page name, the length is unlimited but must be on one line. 

    Multiple cC<helpTag>cA's may be associated with a common text description by 
    proceeding a block of text with multiple tags, each on a separate line, 
    with no intervening non-tag lines (i.e. lines that do not commence with 
    cD!cA). 

    The cC<Text Description>cA that follows is the text associated with the tag. 
    When the help system is invoked with the tag then the text is displayed. 
    There are 2 types of internal command lines, lines starting with a 'cG|cA' 
    indicate that the following line should only be displayed if the requested 
    help page is cC<helpId>cA, where cC<helpId>cA is the the name used in the 
    cC<helpTag>cA. This is a useful mechanism for pages with multiple cC<helpTag>cAs. 

    Lines which contain just "cG$?cA" are MicroEmacs command lines where cG?cA can be: 

    cGacA 
        For a command help page display any global key bindings, for variables 
        display its current value. 

    MicroEmacs uses a special hilighting scheme to control color schemes and 
    hyper-text links, the special embedded tags all start with and escape 
    character (0x1b or 'cG^[cA') and are defined as follows: 

    cG^[c?cA 
        Tag used to change color where cG?cA can be: 
            cGA  cAwhite, used for main text. 
            cGB  cAred, used for underlining. 
            cGC  cAgreen, used for italic font. 
            cGD  cAcyan, used for bold font. 
            cGE  cAlight yellow, used for a header. 
            cGF  cAlight red, used for and image link. 

    cG^[s?cA 
        Tag used to change hilighting scheme where cG?cA can be: 
            cGA  cANormal ehf hilight. 
            cGB  cAMicroEmacs macro (or emf) hilighting. 
        Note that other tags can only be used in the normal ehf hilighting 
        scheme. 

    cG^[ls<link>^[lm<name>^[lecA 
        Used to create hyper-links, cG<link>cA is the help link name which can be 
        omitted if it is the same as cG<name>cA. cG<name>cA should not contain any 
        other tags, it is automatically displayed in the magenta color scheme. 


cEcENOTES cEcA


    When the help system is invoked for the first time, cDme.ehfcA is loaded into 
    internal memory and fragmented into labeled pages using the cC<helpTag>cA 
    information. Hence, any edits made to cDme.emfcA are not visible in the help 
    system until the next session. 

    Macros and alike may add additional help information to the internal help 
    database at run-time using the lslmdefine-help(2)le command. 

    The help hilighting is applied to the help buffer from the hilighting 
    macro's defined in cDhkhelp.emfcA. The hilighting is NOT part of the help 
    file. 

    Special hilighting keys may be included in cDme.ehfcA provided that they are 
    interpreted by the help hilighting defined in cDhkehf.emfcA. 

    cC<Text Description>cA lines cannot commence with cD!cA, cD|cA or cD$cA in the first 
    column. 


cEcEEXAMPLE cEcA


    The following help entry defines the help for lslmglobal-mode(2)le, 
    lslmadd-global-mode(3)le and lslmdelete-global-mode(3)le. It uses most features 
    mentioned, namely multiple link names, color and scheme changes and 
    several hyper-text links: 

        ! 2 global-mode 
        ! 3 add-global-mode 
        ! 3 delete-global-mode 
        ^[cE^[cENAME ^[cE^[cA 


        |global-mode 
            global-mode - Change a global buffer mode 
        |add-global-mode 
            add-global-mode - Set a global buffer mode 
        |delete-global-mode 
            delete-global-mode - Remove a global buffer mode 
        $a 


        ^[cE^[cESYNOPSIS ^[cE^[cA 


            ^[cCn^[cA ^[cDglobal-mode^[cA "^[cCmode^[cA" (^[cDesc m^[cA) 
            ^[cDadd-global-mode^[cA "^[cCmode^[cA" 
            ^[cDdelete-global-mode^[cA "^[cCmode^[cA" 


        ^[cE^[cEDESCRIPTION ^[cE^[cA 


            ^[cDglobal-mode^[cA changes the state of one of the hereditary 
            global modes. A buffer's modes are initialized to the global 
            modes when first created. This command is very useful in changing 
            some of the default behavior such as case sensitive searching (see 
            the example below). See ^[ls^[lmOperating Modes^[le for a full list 
            and description of modes. Also see ^[ls^[lmbuffer-mode(2)^[le for a 
            full description of the use of the argument ^[cCn^[cA. 

            The ^[ls^[lminfo(2)^[le command gives a list of the current global 
            and buffer modes. 

            ^[cDadd-global-mode^[cA and ^[cDdelete-global-mode^[cA are macros 
            defined in me3_8.emf which use global-mode to add or remove a global 
            mode. They are defined for backward compatibility and for ease of 
            use; they are simple macros, add-global-mode is defined as follows: 
        ^[sB 
                define-macro add-global-mode 
                    ; Has the require mode been given as an argument, if so add it 
                    !force 1 global-mode @1 
                    !if &not $status 
                        ; No - use 1 global-mode to add a mode 
                        !nma 1 global-mode 
                    !endif 
                !emacro 

        ^[sA 

        ^[cE^[cEEXAMPLE ^[cE^[cA 


            The following example globally disables ^[ls^[lmexact(2m)^[le and 
            ^[ls^[lmmagic(2m)^[le modes, if these lines are copied to the user 
            setup file then are searches will be simple and case insensitive by 
            default: 
        ^[sB 
                -1 global-mode "exact" 
                -1 global-mode "magic" 

        ^[sA 

        ^[cE^[cENOTES ^[cE^[cA 


            Globally adding ^[ls^[lmbinary(2m)^[le and ^[ls^[lmcrypt(2m)^[le 
            modes is strongly discouraged as any file loaded would be assigned 
            these modes. Instead the use of commands ^[ls^[lmfind-bfile(3)^[le 
            and ^[ls^[lmfind-cfile(3)^[le are recommended. 

            ^[ls^[lmauto(2m)^[le, ^[ls^[lmautosv(2m)^[le, ^[ls^[lmbackup(2m)^[le, 
            ^[ls^[lmexact(2m)^[le, ^[ls^[lmmagic(2m)^[le, ^[ls^[lmquiet(2m)^[le, 
            ^[ls^[lmtab(2m)^[le and ^[ls^[lmundo(2m)^[le modes are present on all 
            platforms by default. On Windows and DOS platforms ^[ls^[lmcrlf(2m)^[le 
            is also present and on DOS ^[ls^[lmctrlz(2m)^[le is also present. 


        ^[cE^[cESEE ALSO ^[cE^[cA 


            ^[ls^[lmOperating Modes^[le, ^[ls^[lmbuffer-mode(2)^[le, 
            ^[ls^[lmfind-bfile(3)^[le, ^[ls^[lmfind-cfile(3)^[le, 
            ^[ls^[lminfo(2)^[le. 


cEcEFILES cEcA


    The help file cDme.ehfcA is located in the MicroEmacs '02 cChomecA directory. 


cEcESEE ALSO cEcA


    lslmdefine-help(2)le, lslm$MEPATH(5)le. 

! 8 me32.ini
cEcENAME cEcA


    me32.ini - Microsoft Window's Initialization (ini) File 


cEcESYNOPSIS cEcA


    cD[Location]cA 
    cDexecA=cC<executablePathname>cA 

    cD[Defaults]cA 
    cDmepath=cAcC<directoryPath>cA 
    cDuserpath=cAcC<directoryPath>cA 
    cDfontfile=cAcC<fontFileName>cA 

    cD[cAcC<userName>cAcD]cA 
    cC<environmentVariable>cAcD=cAcC<value>cA 
    cC<environmentVariable>cAcD=cAcC<value>cA 

    cD[cAcC<userName>cAcD]cA 
    cC<environmentVariable>cAcD=cAcC<value>cA 
    cC<environmentVariable>cAcD=cAcC<value>cA 

    cD;cA cCComments commence with a semi-coloncA 


cEcEPLATFORM cEcA


    cDMicrosoft Windows environments onlycA 


cEcEDESCRIPTION cEcA


    cDme32.inicA is the Microsoft Windows configuration file, located in the 
    windows directory (typically cDC:\WindowscA), the cDme32.inicA file is primarily 
    used to counteract the deficiencies of Windows shell environment (as 
    compared with UNIX) with respect to the initialization of environment 
    variables. 

    The configuration file may be considered to be split into two sections, a 
    cDDefaultscA section, which defines system settings and a cDUsercA section which 
    allows environment variables to be defined. 


cEUser Section cA


    The cDUser SectioncA is executed prior to the cDDefaults SectioncA. The cDUser 
    SectioncA uses the user name which is defined as follows:- 

        * The environment variable lslm$MENAME(5)le. 
        * The cClogin namecA under Windows '95 or NT if cD$MENAMEcA is not set. If the 
          cClogin namecA is defined then environment variable cD$MENAMEcA is set to 
          this value. 
        * The environment variable lslm$LOGNAME(5)le if the cClogin namecA cannot be 
          located. 
        * cDguestcA if none of the above are defined. 

    A section cD[cAcCuserNamecAcD]cA is looked up, and if located each of the entries 
    cC<environmentVariable>cA cD=cA cC<value>cA is extracted and pushed into the execution 
    environment. The cD<environmentVariable>cA is automatically promoted to upper 
    case if specified as a lower case entry. The environment variables may be 
    subsequently used within the cD.emfcA macro files to configure MicroEmacs '02 
    at start up. 

    Any value may be inserted into the environment including the cG$MENAMEcA 
    environment variable which is used in the next section. 


cEDefaults Section cA


    The defaults section, labeled cD[Defaults]cA includes the following keys:- 

    cDmepathcA 
        The directory (or folder) location of the MicroEmacs '02 default 
        configuration files. 

    cDuserpathcA 
        The directory (or folder) location of the user(s) directories. 

        Given that the cDuserpathcA is specified as cGc:\me98.5cA and the user is 
        called cGfoocA, then the directory location cGc:\me98.5\foocA is considered to 
        be the user path. 

        If the cDuserpathcA is omitted then the cDmepathcA entry is used as the user 
        path. 

    The cDuserpathcA and cDmepathcA entries are concatenated together to form the 
    environment variable lslm$MEPATH(5)le, e.g. cCuserpathcAcD\cAcClognamecAcD;cAcCmepathcA. If the 
    entries are omitted the then environment variable cG$MEPATHcA is used as 
    defined. The cDmepathcA and cDuserpathcA are configured initialy by the 
    cDInstallShieldcA installation process. 

    cDfontfilecA 
        The name of the font file used to render the text to the screen. The 
        default font file is cDdosapp.foncA, this is a fixed mono font as used in 
        the MS-DOS windows. 


cELocation Section cA


    The location section, labeled cD[Location]cA, identifies the location of 
    MicroEmacs '02, and is typically used by other components to find and 
    launch MicroEmacs. The section includes the following keys:- 

    cDexecA 
        The absolute pathname to the MicroEmacs '02 executable image. 


cEcEEXAMPLE cEcA


    The following is an example of the cDme32.inicA file:- 

        ; External locater for the executable 
        [Location] 
        exe=c:\Program Files\JASSPA\MicroEmacs\me32.exe 
        ; 
        [Defaults] 
        ; mepath 
        ; The location of the MicroEmacs common files. 
        ; 
        mepath=d:/me98.4/common 
        ; 
        ; userpath - The location of the users MicroEmacs directory. 
        ; The $MENAME is appended as a directory to userpath 
        ; 
        userpath=d:/me98.4/common 
        ; 
        ; fontfile - The name of the font file used as default. 
        fontfile=dosapp.fon 
        ; 
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
        ; 
        ; Environment settings for a user. 
        ; All settings are pushed into the environment. 
        ; 
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
        ; 
        [guest] 
        term=8x12 
        ; 
        [jon] 
        MENAME=jon 
        FOO=bar 
        ; 
        [jnaught] 
        MENAME=jon 
        FOO=bar 
        ; 
        [bill] 
        .... 


    Note that multiple users share the same cDme32.inicA file, each user may 
    include their own configuration settings which may be interrogated in the 
    configuration files (e.g. cG$FOOcA is assigned the value cGbarcA, which may be 
    extracted from the environment context). 


cEcESEE ALSO cEcA


    lslm$MENAME(5)le, lslm$MEPATH(5)le, lslmuser-setup(3)le, lslmemf(8)le. 

! 9 c
! 9 cc
! 9 h
! 9 cpp
! 9 def
! 9 l
! 9 y
! 9 i
! 9 rc
cEcESYNOPSIS cEcA


    C, C++ - C and C++ programming language templates 


cEcEFILES cEcA


    cDhkc.emfcA - C programming language hook definition 
    cDhkcpp.emfcA - C++ programming language hook definition 

    cDc.etfcA - C programming language template file 
    cDh.etfcA - C programming language header template file 
    cDcpp.etfcA - C++ programming language template file 
    cDhpp.etfcA - C++ programming language header template file 


cEcEEXTENSIONS cEcA


    cD.ccA, cD.hcA, cD.defcA - ANSI C 
    cD.cppcA, cD.cccA, cD.hppcA, cD.rccA cD.CcA cC(UNIX only)cA - C++ programming language 
    cD.lcA - LEX 
    cD.ycA - YACC 
    cD.icA - C (or C++) pre-processed file (i.e. output from pre-processor). 
    cD.rccA - Microsoft Developer resource file. 


cEcEMAGIC STRINGS cEcA


    cD-*- c -*-cA 
        Recognized by GNU and MicroEmacs. Denotes a 'C' programming type file, 
        may be used in cD.ccA, cD.defcA and cD.hcA files. 

    cD-*- c++ -*-cA 
        Recognized by GNU and MicroEmacs. Denotes a C++ programming type file, 
        may be used in cD.ccA, cD.defcA and cD.hcA files. 


cEcEDESCRIPTION cEcA


    The cDCcA and cDC++cA file type templates offer the most sophisticated editing 
    features within the MicroEmacs '02 environment. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, 
        preprocessor definitions, comments, strings and characters of the 
        language to be differentiated and rendered in different colors. 

    cDAuto LayoutcA 
        The C-Mode lslmcmode(2m)le performs automatic layout of the text, variables 
        such as ls$c-brace(5)lmc-brace(5)le allow the brace position and text formation to be 
        modified. 

        lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to reformat 
        (re-layout) selected sections of the buffer, or the whole buffer, 
        respectively. 

        Comments may be formatted using cGesc ocA, which reformats the comments 
        according to the current fill paragraph. If a comment commences with 
        cG/***...cA then the comment is automatically formatted to a box. If the 
        comment commentces with cG/**cA then the comment is assumed to be a cCJavacA 
        cCDoccA comment. 

    cDTagscA 
        A C-tags file may be generated within the editor using the cDToolscA -> cDC 
        ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file using 
        the tag information. 

        On invoking the tag generator then the user is presented with a dialog 
        box which specifies the generation option of the tags file. The base 
        directory of the tags file search and tagging options may be specified 
        to locate all of the definitions within the code space. 

        The cDtagscA file is extremely useful where the user is dealing with 
        inherited source code spread over multiple directories. Generation of 
        a recursive tag file with all searching options enabled allows labels 
        to be located extremely rapidly (certainly faster than IDE 
        environments). 

    cDFolding and Information HidingcA 
        Generic folding is enabled within the C and C++ files. The folds occur 
        about braces cD{cA...cD}cA located on the left-hand margin. lslmfold-all(3)le 
        (un)folds all regions in the file, lslmfold-current(3)le (un)folds the 
        current region. Note that folding does not operate on K&R style code. 

        The cDToolscA -> cDC ToolscA menu allows cG#definecA's to be evaluated within the 
        buffer. Where the state of a cG#ifcA is established to be false (using the 
        cG#definecA information) then the disabled region of code is grayed out 
        indicating which regions of the code are active. 

    cDWorking EnvironmentcA 
        lslmcompile(3)le may be invoked to rebuild the source, the user is prompted 
        to save any files. 

        lslmrcs-file(2)le is automatically invoked if an RCS file is detected, the 
        normal check-in/out operations may be performed through the editor. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-ccA - Comment out the current line. 
        cDC-c C-dcA - Uncomment the current line. 
        cDC-c C-ecA - Comment to the end of the line with stars (*). 
        cDA-C-icA - Restyle the current region. 
        cDesc qcA - Format a comment. 
        cDesc ocA - Format a comment. 
        cDf2cA - (un)fold the current region 
        cDf3cA - (un)fold all regions 


cEcENOTES cEcA


    If the default language is C++, rather than 'C' the order of the file 
    hooks should be over-ridden in the users local setup, using:- 
sB
        add-file-hook ".c "                                  fhook-c 
        add-file-hook ".cc .cpp .hpp .rc .h .def .l .y .i"   fhook-cpp 

sA
    This defaults all cD.hcA and cD.defcA files etc. to be C++ rather than C. 

    The hilighting is typically extended using a file cDmyc.emfcA (or cDmycpp.emfcA) 
    i.e. to include the usual extended types of cDint32cA etc, cDmyc.emfcA might be 
    defined as:- 
sB
        hilight .hilight.c 1 "uint8"    .scheme.type 
        hilight .hilight.c 1 "int8"     .scheme.type 
        hilight .hilight.c 1 "uint16"   .scheme.type 
        hilight .hilight.c 1 "int16"    .scheme.type 
        hilight .hilight.c 1 "uint32"   .scheme.type 
        hilight .hilight.c 1 "int32"    .scheme.type 
        hilight .hilight.c 1 "float32"  .scheme.type 
        hilight .hilight.c 1 "float64"  .scheme.type 

sA

cEcEBUGS cEcA


    The 'C' and 'C++' templates have been throughly used, there are no known 
    issues with the templates. 

    The cD.rccA hilighting is a little bogus and should not really be mapped onto 
    cD.cppcA. Do not attept to re-style. 


cEcESEE ALSO cEcA


    ls$c-brace(5)lmc-brace(5)le, lslmcmode(2m)le, lslmcompile(3)le, lslmctags(3f)le, lslmfind-tag(2)le, lslmfold-all(3)le, 
    lslmfold-current(3)le, lslmrcs-file(2)le, lslmrestyle-buffer(3)le, lslmrestyle-region(3)le, 
    lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 ehf
cEcESYNOPSIS cEcA


    ehf - MicroEmacs '02 help file 


cEcEFILES cEcA


    cDhkehf.emfcA - MicroEmacs '02 help file. 


cEcEEXTENSIONS cEcA


    cD.ehfcA, cD*help*cA 


cEcEDESCRIPTION cEcA


    The cDehfcA file type template performs the hilighting of the help file. The 
    cDehfcA file is a computer generated file and uses special embedded text 
    markers to indicate the required color scheme. 

    The macro file includes special macros to locate help information. 


cEcESEE ALSO cEcA


    lslmhelp(2)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 emf
cEcESYNOPSIS cEcA


    emf - MicroEmacs '02 Macro File 


cEcEFILES cEcA


    cDhkemf.emfcA - MicroEmacs '02 Macro File hook definition 
    cDemf.etfcA - Template file 


cEcEEXTENSIONS cEcA


    cD.emfcA - MicroEmacs '02 Macro File 


cEcEDESCRIPTION cEcA


    The cDemfcA file type template handles the hilighting of the MicroEmacs '02 
    macro files. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, comments, 
        strings and characters of the language to be differentiated and 
        rendered in different colors. 

    cDAuto LayoutcA 
        The lsindent(2)lmindentation mechanismle is enabled which performs performs automatic 
        layout of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are 
        available to reformat (re-layout) selected sections of the buffer, or 
        the whole buffer, respectively. 

    cDTagscA 
        A C-tags file may be generated within the editor using the cDToolscA -> 
        cDEmf-ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file 
        using the tag information. 

    cDFolding and Information HidingcA 
        Generic folding is enabled within the cDemfcA files. The folds occur about 
        cDdefine-macrocA and cD!emacrocA text located on the left-hand margin. 
        lslmfold-all(3)le (un)folds all regions in the file, lslmfold-current(3)le 
        (un)folds the current region. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-ccA - Comment out the current line. 
        cDC-c C-dcA - Uncomment the current line. 
        cDC-c esc esc cA- Command complete. 
        cDA-C-icA - Restyle the current region. 
        cDf2cA - (un)fold the current region 
        cDf3cA - (un)fold all regions 


cEcEBUGS cEcA


    No bugs reported 


cEcESEE ALSO cEcA


    lslmemftags(3f)le, lslmfind-tag(2)le, lslmfold-all(3)le, lslmfold-current(3)le, lslmindent(2)le, 
    lslmrestyle-buffer(3)le, lslmrestyle-region(3)le, lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 txt
! 9 doc
cEcESYNOPSIS cEcA


    txt, doc - Plain text document file 


cEcEFILES cEcA


    cDhkdoc.emfcA - Plain text hook definition 


cEcEEXTENSIONS cEcA


    cD.txtcA - ASCII plain text file 
    cD.doccA - ASCII plain text document file 


cEcEDESCRIPTION cEcA


    The cDdoccA file type template handles the hilighting and text formating of a 
    plain text file. Within the text document justification and word wrapping 
    are typically enabled. The template allows the user to format text as 
    left, right, center or no justification. 

    cDAuto LayoutcA 
        The automatic layout of the text is restricted to justification and 
        wrapping and the detection of bulleted lists. ls$fill-bullet(5)lmfill-bullet(5)le may be 
        used to determine the character set used for bullet points, on 
        encountering a bullet the left-hand justification might be modified. 

    cDFormatting rulescA 
        The default mode of operation is automatic mode which attempts to 
        retain the document style whenever a paragraph is re-formatted. This 
        allows rapid entry of text into a reasonable format with no special 
        formating character embedded in the text. 

        The automatic formatting rules used by lslmfill-paragraph(2)le in an 
        automatic text mode are defined as follows:- 

        Text on column 0 
            Text appearing in the first column is always assumed to be left 
            justified, and non-wrapping, provided that the text does not 
            extend to the ls$fill-col(5)lmfill columnle. This is typically used for headers and 
            addresses. 

        Text on right edge 
            Text ending at the right edge (the ls$fill-col(5)lmfill-col(5)le), which commences 
            from more that 50% of the page width is assumed to be right 
            justified, non-wrapping. Typically used for addresses. 

        Text centered 
            Text which is centered on the page is assumed to be centered, this 
            is non-wrapping. 

        Indented 
            All other text, not covered by the cases above is assumed to be 
            available for filling. In this case the text is filled by the 
            paragraph and left/right justification is applied. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-hcA - Help information on current mode. 
        cDC-c C-scA - Spell the buffer. 
        cDC-c C-bcA - Fill both; perform left and right justification on the 
        margins. 
        cDC-c C-bcA - Fill center; center the text on the current line. 
        cDC-c C-lcA - Fill left; fill the text on the paragraph (ragged right 
        edge). 
        cDC-c C-rcA - Fill right; place text on right margin. 
        cDC-c C-ocA - Reduce a paragraph to a single line. 
        cDC-c acA - Move to automatic formatting mode (default). 
        cDC-c lcA - Change mode to left formating 
        cDC-c rcA - Change mode to right formating 
        cDC-c rcA - Change mode to both formating 
        cDC-c ccA - Change mode to center formating 
        cDC-c ncA - Change mode to no formating 


cEcENOTES cEcA


    To move text to a word processor then it is advised that all paragraphs 
    are reduced to single lines, leading white space should be deleted (any 
    possibly blank lines) and then import to the word processor. This saves 
    considerable time as the word processor styles may be applied without 
    handling spaces and band end of line characters. 


cEcEMAGIC STRINGS cEcA


    cD-!- document -!-cA 
        MicroEmacs specific tag, recognizes the file as a plain text document. 
        No hilighting of the document is performed. 

    cD-!- document; sectioned -!-cA 
        MicroEmacs specific tag, recognizes the file as a document that 
        contains sections. A crude section hilighting is enabled as follows:- 

        Lines commencing with cD>cA are assumed to be comments, typically used at 
        the head of the document . 

            > -!- document; sectioned -!- 
            > 
            > Author:       My Self 
            > Created:      11/11/97 
            > Modified:     <211197.1003> 
            > Location:     /xx/yy/zz.doc 


        All lines commencing with start (cG*cA) are assumed to be bullet lists. 
        Bullet is hilighted. 

        All lines commencing with cG[a-zA-Z])cA or cG[0-9])cA are assumed to be minor 
        sections. The section number is hilighted. e.g.: 

            a) text 
            1) text 


        All text in single or double quotes is hilighted, assumed to be 
        literal text. and are hilighted i.e. This is a cD"double quote"cA or cD'a'cA 
        single quote. 

        Lines commencing with underscore (cG_cA) are hilighted to the end. 
        typically used as demarcation breaks or for section underlining 

    cD-!- Document; pseudo-code -!-cA 
        The document contains pseudo code, and the pseudo code is hilighted. 
        The pseudo-code tokens are defined as follows:- 

        cD//cA introduces a comment to the end of the line. 

        Command words comprise:- 
            cGBEGINcA, cGBREAKcA, cGCASEcA, cGCLEARcA, cGCONTINUEcA, cGDOcA, cGDONEcA, cGELIFcA, cGELSEcA, cGENDcA, 
            cGENDIFcA, cGFORcA, cGFUNCTIONcA, cGGOTOcA, cGIFcA, cGONEVENTcA, cGONINTERRUPTcA, cGPROCEDUREcA, 
            cGREPEATcA, cGRETURNcA, cGSETcA, cGSWITCHcA, cGTHENcA, cGTOcA, cGUNTILcA, cGWHILEcA, 

        Pseudo logical operators include 
            cGANDcA, cGFALSEcA, cGMODcA, cGNOTcA, cGORcA, cGTRUEcA, cGXORcA, 

    cD-!- document; sectioned; pseudo-code -!-cA 
        A combination of both of the above. 


cEcEBUGS cEcA


    The automatic mode sometimes mistakes an indented paragraph for a centered 
    paragraph. This only typically occurs when the first line of the paragraph 
    is not filled to the right. When the formatting error occurs, simply pad 
    the line out so that it extends past the fill column and re-apply the 
    formatting. 

    Unfortunately there is nothing that can be done to alleviate this problem, 
    but it occurs infrequently. 


cEcESEE ALSO cEcA


    ls$fill-col(5)lmfill-col(5)le, lslmfill-paragraph(2)le, lslmspell-buffer(3)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 latex
! 9 tex
cEcESYNOPSIS cEcA


    latex - TeX Documentation 


cEcEFILES cEcA


    cDhklatex.emfcA - Tex File hook definition 
    cDlatex.etfcA - Template file 


cEcEEXTENSIONS cEcA


    cD.texcA - TeX Documentation 


cEcEDESCRIPTION cEcA


    The cDlatexcA file type template handles the hilighting of the TeX files. The 
    hilighting is minimal, hilighting the key words and comments. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

    cDHilightingcA 
        The hilighting emphasizes the Tex embedded command strings and 
        comments. No special recognition of the command strings is performed. 

    cDOutline HilightingcA 
        The LaTeX content may be viewed with synthetic hilighting such that 
        headers, text in bold and italic are displayed, removing the LaTeX 
        control sequences. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-ccA - Comment out the current line. 
        cDC-c C-dcA - Uncomment the current line. 

        The command cDlatex-compilecA is available within the buffer which invokes 
        an external process to build the text. 


cEcEBUGS cEcA


    No bugs reported 


cEcESEE ALSO cEcA


    lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 makefile
cEcESYNOPSIS cEcA


    makefile - Make file 


cEcEFILES cEcA


    cDhkmake.emfcA - Make file hook definition 
    cDmake.etfcA - Template file 


cEcEEXTENSIONS cEcA


    cDMakefilecA, cDmakefilecA, cD.makcA - Makefiles. 


cEcEMAGIC STRINGS cEcA


    cD-!- makefile -!-cA 
        Recognized by MicroEmacs only, defines the file to be a makefile. 


cEcEDESCRIPTION cEcA


    The cDmakecA file type template handles the hilighting of the makefile files. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

        By default, cGTABcA's are enabled as this is the syntactical feature of 
        the file. 

    cDHilightingcA 
        The hilighting emphasizes the keywords and comments within the 
        makefile. No special support for Microsoft cDnmake(1)cA is provided 
        because of the number of oddities in their implementation of make. 


cEcEBUGS cEcA


    No attempt is made to hilight any embedded shell commands. 


cEcESEE ALSO cEcA


    lslmimakefile(9)le, lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 imakefile
cEcESYNOPSIS cEcA


    imakefile - Make file 


cEcEFILES cEcA


    cDhkimake.emfcA - Imakefile hook definition 
    cDimake.etfcA - Template file 


cEcEEXTENSIONS cEcA


    cDImakefilecA, cDimakefilecA - Imakefiles. 


cEcEDESCRIPTION cEcA


    The cDImakefilecA file type template handles the hilighting of the Imakefile 
    files. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

        By default, cGTABcA's are enabled as this is the syntactical feature of 
        the file. 

    cDHilightingcA 
        The hilighting emphasizes the keywords and comments within the 
        Imakefile. 


cEcEBUGS cEcA


    No attempt is made to hilight any embedded shell commands. 


cEcESEE ALSO cEcA


    lslmmakefile(9)le, lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 bat
! 9 btm
cEcESYNOPSIS cEcA


    bat, btm - MS-DOS batch files 


cEcEFILES cEcA


    cDhkdos.emfcA - MS-DOS hook definition 


cEcEEXTENSIONS cEcA


    cD.batcA - MS-DOS Batch file 
    cD.btmcA - 4-DOS Batch file 


cEcEMAGIC STRINGS cEcA


    cD-!- msdos -!-cA 
        Recognized by MicroEmacs only. Denotes a MS-DOS batch file. 


cEcEDESCRIPTION cEcA


    The cDdoscA file type templates provide simple hilighting of a MS-DOS batch 
    file. The template provides minimal hilighting support of both standard 
    and 4-DOS batch files. 

    The cCMagic StringcA may be used within the cDconfig.syscA file to force 
    hilighting of the MS-DOS configuration file. 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lslmini(9)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 ini
! 9 hpj
! 9 reg
! 9 rgy
cEcESYNOPSIS cEcA


    ini, hpj, reg, rgy - MS-Windows initialization and registry files 


cEcEFILES cEcA


    cDhkini.emfcA - MS-Windows initialization and registry files. 


cEcEEXTENSIONS cEcA


    cD.inicA - MS-Windows Initialization File 
    cD.hpjcA - MS-Windows Help Project File 
    cD.regcA - Registry File 
    cD.rgycA - (Other) registry File 


cEcEDESCRIPTION cEcA


    The cDinicA file type templates provide simple hilighting of MS-Windows 
    initialization and registry files. The file format is similar to a number 
    of other registry type files which are also over-loaded into the same 
    template. 

    cDHilightingcA 
        The template provides minimal hilighting , but allows the different 
        components of the file to be differentiated. 

    cDFolding and Information HidingcA 
        Generic folding is enabled within the ini files. The folds occur about 
        lines with leading square brackets cD[cA...cD[cA located on the left-hand 
        margin. lslmfold-all(3)le (un)folds all regions in the file, lslmfold-current(3)le 
        (un)folds the current region. 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lslmbat(9)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 f
! 9 f77
! 9 f90
cEcESYNOPSIS cEcA


    f, f77, f90 - Fortran files 


cEcEFILES cEcA


    cDhkf90.emfcA - Fortran hook definition 
    cDf90.etfcA - Fortran 90 template file. 
    cDf.etfcA - Fortran (77) template file. 


cEcEEXTENSIONS cEcA


    cD.fcA - Fortran file 
    cD.f77cA - Fortran 77 file 
    cD.f90cA - Fortran 90 file 


cEcEDESCRIPTION cEcA


    The cDf90cA file type templates provide simple hilighting of Fortran 77 and 
    Fortran 90 files, the template provides minimal hilighting of both 
    language syntaxes, which are overloaded into the same file. 

    The major difference between the file types, apart from the new reserved 
    words, is the comments. In Fortran 90 comments are introduced with cD!cA, 
    while the other types use a cDccA in column 0. 


cEcEBUGS cEcA


    The Fortran hilight file is in it's infancy and a number of it's tokens 
    may be misplaced. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 p
! 9 pas
cEcESYNOPSIS cEcA


    p, pas - Pascal files 


cEcEFILES cEcA


    cDhkpascal.emfcA - Pascal hook definition 
    cDpascal.etfcA - Pascal template file. 


cEcEEXTENSIONS cEcA


    cD.pcA, cD.pascA - Pascal file 


cEcEDESCRIPTION cEcA


    The cDpascalcA file type template provides simple hilighting of Pascal files, 
    the template provides minimal hilighting. 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 rul
cEcESYNOPSIS cEcA


    rul - Install Shield Rules 


cEcEFILES cEcA


    cDhkrul.emfcA - Install Shield hook definition 
    cDrul.etfcA - Install Shield template file. 


cEcEEXTENSIONS cEcA


    cD.rulcA - Install Shield Rules file 


cEcEDESCRIPTION cEcA


    The cDrulcA file type template provides simple hilighting of Install Shield 
    Rules files. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, comments, 
        strings and characters of the language to be differentiated and 
        rendered in different colors. 

    cDAuto LayoutcA 
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout 
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to 
        reformat (re-layout) selected sections of the buffer, or the whole 
        buffer, respectively. 

    cDFolding and Information HidingcA 
        Generic folding is enabled within the rul file. The folds occur about 
        the keywords cDfunctioncA...cDendcA located on the left-hand margin. 
        lslmfold-all(3)le (un)folds all regions in the file, lslmfold-current(3)le 
        (un)folds the current region. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-ccA - Comment out the current line. 
        cDC-c C-dcA - Uncomment the current line. 
        cDC-c C-ecA - Comment to the end of the line with stars (*). 
        cDf2cA - (un)fold the current region 
        cDf3cA - (un)fold all regions 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lslmfold-current(3)le, lslmfold-all(3)le, lslmindent(2)le, lslmrestyle-region(3)le 
    lslmrestyle-buffer(3)le 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 bnf
cEcESYNOPSIS cEcA


    bnf - Backus-Naur Form 


cEcEFILES cEcA


    cDhkbnf.emfcA - Backus-Naur Form hook definition 


cEcEEXTENSIONS cEcA


    cD.bnfcA - Backus-Naur Form file 


cEcEDESCRIPTION cEcA


    The cDbnfcA file type template provides simple hilighting of text presented in 
    Backus-Naur Form. The hilighting allows the components of the BNF to be 
    differentiated quickly. 

    The syntactical tokens that are hilighted are:- 

    cD<cAcC[a-zA-Z]cA.*cD>cA 
        Component language identifiers. 

    cD| { } ::=cA 
        Meta symbols of the BNF format. 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 sql
cEcESYNOPSIS cEcA


    sql - SQL files 


cEcEFILES cEcA


    cDhksql.emfcA - SQL hook definition 
    cDsql.etfcA - SQL template file. 


cEcEEXTENSIONS cEcA


    cD.sqlcA - SQL file 


cEcEDESCRIPTION cEcA


    The cDsqlcA file type template provides simple hilighting of SQL files, the 
    template provides minimal hilighting. 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 vhdl
cEcESYNOPSIS cEcA


    vhdl - VHDL hardware simulation files 


cEcEFILES cEcA


    cDhkvhdl.emfcA - VHDL hook definition 
    cDvhdl.etfcA - VHDL template file. 


cEcEEXTENSIONS cEcA


    cD.vhdlcA, cD.vhdcA - VHDL file 


cEcEDESCRIPTION cEcA


    The cDvhdlcA file type template provides simple hilighting of VHDL files, the 
    template provides minimal hilighting. 


cEcEBUGS cEcA


    None reported. Template could probably benifit from some form of auto 
    indentation. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 awk
! 9 gawk
! 9 nawk
cEcESYNOPSIS cEcA


    awk - AWK files 


cEcEFILES cEcA


    cDhkawk.emfcA - AWK hook definition 
    cDawk.etfcA - AWKL template file. 


cEcEEXTENSIONS cEcA


    cD.awkcA - AWK file 
    cD.gawkcA - GNU AWK file 
    cD.nawkcA - New AWK file 


cEcEMAGIC STRINGS cEcA


    cD#![ \t]*/.*awkcA 
        MicroEmacs '02 recognises the magic string on the first line of the 
        file used to locate the executable. The awk files may be extensionless 
        and are still recognised. 


cEcEDESCRIPTION cEcA


    The cDawkcA file type template provides simple hilighting of AWK files, the 
    template provides minimal hilighting. 


cEcEBUGS cEcA


    None reported. Template could probably benifit from some form of auto 
    indentation. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 fvwm
! 9 fvwmrc
cEcESYNOPSIS cEcA


    fvwm, fvwmrc - FVWM Window manager configuration files 


cEcEFILES cEcA


    cDhkfvwm.emfcA - FVWM configuration file hook definition 


cEcEEXTENSIONS cEcA


    cD.fvwmcA, cD.fvwmrccA - FVWM configuration file 


cEcEMAGIC STRINGS cEcA


    cD-!- fvwm -!-cA 
        The embedded fvwm string may be used with later versions of fvwm which 
        use a different file extension to force the hilighting of the file. 


cEcEDESCRIPTION cEcA


    The cDfvwmcA file type template provides simple hilighting of the FVWM files, 
    the template provides minimal hilighting. 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 sh
! 9 ksh
! 9 csh
! 9 zsh
! 9 login
! 9 profile
! 9 tcshrc
cEcESYNOPSIS cEcA


    *sh - UNIX shell files 


cEcEFILES cEcA


    cDhkshell.emfcA - UNIX shell file hook definition 


cEcEEXTENSIONS cEcA


    cD.shcA - Bourne shell file 
    cD.kshcA - Korn shell file 
    cD.cshcA - C-Shell file 
    cD.zshcA - Z-Shell file 
    cD.logincA - Shell user login file 
    cD.profilecA - Shell user profile 
    cD.tcshrccA - T-Shell start up file 


cEcEMAGIC STRINGS cEcA


    cD#![ \t]*/.*shcA 
        MicroEmacs '02 recognizes the magic string on the first line of the 
        file used to locate the executable. The shell files may be extension 
        less and are still recognized. Note that this is the typical method of 
        identifying shell files and will recognize other files not mentioned 
        above i.e. cDbashcA shells. 


cEcEDESCRIPTION cEcA


    The cDshellcA file type template provides simple hilighting of the shell 
    files. 


cEcEBUGS cEcA


    None reported. 

    There is a heavy bias towards Bourne, Korn and Zsh shells. The author is 
    not a csh shell user so has probably missed a lot of csh features. 


cEcESEE ALSO cEcA


    lslmfvwm(9)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 java
! 9 jav
cEcESYNOPSIS cEcA


    java - Java programming language templates 


cEcEFILES cEcA


    cDhkjava.emfcA - Java programming language hook definition 
    cDjava.etfcA - Java programming language template file 


cEcEEXTENSIONS cEcA


    cD.javacA, cD.javcA - Java 


cEcEDESCRIPTION cEcA


    The cDjavacA file type templates share much with the lslmc(9)le template 
    definitions, utilising the electric 'C' features for automatic layout of 
    text. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, 
        preprocessor definitions, comments, strings and characters of the 
        language to be differentiated and rendered in different colors. 

    cDAuto LayoutcA 
        The electric C-Mode lslmcmode(2m)le performs automatic layout of the text, 
        variables such as ls$c-brace(5)lmc-brace(5)le allow the brace position and text 
        formation to be modified. 

        lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to reformat 
        (re-layout) selected sections of the buffer, or the whole buffer, 
        respectively. 

        Comments may be formatted using cGesc ocA, which reformats the comments 
        according to the current fill paragraph. If a comment commences with 
        cG/***...cA then the comment is automatically formatted to a box. 

    cDFolding and Information HidingcA 
        Generic folding is enabled within the Java files. The folds occur 
        about braces cD{cA...cD}cA located on the left-hand margin. lslmfold-all(3)le 
        (un)folds all regions in the file, lslmfold-current(3)le (un)folds the 
        current region. Note that folding does not operate on K&R style code, 
        with the trailing open brace. 

    cDTagscA 
        A c-tags file may be generated within the editor using the cDToolscA -> 
        cDJava-ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file 
        using the tag information. 

        On invoking the tag generator then the user is presented with a dialog 
        box which specifies the generation option of the tags file. The base 
        directory of the tags file search and tagging options may be specified 
        to locate all of the definitions within the code space. 

        The cDtagscA file is extremely useful where the user is dealing with 
        inherited source code spread over multiple directories. Generation of 
        a recursive tag file with all searching options enabled allows labels 
        to be located extremely rapidly (certainly faster than IDE 
        environments). 

    cDFolding and Information HidingcA 
        Generic folding is enabled within the C and C++ files. The folds occur 
        about braces cD{cA...cD}cA located on the left-hand margin. lslmfold-all(3)le 
        (un)folds all regions in the file, lslmfold-current(3)le (un)folds the 
        current region. Note that folding does not operate on K&R style code. 

        The cDToolscA -> cDC-ToolscA menu allows cG#definecA's to be evaluated within the 
        buffer. Where the state of a cG#ifcA is established to be false (using the 
        cG#definecA information) then the disabled region of code is grayed out 
        indicating which regions of the code are active. 

    cDWorking EnvironmentcA 
        lslmcompile(3)le may be invoked to rebuild the source, the user is prompted 
        to save any files. 

        lslmrcs-file(2)le is automatically invoked if an RCS file is detected, the 
        normal check-in/out operations may be performed through the editor. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-ccA - Comment out the current line. 
        cDC-c C-dcA - Uncomment the current line. 
        cDC-c C-ecA - Comment to the end of the line with stars (*). 
        cDA-C-icA - Restyle the current region. 
        cDesc qcA - Format a comment. 
        cDesc ocA - Format a comment. 
        cDf2cA - (un)fold the current region 
        cDf3cA - (un)fold all regions 


cEcENOTES cEcA


    The hilighting is typically extended using a file cDmyjava.emfcA 


cEcESEE ALSO cEcA


    lslmc(9)le, ls$c-brace(5)lmc-brace(5)le, lslmcmode(2m)le, lslmcompile(3)le, lslmfind-tag(2)le, lslmjavatags(3f)le, 
    lslmfind-tag(2)le, lslmfold-all(3)le, lslmfold-current(3)le, lslmrcs-file(2)le, lslmrestyle-buffer(3)le, 
    lslmrestyle-region(3)le, lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 tcl
! 9 tk
! 9 wish
cEcESYNOPSIS cEcA


    tcl, tk - TCL Programming language templates 


cEcEFILES cEcA


    cDhktcl.emfcA - TCL/TK programming language hook definition 
    cDtcl.etfcA - TCL/TK programming language template file 


cEcEEXTENSIONS cEcA


    cD.tclcA, cD.tkcA - TCL/TK file 


cEcEMAGIC STRINGS cEcA


    cD^#![ \t]*/.*wishcA 
        MicroEmacs '02 recognizes the magic string on the first line of the 
        file used to locate the executable. The tcl files may be extension 
        less and are still recognized. 


cEcEDESCRIPTION cEcA


    The cDtclcA provides hilighting and automatic formatting features, in addition 
    to a number of tools to handle the file type. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, 
        preprocessor definitions, comments, strings and characters of the 
        language to be differentiated and rendered in different colors. 

    cDAuto LayoutcA 
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout 
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to 
        reformat (re-layout) selected sections of the buffer, or the whole 
        buffer, respectively. 

    cDTagscA 
        A C-tags file may be generated within the editor using the cDToolscA -> 
        cDTcl-ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file 
        using the tag information. 

    cDFolding and Information HidingcA 
        Generic folding is enabled within the C and C++ files. The folds occur 
        about braces cD{cA...cD}cA located on the left-hand margin. lslmfold-all(3)le 
        (un)folds all regions in the file, lslmfold-current(3)le (un)folds the 
        current region. Note that folding does not operate on K&R style code. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-ccA - Comment out the current line. 
        cDC-c C-dcA - Uncomment the current line. 
        cDC-c C-ecA - Comment to the end of the line with stars (*). 
        cDA-C-icA - Restyle the current region. 
        cDf2cA - (un)fold the current region 
        cDf3cA - (un)fold all regions 


cEcESEE ALSO cEcA


    lslmindent(2)le, lslmfind-tag(2)le, lslmfold-all(3)le, lslmfold-current(3)le, lslmrestyle-buffer(3)le, 
    lslmrestyle-region(3)le, lslmtcltags(3f)le, lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 asn.1
cEcESYNOPSIS cEcA


    asn.1 - ASN.1 File 


cEcEFILES cEcA


    cDasn1.emfcA - asn.1 file hook definition 
    cDans1.etfcA - Template file 


cEcEEXTENSIONS cEcA


    cDasn1cA - ASN.1 files. 


cEcEMAGIC STRINGS cEcA


    cD-!- asn.1 -!-cA 
        Recognized by MicroEmacs only, defines the file to be a asn.1. 


cEcEDESCRIPTION cEcA


    The cDasn1cA file type template handles the hilighting of the asn.1 files. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

        By default, cGTABcA's are enabled as this is the syntactical feature of 
        the file. 

    cDHilightingcA 
        The hilighting emphasizes the keywords and comments within the asn.1. 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 erf
cEcESYNOPSIS cEcA


    erf - MicroEmacs '02 registry file 


cEcEFILES cEcA


    cDhkerf.emfcA - MicroEmacs '02 registry file. 


cEcEEXTENSIONS cEcA


    cD.erfcA, cD*registry*cA 


cEcEDESCRIPTION cEcA


    The cDerfcA file type template performs the hilighting of the registry file. 

    cDHilightingcA 
        The hilighting features allows components of the language to be 
        differentiated and rendered in different colors. 

    cDAuto LayoutcA 
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout 
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to 
        reformat (re-layout) selected sections of the buffer, or the whole 
        buffer, respectively. 


cEcESEE ALSO cEcA


    lslmlist-registry(2)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 man
cEcESYNOPSIS cEcA


    man - UNIX Manual page 


cEcEFILES cEcA


    cDhkman.emfcA - UNIX manual page hook definition 


cEcEEXTENSIONS cEcA


    cD.mancA - UNIX manual page file 


cEcEDESCRIPTION cEcA


    The cDmancA provides the hilighting of UNIX manual pages, generally acquired 
    through the lslmman(3)le command, via a pipe. cCmancA references within the 
    displayed manual page may be accessed using the mouse in a hypertext 
    fashion. 

    cDHilightingcA 
        The hilighting commands recognize the manual page cCboldcA and cCunderlinecA 
        character sequences and transpose these into the appropriate character 
        hilighting. The hilighting sequences are generally unpleasant because 
        they also remove the characters for display. 

        The multitude of different platforms causes problems as different 
        vendors produce different character sequences for cCboldcA/cCitaliccA text, 
        hence on some platforms it may be necessary to add additional 
        hilighting rules to cater for any local variations. 

    cDShort CutscA 
        Selecting a link node within the manual page using the mouse (i.e. a 
        reference to another manual page) then MicroEmacs '02 attempts to find 
        the manual page in the text and invokes lslmman(3)le to render the page. 
        This provides a crude hyper text mechanism simply using the manual 
        page information itself. 
            The lslmman-clean(3)le command can be used to remove all of the 
            hilighting characters from the current manual page. This is the 
            typical method of reducing a manual page to plain text. 


cEcESEE ALSO cEcA


    lslmman(3)le, lslmman-clean(3)le, 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 vrml
cEcESYNOPSIS cEcA


    vrml - VRML File 


cEcEFILES cEcA


    cDhkvrml.emfcA - VRML File hook definition 


cEcEEXTENSIONS cEcA


    cC<none>cA - Uses the cCMagic StringcA only. 


cEcEMAGIC STRINGS cEcA


    cD#VRMLcA 
        A generic tag that appears on the first line at the top of a cDVRMLcA (or 
        cDwrlcA) file. MicroEmacs automatically recognises the tag and adopts the 
        appropriate mode. 


cEcEDESCRIPTION cEcA


    The cDvrmlcA file type template handles the hilighting of cDVRMLcA files. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, comments, 
        strings and characters of the language to be differentiated and 
        rendered in different colors. 

    cDAuto LayoutcA 
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout 
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to 
        reformat (re-layout) selected sections of the buffer, or the whole 
        buffer, respectively. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDA-C-tabcA - Restyle a region. 


cEcEBUGS cEcA


    No bugs reported 


cEcESEE ALSO cEcA


    lslmindent(2)le, lslmrestyle-buffer(3)le, lslmrestyle-region(3)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 perl
! 9 pl
! 9 pm
cEcESYNOPSIS cEcA


    perl - Practical Extraction and Report Language File. 


cEcEFILES cEcA


    cDhkperl.emfcA - Practical Extraction and Report Language file hook definition 
    cDperl.etfcA - Practical Extraction and Report Language header template file. 
    cDperl.eafcA - Practical Extraction and Report Language abbreviation file. 


cEcEEXTENSIONS cEcA


    cD.plcA, cD.pmcA - Perl file 


cEcEMAGIC STRINGS cEcA


    cD#![ \t]*/.*perlcA 
        MicroEmacs '02 recognizes the magic string on the first line of the 
        file used to locate the executable. The Perl files may be 
        extension-less and are still recognized. 

    cD# -*- perl -*-cA 
        MicroEmacs '02 recognizes the standard GNU Emacs magic string on the 
        first line of the file. The Perl files may be extension-less and are 
        still recognized. 


cEcEDESCRIPTION cEcA


    The cDperlcA file type template provides the hilighting, indentation and tools 
    definitions for a perl file. 

    File recognition is performed using the standard file extension cD.plcA, cD.pmcA 
    or by the magic string. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, comments, 
        strings and characters of the language to be differentiated and 
        rendered in different colors. 

    cDAuto LayoutcA 
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout 
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to 
        reformat (re-layout) selected sections of the buffer, or the whole 
        buffer, respectively. 

    cDFolding and Information HidingcA 
        Generic folding is enabled within perl files. The folds occur about 
        cCsubcA...cD}cA located on the left-hand margin. lslmfold-all(3)le (un)folds all 
        regions in the file, lslmfold-current(3)le (un)folds the current region. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-ccA - Comment out the current line. 
        cDC-c C-dcA - Uncomment the current line. 
        cDC-c esc esc cA- Command complete. 
        cDA-C-icA - Restyle the current region. 
        cDf2cA - (un)fold the current region 
        cDf3cA - (un)fold all regions 

    cDDebuggingcA 
        Debugging a perl script can be done inside MicroEmacs by using the 
        lslmperldb(3)le command. 


cEcEBUGS cEcA


    The flexibility of the perl language does cause some hilighting anomalies 
    from time to time, typically with unbalanced quote characters. Most of the 
    common exceptions have been caught, however there are a few syntax 
    sequences that involve quotation marks that can cause problems. 


cEcESEE ALSO cEcA


    lslmperldb(3)le, lslmfold-all(3)le, lslmfold-current(3)le, lslmindent(2)le, lslmrestyle-buffer(3)le, 
    lslmrestyle-region(3)le, lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 html
! 9 htm
cEcESYNOPSIS cEcA


    html - HyperText Markup Language File. 


cEcEFILES cEcA


    cDhkhtml.emfcA - HyperText Markup Language file hook definition 


cEcEEXTENSIONS cEcA


    cD.htmcA, cD.htmlcA - HyperText Markup Language File. 
    cD.htpcA - cC[Special]cA Super HTML Preprocessor file. 
    cD.htscA - cC[Special]cA Super HTML file. 


cEcEMAGIC STRINGS cEcA


    cD<html>cA 
        MicroEmacs '02 recognizes the magic string on any of the first 4 lines 
        of the file. The HTML files may be extension-less and are still 
        recognized. 


cEcEDESCRIPTION cEcA


    The cDhtmlcA file type template provides simple hilighting of HTML files. 
    Additionally, MicroEmacs '02 is capable of rendering simple HTML files 
    (without graphic content) into the current buffer and follow the hyper 
    text links. The JASSPA HTML documentation may be viewed in this way. 

    cDGeneral EditingcA 
        HTML files may be edited or processed and rendered into the buffer. 
        The cDUse Author ModecA option in the lslmbuffer-setup(3)le dialog determines 
        the edit mode on loading a HTML file; when set to 'cGNcA' the page is 
        rendered, 'cGYcA' and the raw HTML file is presented. The default state is 
        'cGYcA'. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, 
        preprocessor definitions, comments, strings and characters of the 
        language to be differentiated and rendered in different colors. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-hcA - Help information. 
        cDC-c C-acA - Toggle the HTML author status. 
        cDhtml-spell-check-wordcA - spell check the current word. 

    cDRendered ModecA 
        In the non-author mode, the HTML file is extracted and rendered to the 
        buffer. The hypertext links may be followed by selecting them with the 
        mouse or using the cG<RETURN>cA key. 

        The rendered mode is typically used to check HTML text after it has 
        been authored from the editor. The rendered mode only caters for 
        regular HTML 2.0 text. It does not handle tables or frames etc. cC(use a 
        browser)cA. 

        Toggling between rendered and authoring mode, then the buffer should 
        be killed as the translation is only performed when the file is read. 

        The non-author mode can be permanently enabled by setting the cDUse 
        Author ModecA option in the lslmbuffer-setup(3)le dialog to 'cGNcA'. When set to N 
        any HTML files loaded are automatically processed, and rendered 
        according to their HTML content. 


cEcENOTES cEcA


    The lsprint-buffer(2)lmprintle driver may be used to generate HTML from the contents of the 
    buffer. Select the printer destination as cCbuffercA, and cCHTMLcA as the driver. 
    The buffer being printed is converted to HTML and dumped in the print 
    buffer. 

    cD.htscA and cD.htpcA are computer generated extended HTML files used in the 
    MicroEmacs '02 documentation system. 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lslmprint-buffer(2)le, lslmbuffer-setup(3)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 nroff
! 9 troff
! 9 0-9
! 9 tni
! 9 so
! 3 tex2nr
! 3 aman
cEcESYNOPSIS cEcA


    0-9, tni, so - UNIX t/nroff file. 


cEcEFILES cEcA


    cDhknroff.emfcA - UNIX t/nroff file. 
    cDnroff.etfcA - UNIX t/nroff template file 
    cDntags.emfcA - t/nroff tags generator macro definition. 


cEcEEXTENSIONS cEcA


    cD1cA, cD2cA, cD3cA, cD4cA, cD5cA, cD6cA, cD7cA, cD8cA, cD9cA - UNIX t/nroff files. 
    cDtnicA, cDsocA - UNIX t/nroff include files. 
    cDsmcA - cC[Special]cA Superman t/nroff file. 


cEcEMAGIC STRINGS cEcA


    cD-*- nroff -*-cA 
        Recognized by GNU and MicroEmacs. Denotes a t/nroff type file, may be 
        used in cD.1cA/cD.9cA, cD.tnicA and cD.socA files. 


cEcEDESCRIPTION cEcA


    The cDnroffcA file type templates handle UNIX n/troff type files. 

    cDGeneral EditingcA 
        On creating a new file, a new header is automatically included into 
        the file. lslmtime(2m)le is by default enabled, allowing the modification 
        time-stamp to be maintained in the header. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, 
        preprocessor definitions, comments, strings and characters of the 
        language to be differentiated and rendered in different colors. 

    cDTagscA 
        A C-tags file may be generated within the editor using the cDToolscA -> 
        cDNroff-ToolscA -> cDCreate Tag FilecA. lslmfind-tag(2)le takes the user to the file 
        using the tag information. The tags are generated using the cD.XIcA 
        keyword, this may not be standard for all nroff pages. 

    cDFolding and Information HidingcA 
        Generic folding is enabled within the C and C++ files. The folds occur 
        about sections cD.ScA[cDHScA]...cD.ScA[cDHScA] located on the left-hand margin. 
        lslmfold-all(3)le (un)folds all regions in the file, lslmfold-current(3)le 
        (un)folds the current region. Note that folding does not operate on 
        K&R style code. 

    cDToolscA 
        The nroff buffer provides a facility to toggle the hilighting of the 
        buffer on and off. If font change inserts are used (cD\fBcA, cD\fRcA, etc), 
        then the enclosed cDboldcA and cCitaliccA regions are hilighted, hiding the 
        escape sequences. This allows the nroff text to be viewed in a more 
        representative rendered format. 

        The local buffer command cDamancA invokes, the following command sequence 
        (defined in cGhkmancA) to render a nroff cDmancA file into a buffer window;- 

            soelim <file> | tbl -TX | neqn | nroff -man | col -x 


        The command cDtex2nrcA attempts to convert a lslmlatex(9)le file into an nroff 
        file. The cClatexcA escape sequences are converted into their nroff 
        equivalents. The command is only made available when an Nroff file is 
        loaded (as the command is defined in the cGhknroff.emfcA file). 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-scA - Insert a font size escape character cD\S0cA. 
        cDC-c C-rcA - Insert a roman font escape character cD\fRcA. 
        cDC-c C-bcA - Insert a bold font escape character cD\fBcA. 
        cDC-c C-icA - Insert a italic font escape character cD\fIcA. 
        cDC-c C-ccA - Insert a courier font escape character cD\fCcA. 
        cDC-c C-pcA - Insert a previous font escape character cD\fPcA. 
        cDesc ocA, cDesc qcA - lslmfill-paragraph(2)le fills paragraph to next cG.XXcA command. 
        cDC-c bcA - Bold region by inserting cD\fBcA .. cD\fRcA. 
        cDC-c ccA - Courier region by inserting cD\fCcA .. cD\fRcA. 
        cDC-c ccA - Italic region by inserting cD\fIcA .. cD\fRcA. 
        cDC-c C-hcA - Toggle hilighting on/off. 
        cDC-c C-&cA - Adds nroff padding cD\f&cA about words. 
        cDC-x C-&cA - Removes nroff padding cD\f&cA about words. 
        cDesc hcA - Nroff help. 

        cDf2cA - (un)fold the current region 
        cDf3cA - (un)fold all regions 


cEcEBUGS cEcA


    The nroff language template is heavily biased towards the cDmancA macros only 
    and includes all of the extension macros used for generating the JASSPA 
    hypertext documentation. 

    The template in the current form has been used entirely by JASSPA in 
    generating all of the documentation (cDHTMLcA, cDWinhelpcA, cDehfcA, cDPostScriptcA) used 
    by MicroEmacs '02. It does not include all of the troff/nroff keywords, or 
    keywords for any of the standard macro packages. 

    The JASSPA documentation preparation tools are proprietary and have not 
    been made publicly available. 


cEcESEE ALSO cEcA


    lslmfill-paragraph(2)le, lslmfind-tag(2)le, lslmfold-all(3)le, lslmfold-current(3)le, lslmntags(3f)le, 
    lslmtime(2m)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 info
cEcESYNOPSIS cEcA


    info - GNU Info File. 


cEcEFILES cEcA


    cDinfo.emfcA - Info macro file. 


cEcEEXTENSIONS cEcA


    No fixed extension, the root of the cCinfocA tree is specified by 
    cG$INFOPATHcA/dir. The default search paths on different platforms are:- 

        cGc:/infocA - MS-DOS and MS-Windows (all). 
        cG/usr/local/infocA - All UNIX platforms. 


cEcEDESCRIPTION cEcA


    The GNU cCinfocA files are handled by the command lslminfo(3)le which starts the 
    info reader. This reads the initial info file cGdircA and initializes the cCinfocA 
    file traversal. Where the cCinfocA directory is not in the aforementioned 
    locations then the cG$INFOPATHcA environment variable should specify the base 
    directory. 

    The standard cCinfocA navigation keys are in effect within the cCinfocA buffers. 
    The cCmousecA may also be used to select the next info page. 


cEcEBUGS cEcA


    There is no support within MicroEmacs '02 to regenerate the cCinfocA tags and 
    indexes. 


cEcESEE ALSO cEcA


    lslminfo(3)le. 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 cbl
cEcESYNOPSIS cEcA


    cbl - Cobol (85) files 


cEcEFILES cEcA


    cDhkcobol.emfcA - Cobol (85) hook definition 
    cDcobol.etfcA - Cobol (85) template file. 


cEcEEXTENSIONS cEcA


    cD.cblcA - Cobol file 


cEcEMAGIC STRINGS cEcA


    cD-*- cobol -*-cA 
        Recognized by MicroEmacs and GNU Emacs, defines the file to be a cobol 
        file. 


cEcEDESCRIPTION cEcA


    The cDcblcA file type templates provide simple hilighting of Cobol 85 files, 
    the template provides minimal hilighting the language syntax. 


cEcENOTES cEcA


    No special language features are provided within the language syntax 
    definition. 


cEcEBUGS cEcA


    The Fortran hilight file is in it's infancy and a number of it's tokens 
    may be misplaced. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 x86
cEcESYNOPSIS cEcA


    x86 - Intel .x86 Assembler File 


cEcEFILES cEcA


    cDhkasmx86.emfcA - Intel .x86 Assembler hook definition 
    cDasmx86.etfcA - Intel .x86 Assembler template file. 


cEcEEXTENSIONS cEcA


    cD.x86cA - Intel .x86 Assembler File 


cEcEMAGIC STRINGS cEcA


    cD-!- asmx86 -!-cA 
        Recognized by MicroEmacs only, defines the file to be a Intel x86 
        assembler file. 


cEcEDESCRIPTION cEcA


    The cDx86cA file type template provides simple hilighting of Intel x86 
    assembler files. 

    cDHilightingcA 
        The hilighting features allow commands, variables, logical, comments, 
        strings and characters of the language to be differentiated and 
        rendered in different colors. 

    cDAuto LayoutcA 
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout 
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to 
        reformat (re-layout) selected sections of the buffer, or the whole 
        buffer, respectively. 

    cDShort CutscA 
        The short cut keys used within the buffer are:- 

        cDC-c C-ccA - Comment out the current line. 
        cDC-c C-dcA - Uncomment the current line. 


cEcEBUGS cEcA


    None reported. 


cEcESEE ALSO cEcA


    lslmindent(2)le, lslmrestyle-region(3)le lslmrestyle-buffer(3)le lslmasm(9)le 

    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 asm
! 9 s
cEcESYNOPSIS cEcA


    asm, s - Assembler File 


cEcEEXTENSIONS cEcA


    cD.scA - Platform specific assembler file. 
    cD.asmcA - Platform specific assembler file. 


cEcEDESCRIPTION cEcA


    The standard assembler file extensions cD.scA and cD.asmcA are by default not 
    bound to any hook functions as they are platform specific. The user should 
    define a default binding for the assembler file types as appropriate to 
    the current platform and assembler development. i.e. for the Windows 
    environment the lslmx86(9)le file type would be conditionally bound to the file 
    e.g. 
sB
        !if &seq $platform "win32" 
            add-file-hook ".s .asm"             fhook-asmx86 
        !endif 

sA

cEcESEE ALSO cEcA


    lslmx86(9)le. 
    lsfileHooks(2)lmFile Hooksle, lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle. 

! 9 vb
! 9 bas
! 9 cls
cEcESYNOPSIS cEcA


    bas, cls - Visual Basic file 


cEcEFILES cEcA


    cDhkvb.emfcA - Visual Basic macro file. 


cEcEEXTENSIONS cEcA


    cD.bascA, cD.clscA 


cEcEMAGIC STRINGS cEcA


    cD-!- msvb -!-cA 


cEcEDESCRIPTION cEcA


    The cDVisual BasiccA template performs the hilighting of Visual Basic files. 
    The file type is recognised by the standard extension, or by the inclusion 
    of the magic string. 

    cDHilightingcA 
        The hilighting features allows components of the language to be 
        differentiated and rendered in different colors. 

    cDAuto LayoutcA 
        The lsindent(2)lmindentation mechanismle is enabled which performs automatic layout 
        of the text. lslmrestyle-region(3)le and lslmrestyle-buffer(3)le are available to 
        reformat (re-layout) selected sections of the buffer, or the whole 
        buffer, respectively. The default indentation setting is 2. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 m4
cEcESYNOPSIS cEcA


    me - M4 Macro Processor 


cEcEFILES cEcA


    cDhkm4.emfcA - M4 macro processor macro file. 
    cDm4.etfcA - M4 macro processor header template file. 


cEcEEXTENSIONS cEcA


    cD.m4cA 


cEcEDESCRIPTION cEcA


    The cDM4 macro processorcA template performs simple hilighting of cD.m4cA files. 
    The file type is recognized by the standard extension only. 

    cDHilightingcA 
        The hilighting features allows components of the language to be 
        differentiated and rendered in different colors. 


cEcENOTES cEcA


    The M4 hilighting is minimal, no other features have been implemented. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 python
! 9 py
cEcESYNOPSIS cEcA


    python - Python Language File. 


cEcEFILES cEcA


    cDhkpython.emfcA - Python Language file hook definition 


cEcEEXTENSIONS cEcA


    cD.pycA - Python file 


cEcEMAGIC STRINGS cEcA


    cD^#![ \t]*/.*env[ \t]+pythoncA 
        MicroEmacs '02 recognizes the magic string on the first line of the 
        file used to locate the executable. The Python files may be 
        extension-less and are still recognized. 


cEcEDESCRIPTION cEcA


    The cDpythoncA file type template provides simple hilighting of Python files, 
    the template provides minimal hilighting. 

    File recognition is performed using the standard file extension cD.pycA, or by 
    the magic string. 


cEcEBUGS cEcA


    There would appear to be too much applied hilighting in this file, it 
    could probably do with rationalizing. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 scheme
! 9 scm
! 9 sch
cEcESYNOPSIS cEcA


    scheme - Scheme File. 


cEcEFILES cEcA


    cDhkscheme.emfcA - Scheme file hook definition 


cEcEEXTENSIONS cEcA


    cD.scmcA, cD.schcA - Scheme file 


cEcEDESCRIPTION cEcA


    The cDschemecA file type template provides simple hilighting of Scheme files, 
    the template provides minimal hilighting. 

    File recognition is performed using the standard file extensions cD.scmcA or 
    cD.schcA. 


cEcENOTES cEcA


    JASSPA have no idea as to the state of this file hook definition. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 MetaFont
! 9 mp
! 9 mf
cEcESYNOPSIS cEcA


    MetaFont/MetaPost - Meta Font and Post File. 


cEcEFILES cEcA


    cDhkmeta.emfcA - MetaFont/MetaPost file hook definition 


cEcEEXTENSIONS cEcA


    cD.mfcA - MetaFont file 
    cD.mpcA - MetaPost file 


cEcEDESCRIPTION cEcA


    The cDMetacA file type template provides simple hilighting of cDMetaFontcA (cG.mfcA) 
    and cDMetaPostcA (cG.mpcA) files, the template provides minimal hilighting. The 
    same hilighting definition is used for both file types. 

    File recognition is performed using the standard file extensions. 


cEcENOTES cEcA


    JASSPA have no idea as to the state of this file hook definition. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

! 9 texinfo
! 9 texi
cEcESYNOPSIS cEcA


    texinfo - GNU Texinfo documentation file. 


cEcEFILES cEcA


    cDhktexi.emfcA - Texinfo file hook definition 


cEcEEXTENSIONS cEcA


    cD.texicA - Texinfo file 


cEcEMAGIC STRINGS cEcA


    cD-*- texinfo -*-cA 
        Recognized by GNU Emacs and MicroEmacs. 


cEcEDESCRIPTION cEcA


    The cDtexinfocA file type template provides simple hilighting of GNU cDTexinfocA 
    files (cG.texicA), the template provides minimal hilighting. 

    File recognition is performed using the standard file extensions, or the 
    magic string. 


cEcENOTES cEcA


    This template file could benefit from some of the cGhklatex.emfcA technology 
    for generating the cCinfocA file. 


cEcESEE ALSO cEcA


    lsMicroEmacs '02 - Supported File TypeslmSupported File Typesle 

