.\" -*- nroff -*-
.\" Copyright (C) 1998-2009 JASSPA (www.jasspa.com)
.\"
.\" This is part of JASSPA's MicroEmacs, see the LICENSE file for licensing and
.\" copying information.
.\"
.Id $Id: m2cmd160.2,v 2.8 2025/09/09 09:50:30 jon Exp $
.Im MicroEmacs command|macrodevelop
.so me.tni
.TH command-wait 2
.XI command-wait - "Conditional wait command"
.SH NAME
command-wait \- Conditional wait command
.Me $a
.SH SYNOPSIS
.na
.I n
.B command-wait
.ad
.SH DESCRIPTION
When a positive argument \fIn\fR is given \fBcommand-wait\fR waits for \fIn\fR
milliseconds  before returning, this wait cannot be interrupted. If a negative
argument is given, \fBcommand-wait\fR waits for \-\fIn\fR milliseconds but the
command  will  return if the user  interrupts  with any input  activity  (i.e.
presses a key).
.PP
When no argument or an argument of 0 is given  \fBcommand-wait\fR  waits until
either the calling command's  \fB.wait\fR  command variable is undefined or it
is set to false  (\fC0\fR).  When no  argument  is given  events  such as user
input, screen  updates etc. are still  processed,  this interface is best used
when a main macro must wait and process  input until an exit criteria has been
met, the user input is best processed by setting the
.Ht $buffer-input 5
variable to a second macro. The macro
.Ht gdiff 3
uses this command in this way, also see a comprehensive example below.
.PP
When no  argument is given user input and screen  update  events are  ignored,
this is typically used when \*(mS is used in pipe mode, see option \fB-p\fR of
.Ht me 1 ,
see the example below.
.SH EXAMPLE
The  following  macro code will  display a message on the screen for a fixed 5
seconds:
.Me $emf-scheme
.CS
16 screen-poke 10 10 0 "Hello World!"
5000 command-wait
.CE
.Me $ehf-scheme
Similarly the following  macro code will display a message for up to 5 seconds
or till the user presses a key:
.Me $emf-scheme
.CS
16 screen-poke 10 10 0 "Hello World!"
-5000 command-wait
.CE
.Me $ehf-scheme
The  following  example  shows  how  command-wait  can be used to run a system
process making \*(mS wait until the process has completed  before  continuing,
yet giving feedback from the process to the user and allowing the user to kill
the launched process. The process run is a recursive  directory  listing which
will take a long time and give a lot of feed back, to kill the process  with a
prompt use delete-buffer  (bound to '\fCC-x k\fR') or use abort-command (bound
to '\fBC-g\fR') to kill immediately:
.Me $emf-scheme
.CS
0 define-macro test-ipipe-macro
    ; add extra macro code to process output here
    !if &not @#
        ; the process has finished
        set-variable .test.wait 0
    !endif
!emacro

0 define-macro test-input-macro
    !if &seq @cck "redraw"
        @# screen-update
        !return
    !elif &seq @cck "callback"
        !force execute-named-command @cc
        !return
    !elif &seq @cck "idle-pick"
        !abort
    !elif &seq @cc "delete-buffer"
        !force !force set-variable #l0 @mc1 "Abort test [y/n]? " "nNyY"
        !if &and &iseq #l0 "y" .test.wait
            !force ipipe-kill
        !endif
    !elif &seq @cc "abort-command"
        !force ipipe-kill
        set-variable .test.wait 0
    !endif
!emacro

define-macro test
    set-variable #l0 &con &band $system 0x100 "dir /s c:\\\\" "ls -R /"
    set-variable .wait 1
    !force !force !force 0x82 ipipe-shell-command #l0 "*test*" test-ipipe-macro
    set-variable #l2 $status
    !if &band #l1 1
        !force 0 delete-buffer "*cc-cmdline*"
    !endif
    find-buffer "*test*"
    set-variable $buffer-input test-input-macro
    !force !force !force command-wait
    set-variable $buffer-input ""
    ml-write "[test complete]"
!emacro
.CE
.Me $ehf-scheme
The following macro code  demonstrates how \*(mS can be used as a command-line
tool,  piping the output of another  sub-process  as it goes. In this  example
\*(mS  executes a system  directory  listing  command and prints the output to
stdout using ml-write.
.Me $emf-scheme
.CS
ml-write "Loading pipetest.emf"

define-macro pipetest-ipipe
    !if &not @#
        end-of-buffer
    !else
        goto-alpha-mark "I"
    !endif
    ml-write &spr "In pipetest-ipipe %d %d %d" @# .line $window-line
    set-variable #l0 $window-line
    set-variable $window-line .line
    !while &les $window-line #l0
        -1 ml-write @wl
        forward-line
    !done
    set-variable .line $window-line
    !if &not @#
        -2 ml-write "Process finished"
        set-variable .start-up.wait 0
    !endif
!emacro

define-macro start-up
    ml-write "Got into start-up"
    set-variable .wait 1
    set-variable .pipetest-ipipe.line 1
    set-variable #l0 &con &band $system 0x100 "dir" "ls -l"
    -2 ml-write &cat "About to execute: " #l0
    0xc0 ipipe-shell-command #l0 "*test*" pipetest-ipipe
    0 command-wait
    ml-write "start-up continues"
    exit-emacs
!emacro

ml-write "Loading pipetest.emf complete"
.CE
.Me $ehf-scheme
To run this example, save the above macro code to \fCpipetest.emf\fR  and then
run:
.IP
\fBme -n -p @pipetest.emf\fR
.PP
Use the \fB-P\fR option for additional debug lines, printed to stderr. Windows
users  must  use a  console  capable  version  of  \*(mS,  i.e.  mec32.exe  or
mecw32.exe.
.SH "NOTES"
When the given  wait time is smail the  system's  clock  frequency  can play a
large part in the accuracy, for example on Windows the documented smallest time for
.Hr SetTimer 3
is 10 milisconds  (see  \fBUSER_TIMER_MINIMUM\fR)  but in practice tends to be
more like 16ms. The  following  code can be run to test the  granularity  of a
system:
.Me $emf-scheme
.CS
set-variable #g0 $unix-time
1 command-wait
set-variable #g1 $unix-time
1 command-wait
set-variable #g2 $unix-time
1 command-wait
set-variable #g3 $unix-time
1 command-wait
set-variable #g4 $unix-time
list-variables
.CE
.Me $ehf-scheme
The values of \fC#g0\fR to \fC#g5\fR should increase by just over 0.001 (1ms), any more indicates a limitation of the
system clock. This issue can be demonstrated by the following example which attempts to create a stable 'frame-rate'
by allowing for the time taken by the code on each loop, the desired frequency can be adjusted by the changing the 
first variable:
.Me $emf-scheme
.CS
; change the following variable to change the target delay (in ms)
set-variable #l9 100
set-variable #l8 0
set-variable #l7 $unix-time
set-variable #l1 -1
set-variable #l2 0
!repeat
  set-variable #l0 $unix-time
  ; Do work here...
  ml-write &spr "Loop: %4d %s" &inc #l1 1 &mid #l0 7 6
  set-variable #l8 &add #l8 #l2
  ; This gets the current time and removes the time at the start of our loop work, this is removed from our target frame-rate
  !iif &les &set #l2 &sub #l9 &fmu 1000 &fsub $unix-time #l0 1  set-variable #l2 1
  #l2 command-wait
!until &equ #l1 100
set-variable #l6 $unix-time
set-variable #l8 &add #l8 #l2
ml-write &spr "Result: %d iterations took %.3fsec, average time %.2fms, average value for command-wait %.2f" #l1 &fsub #l6 #l7 &fmul 1000 &fdiv &fsub #l6 #l7 #l1 &fdiv #l8 #l1
.CE
.Me $ehf-scheme
When the desired frequency is large or the system clock frequency is large this code is accurate, but if the clock 
frequency is, say, 16ms then a desired frequency of 20ms will typically have a large 12ms error caused by the system 
clock (\fCcommand-wait\fR will end up waiting 2 times 16ms on each loop). If accuracy is required, use an appropriate 
OS, such as any UNIX system.
.PP
the use of
.Ht create-callback 2
intead of \fBcommand-wait\fR typically creates a better user experience as it allows the system to continue to 
functioning normally while waiting for the next loop. 
.SH "SEE ALSO"
.na
.Ht ml-write 2 ,
.Ht create-callback 2 ,
.Ht $time 5 ,
.Ht $unix-time 5 ,
.Ht $buffer-input 5 .
.ad
.FH
