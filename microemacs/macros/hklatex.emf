; -!- emf -!-
; This is part of the JASSPA MicroEmacs macro files
; Copyright (C) 1998-2005 JASSPA (www.jasspa.com)
; See the file me.emf for copying and conditions.
;
; Created:     Jan 26 1998
; Synopsis:    MicroEmacs LaTeX file hook
; Authors:     Detlef Groth, Steve Phillips & Jon Green
;
define-macro fhook-latex
    @# buffer-init "latex"
    ; Set up the default constants
    set-variable :fill-mode "l"
    set-variable :fill-col $fill-col
    buffer-init-hooks
!emacro

set-variable .fhook-latex.name "LaTeX"
set-variable .fhook-latex.setup &reg "/history/fhook/latex" "bfghinopsx"
set-variable .fhook-latex.setup-mask "abefghijkmnopstuwx"
set-variable .fhook-latex.tags "textags"
set-variable .fhook-latex.comment "|%||%|% | %||"
set-variable .fhook-latex.command-flag  "|bo|bo|bo|bo|thb|thb|thb|th|thb|th|th|thbH|bo|bo|bo|bo|bo|bo|"
set-variable .fhook-latex.command-name  "|latex-para|latex-para|latex-backward-paragraph|latex-forward-paragraph|latex-ref-goto-label|latex-ref-go-back|latex-list-label||latex-popup|latex-compile|latex-view|latex-swap-hilight|tex-insert-braces|tex-insert-quote|tex-close-latex-block|tex-goto-last-unclosed-latex-block|tex-up-list|tex-insert-underscore|"
set-variable .fhook-latex.command-nbind "|||||||||||||||||||"
set-variable .fhook-latex.command-kbind "|esc o|esc q|esc p|esc n|C-c l|C-c C-l|C-f7||C-6|||C-c C-h|C-c {|\"|C-c C-e|C-c C-u|C-c }|_|"
set-variable .fhook-latex.command-desc  "|||||\HGoto Reference Label|\HReturn to Reference|List \HLabels||\HInsert Token|Com\Hpile Buffer|\HView Buffer|T\Hoggle hilighting|Insert \HBraces|Insert \HQuote|Close Block|Goto opening block|Up list|Insert Underscore|"

; setup item-list
set-variable .fhook-latex.item-list-s1 "^[ \t]*\\\\chapter\\*?{\\([^}]*\\)}"
set-variable .fhook-latex.item-list-r1 "Chpt \ecB\\1\ecA"
set-variable .fhook-latex.item-list-s2 "^[ \t]*\\\\part\\*?{\\([^}]*\\)}"
set-variable .fhook-latex.item-list-r2 "Part \ecB\\1\ecA"
set-variable .fhook-latex.item-list-s3 "^[ \t]*\\\\section\\*?{\\([^}]*\\)}"
set-variable .fhook-latex.item-list-r3 "Sct  \ecB\\1\ecA"
set-variable .fhook-latex.item-list-s4 "^[ \t]*\\\\subsection\\*?{\\([^}]*\\)}"
set-variable .fhook-latex.item-list-r4 "SSct \ecB\\1\ecA"
set-variable .fhook-latex.item-list-s5 "^[ \t]*\\\\subsubsection\\*?{\\([^}]*\\)}"
set-variable .fhook-latex.item-list-r5 "SSSc \ecB\\1\ecA"
set-variable .fhook-latex.item-list-s6 "^[ \t]*\\\\markboth\\*?{\\([^}]*\\)}"
set-variable .fhook-latex.item-list-r6 "Mark \ecB\\1\ecA"

set-variable .fhook-latex.paragraph-srch "\\(^$\\|^[ \t]*%\\|^[ \t]*$\\|^[ \t]*\\\\\\(newpag\\|section\\|chap\\|subsec\\|subsubsec\\|label\\|begin\\|paragraph\\|subparagraph\\|end\\)\\)"

!if &sin "f" .fhook-latex.setup
    ; Set up collapse for LaTeX
    set-variable .fhook-latex.collapse-open  "\\\\chapter\\|\\\\section\\|\\\\subsection"
    set-variable .fhook-latex.collapse-close "\\\\chapter\\|\\\\section\\|\\\\subsection\\|\\\\markboth\\|\\\\end{document}"
    set-variable .fhook-latex.collapse-mnext "-1"
!endif

!if &seq $platform "win32"
    ; Win32, lets assume that everybody is using MikTex, and why not !!
    set-variable %latex-view    &cond &seq %latex-view    "ERROR" "yap"  %latex-view
    set-variable %latex-compile &cond &seq %latex-compile "ERROR" "latex --c-style-errors --halt-on-error " %latex-compile
    ; Add hooks for the latex compiler errors
    0 add-next-line "*latex-compile*"
    add-next-line "*latex-compile*" "%f:%l:"
!else
    set-variable %latex-compile &cond &seq %latex-compile "ERROR" "latex -interaction=nonstopmode" %latex-compile
    set-variable %latex-view    &cond &seq %latex-view    "ERROR" "xdvi"  %latex-view
!endif

!if &and &sin "h" .fhook-latex.setup &band .hilight.flags 0x02
    !if &not &exist .hilight.latex
        set-variable .hilight.latex &pinc .hilight.next 1
        set-variable .hilight.latexs &pinc .hilight.next 1
        set-variable .hilight.latexb &pinc .hilight.next 1
        set-variable .hilight.latext &pinc .hilight.next 1
        set-variable .hilight.latexh &pinc .hilight.next 1
        set-variable .hilight.latexi &pinc .hilight.next 1
        set-variable .hilight.latexm &pinc .hilight.next 1
        set-variable .hilight.latexn &pinc .hilight.next 1
        set-variable .hilight.latexbi &pinc .hilight.next 1
        set-variable .hilight.latexbt &pinc .hilight.next 1
        set-variable .hilight.latexib &pinc .hilight.next 1
        set-variable .hilight.latexit &pinc .hilight.next 1
        set-variable .hilight.latextb &pinc .hilight.next 1
        set-variable .hilight.latexti &pinc .hilight.next 1
        set-variable .hilight.latexv &pinc .hilight.next 1
    !endif
    ; hilight-latex-common <hilightScheme> <schemeIdentifier>
    ;
    ; Take all of the common objects that are used in the various hilighting
    ; schemes and apply them to the current hilighting format.
    ;
    0 define-macro hilight-latex-common
        ; Get the arguments into the local registers for speed.
        set-variable #l1 @1
        set-variable #l2 @2
        ; Comments
        hilight #l1 2 "^%"                .scheme.comment
        ;symbols
        hilight #l1 64 "\\$\\\\bullet\\$" "·" #l2
        hilight #l1 64 "\\\\>" "    ‘" #l2
        hilight #l1 64 "\\\\\\\\" "\f" #l2
        hilight #l1 64 "\\$\\\\vert\\$" "|" #l2
        hilight #l1 64 "\\$\\\\beta\\$" "ß*" #l2
        hilight #l1 64 "\\$\\\\alpha\\$" "a*" #l2
        hilight #l1 64 "\\$\\\\mu\\$" "µ" #l2
        hilight #l1 64 "\\$\\\\ldots\\$" "..." #l2
        hilight #l1 64 "\\$\\\\geqq\\$" "|>=|" #l2
        hilight #l1 64 "\\$\\\\leqq\\$" "|<=|" #l2
        hilight #l1 64 "\\$\\^{\\\\rm TM}\\$" "™" #l2
        hilight #l1 64 "\\$\\^{\\\\copyright}\\$" "©" #l2
        hilight #l1 64 "\\$\\^{\\\\circledR}\\$" "®" #l2
        hilight #l1 64 "\\$\\^{\\\\circ}\\$" "°" #l2
        hilight #l1 64 "\\\\_" "_" #l2
        hilight #l1 64 "\\\\-" "" #l2
        hilight #l1 64 "\\\\ " " " #l2
        hilight #l1 64 "\\\\textbackslash" "\\" #l2
        hilight #l1 64 "\\\\textbar" "|" #l2
        hilight #l1 64 "\\\\textless" "<" #l2
        hilight #l1 64 "\\\\textgreater" ">" #l2
        hilight #l1 64 "\\\\textasciicircum" "^" #l2
        hilight #l1 64 "\\\\textasciitilde" "~" #l2

        ; Umlauts only examples, use gsar.exe for umlauts
        ; tranlations during compiling
        hilight #l1 64 "\"a" "ä" #l2
        hilight #l1 64 "\"o" "ö" #l2
        hilight #l1 64 "\\\\`a" "à" #l2
        hilight #l1 64 "\\\\`e" "è" #l2
        hilight #l1 64 "\\\\'e" "é" #l2
        ; Double quotes
        hilight #l1 64 "``" "`" #l2
        hilight #l1 64 "''" "'" #l2
        ; Quotes
        hilight #l1 64 "\\\\glqq " "„" #l2
        hilight #l1 64 "\\\\grqq" "\"" #l2
        ; specials
        hilight #l1 64 "\\\\BibTeX\\}\\W" "BibTeX" .scheme.bold
        hilight #l1 64 "\\\\LaTeX\\}\\W"  "LaTeX" .scheme.bold
        hilight #l1 64 "\\\\teTeX\\}\\W"  "teTeX" .scheme.bold
        hilight #l1 64 "\\\\LaTeXe\\}\\W" "LaTeXe" .scheme.bold
        hilight #l1 64 "\\\\Linux\\}\\W"  "Linux" .scheme.bold
        hilight #l1 64 "\\\\TeX\\}\\W"    "TeX" .scheme.bold
        hilight #l1 64 "\\\\MF\\}\\W"     "MF" .scheme.bold
        hilight #l1 64 "\\\\AmSLaTeX\\}\\W" "AmSLaTeX" .scheme.bold
        hilight #l1 64 "\\\\dvipdfm\\\\" "dvipdfm" .scheme.bold
        ; character quoting
        hilight #l1 64 "\\$\\(.\\)\\$" "\\1" #l2
        hilight #l1 64 "\\\\\\$" "$" #l2
        hilight #l1 64 "\\\\{" "{" #l2
        hilight #l1 64 "\\\\}" "}" #l2
        hilight #l1 64 "\\\\%" "%" #l2
        hilight #l1 64 "\\\\#" "#" #l2
        hilight #l1 64 "\\\\&" "&" #l2
        hilight #l1 64 "\\\\char`\\\\\\(.\\)" "\\1" #l2
        hilight #l1 64 "~" " "                                     #l2
        ;references
        hilight #l1 64 "\\\\index{[^}]*}" "" #l2
        hilight #l1 64 "\\\\label{[^}]*}" "" #l2
        hilight #l1 64 "\\\\plabel{[^}]*}" "" #l2
        hilight #l1 64 "\\\\pdfbookmark\\[[^]]*]{[^}]*}{[^}]*}" "" #l2
        hilight #l1 68 "\\\\cite\\[" "[Cite: " "]{[^}]*}" "]" #l2
        hilight #l1 68 "\\\\citet\\[" "[Citet: " "]{[^}]*}" "]" #l2
        hilight #l1 68 "\\\\cite{" "[Cite: " "}" "]" #l2
        hilight #l1 68 "\\\\citet{" "[Citet: " "}" "]" #l2
        hilight #l1 68 "\\\\ref{" "" "}" "" "" .scheme.link
        hilight #l1 68 "\\\\pref{" "" "}" "" "" .scheme.link
        hilight #l1 68 "\\\\includegraphics{" "[Image: " "}" "]" "" .scheme.keyword
        hilight #l1 68 "\\\\caption{" "Caption: " "}" "" "" #l2
        hilight #l1 68 "\\\\pageref{" "|" "}" "|‘" "" .scheme.link
        hilight #l1 68 "\\\\link{" "" "}{[^}]*}" "" "" .scheme.link
        hilight #l1 68 "\\\\footnote{" "[Footnote: " "}" "]" "" .scheme.keyword
        hilight #l1 68 "\\\\dest{" "" "}" "" "" .scheme.link
        hilight #l1 68 "\\\\emph{" "" "}" "" "" .scheme.bold
        ; Other Text modifiers
        hilight #l1 68 "\\\\textrm{" "" "}" "" "" #l2
        hilight #l1 68 "\\\\textsf{" "" "}" "" "" #l2
        ; For literal text surround in verticals - some people
        ; use this. Uncomment to enable.
        ; hilight #l1 68 "|" "" "|" "" "" .scheme.string
        hilight #l1 64 "\\\\\\\\$" "" #l2
    !emacro

    0 hilight .hilight.latex 0                                     $global-scheme
    ; take out the \% token first so we can hilight comments correctly
    hilight .hilight.latex 0 "\\\\%"                               .scheme.prepro
    hilight .hilight.latex 0 "\\\\_"                               .scheme.prepro
    hilight .hilight.latex 2 "%"                                   .scheme.comment
    hilight .hilight.latex 0 "\\\\\\\\"                            .scheme.keyword
    hilight .hilight.latex 4 "\\\\" "\\}\\W" ""                    .scheme.keyword
    hilight .hilight.latex 0 "\\\\section\\*?{[^}]*}"              .scheme.header
    hilight .hilight.latex 0 "\\\\subsection\\*?{[^}]*}"           .scheme.header
    hilight .hilight.latex 0 "\\\\ref{[^}]*}"                      .scheme.link
    hilight .hilight.latex 0 "\\\\link{[^}]*}{[^}]*}"              .scheme.link
    hilight .hilight.latex 0 "\\\\dest{[^}]*}"                     .scheme.link
    ; Font control
    hilight .hilight.latex 0 "\\\\tt\\W"                           .scheme.operator
    hilight .hilight.latex 0 "\\\\it\\W"                           .scheme.operator
    hilight .hilight.latex 0 "\\\\bf\\W"                           .scheme.operator
    hilight .hilight.latex 0 "\\\\textbf"                          .scheme.operator
    hilight .hilight.latex 0 "\\\\textit"                          .scheme.operator
    hilight .hilight.latex 0 "\\\\texttt"                          .scheme.operator
    hilight .hilight.latex 0 "\\\\textcolor"                       .scheme.operator
    hilight .hilight.latex 0 "\\\\textnormal"                      .scheme.operator

    ;; simulation hilighting
    set-variable #l2 &rig $box-chars 10
    0 hilight .hilight.latexs 0                                           $global-scheme
    ; Common hilighting components
    hilight-latex-common                                 .hilight.latexs  $global-scheme
    ;comments
    hilight .hilight.latexs 2 "[^\\\\]\\{%"                               .scheme.comment
    hilight .hilight.latexs 4 "\\\\" "\\}\\W" ""                          .scheme.keyword
    ;headers
    hilight .hilight.latexs 68 "\\\\chapter\\*?{" "*" "}" "" ""           .scheme.header
    hilight .hilight.latexs 68 "\\\\part\\*?{" "Part: " "}" "" ""          .scheme.header
    hilight .hilight.latexs 68 "\\\\section\\*?{" "**" "}" "" ""          .scheme.header
    hilight .hilight.latexs 68 "\\\\subsection\\*?{" "***" "}" "" ""      .scheme.header
    hilight .hilight.latexs 68 "\\\\subsubsection\\*?{" "****" "}" "" ""  .scheme.header
    hilight .hilight.latexs 68 "\\\\paragraph\\*?{" "*****" "}" "" ""     .scheme.header
    hilight .hilight.latexs 68 "\\\\subparagraph\\*?{" "******" "}" "" "" .scheme.header
    hilight .hilight.latexs 68 "\\\\markboth{" "" "}{[^}]*}" "" ""        .scheme.header
    hilight .hilight.latexs 68 "\\\\bibliography{" "<<Bibliography: " "}" ">>" "" .scheme.keyword
    hilight .hilight.latexs 64 "\\\\tableofcontents" "<<Table of Contents>>" .scheme.keyword
    ;
    ; hide some unimportant tokens completely
    hilight .hilight.latexs 64 "\\\\bibliographystyle{[^}]*}" ""          $global-scheme
    hilight .hilight.latexs 64 "\\\\pagenumbering{[^}]*}" ""              $global-scheme
    hilight .hilight.latexs 64 "\\\\newline" ""                           $global-scheme
    ;Lines
    hilight .hilight.latexs 64 "\\\\newpage" &spr "%n<<Page Break>>%n" 32 #l2 32 #l2 .scheme.italic
    hilight .hilight.latexs 64 "\\\\hline" &spr "%n" 78 #l2               $global-scheme
    hilight .hilight.latexs 64 "\\\\toprule" &spr "%n" 64 #l2             $global-scheme
    hilight .hilight.latexs 64 "\\\\bottomrule" &spr "%n" 64 #l2          $global-scheme
    ; Begin and End
    hilight .hilight.latexs 68 "\\\\begin{" "|" "}" ">>" ""               .scheme.keyword
    hilight .hilight.latexs 68 "\\\\end{" "<<" "}" "|" ""                 .scheme.keyword
    hilight .hilight.latexs 68 "\\\\verb\\+" "" "\\+" "" ""               $global-scheme
    ;
    hilight .hilight.latexs 0xc0 "\\\\begin{verbatim}" "|verbatim>>" .hilight.latexv .scheme.keyword
    hilight .hilight.latexs 64 "\\\\begin{figure}\\[[^]]*]" "|figure>>"              .scheme.keyword
    hilight .hilight.latexs 64 "\\\\begin{table}\\[[^]]*]" "|table>>"                .scheme.keyword
    hilight .hilight.latexs 64 "\\\\begin{tabular}{[^}]*}" "|tabular>>"              .scheme.keyword
    hilight .hilight.latexs 68 "\\\\begin{biography}{" "|biography: " "}" ">>" ""    .scheme.keyword
    ; Division help
    hilight .hilight.latexs 64 "\\\\-" ""                 .scheme.italic
    hilight .hilight.latexs 64 "\\\\item" "   *"          .scheme.italic
    hilight .hilight.latexs 64 "\\\\itemitem" "       *"  .scheme.italic
    hilight .hilight.latexs 68 "\\\\item\\[" "" "]" "" "" .scheme.bold
    hilight .hilight.latexs 64 "\\\\ind" "    "           $global-scheme
    ; Environment
    hilight .hilight.latexs 64 "&" "|"                     $global-scheme
    hilight .hilight.latexs 64 "\\\\linewidth" "ˆlw|"   .scheme.italic
    hilight .hilight.latexs 64 "\\\\pdfimage width" "PNG*" .scheme.italic
    ; textformat
    hilight .hilight.latexs 0xc0 "\\\\textbf{" ""     .hilight.latexb .scheme.bold
    hilight .hilight.latexs 0xc0 "\\\\textit{" ""     .hilight.latexi .scheme.italic
    hilight .hilight.latexs 0xc0 "\\\\texttt{" ""     .hilight.latext .scheme.string
    hilight .hilight.latexs 0xc0 "\\\\textnormal{" "" .hilight.latexn $global-scheme
    hilight .hilight.latexs 0xc0 "{\\\\ttfamily" ""   .hilight.latext .scheme.string
    hilight .hilight.latexs 0xc0 "{\\\\bf *" ""       .hilight.latexb .scheme.bold
    hilight .hilight.latexs 0xc0 "{\\\\it *" ""       .hilight.latexi .scheme.italic
    hilight .hilight.latexs 0xc0 "{\\\\tt *" ""       .hilight.latext .scheme.string
    ;hilight .hilight.latexs 0xc0 "\\$" ""            .hilight.latexm .scheme.string
    ;
    ; hilight scheme for normal
    ;
    0 hilight  .hilight.latexn 2 50                                     $global-scheme
    hilight-latex-common                              .hilight.latexn   $global-scheme
    hilight .hilight.latexn 0xc0 "}" ""               .hilight.latexs   $global-scheme
    hilight .hilight.latexn 0xc0 "{\\\\bf *" ""       .hilight.latexb  .scheme.bold
    hilight .hilight.latexn 0xc0 "{\\\\it *" ""       .hilight.latexi  .scheme.italic
    hilight .hilight.latexn 0xc0 "{\\\\tt *" ""       .hilight.latext  .scheme.string
    hilight .hilight.latexn 0xc0 "\\\\textbf{" ""     .hilight.latexb  .scheme.bold
    hilight .hilight.latexn 0xc0 "\\\\textit{" ""     .hilight.latexbi .scheme.italic
    hilight .hilight.latexn 0xc0 "\\\\texttt{" ""     .hilight.latexbt .scheme.string
    hilight .hilight.latexn 0xc0 "\\\\textnormal{" "" .hilight.latexn  .scheme.error
    ;
    ; hilight scheme for bold
    ;
    0 hilight  .hilight.latexb 2 50                                    .scheme.bold
    hilight-latex-common                              .hilight.latexb  .scheme.bold
    hilight .hilight.latexb 0xc0 "}" ""               .hilight.latexs  .scheme.bold
    hilight .hilight.latexb 0xc0 "{\\\\bf *" ""       .hilight.latexb  .scheme.error
    hilight .hilight.latexb 0xc0 "{\\\\it *" ""       .hilight.latexbi .scheme.italic
    hilight .hilight.latexb 0xc0 "{\\\\tt *" ""       .hilight.latexbt .scheme.string
    hilight .hilight.latexb 0xc0 "\\\\textbf{" ""     .hilight.latexb  .scheme.error
    hilight .hilight.latexb 0xc0 "\\\\textit{" ""     .hilight.latexbi .scheme.italic
    hilight .hilight.latexb 0xc0 "\\\\texttt{" ""     .hilight.latexbt .scheme.string
    hilight .hilight.latexb 0xc0 "\\\\textnormal{" "" .hilight.latexn  $global-scheme
    ;
    ; hilight scheme for italic
    ;
    0 hilight  .hilight.latexi 2 50                                    .scheme.italic
    hilight-latex-common                              .hilight.latexi  .scheme.italic
    hilight .hilight.latexi 0xc0 "}" ""               .hilight.latexs  .scheme.italic
    hilight .hilight.latexi 0xc0 "{\\\\bf *" ""       .hilight.latexib .scheme.bold
    hilight .hilight.latexi 0xc0 "{\\\\it *" ""       .hilight.latexi  .scheme.error
    hilight .hilight.latexi 0xc0 "{\\\\tt *" ""       .hilight.latexit .scheme.string
    hilight .hilight.latexi 0xc0 "{\\\\tt *" ""       .hilight.latexit .scheme.string
    hilight .hilight.latexi 0xc0 "\\\\textbf{" ""     .hilight.latexib .scheme.bold
    hilight .hilight.latexi 0xc0 "\\\\textit{" ""     .hilight.latexi  .scheme.error
    hilight .hilight.latexi 0xc0 "\\\\texttt{" ""     .hilight.latexit .scheme.string
    hilight .hilight.latexi 0xc0 "\\\\textnormal{" "" .hilight.latexn  $global-scheme
    ;
    ; hilight scheme for fixed-font
    ;
    0 hilight  .hilight.latext 2 50                                    .scheme.string
    hilight-latex-common                              .hilight.latext  .scheme.string
    hilight .hilight.latext 0xc0 "}" ""               .hilight.latexs  .scheme.string
    hilight .hilight.latext 0xc0 "{\\\\bf *" ""       .hilight.latextb .scheme.bold
    hilight .hilight.latext 0xc0 "{\\\\it *" ""       .hilight.latexti .scheme.italic
    hilight .hilight.latext 0xc0 "{\\\\tt *" ""       .hilight.latext  .scheme.error
    hilight .hilight.latext 0xc0 "\\\\textbf{" ""     .hilight.latextb .scheme.bold
    hilight .hilight.latext 0xc0 "\\\\textit{" ""     .hilight.latexti .scheme.italic
    hilight .hilight.latext 0xc0 "\\\\texttt{" ""     .hilight.latext  .scheme.error
    hilight .hilight.latext 0xc0 "\\\\textnormal{" "" .hilight.latexn  $global-scheme
    ;
    ; hilight scheme for italic bold
    ;
    0 hilight  .hilight.latexib 2 50                      .scheme.bold
    hilight-latex-common                 .hilight.latexib .scheme.bold
    hilight .hilight.latexib 0xc0 "}" "" .hilight.latexi  .scheme.italic
    ;
    ; hilight scheme for italic fixed-font
    ;
    0 hilight  .hilight.latexit 2 50                      .scheme.bold
    hilight-latex-common                 .hilight.latexit .scheme.bold
    hilight .hilight.latexit 0xc0 "}" "" .hilight.latexi  .scheme.italic
    ;
    ; hilight scheme for bold italic
    ;
    0 hilight  .hilight.latexbi 2 50                      .scheme.italic
    hilight-latex-common                 .hilight.latexit .scheme.italic
    hilight .hilight.latexbi 0xc0 "}" "" .hilight.latexb  .scheme.bold
    ;
    ; hilight scheme for bold fixed-font
    ;
    0 hilight  .hilight.latexbt 2 50                      .scheme.string
    hilight-latex-common                 .hilight.latexbt .scheme.string
    hilight .hilight.latexbt 0xc0 "}" "" .hilight.latexb  .scheme.bold
    ;
    ; hilight scheme for fixed-font bold
    ;
    0 hilight  .hilight.latextb 2 50                      .scheme.bold
    hilight-latex-common                 .hilight.latextb .scheme.bold
    hilight .hilight.latextb 0xc0 "}" "" .hilight.latext  .scheme.string
    ;
    ; hilight scheme for fixed-font italic
    ;
    0 hilight  .hilight.latexti 2 50                      .scheme.italic
    hilight-latex-common                 .hilight.latexti .scheme.italic
    hilight .hilight.latexti 0xc0 "}" "" .hilight.latext  .scheme.string
    ;
    ; hilight scheme for maths
    ;
    0 hilight  .hilight.latexm 2 50                        .scheme.string
    hilight-latex-common                  .hilight.latexm  .scheme.string
    hilight .hilight.latexm 0xc0 "\\$" "" .hilight.latexs  .scheme.string
    ;
    ; hilight scheme for verbatim text
    ;
    0 hilight  .hilight.latexv 2 50                                $global-scheme
    hilight .hilight.latexv 0xc0 "\\\\end{verbatim}" "<<verbatim|" .hilight.latexs .scheme.keyword

    0 define-macro latex-swap-hilight
        !if &equal $buffer-hilight .hilight.latex
            set-variable $buffer-hilight .hilight.latexs
            1 buffer-mode "view"
        !else
            set-variable $buffer-hilight .hilight.latex
            -1 buffer-mode "view"
        !endif
    !emacro
    ; redefine to free memory
    0 define-macro hilight-latex-common
    !emacro
!endif
;
; TeX language specific macros.
;
; latex-forward-paragraph; Advance to the start of the next paragraph This is
; a little bit different from the latex-para as we ignore comments.
0 define-macro latex-forward-paragraph
    ; Iterate for the number of times requested.
    !while &gre &pdec @# 1 0
        forward-line
        ; Find the end of the paragraph
        !force search-buffer "em" .fhook-latex.paragraph-srch
        !if &not $status
            end-of-buffer
            !return
        !endif
        beginning-of-line
    !done
!emacro
; latex-backward-paragraph; Advance to the start of the previous paragraph
; This is a little bit different from the latex-para as we ignore comments.
0 define-macro latex-backward-paragraph
    ; Iterate for the number of times requested.
    !while &gre &pdec @# 1 0
        backward-line
        ; Find the start of the paragraph
        !force search-buffer "bem" .fhook-latex.paragraph-srch
        !if &not $status
            beginning-of-buffer
            !return
        !endif
        beginning-of-line
    !done
!emacro
; latex-para; Format the paragraph. We do this by inserting blank lines
; around our selected paragraph and then performing a fill operation on it.
; The blank lines are then removed leaving the formated paragraph.
;
; Note: If no arguments are supplied then the current position is retained in
; the paragraph. This position is saved as 'mark'.
0 define-macro latex-para
    ; Save mark at point.
    !if &not @?
        set-mark
    !endif
    beginning-of-line
    !while &gre &pdec @# 1 0
        ; Skip blank lines, we do this here incase we are within multiple
        ; blank lines which causes things to go wrong.
        beginning-of-line
        !force search-buffer "m" "\\S"
        end-of-line
        ; Find the end of the paragraph
        !force search-buffer "em" .fhook-latex.paragraph-srch
        !if &not $status
            !abort
            end-of-buffer
            ; Force an ending !!
            set-variable @# 1
        !endif
        beginning-of-line
        insert-newline
        ; Jump back line.
        backward-line
        ; Find the start of the paragraph
        !force search-buffer "bem" .fhook-latex.paragraph-srch
        !if $status
            end-of-line
        !else
            beginning-of-buffer
        !endif
        insert-newline
        fill-paragraph
        search-buffer "bem" "^$"
        forward-delete-char
        search-buffer "em" "^$"
        beginning-of-line
        forward-delete-char
    !done
    ; If no argument specified then restore the cursor position
    !if &not @?
        exchange-point-and-mark
    !endif
!emacro

define-macro latex-compile
    !if &bmod "edit"
        !if &iseq @mc1 "Save buffer first (y/n) :" "nNyY" "y"
            save-buffer
        !endif
    !endif
    set-variable #l0 @ml20 "latex-compile" &spr "%s %s" %latex-compile &rig $buffer-fname &rsin "/" $buffer-fname
    0 ipipe-shell-command #l0 "*latex-compile*"
!emacro

define-macro latex-view
    set-variable #l0 &rig $buffer-fname &rsin "/" $buffer-fname
    set-variable #l0 &lef #l0 &sub &rsin "." #l0 1
    set-variable #l0 @ml20 "latex-view" &spr "%s %s" %latex-view #l0
    0 ipipe-shell-command #l0 "*latex-view*"
!emacro

define-macro latex-list-label
    set-variable #l0 .fhook-latex.item-list-s1
    set-variable #l1 .fhook-latex.item-list-r1
    set-variable #l2 .fhook-latex.item-list-s2
    set-variable .fhook-latex.item-list-s1 "\\\\label\\*?{\\([^}]*\\)}"
    set-variable .fhook-latex.item-list-r1 "Lbl  \ecB\\1\ecA"
    unset-variable .fhook-latex.item-list-s2
    !force !force item-list
    set-variable .fhook-latex.item-list-s1 #l0
    set-variable .fhook-latex.item-list-r1 #l1
    set-variable .fhook-latex.item-list-s2 #l2
!emacro

0 define-macro latex-goto-buffer
    popup-window &mid $buffer-bname 1 &sub &len $buffer-bname 13
!emacro

define-macro latex-goto-section
    set-variable #l0 &mid $buffer-bname 1 &sub &len $buffer-bname 13
    set-variable #l2 @wl
    set-variable #l1 &lef #l2 4
    !if &seq #l1 "Chap"
        set-variable #l1 "chapter"
        set-variable #l2 &rig #l2 12
    !elif &seq #l1 "Sect"
        set-variable #l1 "section"
        set-variable #l2 &rig #l2 13
    !elif &seq #l1 "SSec"
        set-variable #l1 "subsection"
        set-variable #l2 &rig #l2 14
    !elif &seq #l1 "SSSe"
        set-variable #l1 "\\(sub\\)+subsection"
        set-variable #l2 &rig #l2 15
    !elif &seq #l1 "Labe"
        set-variable #l1 "label"
        set-variable #l2 &rig #l2 12
    !else
        ml-write "[Invalid line!]"
        !abort
    !endif
    str-to-regex #l2
    popup-window #l0
    beginning-of-buffer
    !force search-buffer "em" &spr "\\\\%s\\*?{\\(\\\\centerline{\\)?%s}" #l1 #l2
    !if &not $status
        ml-write &spr "[Failed to find section \"%s\"]" #l2
        !abort
    !endif
    beginning-of-line
!emacro

0 define-macro latex-ref-goto-label
    set-alpha-mark "R"
    ; end of link must be found within 2 lines
    end-of-line
    !force -2 search-buffer "bem" "\\\\ref\\({[^\n}]*}\\)"
    !if &not $status
        goto-alpha-mark "R"
        ml-write "[Failed to find \\ref{...}]"
        !abort
    !endif
    set-alpha-mark "R"
    set-variable #l0 @s1
    beginning-of-buffer
    !force search-buffer "em" &cat "\\\\label" #l0
    !if &not $status
        goto-alpha-mark "R"
        ml-write &spr "[Failed to find \\label%s]" #l0
        !abort
    !endif
    beginning-of-line
!emacro

define-macro latex-ref-go-back
    goto-alpha-mark "R"
!emacro

; latex-spell-word; modify the spelling rules so that the speller does
; not complain about TeX commands.
0 define-macro latex-spell-word
    ; simply skip any word starting with a \
    -2 show-region
    !force backward-char
    !if &seq @wc "\\"
        2 show-region
        set-variable .spell.check-word ""
        !return
    !elif &seq @wc "-"
        !if &xse &mid @wl &sub $window-col 2 3 "\\w\\\\-"
            forward-char
            !while &xse &lef @wl $window-col ".*\\w+\\(\\\\-\\|[-.']\\)"
                backward-char
                backward-word
            !done
            search-buffer "em" "\\w+\\(\\(\\\\-\\|[-.']\\)\\w+\\)+"
            set-variable .spell.check-word &rep @s0 "\\-" ""
            !return
        !endif
    !endif
    2 show-region
    !if &seq @wc "\\"
        !force forward-char
        !if &seq @wc "-"
            !force forward-char
            !if &inw @wc
                -2 show-region
                search-buffer "em" "\\(\\w*\\)\\\\-\\(\\w*\\)"
                set-variable .spell.check-word &cat @s1 @s2
                !return
            !endif
        !endif
    !endif
    2 show-region
    !abort
!emacro

;; latex popup ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ------------- greek  letters --------------------------------;
0 define-macro latex-popup-greek
    insert-string &lget "|$\\alpha$|$\\beta$|$\\gamma$|$\\delta$|$\\epsilon$|$\\mu$|$\\zeta$" @#
!emacro
;------------------------ headers ------------------------------------;
0 define-macro latex-popup-header
    execute-string &lget "|\\chapter{\p}\P|\\section{\p}\P|\\subsection{\p}\P|\\subsubsection{\p}\P|\\paragraph{\p}\P|\\subparagraph{\p}\P|" @#
!emacro
;------------------------ symbols ------------------------------------;
0 define-macro latex-popup-symbol
    insert-string &lget "|$\^{\\rm TM}$|$^{\\copyright$}|$^{\\circledR}$|\\glqq|\\grqq|" @#
!emacro
;------------------------ cross-reference ------------------------------------;
0 define-macro latex-popup-reference
    execute-string &lget "|\\ref{\p}\P|\\pageref{\p}\P|\\label{\p}\P|\\cite{\p}\P|" @#
!emacro
 ;------------------------ format  ------------------------------------;
0 define-macro latex-popup-format
    execute-string &lget "|\\textbf{\p}\P|\\textit{\p}\P|\\Large{\p}\P|\\large{\p}\P|\\small{\p}\P|\\footnotesize{\p}\P|\\scriptsize{\p}\P|" @#
!emacro
 ;------------------------ environment  ------------------------------------;
0 define-macro latex-popup-environment
    execute-string &lget "|\\begin{enumerate}\N \\item \p\N\f\\item \N\\end{enumerate}\P|\\begin{itemize}\N \\item \p\N\f\\item \N\\end{itemize}\P|" @#
!emacro
;---------------------- higher and lower numbers --------------------------;
0 define-macro latex-make-format
    kill-region
    execute-string &lget "|$^|$_|\\textit{|\\textbf{|" @#
    yank
    -1 yank
    execute-string &lget "|$|$|}|}|" @#
!emacro

;------------ latex-popup ------------------------------------------------
!if &not &exist .osd.latex-popup
    ; set up the osd tool menu & help dialog
    set-variable .osd.latex-popup &pinc .osd.next 1
    set-variable .osd.latex-popgk &pinc .osd.next 1
    set-variable .osd.latex-pophd &pinc .osd.next 1
    set-variable .osd.latex-popsb &pinc .osd.next 1
    set-variable .osd.latex-poprf &pinc .osd.next 1
    set-variable .osd.latex-popft &pinc .osd.next 1
    set-variable .osd.latex-popev &pinc .osd.next 1
!endif

osd .osd.latex-popgk 0   "b"
osd .osd.latex-popgk 1   "" "\Halpha"           1 latex-popup-greek
osd .osd.latex-popgk 2   "" "\Hbeta"            2 latex-popup-greek
osd .osd.latex-popgk 3   "" "\Hgamma"           3 latex-popup-greek
osd .osd.latex-popgk 4   "" "\Hdelta"           4 latex-popup-greek
osd .osd.latex-popgk 5   "" "\Hepsilon"         5 latex-popup-greek
osd .osd.latex-popgk 6   "" "\Hmy"              6 latex-popup-greek

osd .osd.latex-pophd 0   "b"
osd .osd.latex-pophd 1   "" "\H1 chapter"       1 latex-popup-header
osd .osd.latex-pophd 2   "" "\H2 section"       2 latex-popup-header
osd .osd.latex-pophd 3   "" "\H3 subsection"    3 latex-popup-header
osd .osd.latex-pophd 4   "" "\H4 subsubsection" 4 latex-popup-header
osd .osd.latex-pophd 5   "" "\H5 paragraph"     5 latex-popup-header
osd .osd.latex-pophd 6   "" "\H6 subparagraph"  6 latex-popup-header

osd .osd.latex-popsb 0   "b"
osd .osd.latex-popsb 1   "" "\H1 TM"            1 latex-popup-symbol
osd .osd.latex-popsb 2   "" "\H2 ©"             2 latex-popup-symbol
osd .osd.latex-popsb 3   "" "\H3 ®"             3 latex-popup-symbol
osd .osd.latex-popsb 4   "-"
osd .osd.latex-popsb 5   "" "\H4 quotes „"      4 latex-popup-symbol
osd .osd.latex-popsb 6   "" "\H5 quotes \""     5 latex-popup-symbol

osd .osd.latex-poprf 0   "b"
osd .osd.latex-poprf 1   "" "\Href"             1 latex-popup-reference
osd .osd.latex-poprf 2   "" "\Hpageref"         2 latex-popup-reference
osd .osd.latex-poprf 3   "" "\Hlabel"           3 latex-popup-reference
osd .osd.latex-poprf 4   "" "\Hcite"            4 latex-popup-reference

osd .osd.latex-popft 0   "b"
osd .osd.latex-popft 1   ""  "\Htextbf"         1 latex-popup-format
osd .osd.latex-popft 2   ""  "text\Hit"         2 latex-popup-format
osd .osd.latex-popft 3   "-"
osd .osd.latex-popft 4   ""  "\HLarge"          3 latex-popup-format
osd .osd.latex-popft 5   ""  "l\Harge"          4 latex-popup-format
osd .osd.latex-popft 6   ""  "\Hsmall"          5 latex-popup-format
osd .osd.latex-popft 7   ""  "\Hfootnotesize"   6 latex-popup-format
osd .osd.latex-popft 8   ""  "s\Hcriptsize"     7 latex-popup-format
osd .osd.latex-popft 9   "-"
osd .osd.latex-popft 10  ""  "\Hhigh number"    1 latex-make-format
osd .osd.latex-popft 20  ""  "lo\Hw number"     2 latex-make-format
osd .osd.latex-popft 29  "-"
osd .osd.latex-popft 30  ""  "\Hmake italic"    3 latex-make-format
osd .osd.latex-popft 40  ""  "make \Hbold"      4 latex-make-format

osd .osd.latex-popev 0   "b"
osd .osd.latex-popev 1   ""  "\Henumerate"      1 latex-popup-environment
osd .osd.latex-popev 2   ""  "\Hitemize"        2 latex-popup-environment

osd .osd.latex-popup 0   "b"
osd .osd.latex-popup 1   "M" "\HHeader"        .osd.latex-pophd
osd .osd.latex-popup 2   "M" "\HReferences"    .osd.latex-poprf
osd .osd.latex-popup 3   "M" "\HFormat"        .osd.latex-popft
osd .osd.latex-popup 4   "M" "\HEnvironment"   .osd.latex-popev
osd .osd.latex-popup 5   "M" "\HGreek"         .osd.latex-popgk
osd .osd.latex-popup 6   "M" "\HSymbols"       .osd.latex-popsb

define-macro latex-popup
    !if @#
        ; redefine the position to be next to the cursor if this has
        ; been invoked with an argument.
        osd .osd.latex-popup  0 "ba" &add $cursor-x 1 &sub $cursor-y 1
    !else
        osd .osd.latex-popup  0 "b"
    !endif
    .osd.latex-popup osd
!emacro

; Buffer hook. Modify the fill mode to left only. This ensures that we
; always fill the line correctly irrespective of the mode of the caller.
; The likes of centre and justified are not warrented in a TeX buffer.
;
0 define-macro bhook-latex
    ; Save the other context. Restore local context
    set-variable :ofill-mode $fill-mode
    set-variable $fill-mode  :fill-mode
    set-variable :ofill-col  $fill-col
    set-variable $fill-col   :fill-col
!emacro
;
0 define-macro ehook-latex
    ; Restore existing context
    set-variable :fill-mode $fill-mode
    set-variable $fill-mode :ofill-mode
    set-variable :fill-col $fill-col
    set-variable $fill-col :ofill-col
!emacro

; Find the previous opening latex block.
; The state of the call is returned to the caller in #l9.
; The return information is defined as a list as follows:-
;
; |n|
;     There are no containing \begin blocks open
;
; |o|begin|name|line|col|
;     Open \begin block pending.
;
; |e|end|name|line|col|
;     \end exists with no \begin.
;
; |m|end|name|line|col|begin|name|line|col|
;     Mismatch of \begin and \end. The position information is supplied.
;
0 define-macro latex-block-find-backward
    set-variable #l9 0
    set-variable #l8 "||"
    set-variable #l7 "||"
    set-variable #l6 "||"
    set-variable #l5 "o"
    !repeat
        ; Search for begin or end.
        !force search-buffer "bem" "\\\\\\(begin\\|end\\){\\([^}]+\\)}"
        !if $status
            ; Save the search
            set-variable #l1 @s1
            set-variable #l2 @s2
            ; ml-write &spr "Found[%d] \\%s{%s}:%d" #l9 #l1 #l2 $window-line

            ; Make sure we are not in a comment.
            !if &gre $window-col 0
                !force -1 search-buffer "bem" "\\(^%\\|[^\\\\]%\\)"
                !if $status
                    ; Found comment, start search again.
                    set-variable #l5 "c"
                !endif
            !endif

            ; Process the search.
            !if &seq #l5 "c"
                set-variable #l5 "o"
            !elif &iseq #l1 "end"
                ; Found an '\end' push onto the stack.
                set-variable #l9 &add #l9 1
                set-variable #l8 &lset #l8 #l9 #l2
                set-variable #l7 &lset #l7 #l9 $window-line
                set-variable #l6 &lset #l6 #l9 $window-col
                set-variable #l5 "b"
            !elif &equ #l9 0
                ; Found a '\begin' with nothing on stack exit with an open status.
                set-variable #l5 "q"
                set-variable #p9 &spr "|o|begin|%s|%d|%d|" #l2 $window-line $window-col
            !else
                ; Found a '\begin' with '\end' on the stack
                !if &not &seq #l2 &lget #l8 #l9
                    ; The '\begin' does not match the '\end'
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|m|end|%s|%d|%d|begin|%s|%d|%d|" &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9 #l2 $window-line $window-col
                !else
                    set-variable #l9 &sub #l9 1
                    set-variable #l5 "b"
                !endif
            !endif
        !elif &gre #l9 0
            set-variable #l5 "q"
            set-variable #p9 &spr "|e|end|%s|%d|%d|" &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
        !else
            set-variable #l5 "q"
            set-variable #p9 "|n|"
        !endif
        !if &seq #l5 "b"
            !force backward-char
            !if $status
                set-variable #l5 "o"
            !elif &gre #l9 0
                set-variable #l5 "q"
                set-variable #p9 &spr "|e|end|%s|%d|%d|" &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
            !else
                set-variable #l5 "q"
                set-variable #p9 "|n|"
            !endif
        !endif
    !until &seq #l5 "q"
!emacro

; Find the next closing latex block.
; The state of the call is returned to the caller in #l9.
; The return information is defined as a list as follows:-
;
; |n|
;     There are no containing \begin blocks open
;
; |o|begin|name|line|col|
;     Open \begin block pending.
;
; |e|end|name|line|col|
;     \end exists with no \begin.
;
; |m|end|name|line|col|begin|name|line|col|
;     Mismatch of \begin and \end. The position information is supplied.
;
0 define-macro latex-block-find-forward
    set-variable #l9 0
    set-variable #l8 "||"
    set-variable #l7 "||"
    set-variable #l6 "||"
    set-variable #l5 "o"
    set-variable #l4 0
    !repeat
        ; Search for begin or end.
        !force search-buffer "em" "\\\\\\(begin\\|end\\){\\([^}]+\\)}"
        ; 1 screen-update
        !if $status
            ; Save the search
            set-variable #l1 @s1
            set-variable #l2 @s2
            set-variable #l4 &add #l4 1
            ; ml-write &spr "Processing[%05d/%d] \\%s{%s}:%d" #l4 #l9 #l1 #l2 $window-line

            ; Make sure we are not in a comment.
            set-position "\x82"
            !if &gre $window-col 0
                backward-char
                !force -1 search-buffer "bem" "\\(^%\\|[^\\\\]%\\)"
                !if $status
                    ; Found comment, start search again.
                    set-variable #l5 "c"
                !endif
           !endif
           goto-position "\x82"

            ; Process the search.
            !if &seq #l5 "c"
                set-variable #l5 "o"
                end-of-line
            !elif &iseq #l1 "begin"
                ; Found an '\begin' push onto the stack.
                set-variable #l9 &add #l9 1
                set-variable #l8 &lset #l8 #l9 #l2
                set-variable #l7 &lset #l7 #l9 $window-line
                set-variable #l6 &lset #l6 #l9 $window-col
                set-variable #l5 "o"
            !elif &equ #l9 0
                ; Found a '\end' with nothing on stack exit with an open status.
                set-variable #l5 "q"
                set-variable #p9 &spr "|o|end|%s|%d|%d|" #l2 $window-line $window-col
            !else
                ; Found a '\begin' with '\end' on the stack
                !if &not &seq #l2 &lget #l8 #l9
                    ; The '\end' does not match the '\begin'
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|m|end|%s|%d|%d|begin|%s|%d|%d|" #l2 $window-line $window-col &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
                !else
                    set-variable #l9 &sub #l9 1
                    set-variable #l5 "o"
                !endif
            !endif
        !elif &gre #l9 0
            set-variable #l5 "q"
            set-variable #p9 &spr "|e|begin|%s|%d|%d|" &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
        !else
            set-variable #l5 "q"
            set-variable #p9 "|n|"
        !endif
    !until &seq #l5 "q"
!emacro

; Find the next closing latex block that has not been opened.
; The state of the call is returned to the caller in #l9.
; The return information is defined as a list as follows:-
;
; |n|
;     There are no containing \begin blocks open
;
; |o|name|line|col|
;     Open block pending.
;
; |e|name|line|col|
;     Closing bracket exists with no opening.
;
; |m|names|lines|cols|name2e|linee|cole|
;     Mismatch of start and end brackets.
;     The position information is supplied.
;
0 define-macro tex-bracket-find-forward
    set-variable #l9 0
    set-variable #l8 "||"
    set-variable #l7 "||"
    set-variable #l6 "||"
    set-variable #l5 "o"
    set-variable #l4 0
    !repeat
        ; Search for next significant construct
        !force search-buffer "em" "\\(\\\\begin{\\|\\\\end{\\|[{}$\\[\\]]\\)"
        !if $status
            ; Save the search
            set-variable #l1 @s1
            set-variable #l4 &add #l4 1
            ; ml-write &spr "Processing[%05d/%d] %s:%d \"%s\" \"%s\" \"%s\"" #l4 #l9 #l1 $window-line #l8 #l7 #l6
            ; 1 screen-update

            ; Make sure we are not in a comment.
            set-position "\x82"
            !if &gre $window-col 1
                backward-char
                !force -1 search-buffer "bem" "\\(^%\\|[^\\\\]%\\)"
                !if $status
                    ; Found comment, start search again.
                    set-variable #l5 "c"
                !endif
            !endif
            goto-position "\x82"

            ; Process the search.
            !if &seq #l5 "c"
                set-variable #l5 "o"
                end-of-line
            !elif &seq #l1 "\\begin{"
                ; See if this is a verbatim environment, if so then skip over
                ; it.
                set-variable #l3 ""
                !while &not &sin @wc "}\n"
                    set-variable #l3 &cat #l3 @wc
                    forward-char
                !done
                !if &and &seq @wc "}" &seq #l3 "verbatim"
                    !force search-buffer "em" "\\\\end{verbatim}"
                    !if $status
                        set-variable #l5 "s"
                    !endif
                !endif

                ; Determine if skipping.
                !if &seq #l5 "s"
                    set-variable #l5 "o"
                !else
                    goto-position "\x82"
                    ; Push onto the stack.
                    set-variable #l9 &add #l9 1
                    set-variable #l8 &lset #l8 #l9 "\\begin"
                    set-variable #l7 &lset #l7 #l9 $window-line
                    set-variable #l6 &lset #l6 #l9 $window-col
                    backward-char
                !endif
            !elif &seq #l1 "\\end{"
                backward-char
                !if &equ #l9 0
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|o|%s|%d|%d|" #l1 $window-line $window-col
                !elif &not &seq "\\begin" &lget #l8 #l9
                    ; Found a '\end' with '\begin' on the stack
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|m|%s|%d|%d|%s|%d|%d|" "\\end" $window-line $window-col &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
                !else
                    set-variable #l8 &lset #l8 #l9 ""
                    set-variable #l7 &lset #l7 #l9 ""
                    set-variable #l6 &lset #l6 #l9 ""
                    set-variable #l9 &sub #l9 1
                !endif
            !elif &or &iseq #l1 "{" &iseq #l1 "["

                ; Simple test to see if '[' is in a {[} enclosure.
                !if &and &iseq #l1 "[" &seq @wc "}"
                    !if &gre $window-col 1
                        2 backward-char
                        !if &seq @wc "{"
                            set-variable #l5 "s"
                        !endif
                        2 forward-char
                    !endif
                !endif

                ; Simple test to see if '{' is escaped '\{'.
                !if &and &iseq #l1 "{" &gre $window-col 1
                    2 backward-char
                    !if &seq @wc "\\"
                        set-variable #l5 "s"
                    !endif
                    2 forward-char
                !endif
                ;
                ; Precheck.
                !if &seq #l5 "s"
                    set-variable #l5 "o"
                !else
                    ; Push onto the stack.
                    set-variable #l9 &add #l9 1
                    set-variable #l8 &lset #l8 #l9 #l1
                    set-variable #l7 &lset #l7 #l9 $window-line
                    set-variable #l6 &lset #l6 #l9 $window-col
                !endif
                set-variable #l5 "o"
            !elif &iseq #l1 "}"
                ; Simple test to see if '}' is escaped '\}'.
                !if &gre $window-col 1
                    2 backward-char
                    !if &seq @wc "\\"
                        set-variable #l5 "s"
                    !endif
                    2 forward-char
                !endif
                ; Precheck.
                !if &seq #l5 "s"
                    ; Skipping escaped character.
                    set-variable #l5 "o"
                !elif &equ #l9 0
                    ; Mismatched.
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|o|%s|%d|%d|" #l1 $window-line $window-col
                !elif &not &seq "{" &lget #l8 #l9
                    ; Found a '}' with '{' on the stack
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|m|%s|%d|%d|%s|%d|%d|" #l1 $window-line $window-col &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
                !else
                    ; Matched - pop last opening off the stack.
                    set-variable #l8 &lset #l8 #l9 ""
                    set-variable #l7 &lset #l7 #l9 ""
                    set-variable #l6 &lset #l6 #l9 ""
                    set-variable #l9 &sub #l9 1
                !endif
            !elif &iseq #l1 "]"
                ; Simple test to see if '[' is in a {[} enclosure.
                !if &seq @wc "}"
                    !if &gre $window-col 1
                        2 backward-char
                        !if &seq @wc "{"
                            set-variable #l5 "s"
                        !endif
                        2 forward-char
                    !endif
                !endif

                ; Process the close bracket.
                !if &seq #l5 "s"
                    set-variable #l5 "o"
                !elif &equ #l9 0
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|o|%s|%d|%d|" #l1 $window-line $window-col
                !elif &not &seq "[" &lget #l8 #l9
                    ; Found a ']' with '[' on the stack
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|m|%s|%d|%d|%s|%d|%d|" #l1 $window-line $window-col &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
                !else
                    set-variable #l8 &lset #l8 #l9 ""
                    set-variable #l7 &lset #l7 #l9 ""
                    set-variable #l6 &lset #l6 #l9 ""
                    set-variable #l9 &sub #l9 1
                !endif
            !elif &iseq #l1 "$"
                ; Simple test to see if '$' is escaped '\$'.
                !if &gre $window-col 1
                    2 backward-char
                    !if &seq @wc "\\"
                        set-variable #l5 "s"
                    !endif
                    2 forward-char
                !endif

                ; Precheck.
                !if &seq #l5 "s"
                    set-variable #l5 "o"
                ; Found a '$' with '$' on the stack
                !elif &seq "$" &lget #l8 #l9
                    set-variable #l8 &lset #l8 #l9 ""
                    set-variable #l7 &lset #l7 #l9 ""
                    set-variable #l6 &lset #l6 #l9 ""
                    set-variable #l9 &sub #l9 1
                !else
                    set-variable #l9 &add #l9 1
                    set-variable #l8 &lset #l8 #l9 #l1
                    set-variable #l7 &lset #l7 #l9 $window-line
                    set-variable #l6 &lset #l6 #l9 $window-col
                !endif
            !elif &equ #l9 0
                ; Found a '\end' with nothing on stack exit with an open status.
                set-variable #l5 "q"
                set-variable #p9 &spr "|o|end|%s|%d|%d|" #l1 $window-line $window-col
            !else
                ; Error - should never get here.
                set-variable #l5 "q"
                set-variable #p9 &spr "|H|ERROR|%s|%d|%d|" #l1 $window-line $window-col
            !endif
        !elif &gre #l9 0
            set-variable #l5 "q"
            set-variable #p9 &spr "|e|%s|%d|%d|" &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
        !else
            set-variable #l5 "q"
            set-variable #p9 "|n|"
        !endif
        !if &and &seq #l5 "f" 0
            !force forward-char
            !if &not $status
                !if &gre #l9 0
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|e|%s|%d|%d|" &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
                !else
                    set-variable #l5 "q"
                    set-variable #p9 "|n|"
                !endif
            !endif
            set-variable #l5 "o"
        !endif
    !until &seq #l5 "q"
!emacro

; Find the next opening tex block that has not been opened.
; The state of the call is returned to the caller in #l9.
; The return information is defined as a list as follows:-
;
; |n|
;     There are no containing \begin blocks open
;
; |o|name|line|col|
;     Open block pending.
;
; |e|name|line|col|
;     Opening bracket exists with no matching closing.
;
; |m|names|lines|cols|name2e|linee|cole|
;     Mismatch of start and end brackets.
;     The position information is supplied.
;
0 define-macro tex-bracket-find-backward
    set-variable #l9 0
    set-variable #l8 "||"
    set-variable #l7 "||"
    set-variable #l6 "||"
    set-variable #l5 "o"
    set-variable #l4 0
    !repeat
        ; !force backward-char
        ; Search for next significant construct
        !force search-buffer "bem" "\\([{}$\\[\\]]\\|\\\\begin{\\|\\\\end{\\)"
        !if $status
            ; Save the search
            set-variable #l1 @s1
            set-variable #l4 &add #l4 1
            ; 1 screen-update
            ; 50 ml-write &spr "Processing[%05d/%d] %s:%d \"%s\" \"%s\" \"%s\"" #l4 #l9 #l1 $window-line #l8 #l7 #l6

            ; Make sure we are not in a comment.
            set-position "\x82"
            !if &gre $window-col 1
                backward-char
                !force -1 search-buffer "bem" "\\(^%\\|[^\\\\]%\\)"
                !if $status
                    ; Found comment, start search again.
                    set-variable #l5 "c"
                !endif
            !endif
            goto-position "\x82"

            ; Process the search.
            !if &seq #l5 "c"
                !if &equ $window-col 0
                    backward-line
                    end-of-line
                !endif
                set-variable #l5 "o"
            !elif &seq #l1 "\\end{"
                exchange-point-and-mark
                set-variable #l3 ""
                forward-char
                !while &not &sin @wc "}\n"
                    set-variable #l3 &cat #l3 @wc
                    forward-char
                !done
                !if &and &seq @wc "}" &seq #l3 "verbatim"
                    !force search-buffer "bem" "\\\\begin{verbatim}"
                    !if $status
                        set-variable #l5 "s"
                    !endif
                !endif

                ; Determine if skipping.
                !if &seq #l5 "s"
                    set-variable #l5 "b"
                !else
                    goto-position "\x82"
                    ; Push onto the stack.
                    set-variable #l9 &add #l9 1
                    set-variable #l8 &lset #l8 #l9 "\\end"
                    set-variable #l7 &lset #l7 #l9 $window-line
                    set-variable #l6 &lset #l6 #l9 $window-col
                !endif
            !elif &seq #l1 "\\begin{"
                ; Pop the '\end'
                !if &seq #l5 "q"
                !elif &equ #l9 0
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|o|%s|%d|%d|" #l1 $window-line $window-col
                !elif &not &seq "\\end" &lget #l8 #l9
                    ; Found a '\end' with '\begin' on the stack
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|m|%s|%d|%d|%s|%d|%d|" "\\end" $window-line $window-col &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
                !else
                    set-variable #l8 &lset #l8 #l9 ""
                    set-variable #l7 &lset #l7 #l9 ""
                    set-variable #l6 &lset #l6 #l9 ""
                    set-variable #l9 &sub #l9 1
                !endif
            !elif &or &iseq #l1 "}" &iseq #l1 "]"
                ; Simple test to see if '[' is in a {[} enclosure.
                !if &gre $window-col 0
                    backward-char
                    ; Simple test to see if '{' is escaped '\{'.
                    !if &and &iseq #l1 "{" &seq @wc "\\"
                        set-variable #l5 "s"
                    !elif &and &iseq @wc "{" &seq #l1 "["
                        2 forward-char
                        !if &seq @wc "}"
                            set-variable #l5 "s"
                        !endif
                        2 backward-char
                    !endif
                    forward-char
                !endif

                ; Precheck.
                !if &not &seq #l5 "s"
                    ; Push onto the stack.
                    set-variable #l9 &add #l9 1
                    set-variable #l8 &lset #l8 #l9 #l1
                    set-variable #l7 &lset #l7 #l9 $window-line
                    set-variable #l6 &lset #l6 #l9 $window-col
                !endif
                set-variable #l5 "o"
            !elif &iseq #l1 "{"
                ; Simple test to see if '{' is escaped '\{'.
                !if &gre $window-col 0
                    backward-char
                    !if &seq @wc "\\"
                        set-variable #l5 "s"
                    !endif
                    forward-char
                !endif
                ; Precheck.
                !if &seq #l5 "s"
                    ; Skipping escaped character.
                    set-variable #l5 "o"
                !elif &equ #l9 0
                    ; Mismatched.
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|o|%s|%d|%d|" #l1 $window-line $window-col
                !elif &not &seq "}" &lget #l8 #l9
                    ; Found a '}' with '{' on the stack
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|m|%s|%d|%d|%s|%d|%d|" #l1 $window-line $window-col &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
                !else
                    ; Matched - pop last opening off the stack.
                    set-variable #l8 &lset #l8 #l9 ""
                    set-variable #l7 &lset #l7 #l9 ""
                    set-variable #l6 &lset #l6 #l9 ""
                    set-variable #l9 &sub #l9 1
                !endif
            !elif &iseq #l1 "["
                ; Simple test to see if '[' is in a {[} enclosure.
                !if &gre $window-col 0
                    backward-char
                    !if &seq @wc "{"
                        2 forward-char
                        !if &seq @wc "}"
                            set-variable #l5 "s"
                        !endif
                        2 backward-char
                    !endif
                    forward-char
                !endif

                ; Process the close bracket.
                !if &seq #l5 "s"
                    set-variable #l5 "o"
                !elif &equ #l9 0
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|o|%s|%d|%d|" #l1 $window-line $window-col
                !elif &not &seq "]" &lget #l8 #l9
                    ; Found a ']' with '[' on the stack
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|m|%s|%d|%d|%s|%d|%d|" #l1 $window-line $window-col &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
                !else
                    set-variable #l8 &lset #l8 #l9 ""
                    set-variable #l7 &lset #l7 #l9 ""
                    set-variable #l6 &lset #l6 #l9 ""
                    set-variable #l9 &sub #l9 1
                !endif
            !elif &iseq #l1 "$"
                ; Simple test to see if '$' is escaped '\$'.
                !if &gre $window-col 0
                    backward-char
                    !if &seq @wc "\\"
                        set-variable #l5 "s"
                    !endif
                    forward-char
                !endif

                ; Precheck.
                !if &seq #l5 "s"
                    set-variable #l5 "o"
                ; Found a '$' with '$' on the stack
                !elif &seq "$" &lget #l8 #l9
                    set-variable #l8 &lset #l8 #l9 ""
                    set-variable #l7 &lset #l7 #l9 ""
                    set-variable #l6 &lset #l6 #l9 ""
                    set-variable #l9 &sub #l9 1
                !else
                    set-variable #l9 &add #l9 1
                    set-variable #l8 &lset #l8 #l9 #l1
                    set-variable #l7 &lset #l7 #l9 $window-line
                    set-variable #l6 &lset #l6 #l9 $window-col
                !endif
            !elif &equ #l9 0
                ; Found a '\end' with nothing on stack exit with an open status.
                set-variable #l5 "q"
                set-variable #p9 &spr "|o|end|%s|%d|%d|" #l1 $window-line $window-col
            !else
                ; Error - should never get here.
                set-variable #l5 "q"
                set-variable #p9 &spr "|H|ERROR|%s|%d|%d|" #l1 $window-line $window-col
            !endif
        !elif &gre #l9 0
            set-variable #l5 "q"
            set-variable #p9 &spr "|e|%s|%d|%d|" &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
        !else
            set-variable #l5 "q"
            set-variable #p9 "|n|"
        !endif
        !if &and &seq #l5 "f" 0
            !force forward-char
            !if &not $status
                !if &gre #l9 0
                    set-variable #l5 "q"
                    set-variable #p9 &spr "|e|%s|%d|%d|" &lget #l8 #l9 &lget #l7 #l9 &lget #l6 #l9
                !else
                    set-variable #l5 "q"
                    set-variable #p9 "|n|"
                !endif
            !endif
            set-variable #l5 "o"
        !endif
    !until &seq #l5 "q"
!emacro

; Moves up a level by advancing forwards to the next bracket that closes a
; statement. i.e. Finds the next "\end{", "}" or "]"
define-macro tex-find-forward
    set-position "\x81"
    tex-bracket-find-forward
    set-variable #l0 &lget #l9 1
    !if &seq #l0 "n"
        ml-write "No bracket mismatches."
    !elif &seq #l0 "o"
        ml-write &spr "Next '%s':%d/%d" &lget #l9 2 &lget #l9 3 &lget #l9 4
    !elif &seq #l0 "m"
        ml-write &spr "Mismatch '%s':%d/%d ... '%s':%d/%d" &lget #l9 5 &lget #l9 6 &lget #l9 7 &lget #l9 2 &lget #l9 3 &lget #l9 4
    !elif &seq #l0 "e"
        ml-write &spr "No matching '%s':%d/%d" &lget #l9 2 &lget #l9 2 &lget #l9 3 &lget #l9 4
    !else
        ml-write &spr "ERROR: status=%s(%s)" #l0 #l9
    !endif
!emacro

; Down up a level by advancing backwards to the next bracket that closes a
; statement. i.e. Finds the next "\begin{", "{" or "["
define-macro tex-find-backward
    set-position "\x81"
    tex-bracket-find-backward
    set-variable #l0 &lget #l9 1
    !if &seq #l0 "n"
        ml-write "No bracket mismatches."
    !elif &seq #l0 "o"
        ml-write &spr "Next '%s':%d/%d" &lget #l9 2 &lget #l9 3 &lget #l9 4
    !elif &seq #l0 "m"
        ml-write &spr "Mismatch '%s':%d/%d ... '%s':%d/%d" &lget #l9 5 &lget #l9 6 &lget #l9 7 &lget #l9 2 &lget #l9 3 &lget #l9 4
    !elif &seq #l0 "e"
        ml-write &spr "No matching '%s':%d/%d" &lget #l9 2 &lget #l9 2 &lget #l9 3 &lget #l9 4
    !else
        ml-write &spr "ERROR: status=%s(%s)" #l0 #l9
    !endif
!emacro

; Find the next \begin{...} block backwards.
define-macro latex-find-backward
    set-position "\x81"
    latex-block-find-backward
    set-variable #l0 &lget #l9 1
    !if &seq #l0 "n"
        ml-write "At outermost level. No \\begin{...} ... \\end{...} mismatch."
    !elif &seq #l0 "o"
        ml-write &spr "Next \\begin{%s}:%d(%d)" &lget #l9 3 &lget #l9 4 &lget #l9 5
    !elif &seq #l0 "m"
        ml-write &spr "Mismatch \\begin{%s}:%d(%d) ... \\end{%s}:%d(%d)." &lget #l9 7 &lget #l9 8 &lget #l9 9 &lget #l9 3 &lget #l9 4 &lget #l9 5
    !elif &seq #l0 "e"
        ml-write &spr "No \begin{%s} matching \\end{%s}:%d(%d)." &lget #l9 3 &lget #l9 3 &lget #l9 4 &lget #l9 5
    !else
        ml-write &spr "ERROR: status=%s(%s)" #l0 #l9
    !endif
!emacro

; Find the next open \end{...} block forwards.
define-macro latex-find-forward
    set-position "\x81"
    latex-block-find-forward
    set-variable #l0 &lget #l9 1
    !if &seq #l0 "n"
        ml-write "At outermost level. No \\begin{...} ... \\end{...} mismatch."
    !elif &seq #l0 "o"
        ml-write &spr "Next \\end{%s}:%d(%d)" &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !elif &seq #l0 "m"
        ml-write &spr "Mismatch \\begin{%s}:%d(%d) ... \\end{%s}:%d(%d)." &lget #l9 7 &lget #l9 8 &lget #l9 9 &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !elif &seq #l0 "e"
        ml-write &spr "No \end{%s} matching \\begin{%s}:%d(%d)." &lget #l9 3 &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !else
        ml-write &spr "ERROR: status=%s(%s)" #l0 #l9
    !endif
!emacro

; Goto the last unclosed latex block. i.e. moves to \begin{...} This is
; typically bound to C-c C-u
define-macro tex-goto-last-unclosed-latex-block
    set-position "\x81"
    latex-block-find-backward
    set-variable #l0 &lget #l9 1
    !if &seq #l0 "n"
        ml-write "Not Found - at outermost level. (All \\begin{...} ... \\end{...} matched)"
        goto-position "\x81"
    !elif &seq #l0 "o"
        ml-write &spr "Next \\begin{%s}:%d(%d)" &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !elif &seq #l0 "m"
        ml-write &spr "Mismatch \\begin{%s}:%d(%d) ... \\end{%s}:%d(%d)." &lget #l9 7 &lget #l9 8 &lget #l9 9 &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !elif &seq #l0 "e"
        ml-write &spr "No \begin{%s} matching \\end{%s}:%d(%d)." &lget #l9 3 &lget #l9 3 &lget #l9 4 &lget #l9 5
        goto-position "\x81"
    !else
        ml-write &spr "Macro error: Status=%s(%s)" #l0 #l9
        goto-position "\x81"
    !endif
!emacro

; Create an \end{...} to match the last unclosed \begin{...}
; Typically bound to "C-c C-e"
define-macro tex-close-latex-block
    set-position "\x81"
    set-variable #l1 ""
    latex-block-find-backward
    set-variable #l0 &lget #l9 1
    !if &seq #l0 "n"
        ml-write "Not Found - at outermost level. (All \\begin{...} ... \\end{...} matched)"
        goto-position "\x81"
    !elif &seq #l0 "o"
        ml-write &spr "Found \\begin{%s} at line %d col %d" &lget #l9 3 &lget #l9 4 &lget #l9 5
        goto-position "\x81"
        insert-string &spr "\\end{%s}" &lget #l9 3
        set-variable #l3
    !elif &seq #l0 "m"
        set-variable #l1 &spr "Mismatch \\begin{%s}:%d(%d) ... \\end{%s}:%d(%d)." &lget #l9 7 &lget #l9 8 &lget #l9 9 &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !elif &seq #l0 "e"
        set-variable #l1 &spr "No \begin{%s} matching \\end{%s}:%d(%d)." &lget #l9 3 &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !else
        ml-write &spr "Macro error: Status=%s(%s)" #l0 #l9
        goto-position "\x81"
    !endif
    ; See if the user wants to go to the error.
    !if &not &seq #l1 ""
        set-variable #l1 &cat #l1 " Goto error (y/n) ? "
        !if &iseq @mc1 #l1 "yYnN" "n"
            goto-position "\x81"
        !endif
    !endif
!emacro

; Verify that all of the latex blocks are closed from the current position.
define-macro latex-verify
    set-position "\x81"
    ml-write "Checking for \\begin{..} .. \\end{..} pairs from current position ..."
    latex-block-find-forward
    set-variable #l0 &lget #l9 1
    !if &seq #l0 "n"
        ml-write "All \\begin{...} ... \\end{...} matched OK)"
        goto-position "\x81"
        ; Check for bracket matching by looking forward.
        ml-write "\\begin{}/\\end{} OK. Checking bracket {}[] matching from current position ..."
        tex-find-forward
    !elif &seq #l0 "o"
        ml-write &spr "ERROR: No \\begin for \\end{%s}@%d/%d" &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !elif &seq #l0 "m"
        ml-write &spr "ERROR: Mismatched \\begin{%s}@%d/%d ... \\end{%s}@%d/%d" &lget #l9 7 &lget #l9 8 &lget #l9 9 &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !elif &seq #l0 "e"
        ml-write &spr "ERROR: No \begin{%s} matching \\end{%s}@%d/%d" &lget #l9 3 &lget #l9 3 &lget #l9 4 &lget #l9 5
        set-variable $window-line &lget #l9 4
        set-variable $window-col &lget #l9 5
    !else
        ml-write &spr "Macro error: Status=%s(%s)" #l0 #l9
        goto-position "\x81"
    !endif
!emacro

; Handle the expansion of LaTeX abbreviations. The only one we handle here is
; \\end{}. If we are not performing an expansion then simply return NULL.
0 define-macro latex-pre-expand-abbrev
    ; Handling \end.
    !if &not &seq &mid @wl &sub $window-col 5 5 "\\end{"
        !abort
    !endif
    ; Set up the buffer to look for the backward tag.
    set-position "\x81"
    5 backward-char
    ; Find the block backwards.
    latex-block-find-backward
    set-variable #l0 &lget #l9 1
    !if &seq #l0 "o"
        ; Found a match - insert it.
        goto-position "\x81"
        insert-string &spr "%s" &lget #l9 3
        !return
    !endif
    ; Failed. Restore position and return abort.
    goto-position "\x81"
    !abort
!emacro

; Insert a quote for Tex in context sensitive way. A numeric argument always
; inserts a literal quote. This is simply bound to '"'
define-macro tex-insert-quote
    ; If there is an arqument then insert a literal.
    !if @?
        set-variable #l0 "\""
    !else
        set-variable #l0 "''"
        ; If we are in a verbatim environment then insert a literal.
        set-position "\x81"
        latex-block-find-backward
        set-variable #l1 &lget #l9 1
        goto-position "\x81"
        ; Process.
        !if &and &seq #l1 "o" &seq "verbatim" &lget #l9 3
            ; Verbatim environment.
            set-variable #l0 "\""
        !elif &equ $window-col 0
            ; If we are at the start of the line or the previous character is
            ; space then insert an opening quote.
            set-variable #l0 "``"
        !else
            ; Find the previous character.
            !force backward-char
            !if $status
                set-variable #l1 @wc
                !if &sin #l1 " \t"
                    set-variable #l0 "``"
                !elif &sin #l1 "\\"
                    set-variable #l0 "\""
                !endif
                forward-char
            !endif
        !endif
    !endif
    insert-string #l0
!emacro

; Inserts an underscore, bound to "_"
define-macro tex-insert-underscore
    ; If there is an arqument then insert a literal.
    !if @?
        set-variable #l0 "_"
    !else
        ; If we are in a verbatim environment then insert a literal.
        set-position "\x81"
        latex-block-find-backward
        set-variable #l0 &lget #l9 1
        goto-position "\x81"
        ; Process.
        !if &and &seq #l0 "o" &seq "verbatim" &lget #l9 3
            ; Verbatim environment.
            set-variable #l0 "_"
        !elif &equ $window-col 0
            ; If we are at the start of the line or the previous character is
            ; space then insert an opening quote.
            set-variable #l0 "\\_"
        !else
            ; Find the previous character.
            backward-char
            set-variable #l1 @wc
            !if &sin #l1 "\\"
                set-variable #l0 "_"
            !else
                set-variable #l0 "\\_"
            !endif
            forward-char
        !endif
    !endif
    insert-string #l0
!emacro

; Insert a set of brackets, typically bound to "C-c {"
define-macro tex-insert-braces
    insert-string "{}"
    backward-char
!emacro

; Move to the next set of braces, typically bound to "C-c }".
; n Move up 'n' levels.
; -n Move backwards 'n' levels
define-macro tex-up-list
    ; Get numeric argument.
    !if @?
        set-variable #l1 @#
    !else
        set-variable #l1 1
    !endif
    ; Do the processing.
    !if &less #l1 0
        !while #l1 &less 0
            tex-bracket-find-backward
            set-variable #l0 &lget #l9 1
            !if &seq #l0 "n"
                ml-write "At outmost level."
                set-variable #l1 0
            !elif &seq #l0 "o"
                ; Found !
            !endif
            set-variable #l1 &add #l1 1
        !done
    !else
        !while #l1 &gre 0
            tex-bracket-find-forward
            set-variable #l0 &lget #l9 1
            !if &seq #l0 "n"
                ml-write "At outmost level."
                set-variable #l1 0
            !elif &seq #l0 "o"
                ; Found !
            !endif
            set-variable #l1 &sub #l1 1
        !done
    !endif
!emacro

buffer-init-fhook "latex"
