;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Created By    : Jon Green
;  Created       : Mon Mar 20 22:36:48 2000
;  Description   : Common document macros. 
;
;  Notes         : These were removed from the hkdoc template to create
;                  a set of common macros which may be invoked from 
;                  other templates rather than simply the doc one. 
;
; The Document template undersatnds magic tokens as follows:-
;
; -!- Document -!-
;
;     Read as a sectioned document. Uses a simple hilighting scheme
;     such that the following is recognised:-
;
;     1.1 Title        - Whole line hilighted in yellow
;     a) Text          - Bullets are hilighted.
;     * Text           - Bullets are hilighted.
;     "Text"           - Quoted text is hilighted.
;
;
; SECTIONED DOCUMENT.
;
; Define using a magic string: -!- document -!-
; Hilights the following items
;
; n.n.n
;         Section headers, All lines commencing with a n.XX sequence which
;         assumes a numbered section. e.g.
;
;         2.0 Scheduler
;
; Appendix
;         Section headers. Assumes this is an Appendix. All lines commencing
;         with "Appendix are assumed to be headers. e.g.
;
;         Appendix A - Data structures
; >
;         All lines commencing with '>' are assumed to be a comment.
;         Typically used at the head of the document. e.g.
;
;         > -!- document; sectioned; pseudo-code -!-
;         >
;         > Author:       My Self
;         > Created:      11/11/97
;         > Modified:     <011015.2258>
;         > Location:     /xx/yy/zz.doc
; *
;         All lines commencing with '*' are assumed to be bullet lists. Bullet
;         is hilighted. e.g.
;
;         * Bullet item
;
; A) 1)
;         All lines commencing with [a-zA-Z]) or [0-9]) are assumed to be
;         minor sections. The section number is hilighted. e.g:
;
;         a) text
;         1) text
;
; 'xx' "yy"
;         All text in single or double quotes is hilighted, assumed to be
;         literal text. e.g.
;
;         This is a "double quote" or 'a' single quote.
; ____
;         Lines commencing with '_' (underscore) are hilighted to the end.
;         typically used as demarkation breaks or for section underlining
;         e.g.
;
;
;         text.....
;         ________________________________________________________________
;
;         Add a nice big line to separate sections
;
;  Copyright (c) 2000-2001 JASSPA.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; arguments when executed must be the "extension"
set-variable #l1 @1
set-variable #l0 &ind &spr ".fhook-%s.setup" #l1

!if &and &sin "h" #l0 &band .hilight.flags 0x02
    !if &not &exist .hilight.doc
        set-variable .hilight.doc  &pinc .hilight.next 1
        set-variable .hilight.doc1 &pinc .hilight.next 1
    !endif
    !if &not &exist &ind &cat ".hilight." #l1
        set-variable  &ind &cat ".hilight." #l1 .hilight.doc
    !endif
    ; Define the hilighting. Note that we use a look back so that
    ; we can process the inserted schemes if necessary. Ordinarily
    ; we do not need it. This will only hurt branch tokens, as there
    ; are none below then there is no adverse effect.
    0 hilight  .hilight.doc 2 100                               $global-scheme
    hilight .hilight.doc 0x20 "*\\}[ \t]+\\w"                   .scheme.no1
    hilight .hilight.doc 0x21 "\\w)"                            .scheme.no1
    hilight .hilight.doc 1 "\\*[A-Za-z_]+\\*"                   .scheme.bold
    hilight .hilight.doc 1 "<[A-Za-z_]+>"                       .scheme.italic
    hilight .hilight.doc 1 "_[A-Za-z0-9]+_"                     .scheme.under
    hilight .hilight.doc 0 "^\\s *\\[\\w*\\]"                   .scheme.no1
    hilight .hilight.doc 0x22 "[0-9]+\\.[0-9.]*[ \t]+\\w"       .scheme.header
    hilight .hilight.doc 0x804 "\"" "\"" "\\"                   .scheme.string
    hilight .hilight.doc 0x804 "`" "'" ""                       .scheme.no1
    hilight .hilight.doc 0    "'.'"                             .scheme.quote
    hilight .hilight.doc 0    "'\\\\.'"                         .scheme.quote
    hilight .hilight.doc 0x22 "^[ \t]*Appendix [[:alpha:]]"     .scheme.header
    hilight .hilight.doc 0x22 "_\\W"                            .scheme.comment
    hilight .hilight.doc 0x22 ">"                               .scheme.comment
    hilight .hilight.doc 0x80 "^[ \t]+@" .hilight.doc1          .scheme.no2
    ; @ block
    0 hilight .hilight.doc1 0                                   .scheme.no2
    hilight   .hilight.doc1 0x80 "^[ \t]*\n" .hilight.doc       $global-scheme
    hilight   .hilight.doc1 0x80 "^\n"       .hilight.doc       $global-scheme
    
    ; Allow inserts into the documentation mode. You may add to the
    ; available inserts by adding to your mydoc.emf file
    
    ; Allow MicroEmacs Macro .emf inserts
    ; Force the ".emf" scheme to be loaded into the context of the document
    ; scheme. We delimit the .emf scheme with a pair of markers ">emf>" and
    ; ">doc>"
    ;
    ; Force the hilighting mode to load if not already loaded.
    !if &not &exi .hilight.emf
        !force execute-file "hkemf"
    !endif
    ; If the hilighting mode is loaded then modify it.
    !if &and &sin "h" .fhook-emf.setup &band .hilight.flags 0x02 
        hilight .hilight.doc 0x80 "^>emf>" .hilight.emf .scheme.hide
        hilight .hilight.emf 0x80 "^>doc>" .hilight.doc .scheme.hide
    !endif
    
    ; Allow Pseudo Code inserts
    ; Force the ".pseudo" scheme to be loaded into the context of the document
    ; scheme. We delimit the .emf scheme with a pair of markers ">pseudo>" and
    ; ">doc>"
    ;
    ; Force the hilighting mode to load if not already loaded.
    !if &not &exi .hilight.pseudo
        !force execute-file "hkpseudo"
    !endif
    ; If the hilighting mode is loaded then modify it.
    !if &exi .hilight.pseudo
        hilight .hilight.doc 0x80 "^>pseudo>" .hilight.pseudo .scheme.hide
        hilight .hilight.pseudo 0x80 "^>doc>" .hilight.doc .scheme.hide
    !endif
    
    ; Allow BNF inserts
    ; Force the ".bnf" scheme to be loaded into the context of the document
    ; scheme. We delimit the .emf scheme with a pair of markers ">bnf>" and
    ; ">doc>"
    ;
    ; Force the hilighting mode to load if not already loaded.
    !if &not &exi .hilight.bnf
        !force execute-file "hkbnf"
    !endif
    ; If the hilighting mode is loaded then modify it.
    !if &and &sin "h" .fhook-bnf.setup &band .hilight.flags 0x02 
        hilight .hilight.doc 0x80 "^>bnf>" .hilight.bnf .scheme.hide
        hilight .hilight.bnf 0x80 "^>doc>" .hilight.doc .scheme.hide
    !endif
    
    ; Allow C Code inserts
    ; Force the ".c" scheme to be loaded into the context of the document
    ; scheme. We delimit the .emf scheme with a pair of markers ">c>" and
    ; ">doc>"
    ;
    ; Force the hilighting mode to load if not already loaded.
    !if &not &exi .hilight.c
        !force execute-file "hkc"
    !endif
    ; If the hilighting mode is loaded then modify it.
    !if &and &sin "h" .fhook-c.setup &band .hilight.flags 0x02 
        hilight .hilight.doc 0x80 "^>c>"   .hilight.c   .scheme.hide
        hilight .hilight.c   0x80 "^>doc>" .hilight.doc .scheme.hide
    !endif
    
    ; Allow C++ Code inserts ...
    !if &not &exi .hilight.cpp
        !force execute-file "hkcpp"
    !endif
    !if &and &sin "h" .fhook-cpp.setup &band .hilight.flags 0x02 
        hilight .hilight.doc 0x80 "^>cpp>"     .hilight.cpp .scheme.hide
        hilight .hilight.doc 0x80 "^>c\\+\\+>" .hilight.cpp .scheme.hide
        hilight .hilight.cpp 0x80 "^>doc>"     .hilight.doc .scheme.hide
    !endif
    ; Allow Perl Code inserts ...
    !if &not &exi .hilight.perl
        !force execute-file "hkperl"
    !endif
    !if &and &sin "h" .fhook-perl.setup &band .hilight.flags 0x02 
        hilight .hilight.doc  0x80 "^>perl>" .hilight.perl .scheme.hide
        hilight .hilight.doc  0x80 "^>pl>"   .hilight.perl .scheme.hide
        hilight .hilight.perl 0x80 "^>doc>"  .hilight.doc  .scheme.hide
    !endif
    ; Allow TCL Code inserts ...
    !if &not &exi .hilight.tcl
        !force execute-file "hktcl"
    !endif
    !if &and &sin "h" .fhook-cpp.setup &band .hilight.flags 0x02 
        hilight .hilight.doc 0x80 "^>tcl>" .hilight.tcl .scheme.hide
        hilight .hilight.tcl 0x80 "^>doc>" .hilight.doc .scheme.hide
    !endif
!endif

!if &not &exist .osd.doc-stat
    set-variable .osd.doc-stat &pinc .osd.next 1
!endif
-1 osd .osd.doc-stat
osd .osd.doc-stat 0  "batcdH" 9 3 99 .scheme.osd-title "Current Mode Settings"
osd .osd.doc-stat 3  "" 
osd .osd.doc-stat 7  "" 
osd .osd.doc-stat 11 "" 
osd .osd.doc-stat 99 "BcfH" .scheme.osd-ebtt "  &OK  " f void 

define-macro doc-mode-state
    osd .osd.doc-stat 4  "" &spr " Filling to column : %d " $fill-col 
    osd .osd.doc-stat 5  "" &spr " Justification Mode: %s " $fill-mode
    set-variable #l0 "Unknown mode, default to left:NAuto-detect All (L/R/C):OAuto-detect One for word-processor:BAuto-detect Both (R/C):LAuto-detect Left:RAuto-detect Right:CAuto-detect Center:nNone:bBoth justify (L/R):lLeft:rRight:cCenter:oOne for word-processor:"
    set-variable #l0 &rig #l0 &add 1 &sin &cat ":" $fill-mode #l0
    set-variable #l0 &lef #l0 &sub &sin ":" #l0 1
    osd .osd.doc-stat 6  "" &spr "     %s " #l0
    osd .osd.doc-stat 8  "" &spr " Ignore characters : %s " $fill-ignore
    osd .osd.doc-stat 9  "" &spr " Bullet characters : %s " $fill-bullet
    osd .osd.doc-stat 10 "" &spr " Bullet lookahead  : %d " $fill-bullet-len
    .osd.doc-stat osd
!emacro

0 define-macro doc-set-justify
    set-variable $fill-mode &mid "BBCLnR" @# 1
    doc-mode-state
!emacro

define-macro fill-paragraph-center
    set-variable #l1 $fill-mode
    set-variable $fill-mode "c"
    @# fill-paragraph
    set-variable $fill-mode #l1
!emacro

define-macro fill-paragraph-left
    set-variable #l1 $fill-mode
    set-variable $fill-mode "l"
    @# fill-paragraph @mna
    set-variable $fill-mode #l1
!emacro

define-macro fill-paragraph-right
    set-variable #l1 $fill-mode
    set-variable $fill-mode "r"
    @# fill-paragraph @mna
    set-variable $fill-mode #l1
!emacro

define-macro fill-paragraph-both
    set-variable #l1 $fill-mode
    set-variable $fill-mode "b"
    @# fill-paragraph @mna
    set-variable $fill-mode #l1
!emacro

define-macro fill-paragraph-gutter
    set-variable #l1 $fill-mode
    set-variable $fill-mode "g"
    @# fill-paragraph @mna
    set-variable $fill-mode #l1
!emacro

; Default body of a bhook.
define-macro doc-bhook-body
    ; Save other context; restore local context
    set-variable :ofill-mode $fill-mode
    set-variable $fill-mode  :fill-mode
    set-variable :ofill-col  $fill-col
    set-variable $fill-col   :fill-col
!emacro

; Default body of a ehook
define-macro doc-ehook-body
    ; Restore existing context
    set-variable :fill-mode $fill-mode
    set-variable $fill-mode :ofill-mode
    set-variable :fill-col $fill-col
    set-variable $fill-col :ofill-col
    ;ml-write "Restored old setting !! " $fill-col
!emacro

; Defualt body of a fhook
define-macro doc-fhook-body
    set-variable #l1 &rig $buffer-fhook 6
    set-variable #l0 &ind &spr ".fhook-%s.setup" #l1
    ; if arg is 0 this is a new file so add template
    !if &not @#
        etfinsrt #l1
    !endif
    buffer-initialize
    ; Set up the default constants
    set-variable :fill-mode $fill-mode
    set-variable :fill-col $fill-col
    ; Over-ride any special document modes
    !force set-variable #l2 @1
    !if &and $status &sin "n" #l0
        ; Search for additional modes in a -!- document -!-
        ;
        ; -!- Document; fill-column: <digit> -!-
        ;
        ;
        beginning-of-buffer
        !force -20 regex-forward &spr "-[*!]-[ \t]*%s[ \t]*" #l2
        !if $status
            ; Search for fill-column: <var>;
            !force -1 regex-forward "fill-column[ \t]*:[ \t]*\\([0-9]+\\)[ \t]*[-;]"
            !if $status
                set-variable :fill-col @s1
                beginning-of-line
            !endif
            ; Search for fill-mode: <string>
            !force -1 regex-forward "fill-mode[ \t]*:[ \t]*\\([a-zA-Z]+\\)[ \t]*[-;]"            
            !if $status
                set-variable #l0 @s1
                !if &iseq #l0 "left"
                    set-variable :fill-mode "L"
                !elif &iseq #l0 "none"
                    set-variable :fill-mode "n"
                !elif &iseq #l0 "right"
                    set-variable :fill-mode "R"
                !elif &iseq #l0 "full"
                    set-variable :fill-mode "B"
                !elif &iseq #l0 "both"
                    set-variable :fill-mode "B"
                !elif &iseq #l0 "center"
                    set-variable :fill-mode "C"
                !endif
                beginning-of-line
            !endif
            ; Add any others in here.

            ; Back to the start of the buffer
            beginning-of-buffer
        !endif
    !endif
!emacro

set-variable &ind &spr ".fhook-%s.command-flag"  #l1 "|thb|hb|thb|th|h|h|thb|thb|thb|thb|thb|h|h|th|h|h|thb|thb|thb|thb|thb|thb|"
set-variable &ind &spr ".fhook-%s.command-name"  #l1 "|doc-mode-state|spell-buffer|paragraph-to-line||||fill-paragraph-both|fill-paragraph-center|fill-paragraph-left|fill-paragraph-gutter|fill-paragraph-right|fill-paragraph|ifill-paragraph||||doc-set-justify|doc-set-justify|doc-set-justify|doc-set-justify|doc-set-justify|doc-set-justify|"
set-variable &ind &spr ".fhook-%s.command-nbind" #l1 "|||||||||||||||||0|1|2|3|4|5|"
set-variable &ind &spr ".fhook-%s.command-kbind" #l1 "|C-c C-h|C-c C-s|C-c o||||C-c C-b|C-c C-c|C-c C-l|C-c C-g|C-c C-r||||||C-c a|C-c b|C-c c|C-c l|C-c n|C-c r|"
set-variable &ind &spr ".fhook-%s.command-desc"  #l1 "|&Show Current Settings|Spell Check Buffer|Fill Paragraph for WP Export||To format current paragraph:||Justify Both Margins|Justify Center|Justify Left|Justify Gutter (on left margin)|Justify Right|Format Paragraph in Current Mode|Intelligently Format Paragraph||To change justification mode:||Change to auto justification [DEFAULT]|Change to both justification|Change to center justification|Change to left justification|Change to none justification|Change to right justification|"
!if &sin "f" #l0
    ; Define the folding definitions.
    set-variable &ind &spr ".fhook-%s.fold-open" #l1  "^[ \t]*\\(Appendix[ \t]+[A-Z][0-9.]*\\|[0-9]\\.[0-9.]*\\)[ \t]+\\w"
    set-variable &ind &spr ".fhook-%s.fold-close" #l1 "^[ \t]*\\(Appendix[ \t]+[A-Z][0-9.]*\\|[0-9]\\.[0-9.]*\\)[ \t]+\\w"
    set-variable &ind &spr ".fhook-%s.fold-mopen" #l1 "1"
    set-variable &ind &spr ".fhook-%s.fold-mnext" #l1 "-1"
!endif
