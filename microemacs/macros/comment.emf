; -!- emf -!-
; This is part of the JASSPA MicroEmacs macro files
; Copyright (C) 2001-2002 JASSPA (www.jasspa.com)
; See the file me.emf for copying and conditions.
;
; Created:     Mon Feb 26 2001
; Synopsis:    General comment adding and removing routines
; Authors:     Steven Phillips
;
; Notes:
;      To use, the current buffer fhook command variable .comment must be set
;      to a list giving the following:
;           "|<Comment start>|<Comment end>|<comment pad>|<mid-box-left>|<mid-box-right>|<comment-flags>|"
;      e.g. the following are C and emf comments
;           set-variable .fhook-c.comment "|/*|*/|*| * | * |f|"
;           set-variable .fhook-emf.comment "|;||;|; | ;||"
;      The following flags are used:
;           b   Box format required, i.e. create right edge as well
;           f   Footer line required
;           F   Fill footer line with <comment pad> strings
;           h   Header line required
;           H   Fill header line with <comment pad> strings
;           j   Enable Justify mode in *comment* buffer
;
; comment line ie xxx -> <comment start>xxx
;              or xxx -> <comment start>xxx<comment end>
define-macro comment-line
    set-variable #l0 &ind &spr ".%s.comment"  $buffer-fhook
    !if &seq &set #l1 &lget #l0 1 ""
        ml-write "[Comments not setup for this buffer]"
        !abort
    !endif
    set-variable  #l2 &lget #l0 2
    beginning-of-line
    !while &gre &pdec @# 1 0
        insert-string #l1
        !if &not &seq #l2 ""
            end-of-line
            insert-string #l2
        !endif
        beginning-of-line
        forward-line
    !done
!emacro
;
; uncoment line ie <comment start>xxx -> xxx
;               or <comment start>xxx<comment end> -> xxx
define-macro uncomment-line
    set-variable #l0 &ind &spr ".%s.comment"  $buffer-fhook
    !if &seq &set #l1 &lget #l0 1 ""
        ml-write "[Comments not setup for this buffer]"
        !abort
    !endif
    set-variable #l3 &bmod "magic"
    -1 buffer-mode "magic"
    !if &seq &set #l2 &lget #l0 2 ""
        beginning-of-line
        !while &gre &pdec @# 1 0
            !force -1 search-forward #l1
            !if $status
                &len #l1 backward-delete-char
                -1 yank
            !endif
            forward-line
            beginning-of-line
        !done
    !else
        !while &gre &pdec @# 1 0
            search-forward #l2
            search-backward #l1
            &len #l1 forward-delete-char
            -1 yank
            search-forward #l2
            &len #l2 backward-delete-char
            -1 yank
            beginning-of-line
            forward-line
        !done
    !endif
    ; restore magic mode
    &cond #l3 1 -1 buffer-mode "magic"
!emacro
;
; fill from the current column to fill-col with <comment pad> and a trailing <comment end>
define-macro comment-to-end-of-line
    set-variable #l0 &ind &spr ".%s.comment"  $buffer-fhook
    !if &seq &lget #l0 1 ""
        ml-write "[Comments not setup for this buffer]"
        !abort
    !endif
    !if &not &len &set #l1 &lget #l0 3
        set-variable #l1 " "
    !endif
    !if &seq &set #l2 &lget #l0 2 ""
        set-variable #l2 &trb &lget #l0 5
    !endif
    &div &sub &sub $fill-col $window-acol &len #l2 &len #l1 insert-string #l1
    insert-string #l2
!emacro


define-macro comment-start
    !force 0 find-buffer "*comment*"
    !if $status
        !return
    !endif
    set-variable #l0 &ind &spr ".%s.comment"  $buffer-fhook
    !if &seq  &lget #l0 1 ""
        ml-write "[Comments not setup for this buffer]"
        !abort
    !endif
    ; check we can edit the buffer 
    1 buffer-mode "edit" @mna
    set-position "\x83"
    set-variable #l1 $window-acol
    find-buffer "*comment*"
    1 buffer-mode "indent"
    1 buffer-mode "wrap"
    !if &sin "j" &lget #l0 6
        1 buffer-mode "justify"
    !else
        -1 buffer-mode "justify"
    !endif
    set-variable :comment #l0
    set-variable :column #l1
    set-variable :fill-col $fill-col
    set-variable $fill-col &sub $fill-col &sub #l1 &len &lget #l0 4
    !if &sin "b" &lget :comment 6
        set-variable $fill-col &sub $fill-col &len &lget #l0 5
    !endif
    !if &les $fill-col 20
        set-variable $fill-col 20
    !endif
    buffer-bind-create "b" "C-c C-c" "" comment-end 
!emacro

define-macro comment-end
    clean
    beginning-of-buffer
    set-variable #l0 &lget :comment 4
    set-variable #l9 &lget :comment 5
    !if &not &len &set #l8 &lget :comment 3
        set-variable #l8 " "
    !endif
    !if &sin "h" &lget :comment 6
        insert-string &lget :comment 1
        !if &sin "b" &lget :comment 6
            set-variable #l1 &cond &sin "H" &lget :comment 6 #l8 " "
            set-variable #l2 &add $fill-col &sub &len #l0 &len &lget :comment 1
            set-variable #l2 &add #l2 &sub &len #l9 &len &trl #l9
            &div #l2 &len #l1 insert-string #l1
            insert-string &trb #l9
        !elif &sin "H" &lget :comment 6
            !if &not &sin #l8 " "
                set-variable #l2 &add $fill-col &sub &len #l0 &len &lget :comment 1
                &div #l2 &len #l8 insert-string #l8
            !endif
        !endif
        insert-newline
    !else
        ; if the line starts with a fill string don't insert any white spaces etc
        set-variable #l1 &or &sin #l8 " " &not &seq &mid @wl $window-col &len #l8 #l8
        !if &sin "b" &lget :comment 6
            end-of-line
            &sub $fill-col $window-acol insert-space
            !if &not #l1
                &sub &len #l0 &len &lget :comment 1 insert-space
            !endif
            insert-string &trr #l9
            beginning-of-line
        !endif
        insert-string &lget :comment 1
        !if #l1
            insert-string &rig #l0 &len &lget :comment 1
        !endif
        beginning-of-line
        forward-line
    !else
        insert-string &lget :comment 1
    !endif
    set-variable #l1 #l8
    str-to-regex #l1
    set-variable #l1 &spr "^\\(%s\\)\\{3,\\}$" #l1
    !while &not &seq @wc ""
        !if &xse @wl #l1
            end-of-line
            set-variable #l2 &add &sub $fill-col $window-acol &sub &len #l0 &len &trr #l0
            !if &sin "b" &lget :comment 6
                set-variable #l2 &add #l2 &sub &len #l9 &len &trl #l9
                &div #l2 &len #l8 insert-string #l8
                insert-string &trb #l9
            !else
                &div #l2 &len #l8 insert-string #l8
            !endif
            beginning-of-line
            insert-string &trr #l0
        !else
            !if &sin "b" &lget :comment 6
                end-of-line
                &sub $fill-col $window-acol insert-space
                insert-string &trr #l9
                beginning-of-line
            !endif
            insert-string #l0
        !endif
        beginning-of-line
        :column insert-space
        beginning-of-line
        forward-line
    !done
    !if &sin "f" &lget :comment 6
        :column insert-space
        !if &sin "F" &lget :comment 6
            set-variable #l1 #l8
            !jump 3
        !elif &sin "b" &lget :comment 6
            set-variable #l1 " "
            insert-string &trr #l0
            !if &seq &set #l3 &lget :comment 2 ""
                set-variable #l3 #l9
            !endif
            set-variable #l2 &add $fill-col &sub &len #l0 &len &trr #l0
            !if &sin "b" &lget :comment 6
                set-variable #l2 &add #l2 &sub &len #l9 &len &trl #l9
            !else
                set-variable #l2 &sub #l2 &len &trl #l3
            !endif
            &div #l2 &len #l1 insert-string #l1
            insert-string &trl #l3
        !elif &seq &lget :comment 2 ""
            insert-string &trr #l0
        !else
            insert-string &lef #l0 &sub &len #l0 &len &trl #l0
            insert-string &trl &lget :comment 2
        !endif
    !elif &not $seq "" &lget :comment 2
        backward-line
        end-of-line
        insert-string &rig #l0 &len &lget :comment 1
        insert-string &lget :comment 2
    !endif
    beginning-of-buffer
    set-mark
    end-of-buffer
    set-variable #l1 :column
    copy-region
    set-variable $fill-col :fill-col
    0 delete-buffer $buffer-bname
    goto-position "\x83"
    yank
    -1 yank
    !if &seq @wl ""
        #l1 insert-space
    !endif
!emacro

0 define-macro comment-restyle-get-s
    ; get to the first comment start
    beginning-of-line
    !force -1 search-forward #p8
    set-alpha-mark "0x80"
    ; try moving forward line by line
    beginning-of-line
    forward-line
    !tjump &seq &lef &trl @wl &len #p8 #p8 -1
    set-mark
    ; now go back to the start and go backwards
    goto-alpha-mark "0x80"
    beginning-of-line
    !force backward-line
    !if $status
        !tjump &seq &lef &trl @wl &len #p8 #p8 -2
        forward-line
    !endif
    -1 search-forward #p8
    -2 show-region
    set-position "\x83"
    kill-region @mna
    set-variable #p0 $window-acol
    find-buffer "*comment*"
    yank
    -1 yank
    backward-delete-char
    beginning-of-buffer
!emacro
0 define-macro comment-restyle-get-e
    search-forward #p7
    !if &seq &trl &rig @wl $window-col ""
        beginning-of-line
        forward-line
    !endif
    set-mark
    search-backward #p8
    set-position "\x83"
    kill-region @mna
    set-variable #p0 $window-acol
    find-buffer "*comment*"
    yank
    -1 yank
    set-mark
    search-backward #p7
    -1 kill-region
    beginning-of-buffer
    &len #p8 forward-delete-char
    -1 yank
    set-variable #l0 &lget #p9 4
    set-variable #l0 &rig #l0 &len #p8
    !if &seq &lef @wl &len #l0 #l0
        &len #l0 forward-delete-char
        -1 yank
    !endif
!emacro

0 define-macro comment-restyle-i
    set-variable #l9 #p9
    set-variable #l8 &lget #l9 1
    set-variable #l7 &lget #l9 2
    !if &seq #l7 ""
        comment-restyle-get-s
    !else
        comment-restyle-get-e
        forward-line
    !endif
    1 buffer-mode "indent"
    1 buffer-mode "wrap"
    !if &sin "j" &lget #l9 6
        1 buffer-mode "justify"
    !else
        -1 buffer-mode "justify"
    !endif
    1 buffer-mode "magic"
    set-variable :column #l0
    set-variable :fill-col $fill-col
    set-variable $fill-col &sub $fill-col &add #l0 &len &lget #l9 4
    set-variable #l2 &lget #l9 4
    set-variable #l1 &trb #l2
    set-variable #l2 &rig #l2 &len #l8
    str-to-regex #l1
    str-to-regex #l2
    set-variable #l0 &spr "^\\s *%s\\(%s\\)?" #l1 #l2
    !force 1 replace-string #l0 ""
    !if $status
        forward-char
        !jump -3
    !endif
    end-of-buffer
    backward-line
    set-variable #l4 &seq &trl @wl ""
    beginning-of-buffer
    set-variable #l2 &trb &lget #l9 5
    str-to-regex #l2
    set-variable #l0 &spr "\\(.*[ a-zA-Z1-9].*\\)\\s *%s\\s *$" #l2
    set-variable #l1 0
    !force 1 replace-string #l0 "\\1"
    !if $status
        set-variable #l1 1
        !jump -3
    !endif
    clean
    set-variable #l3 ""
    set-variable #l2 &lget #l9 3
    str-to-regex #l2
    set-variable #l0 &spr "^%s%s%s\\(\\(%s\\)*\\)$" #l2 #l2 #l2 #l2
    ; check for a header line
    beginning-of-buffer
    !force -1 search-forward #l0
    !if $status
        ; got a filled header line
        beginning-of-line
        set-mark
        forward-line
        -1 kill-region
        set-variable #l3 &cat #l3 "Hh"
    !elif &seq @wl ""
        ; got an empty header line
        forward-delete-char
        set-variable #l3 &cat #l3 "h"
    !endif
    ; check for a footer line
    !if #l4
        set-variable #l3 &cat #l3 "f"
    !else
        end-of-buffer
        backward-line
        !force -1 search-forward #l0
        !if $status
            ; got a filled footer line
            beginning-of-line
            set-mark
            forward-line
            -1 kill-region
            set-variable #l3 &cat #l3 "Ff"
        !endif
    !endif
    ; find any dividing lines
    beginning-of-buffer
    !force search-forward #l0
    !if $status
        &len @s1 backward-delete-char
        -1 yank
        !jump -4
    !endif
    !if #l1
        set-variable $fill-col &sub $fill-col &len &lget #l9 5
        set-variable #l3 &cat #l3 "b"
        !if &sin "H" #l3
            ; if we have a Header and a right hand end then alway
            ; force to a box
            set-variable #l3 &cat #l3 "Ff"
        !endif
    !endif
    set-variable :comment &lset #l9 6 #l3
    !if &les $fill-col 20
        set-variable $fill-col 20
    !endif
    beginning-of-buffer
    !force 30000 ifill-paragraph
    comment-end
!emacro

define-macro comment-restyle
    !force 0 find-buffer "*comment*"
    !if $status
        !return
    !endif
    set-variable #l9 &ind &spr ".%s.comment"  $buffer-fhook
    !if &seq &lget #l9 1 ""
        ml-write "[Comments not setup for this buffer]"
        !abort
    !endif
    set-variable #l3 &bmod "magic"
    -1 buffer-mode "magic"
    !force !force comment-restyle-i
    ; restore magic mode
    &cond #l3 1 -1 buffer-mode "magic"
!emacro

