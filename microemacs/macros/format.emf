; -!- emf -!-
; This is part of the JASSPA MicroEmacs macro files
; Copyright (C) 1998-2004 JASSPA (www.jasspa.com)
; See the file me.emf for copying and conditions.
;
; Created:     Sat Jul 18 1998
; Synopsis:    Contains buffer formating commands, namely:
; Authors:     Steven Phillips & Jon Green
;                  clean sort-lines-ignore-case tabs-to-spaces restyle-region
;                  restyle-buffer ifill-paragraph paragraph-to-line
;                  delete-indentation
;
; clean - clean all redundant white-spaces
; If an argument is given it runs in spotless mode which removes blank
; ines as well
define-macro clean
    ;
    ; Prepare to clean up file.
    ; Remember position & magic mode
    set-position "\x81"
    set-variable #l1 &not &bmod magic
    !if #l1
        1 buffer-mode "magic"
    !endif
    ;
    ; Get rid of trailing white space on EOL
    beginning-of-buffer
    replace-string "[\t ]+$" ""
    beginning-of-buffer
    replace-string "[ ]+\t" "\t"
    ;
    ; Strip trailing blank lines.
    end-of-buffer
    backward-line
    !while &and &gre $window-line 1 &sequal @wc "\n"
        set-mark
        forward-line
        -1 kill-region
        backward-line
    !done
    ;
    ; if argument given then run a 'spotless' macro, i.e.
    ; Reduce multiple blank lines to single blanks 
    !if @?
        !repeat
            beginning-of-buffer
            replace-string "\n\n\n" "\n\n"
            beginning-of-buffer
            !force search-forward "\n\n\n"
        !until &not $status
    !endif
    ;
    ; Clean up - restore buffer modes etc.
    ; Move back to starting position & restore original magic mode
    !force goto-position "\x81"
    !if #l1
        -1 buffer-mode "magic"
    !endif
    !if &seq @p ""
        screen-update
        ml-write "[Cleaned up buffer]"
    !endif
!emacro
;
; Insert a normal none c-mode/indent tab (still effected by tab mode)
define-macro normal-tab
    ; Remember we have set cmode
    set-variable #l0 &bmod cmode
    set-variable #l1 $buffer-indent
    -1 buffer-mode "cmode"
    set-variable $buffer-indent 0
    !force !force @# tab
    set-variable #l2 $status
    set-variable $buffer-indent #l1
    &cond #l0 1 -1 buffer-mode "cmode"
    !return #l2
!emacro
;
; tabs-to-spaces - Convert all of the tabs to spaces.
define-macro tabs-to-spaces
    ; Remember line
    set-variable #l0 $window-line
    beginning-of-buffer
    !force search-forward "\t"
    !while $status
        set-variable #l1 $window-acol
        backward-delete-char
        &sub #l1 $window-acol insert-space
        !force search-forward "\t"
    !done
    goto-line #l0
    screen-update
    ml-write "[Converted tabs]"
!emacro
;
; sort-case-lines
; Sort lines case insensitivelly regardless of the current 'exact' mode
; setting.
define-macro sort-lines-ignore-case
    set-variable #l0 &bmod exact
    -1 buffer-mode "exact"
    !if @?
        @# sort-lines
    !else
        sort-lines
    !endif
    &cond #l0 1 -1 buffer-mode "exact"
!emacro

define-macro paragraph-to-line
    set-variable #l1 $fill-mode
    set-variable $fill-mode "O"
    !force &sub 0 @# fill-paragraph
    !if &not $status
        set-variable $fill-mode #l1
        !abort
    !endif
    set-variable $fill-mode #l1
!emacro
;
; create the delete-indentation command usually bound to "esc ^"
define-macro delete-indentation
    !repeat
        beginning-of-line
        !while &sin @wc " \t"
            forward-delete-char
        !done
        backward-delete-char
        backward-char
        !while &sin @wc " \t"
            forward-delete-char
            backward-char
        !done
        forward-char
        !if &not &sequal @wc "\n"
            insert-space
        !endif
    !until &les &dec @# 1 1
!emacro
; ifill-paragraph - intelligently try to fill paragraphs by spotting
; bullet lists etc.
0 define-macro ifill-para2
    set-variable #l0 $window-line
    end-of-line
    !force backward-paragraph
    !if $status 
        ; Special case for first line
        !if &xseq @wl "^[ \t]*$"
            forward-line
        !endif
    !endif
    set-variable #l1 $window-line
    beginning-of-line
    !while &les $window-line #l0
        !force -1 search-forward &spr "^[ \t]*[^%s]\\{0,3\\}[%s][ \t]" .ifill-para2.bullet .ifill-para2.bullet
        !if $status
            2 backward-char
            set-variable #l2 &mid @wl $window-col 1
            beginning-of-line
            search-forward "^[ \t]*"
            str-to-regex #l2
            set-variable #l2 &spr "^%s[^%s]\\{0,3\\}%s[ \t]" &lef @wl $window-col .ifill-para2.bullet #l2
            beginning-of-line
            forward-line
            !force &sub &sub $window-line #l0 1 search-forward #l2
            !if $status
                #l0 goto-line
                set-variable #l3 0
                !repeat
                    !force -1 search-forward #l2
                    !if $status
                        beginning-of-line
                        set-variable #l4 $window-line
                        insert-newline
                        ifill-para2
                        !if #l3
                            search-forward "^$"
                            1 kill-line
                            -1 yank
                        !endif
                        #l4 goto-line
                        set-variable #l3 1
                    !endif
                    backward-line
                !until &equ #l1 $window-line
                !if &not &seq @wl ""
                    ifill-para2
                !endif
                !if #l3
                    search-forward "^$"
                    1 kill-line
                    -1 yank
                !endif
                forward-paragraph
                beginning-of-line
                !return
            !endif
        !else
            forward-line
        !endif
    !done
    !if &seq .mode ""
        set-variable #l0 $recent-keys
        @# fill-paragraph @mna
        set-variable #l1 $recent-keys
        !if &not &seq #l0 #l1
            set-variable #l2 &trr &lef #l1 &sin " " #l1
            !if &lfin "|a|A|v|V|" #l2
                set-variable .mode #l2 
            !endif
        !endif
    !else
        @# fill-paragraph .mode
    !endif
!emacro

0 define-macro ifill-para1
    !force forward-paragraph
    !if &not $status
        !return
    !endif
    !force backward-line
    set-variable #l0 $window-line
    !force backward-paragraph
    !if $status 
        ; Special case for first line
        !if &xseq @wl "^[ \t]*$"
            forward-line
        !endif
    !endif
    beginning-of-line
    set-variable #l1 $window-line
    set-variable #l2 0
    !repeat
        !if &gre $window-line #l0
            !jump 4
        !endif
        !force -1 search-forward "[0-9A-Za-z]"
        !if &not $status
            ; no alpha-numeric chars, treat this line as a divider
            !if &gre $window-line #l1
                set-variable #l3 $window-line
                insert-newline
                2 backward-line
                @# ifill-para2
                1 kill-line
                -1 yank
                set-variable #l0 &add #l0 &sub $window-line #l3
            !endif
            !if #l2
                set-variable #l3 &sub $window-line 1
                #l2 goto-line
                1 kill-line
                -1 yank
                #l3 goto-line
            !else
                set-variable #l0 &add #l0 1
            !endif
            !if &equ $window-line #l0
                !return
            !endif
            forward-line
            set-variable #l2 $window-line
            insert-newline
            set-variable #l1 $window-line
        !else
            forward-line
            beginning-of-line
        !endif
    !until 0
!emacro

define-macro ifill-paragraph
    ; Save mark at point.
    !if &not @?
        set-mark
    !endif
    !if &les @# 0
        set-variable #l0 -1
        set-variable @# &abs @#
    !elif @#
        set-variable #l0 1
    !else
        !return
    !endif
    set-variable .ifill-para2.mode ""
    !if &les &len &set #l2 &rep $fill-bullet "]" "" &len $fill-bullet
        set-variable #l2 &cat "]" #l2
    !endif
    !if &les &len &set #l3 &rep #l2 "\\" "" &len #l2
        set-variable #l3 &cat #l3 "\\\\"
    !endif
    !if &les &len &set #l2 &rep #l3 "-" "" &len #l3
        set-variable #l2 &cat #l2 "\\-"
    !endif
    set-variable .ifill-para2.bullet #l2
    set-variable #l1 &cond &bmod "magic" 1 -1
    1 buffer-mode "magic"
    beginning-of-line
    !while &gre &pdec @# 1 0
        !force !force #l0 ifill-para1
        !if &not $status
            #l1 buffer-mode "magic"
            !abort
        !elif &seq @wc ""
            set-variable @# 0
        !endif
    !done
    #l1 buffer-mode "magic"
    ; If no arguments specified then restore the cursor position.
    !if &not @?
        exchange-point-and-mark
    !endif
!emacro
;
0 define-macro restyle-region-int
    set-variable #l0 $window-line
    set-alpha-mark "\x82"
    exchange-point-and-mark
    !if &gre $window-line #l0
        set-variable #l0 $window-line
        set-alpha-mark "\x82"
        exchange-point-and-mark
    !endif
    !if &or &bmod "cmode" $buffer-indent
        !while &les $window-line #l0
            beginning-of-line
            tab @mna
            forward-line
        !done
        beginning-of-line
    !else
        !if &seq $buffer-fhook "fhook-nroff"
            set-variable #l1 "1 nroff-para"
        !elif &seq $buffer-fhook "fhook-latex"
            set-variable #l1 "1 latex-para"
        !else
            set-variable #l1 "1 ifill-paragraph"
        !endif
        !while &les $window-line #l0
            execute-line #l1
            set-mark
            goto-alpha-mark "\x82"
            set-variable #l0 $window-line
            exchange-point-and-mark
        !done
    !endif
!emacro

define-macro restyle-region
    ml-write "[Restyling...]"
    set-variable #l0 $mouse
    set-variable #l1 $system
    set-variable $mouse &bor 0x50000 &band 0xffff #l0
    set-variable $system &bor $system 0x1000
    !force !force restyle-region-int
    !if &not $status
        set-variable $system #l1
        set-variable $mouse #l0
        !abort
    !endif
    set-variable $system #l1
    set-variable $mouse #l0
    ml-write "[Restyle complete]"
!emacro

define-macro restyle-buffer
    set-alpha-mark "\x81"
    end-of-buffer
    set-mark
    beginning-of-buffer
    restyle-region
    goto-alpha-mark "\x81"
!emacro

!if &not &exi .osd.indstp
    set-variable .osd.indstp &pinc .osd.next 1
!endif
0 define-macro indent-setup-exec
    !if &equ @# 3
        !return &not &bmod "tab"
    !elif &equ @# 2
        set-variable $result $buffer-indent-width
    !elif &equ @# 1
        set-variable $result $buffer-tab-width
    !elif &equ @# -1
        set-variable $buffer-tab-width @ml2 "" $buffer-tab-width
    !elif &equ @# -2
        set-variable $buffer-indent-width @ml2 "" $buffer-indent-width
    !elif &equ @# -3
        0 buffer-mode "tab"
    !endif
!emacro
osd .osd.indstp  0 "batcdHs" 9 3 30 10 -1 -1 110 .scheme.osd-title "Indentation Setup"
osd .osd.indstp 10 ""
osd .osd.indstp 20 "Sfh" "  \HTab Width:    " 30
osd .osd.indstp 30 "EtRxHf" 30 .scheme.osd-entry "##########" 1 indent-setup-exec
osd .osd.indstp 40 ""
osd .osd.indstp 50 "Sfh" "  \HIndent Width: " 60
osd .osd.indstp 60 "EtRxHf" 60 .scheme.osd-entry "##########" 2 indent-setup-exec
osd .osd.indstp 70 ""
osd .osd.indstp 80 "fh" "  "
osd .osd.indstp 90 "Cptfx" 90 &spr "%s\} \HUse tab characters" .osd.checkbox-chars 3 indent-setup-exec
osd .osd.indstp 100 ""
osd .osd.indstp 110 "BtcfHh" 110 .scheme.osd-ebtt " \HOkay "  f void
define-macro indent-setup
    .osd.indstp osd
!emacro
