;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Created By    : Detlef Groth & Steven Phillips
;  Created       : Sat Aug 4 16:50:33 2001
;  Last Modified : <010807.0916>
;  Description   : Generic macros for creating a list of functions defined
;                  in current buffer
;
;  Notes
;
; To add support for a new buffer type a list of search/replace strings must
; be created. The search strings must use regex (magic mode) and groups \(..\)
; to get the found function name into the replace string, e.g. given the ME
; macro definition is:
;
;    define-macro macro-name
;
; Searching for "define-macro \([a-z-]+\)" and replacing with "Macro \1" will
; work... most of the time. The space between define-macro and the name does
; not have to be a single space and the name does not have to contain just
; lower case latters, so these search strings should be a flexible as 
; possible, try "define-macro\s +\(\w+\)".
;
; This however is not as optimal as it could be and if you have large files
; this could become slow. Performance can be greatly increased if it can be
; anchored to the start of the line, e.g. "^define-macro\s +\(\w+\)", but to
; allow for intial white spaces and the optional numeric argument, you really
; need "^\s *[0-9]*\s *define-macro\s +\(\w+\)".
;
; To hilight the function name you need the name encased the name in a magic
; hilighting string, "\ecBmacro-name\ecA" where \e is an escape char, so the
; replace string should be "Macro \ecB\1\ecA".
;
; Now all thats needed is to set these variables as fhook command variables,
; for macro files, the file hook command is fhook-emf, therefore the
; following is required:
;
;    set-variable .fhook-emf.list-functions-s1 "^\\s *[0-9]*\\s *define-macro\\s +\\(\\w+\\)"
;    set-variable .fhook-emf.list-functions-r1 "Macro \ecB\\1\ecA"
;
; Note that you can have as many of these search and replace variables as you
; require, i.e. .list-functions-s1, .list-functions-s2, .list-functions-s3, ...
; but the more you have the slower it will be, often a good regex can do the
; job of 2 or 3.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

!if &band .hilight.flags 0x01 
    !if &not &exist .hilight.list-func
        set-variable .hilight.list-func &pinc .hilight.next 1
    !endif
    0 hilight .hilight.list-func 0 $global-scheme
    hilight .hilight.list-func 0x40 "^...... " "" $global-scheme
    hilight .hilight.list-func 0x44 "\ecB" "" "\ecA" "" "" .scheme.function
!endif

define-macro list-functions
    !if &not &exi &ind &spr ".%s.list-functions-s1" $buffer-fhook
        ml-write "[list-functions not setup]"
        !abort
    !endif
    set-variable #l0 &ind &spr ".%s.list-functions-s1" $buffer-fhook
    set-variable #l1 $buffer-bname
    set-variable #l2 &bmod "magic"
    set-variable #l3 $buffer-mask
    1 buffer-mode "magic"
    delete-other-windows
    !force 0 delete-buffer "*list-functions*"
    find-buffer "*list-functions*"
    split-window-horizontally
    25 shrink-window-horizontally
    ; to simple click the function
    buffer-bind-create "bio" "return" "" list-functions-find
    buffer-bind-create "bio" "delete" "" list-functions-close
    buffer-bind-create "b"   "esc f7" "" list-functions-close
    set-variable :mouse-word-select "list-functions-find"
    set-variable $buffer-hilight .hilight.list-func
    set-variable :buffer-bname #l1
    set-variable $buffer-mask #l3
    next-window-find-buffer #l1
    set-alpha-mark "p"
    set-variable #l9 1
    !repeat
        beginning-of-buffer
        set-variable #l5 &ind &spr ".%s.list-functions-r%d" $buffer-fhook #l9
        !force search-forward #l0 ; must be declared in my...emf-files
        !while $status ; if found put into the *function*-buffer
            set-variable #l3 $window-line
            next-window
            set-variable #l4 $window-line
            insert-string @s0
            !if &not &seq #l5 "ERROR"
                #l4 goto-line
                -1 replace-string #l0 #l5
            !endif
            !if &gre $window-line #l4
                delete-indentation
                !jump -2
            !endif
            end-of-line
            insert-newline
            backward-line
            insert-string &spr "%6d " #l3
            &add #l4 1 goto-line
            next-window
            !force search-forward #l0
        !done
        set-variable #l0 &ind &spr ".%s.list-functions-s%d" $buffer-fhook &inc #l9 1
    !until &seq #l0 "ERROR"
    goto-alpha-mark "p"
    next-window
    beginning-of-buffer
    set-mark
    end-of-buffer
    backward-delete-char
    sort-lines
    beginning-of-buffer
    -1 buffer-mode "edit"
    1 buffer-mode "magic"
    1 buffer-mode "view"
    next-window
    &cond #l2 1 -1 buffer-mode "magic"
!emacro

define-macro list-functions-find
    beginning-of-line
    search-forward "^ *\\([0-9]+\\)"
    set-variable #l0 :buffer-bname
    set-variable #l1 @s1
    next-window-find-buffer #l0
    #l1 goto-line
    recenter
!emacro

define-macro list-functions-close
    !force 0 popup-window "*list-functions*"
    !if $status
        !force delete-window
        -1 find-buffer "*list-functions*"
    !endif
!emacro
