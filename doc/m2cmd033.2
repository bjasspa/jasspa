.\" -*- nroff -*-
.\" This is part of the JASSPA MicroEmacs documentation files.
.\" Copyright (c) 1998-2004 JASSPA (www.jasspa.com)
.\" See the file "me.nrs" for copying and conditions.
.\"
.\"  Created By    : Jon Green
.\"  Created       : Sat Jul 25 00:00:27 1998
.\"
.Id $Id: m2cmd033.2,v 2.7 2004-03-23 20:50:56 jon Exp $
.Im MicroEmacs command|indent|scuts
.so me.tni
.TH indent 2
.XI indent - "Manage the auto-indentation methods"
.SH NAME
indent \- Manage the auto-indentation methods
.Me $a
.SH SYNOPSIS
.na
.I 0
.B indent
"\|\fIind-no\fR\|"
"\|\fIflags\fR\|"
"\|\fIlook-back\fR\|"
[ "\|\fIindent-scheme\fR\|" ]
.sp
.B indent
"\|\fIind-no\fR\|"
"\|\fItype\fR\|"
"\|\fItoken\fR\|"
[ "\|\fIclose\fR\|" "\|\fIignore\fR\|" ]
[ "\|\fIindent\fR\|" ]
.br
.B indent
"\|\fIind-no\fR\|"
"\fBt\fR"
"\|\fItoken\fR\|"
"\|\fIindent-scheme\fR\|"
.br
.B indent
"\|\fIind-no\fR\|"
"\fBx\fR" | "\fBw\fR"
"\|\fItoken\fR\|"
"\|\fIindent\fR\|"
"\|\fIindent-scheme\fR\|"
.ad
.SH DESCRIPTION
The \fBindent\fR  command creates and manages the auto-indenting  methods, the
process of creating a new indentation method is best described in
.Hl "File Language Templates" languageTemplates 2 .
The  command  takes  various  forms as defined by the  arguments.  Each of the
argument configurations is defined as follows:-
.SS "Indentation Method Creation"
.na
.I 0
.B indent
"\|\fIind-no\fR\|"
"\|\fIflags\fR\|"
"\|\fIlook-back\fR\|"
[ "\|\fIindent-scheme\fR\|" ]
.ad
.PP
With an argument of \fC0\fR,  \fBindent\fR  creates a new  indentation  method
with the integer handle  \fIind-no\fR. The indentation method is assigned to a
buffer by setting
.Ht $buffer-indent 5
to \fIind-no\fR. \fIind-no\fR cannot be 0 as setting
.B $buffer-indent
to zero disables indentation.
If the indentation method with the same \fIind-no\fR already exists, then the
existing method is deleted and a new method may be created.
.PP
.I flags
Sets the indent bit flags where:-
.IP \fC0x01\fR
Indent  method is case  insensitive.  Note that  \fBindent\fR  tokens  must be
specified in lower case.
.IP \fC0x02\fR
Defines a \fBfast  look-back\fR  indentation  scheme to be used in conjunction
with the  current  indentation  scheme. The fast  look-back  scheme is used to
identify a change in the  current  buffer's  indent  scheme, for  example  the
starting  of  embedded  script in html. The  \fIindent-scheme\fR  argument  is
required  when  this  flag bit is set and  identifies  the  handle  of the fast
look-back  indentation  scheme to be used.
.IP
This feature is only used when indent is required to support  multiple complex
indentation  schemes within a single file, for example  indentation of scripts
within html, asp or php pages etc. When defined the given  \fIindent-scheme\fR
must also be defined using \fBindent\fR, the scheme's \fIlook-back\fR argument
is  typically  set to look  back a long way to  ensure  correctness,  i.e. 500
lines, but it should therefore contain few tokens to maintain performance.
.LP
.I look-back
specifies the maximum  number of lines, prior to the current line,  considered
when calculating the indentation of a line, i.e. if there are  \fIlook-back\fR
number of lines  between the line to be indented  and the  previous  non-blank
line then the current indentation is lost.
.PP
If \fIlook-back\fR is set to 0 then the indentation is effectively disabled as
the  current  indentation  can  never be found.  The  maximum  value  has been
increase as of January 2004 from 255 to an integer (large  number), a value of
10 is  typically  sufficient  for a normal  indent  scheme  and 500 for a fast
look-back scheme.
.SS "Indentation Rule Creation"
.na
.B indent
"\|\fIind-no\fR\|"
"\|\fItype\fR\|"
"\|\fItoken\fR\|"
[ "\|\fIclose\fR\|"
[ "\|\fIignore\fR\|" ]]
[ "\|\fIindent\fR\|" ]
[ "\|\fIindent-scheme\fR\|" ]
.ad
.PP
With the default argument of \fC1\fR,  \fBindent\fR creates a new rule for the
indentation  method  \fIind-no\fR  which must have previously been defined and
initialized.
.PP
The  indentation of a line in a buffer, which is using an indentation  method,
is  affected  by the token  types  matched  on the line  (\fItype\fR  \fCf\fR,
\fCo\fR,  \fCs\fR)  and  the  current  indentation  (if  line  is not of  type
\fCf\fR).
.PP
The  current  indentation  is  determined  by  searching  the  previous  lines
(look-back) for the indentation of the last indented line. This may not simply
be the  indentation  of the last  non-blank  line, the  exact  indentation  is
determined  by searching for tokens in the line and assessing  their effect on
the indentation of the current line.
.PP
The format of the regex valid in the "\fItoken\fR" and "\fIclose\fR" arguments
are the same as at used by hilight token creation, see
.Ht hilight 2
for more information.
.PP
The  indent  tokens  may be  assigned  one of the  following  types,  using the
\fItype\fR  argument.  If the type is  specified  in upper case then the token
must be surrounded by non-alpha-numeric characters:
.TP
\fBFixed\fR (\fI\|type\fR = '\fCf\fR' or '\fCF\fR')
.\"
A line  containing  a  fixed  indent  token  will  be  indented  to the  given
\fIindent\fR column from the left-hand edge. \fIindent\fR is the only argument
specified. e.g. \*(mS macro \fC!goto\fR labels:-
.RS
.Me $emf-scheme
.CS
indent .hilight.emf f "*" 0
.CE
.Me $ehf-scheme
producing
.CS
.ne 3
    \.....
*label
    \.....
.CE
The fixed token must be the first non-white character on the line, the rest of
the line is ignored. The indentation of the previous line has no effect.
.RE
.TP
\fBIndent-from-next-line-onward\fR (\|\fItype\fR = '\fCn\fR' or '\fCN\fR')
.\"
The  indentation  changes by \fIindent\fR  from the next line onwards from the
current line.  \fIindent\fR  is the only argument  specified. e.g. \*(mS macro
\fC!if\fR:-
.RS
.Me $emf-scheme
.CS
indent .hilight.emf n "!if" 4
.CE
.Me $ehf-scheme
Keeps  the  indentation  of  the  \fC!if\fR  line  the  same  as the  previous
indentation,  change  the  indentation  on the  following  lines by an extra 4
characters, to produce:
.CS
.ne 3
\....
!if
    \....
.CE 0
.RE
.TP
\fBIndent-from-current-line-onward\fR (\|\fItype\fR = '\fCo\fR' or '\fCO\fR')
.\"
Increment  the  current  and  following  lines  indentation  by  \fIindent\fR.
\fIindent\fR is the only argument specified. e.g. \*(mS macro \fC!endif\fR
.RS
.Me $emf-scheme
.CS
indent .hilight.emf o "!endif" -4
.CE
.Me $ehf-scheme
decrement the indent of the \fC!endif\fR  line and following lines by 4 spaces
producing:
.CS
.ne 3
    \....
!endif
\....
.CE 0
.RE
.TP
\fBIndent-single\fR (\fI\|type\|\fR = '\fCs\fR' or '\fCS\fR')
.\"
Changes the  indentation  of the current  line  \s-1ONLY\s0  by  \fIindent\fR.
\fIindent\fR is the only argument specified. e.g. \*(mS macro \fC!elif\fR:-
.RS
.Me $emf-scheme
.CS
indent .hilight.emf o "!elif" -4
.CE
.Me $ehf-scheme
decrements  the  indentation  of the  \fC!elif\fR  line by 4  characters,  but
restores the previous indentation after the current line, producing:
.CS
.ne 3
    \....
!elif
    \....
.CE 0
.RE
.TP
\fBBracket\fR (\fI\|type\|\fR = '\fCb\fR' or '\fCB\fR')
.\"
A bracket  should be used when a  starting  token  pairs with a closing  token
which may span  multiple  lines.  i.e. the  opening  and  closing  braces of a
programming  language.  Note  that the  opening  and  closing  tokens  must be
different  otherwise  they  cannot be  differentiated.  A bracket has two main
effects:
.RS
.IP "When the previous line has an unmatched open bracket"
In this  situation the current line is indented to the right of the mismatched
bracket.
.IP "When the previous line has an unmatched close bracket"
In this  situation  the matching open bracket is hunted for in previous  lines
until either the \fIlook-back\fR limit (See \fBIndentation Method Creation\fR)
is  exhausted or the bracket is matched, in which case the indent of that line
is used.
.LP
For a bracket the only other  argument  given is the  \fIclose\fR.  e.g. tcl's
\'\fC(\fR' and '\fC)\fR' brackets
.Me $emf-scheme
.CS
indent .hilight.tcl b "(" ")"
.CE
.Me $ehf-scheme
Which produces:
.CS
.ne 5
\....
\.... (....
      \....
      \....)
\....
.CE 0
.RE
.TP
\fBContinue\fR (\|\fItype\fR\| = '\fCc\fR' or '\fCC\fR')
.\"
Indicates that when \fItoken\fR is found on the current line, the next line is
a  continuation  of the current line. The  indentation of the next line is the
indentation  of the  first  continuation  line  plus the  given  \fIindent\fR.
\fIindent\fR is the only argument specified. e.g. tcl's '\\'
.RS
.Me $emf-scheme
.CS
indent .hilight.tcl c "\\\\" 10
.CE
.Me $ehf-scheme
A simple example is
.CS
.ne 4
\....
12345678901234567890      \\
         \....
\....
.CE
When used in conjunction with brackets, the following effect is observed:
.CS
.ne 7
\....
12345678901234567890      \\
          \....(....       \\
               \....)      \\
          \....            \\
          \....
\....
.CE
This shows why the first continuation line (the \fC123456...\fR  line) must be
located and used as the base line from which the indentation is derived; again
the \fIlook-back\fR limits the search for this line.
.RE
.TP
\fBExclusion\fR (\fI\|type\|\fR = '\fCe\fR' or '\fCE\fR')
.\"
Used to exclude text between start  \fItoken\fR and \fIclose\fR token from the
indentation  calculation, typically used for quotes. The \fIignore\fR argument
is also specified (see
.Ht hilight 2
\fCtype 0x004\fR type bracket)
e.g. \*(mS macro quotes:-
.RS
.Me $emf-scheme
.CS
indent .hilight.emf e "\\"" "\\"" "\\\\"
.CE
.Me $ehf-scheme
e.g. tcl's quotes
.Me $emf-scheme
.CS
indent .hilight.tcl e "\\"" "\\"" "\\\\"
.CE
.Me $ehf-scheme
producing:-
.CS
\....
".... ignore { ... \\" ... ignore another { token ... "
\....
.CE 0
.RE
.TP
\fBIgnore\fR (\fI\|type\|\fR = '\fCi\fR' or '\fCI\fR')
.\"
Text to the right of a line containing \fItoken\fR is to be ignored; typically
used for comments. e.g. \*(mS macro '\fC;\fR' comment:-
.RS
.Me $emf-scheme
.CS
indent .hilight.emf i ";"
.CE
.Me $ehf-scheme
Or tcl's '\fC#\fR' comment
.Me $emf-scheme
.CS
indent .hilight.tcl i "#"
.CE
.Me $ehf-scheme
producing
.CS
.ne 3
\....
# ... ignore this { indent token
\....
.CE 0
.RE
.TP
\fBType\fR (\fI\|type\|\fR =  '\fCt\fR' or '\fCT\fR')
.\"
Used in a \fBfast look-back\fR  indentation scheme (see bit \fC0x02\fR of
\fB0 indent\fR  above) to define the scheme change tokens. The fast look-back token
typically shadows the \fCx\fR and \fCw\fR types and identifies the indentation
scheme. The token itself does not change the indentation, it simply identifies
the  indentation  scheme. The '\fCx\fR' or '\fCw\fR' types are used to perform
the actual indentation of the line if required.
.IP
If the  \fIindent-scheme\fR  is defined as zero (\fC0\fR) then the indentation
scheme is set to the same value as the
.Ht $buffer-indent 5
variable.
.IP
The following example is taken from the XML language  definition . A fast-look
back  scheme  is  used  (\fChilight.xmlT\fR)  to  search  for the  alternative
indentation  schemes  for  \fIjavascript\fR  and  \fIvbscript\fR.  The \fCt\fR
indent type defines the start of script  tokens and to switch the  indentation
to the new indent type.
.RS
.Me $emf-scheme
.CS
; Fast look-back indentation scheme
0 indent .hilight.xmlT 1 500
; Indentation scheme
0 indent .hilight.xml 3 20 .hilight.xmlT

!if &exist .indent.javascript
    indent .hilight.xmlT t "<script ... javascript>"   .indent.javascript
    indent .hilight.xml  x "<script ... javascript>" 2 .indent.javascript
    indent .indent.javascript w "</script>" -2 0
!endif
!if &exist .indent.vbscript
    indent .hilight.xmlT t "<script ... vbscript>"   .indent.vbscript
    indent .hilight.xml  x "<script ... vbscript>" 2 .indent.vbscript
    indent .indent.vbscript w "</script>" -2 0
!endif
indent .hilight.xmlT t "</script>" 0
indent .hilight.xml  o "</script>" -2
; Define the indentation tokens. XML is well defined so there are
; always opening and closing brackets.
indent .hilight.xml e "\\"" "\\"" "\\\\"
indent .hilight.xml b "<!--" "-->"
indent .hilight.xml b "<\\\\?" "\\\\?>"
indent .hilight.xml n "<[^/!]" 2
indent .hilight.xml o "</"    -2
indent .hilight.xml o "/>"    -2
.CE 0
.Me $ehf-scheme
.RE
.TP
\fBChange\fR (\fI\|type\|\fR = '\fCx\fR' or '\fCX\fR' or '\fCw\fR' or '\fCW\fR')
.\"
Change the indentation scheme from the current scheme to the new
.IR indent-scheme .
If the
.I indent-scheme
is specified as zero  (\fC0\fR) then the indentation scheme is set to the same
handle value as the
.Ht $buffer-indent 5
variable.
.I indent
specifies  the indent  value, when the  \fItype\fR is \fCw\fR then the current
line onwards is indented (similar to \fCo\fR), a \fItype\fR of \fCx\fR indents
the next line onwards (similar to \fCn\fR).
.IP
Refer the the \fItype\fR\|=\fCt\fR for an example of indentation switching.
.SH EXAMPLE
Examples  of  indentation  method  creations  can  be  found  in  macro  files
\fChkemf.emf\fR,  \fChktcl.emf\fR and  \fChkvrml.emf\fR. The following example
is taken from \fChkemf.emf\fR:-
.Me $emf-scheme
.CS
!if &not &exist .hilight.emf
    set-variable .hilight.emf &pinc .hilight.next 1
!endif

\...

0 indent  .hilight.emf 0 10
indent .hilight.emf N "define-macro" 4
indent .hilight.emf n "!if" 4
indent .hilight.emf s "!eli" -4
indent .hilight.emf s "!els" -4
indent .hilight.emf o "!end" -4
indent .hilight.emf n "!whi" 4
indent .hilight.emf o "!don" -4
indent .hilight.emf n "!rep" 4
indent .hilight.emf o "!until" -4
indent .hilight.emf o "!ema" -4
indent .hilight.emf e "\\"" "\\"" "\\\\"
indent .hilight.emf i ";"
indent .hilight.emf f "*" 0
.CE
.PP
Note that a \fB.hilight\fR command variable is typically used as a buffer with
indentation  rules will almost certainly have hilighting and the same variable
is used to define the hilighting scheme.
.Me $ehf-scheme
.SH "SEE ALSO"
.na
.Hl "File Language Templates" languageTemplates 2 ,
.Ht $buffer-indent 5 ,
.Ht add-file-hook 2 ,
.Ht hilight 2 .
.ad
.FH
