.\" -*- nroff -*-
.\" This is part of the JASSPA MicroEmacs documentation files.
.\" Copyright (c) 1998-2005 JASSPA (www.jasspa.com)
.\" See the file "me.nrs" for copying and conditions.
.\"
.Id $Id: m3mac064.3,v 1.12 2005-01-23 15:28:55 jon Exp $
.Im MicroEmacs command|macrodevelop
.so me.tni
.TH buffer-init 3
.XI buffer-init - "Initialize a buffer language template"
.XI buffer-init-hooks - "Initialize the buffer language template hooks"
.XI buffer-init-fhook - "Initialize the buffer file hooks"
.SH NAME
.Me "|buffer-init"
buffer-init \- Initialize a buffer language template.
.br
.Me "|buffer-init-hooks"
buffer-init-hooks \- Initialize the buffer language template hooks.
.br
.Me "|buffer-init-fhook"
buffer-init-fhook \- Initialize the buffer file hooks.
.Me $a
.SH SYNOPSIS
.na
.I n
.B buffer-init
.I name
[\|\fIetf\fR\|]
.br
.B buffer-init-hooks
.br
.B buffer-init-fhook
.I name
.ad
.SH DESCRIPTION
The
.B buff-init
commands  prepare  the  operating  modes of a buffer for a language  template.
These   commands   operate  with   variables   defined  in  the  template  and
automatically  configure \*(mS to use the template.
.PP
The commands are used in the hook files (hkXXX.emf - see
.Hl "File Hooks" fileHooks 2 )
and simply the setting up of
.Hl "File Language Templates" languageTemplates 2
by automating common actions and integrating the configuration settings
made via
.Ht buffer-setup 3 .
.PP
The hook file is declared from  \fCme.emf\fR or the user start up file binding
a file extension or magic string association with the hook file. i.e.
.RS
.Me $emf-scheme
.CS
-1 add-file-hook "-[*!]-[ \\t]*XXX.*-[*!]-"    fhook-XXX
 1 add-file-hook "^#!/.*XXX"                  fhook-XXX
.CE
.Me $ehf-scheme
.RE
On loading a file which matches the
.Ht add-file-hook 2
definition  then the  \fChkXXX.emf\fR  file is  executed  and the  template is
applied to the file.
.PP
A basic template framework to be used with the \fBbuff-init\fR commands may be
defined as follows for a language template called \fIXXX\fR:-
.Me $emf-scheme
.CS
; File hook - initialize buffer on loading the file.
define-macro fhook-XXX
    set-variable $buffer-mask "luh1"
    @# buffer-init "XXX"
    buffer-init-hooks
!emacro

; buffer-init variables
set-variable .fhook-XXX.name "XXX Macro"
set-variable .fhook-XXX.setup &reg "/history/fhook/XXX" "bdfghnopx"
set-variable .fhook-XXX.setup-mask "abdefghikmnoptux"
; Commenting configuration -- omit if not defined.
set-variable .fhook-XXX.comment "|#||#|# | #||"
; Additional commands -- omit if not defined.
set-variable .fhook-XXX.command-flag  "||"
set-variable .fhook-XXX.command-name  "||"
set-variable .fhook-XXX.command-nbind "||"
set-variable .fhook-XXX.command-kbind "||"
set-variable .fhook-XXX.command-desc  "||"
; Set up collapse or folding for XXX -- omit if not defined
set-variable .fhook-XXX.collapse-open  "^{"
set-variable .fhook-XXX.collapse-close "^}"
set-variable .fhook-XXX.collapse-mopen  "-1"
set-variable .fhook-XXX.collapse-mclose "1"
set-variable .fhook-XXX.collapse-mnext "-1"
; setup XXX item-list -- omit if not defined
set-variable .fhook-XXX.item-list-s1 "^[ \\t]*func\\\\(\\\\w+\\\\)"
set-variable .fhook-XXX.item-list-r1 "^[ \\t]*end"
; Set up hilighting
!if &and &sin "h" .fhook-XXX.setup &band .hilight.flags 0x02
    ; Hi-light XXX Mode
    !if &not &exi .hilight.XXX
        set-variable .hilight.XXX &pinc .hilight.next 1
    !endif

    0 hilight .hilight.XXX  2 50
    hilight .hilight.XXX 0 "#.*"          .scheme.comment
    hilight .hilight.XXX 1 "end"          .scheme.keyword
    hilight .hilight.XXX 1 "^[ \\t]*func" .scheme.function
    ; ... more ...

    ; Hilight numbers.
    !if &band .hilight.flags 0x08
        ; hilight constants, e.g. numbers
        hilight .hilight.XXX 1 "[[:digit:]]+"       .scheme.constant
        hilight .hilight.XXX 1 "-[[:digit:]]+"      .scheme.constant
        hilight .hilight.XXX 1 "0[xX][[:xdigit:]]+" .scheme.constant
        hilight .hilight.XXX 1 "[[:digit:]]+\\.[[:digit:]]+"  .scheme.constant
        hilight .hilight.XXX 1 "-[[:digit:]]+\\.[[:digit:]]+" .scheme.constant
        hilight .hilight.XXX 1 "[[:digit:]]+\\.[[:digit:]]+f"  .scheme.constant
        hilight .hilight.XXX 1 "-[[:digit:]]+\\.[[:digit:]]+f" .scheme.constant
    !endif
!endif

; End the initialisation - call user extensions i.e. myXXX.emf
buffer-init-fhook "XXX"
.CE
.Me $ehf-scheme
.B buffer-init
is invoked from the buffer file hook
.Hl fhook fileHooks 2
and is invoked with the numerical  argument  passed to the  \fIfhook\fR  macro
(specified  as  \fC$#\fR).  The call  takes  two  arguments,  the first is the
\fIname\fR  of the  template or hook, in the example  this is  \fIXXX\fR.  The
second argument is the \fIetf\fR template name (see
.Ht etf 8 ).
The  command  initializes  the  buffer,  using the  \fI.fhook-XXX\fR  variable
information defined in the file.
.PP
.B buffer-init-hooks
is invoked from the buffer file hook
.Hl fhook fileHooks 2
typically following the
.B buffer-init
call  this  macro   invokes   any  user   defined   file  hooks  of  the  form
\fBmy-fhook-XXX\fR. User defined \fBmy-bhook-XXX\fR and \fBmy-ehook-XXX\fR are
configured into the buffer space ready for execution.
.PP
.B buffer-init-hooks 
must be placed in all \fBfhook-XXX\fR  macros to correctly initialize the file
hooks. If this is not added then the "\fCmy-*hook-always\fR" macros may not be
called correctly for buffers where the \fBfhook-XXX\fR has not been configured
correctly.
.PP
.B buffer-init-fhook
is  placed at the end of the hook file  definition  and  retrieves  additional
configuration  information  from the  registry and the user  settings, it will
also locate and load any user additions to the template by loading the file
\fCmyXXX.emf\fR.
.PP
A set of global default file hooks may be defined of the form
\fBmy-fhook-always\fR,    \fBmy-bhook-always\fR,   \fBmy-ehook-always\fR   and
\fBmy-dhook-always\fR. These file hooks are global and invoked after the
.SS "Execution Sequence"
It is important to understand the execution sequence of the buffer hook files.
On identifying a new file hook then the  \fChkXXX.emf\fR  file is fetched from
the file system and  executed.  Execution  causes all of the  variables  to be
defined and finally, when all definitions have been made,
.B buffer-init-fhook
is  executed to load in any user  defined  extensions.  At this point then the
macro  \fBfhook-XXX\fR  has ONLY been defined it has NOT been  executed.  This
load operation is performed once only and is on demand.
.PP
The  \fBfhook-XXX\fR  macro  must  be  defined  BEFORE  any  of the  variables
associated with the hook as all subsequent variables are command variables and
are defined in the context of the macro definition. See
.Ht Variables 4
for more information on macro variables.
.PP
\fBfhook-XXX\fR   is  invoked  to  apply  hilighting,   buffer  key  bindings,
indentation etc. to a new buffer which has just been created.
.PP
\fBehook-XXX\fR is invoked when a buffer is swapped out. This may be used to
save global variables that have been modified in the context of the buffer.
.PP
\fBbhook-XXX\fR  is invoked  when a buffer is swapped  in. This may be used to
restore variables that are specific to a buffer to global variables.
.PP
\fBdhook-XXX\fR  is invoked  before a buffer is  deleted.  This may be used to
clean up a buffer before it is destroyed.
.PP
.B "Extended file hooks"
.br
The buffer  hooks  \fC[fbed]hook-XXX\fR  may be  extended  by user  specific
configuration in the form  \fCmy-[fbed]hook-any\fR,  these are invoked after
the  primary  hook as been  invoked  and operate on all buffers  rather than a
specific buffer type. The  \fImy-*hook-always\fR  mechanism is provided by the
\fIbuffer-init\fR  macros  of  \fCbuffinit.emf\fR  rather  than  from the base
command set of \*(mS.
.SS "Configuration Masks"
Buffer   initialization  is  controlled  by  the  settings  of  the  variables
\fB.fhook-XXX.setup\fR and \fBfhook-XXX.setup-mask\fR:-
.Me $emf-scheme
.CS
set-variable .fhook-XXX.setup &reg "/history/fhook/XXX" "bdfghnopx"
set-variable .fhook-XXX.setup-mask "abdefghikmnoptux"
.CE
.Me $ehf-scheme
The variables use an ASCII  configuration  string that identifies the modes of
operation that are required. Upper and lower case  alternatives are presented,
an uppercase flag disables the mode, lower case enables. Where the flag is not
specified then the mode is not changed.
.TP
\fCa\fR \- Auto mode
.\"
Configure
.Ht auto 2m
mode for automatic source file line type detection. Typically enabled for text
files.
.TP
\fCb\fR \- Abbreviation mode
.\"
Configures the abbreviation mode using
.Ht buffer-abbrev-file 2
for the buffer.
.TP
\fCc\fR \- View / Author mode
.\"
Configure
.Ht view 2m
mode for read only or authoring.
.TP
\fCd\fR \- Auto indentation operation.
.\"
Automatic indent is enabled using
.Ht indent 2 .
.IP
Where
.Ht indent 2m
mode is required then omit the \fCd\fR flag and use flag \fCi\fR instead.
.TP
\fCe\fR \- Exact or case sensitivity operation
.\"
Configure
.Ht exact 2m
case sensitive mode. \fCe\fR enable exact, \fCE\fR disable exact.
.TP
\fCf\fR \- Folding/Collapsing operation
.\"
Configures folding support, if enabled then the variables
\fI.fhook-XXX.collapse-OPERATION\fR, should be defined to declare the folding
points.
.TP
\fCg\fR \- Fence matching operation
.\"
Configure fence matching mode with
.Ht fence 2m .
Note that fence matching is now typically  performed in the macro  environment
using
.Ht display-matching-fence 3
rather than the in-built  fence  matching.  This colorizes the fences that are
matched. \fCg\fR enable fence matching, \fCG\fR disable fence matching.
.TP
\fCh\fR \- Hilighting
.\"
Support syntax hilighting, when defined then the hilighting scheme defined
by \fI.hilight.XXX\fR is attached to the buffer.
.TP
\fCi\fR \- Automatic indentation
.\"
Support indentation using
.Ht indent 2m .
Automatic indentation (see
.Ht indent 2 )
is defined with the \fCd\fR flag.
\fCi\fR enables indent, \fCI\fR disables indent.
.TP
\fCj\fR \- Justify
Configure paragraph justification using
.Ht justify 2m .
\fCj\fR enable justify, \fCJ\fR disable justify.
.TP
\fCk\fR \- Backup mode
.\"
Configure backups with
.Ht backup 2m
mode. \fCk\fR enable backup, \fCK\fR disable backup.
.TP
\fCm\fR \- Magic mode
.\"
Configure regular expression
.Ht magic 2m
mode. \fCm\fR enable magic, \fCM\fR disable magic.
.TP
\fCn\fR \- New buffer header
.\"
Enable the insertion of a buffer header from the
.Ht etf 8
template file.
.TP
\fCo\fR \- Tool menu
.\"
Enable the tool menu for the buffer.
.TP
\fCp\fR \- Help page
.\"
Produce a help page for the buffer describing the bindings.
.TP
\fCs\fR \- Auto spell
.\"
Configure automatic spelling for the buffer using
.Ht auto-spell 3 .
.TP
\fCt\fR \- Tab mode
.\"
Configure insertion of literal tabs by enabling
.Ht tab 2m
mode. \fCt\fR enable tab, \fCT\fR disable tab.
.TP
\fCu\fR \- Undo
.\"
Configure the undo/redo history using
.Ht undo 2m
mode. \fCu\fR enable undo, \fCU\fR disable undo.
.TP
\fCw\fR \- Wrap
.\"
Configure wrapping using
.Ht wrap 2m
mode. \fCw\fR enable wrap, \fCW\fR disable wrap.
.TP
\fCx\fR \- Time stamping
.\"
Configure time stamping as defined by
.Ht time 2m .
.TP
\fC1\fR \- Reformatting hilighting
.\"
A special internal flag indicating that hilighting is used
for reformatting purposes, i.e. to make readable and hide control text.
.TP
\fC#\fR \- Commenting
Special flag used to indicate commenting is supported. The comment format
should be defined with the \fI.fhook-XXX.comment\fR variable within the
template.
.LP
\fB.fhook-XXX.setup\fR is the current set-up, this is normally defined to take
settings  from the registry  providing a default when not defined. This is the
only mask that is allowed to include the uppercase  flags. All values  defined
in  \fB.fhook-XXX.setup\fR  are explicitly enabled or disabled by default. The
setup set should contain the configuration flags that are required to make the
template operate correctly, but should not include modes that the user may set
up i.e. \fIexact\fR or \fImagic\fR etc.
.PP
\fB.fhook-XXX.setup-mask\fR defines the set of flags that are allowed with the
template. The configuration defined in
.Ht buffer-setup 3
is tested  against  the mask, if the mask  allows it then the mode is enabled.
\fB.fhook-XXX.setup\fR is generally a subset of \fB.fhook-XXX.setup-mask\fR.
.PP
.Ht buffer-setup 3
operates   with   the   values   defined   by    \fB.fhook-XXX.setup\fR    and
\fB.fhook-XXX.setup-mask\fR.  The initialization of  \fB.fhook-XXX.setup\fR  is
performed using the registry as follows:-
.Me $emf-scheme
.CS
set-variable .fhook-XXX.setup &reg "/history/fhook/XXX" "bdfghnopx"
.CE
.Me $ehf-scheme
This allows the user to configure over-ridding modes  via
.Ht buffer-setup 3 .
The user configuration is saved to the
.Hl "Registry" Registry -
and restored using
.Ht &reg 4 ,
when the variable is defined. The flags that are defined by
.Ht buffer-setup 3
include   \fCa\fR,  \fCb\fR,  \fCc\fR,  \fCd\fR,  \fCe\fR,  \fCf\fR,  \fCg\fR,
\fCh\fR,  \fCi\fR,  \fCj\fR,  \fCk\fR,  \fCm\fR,  \fCn\fR,  \fCo\fR,  \fCp\fR,
\fCs\fR, \fCt\fR, \fCu\fR, \fCw\fR, and \fCx\fR.
.SS Tags
The buffer  setup may be  configured  to add a tags  generator to the language
template,  this is added to the menu. The tags  generation  is declared in the
template by assigning the variable  \fB.fhook-XXX.tags\fR  with a command line
to run tags utility. The command line string  should  commence  with a \fC!\fR
character to tell \*(mS to execute an external command, for example to use the
GNU
.Hr ctags 2
utility is defined as:-
.Me $emf-scheme
.CS
set-variable .fhook-c.tags "!ctags *.c *.h"
.CE
.Me $ehf-scheme
When the value  starts with a '\fC!\fR'  then rest of the line is spawned as a
process, no additional interface is provided to the command.
.PP
Some language templates include a macro \fItags\fR  facility to generate a tags file
(See
.Ht emftags 3f
\- \fCemftags.emf\fR,
.Ht ctags 3f
\- \fCctags.emf\fR,
.Ht ntags 3f
\- \fCntags.emf\fR).
\fB.fhook-XXX.tags\fR  may be  defined  to use an internal macro  based  tags  generator
rather than an external command. Without the '\fC!\fR' character the
command line is assumed to be an \*(mS macro based and runs the command
.CS
me @<.tags-var-value> -v%tag-options=<options>
.CE
A macros based command line for the 'C' Programming Language is defined as:-
.Me $emf-scheme
.CS
set-variable .fhook-c.tags "ctags"
.CE
.Me $ehf-scheme
The  presence  of a  tags  generator  is  not  flagged  in  the  setup  flags,
declaration  of the  \fB.fhook-XXX.tags\fR  variable is  sufficient to declare
that a tags generator exists.
.SS Comments
The  format  of   comments   may  be  defined  in  the   template   using  the
\fB.fhook-XXX.comment\fR  variable.  Definition of the comment form allows the
comment  formatting to be  automatically  set up. Where the comment  format is
defined  then  the  following  key  bindings  are  automatically  added to the
template:-
.IP
\fCC-c C-s\fR \fBcomment-start\fR \- start a new comment.
.br
\fCC-c C-c\fR \fBcomment-line\fR \- comment out the current line.
.br
\fCC-c C-d\fR \fBuncomment-line\fR \- remove commenting from current line.
.br
\fCC-c C-e\fR \fBcomment-to-end-of-line\fR \- comment to end of line.
.br
\fCC-c C-r\fR \fBcomment-restyle\fR \- format/re-style comment.
.LP
Help  information  is  automatically  added to the buffer to describe  the key
bindings if help information is enabled.
.PP
The    default    comment    format    is    defined    with   the    variable
\fB.fhook-XXX.comment\fR with an argument string in the form "\fB|\fR
.I "<comment-start>"
.B |
.I "<comment-end>"
.B |
.I "<comment-pad>"
.B |
.I "<mid-box-left>"
.B |
.I "<mid-box-right>"
.B |
.I "<comment-flags>"
\fB|\fR".
Where a language supports multiple comment types, or styles, then additional
comment styles may be specified with a comment definition of the form
\fB.fhook-XXX.comment-N\fR where \fBN\fR is an integer from \fC1\fR to
\fCn\fR. Each definition defines an different comment style. Additional
comment definitions should be ordered such that the longest or most definitive
comment definition appears before other comment definitions which have less
definitive features. The comment matching searches each of the comment
definitions in the order \fC1\fR to \fCn\fR to determine the comment style, as
soon as a positive match is located then the comment is used without searching
the remaining comments.
.PP
The fields of the comment definition are defined as follows:-
.TP
\fI<comment-start>\fR
.\"
The format of the start of the comment or comment open syntax.
.TP
\fI<comment-end>\fR
.\"
The format of the closing  comment, where the comment exists to the end of the
line  then the  field is  defined  as empty.  Leading  white  space  should be
included  where this affects the horizontal  positioning of the comment, white
leading space is ignored in any match i.e. "\fC\ */\fR" for C type comments.
.TP
\fI<comment-pad>\fR
.\"
The character to use to pad a comment  between the  \fI<comment-start>\fR  and
\fI<comment-end>\fR characters when creating a line or a box formation.
.TP
\fI<mid-box-left>\fR
.\"
The start of a comment continuation line when creating a box comment.
.TP
\fI<mid-box-right>\fR
.\"
The end of a comment  continuation  line when  creating a box  comment and the
comment is not closed and continues on the next line.
.TP
\fI<comment-flags>\fR
.\"
The comment flags define how the comment  should be formatted when  re-styled.
The flags are defined as single characters that describe the attributes.
Re-styling may include the following attributes:-
.RS
.BP "b"
Box format required, create a left and right edge for the comment.
.BP "f"
A footer line is required, a new line is created following the comment text to
contain  the with a closing  comment  \fI<comment-end>\fR  string.  The end of
comment is not padded.
.BP "F"
As \fBf\fR except the footer line is left padded with
\fI<comment-pad>\fR strings.
.BP "h"
A header line is required, a new line is created before the comment text to
contain  the opening  comment  \fI<comment-start>\fR  string.  The end of
comment is not padded.
.BP "H"
As \fBh\fR except the header line is right padded with
\fI<comment-pad>\fR strings.
.BP "j"
Enable justification mode in the *comment* buffer and re-style.
.BP "r"
A restyle  key binding is added to the buffer  "\fC\*eo\fR"  and  "\fC\*eq\fR"
buffer key bindings are added and bound to
.Ht comment-restyle 3 .
The \fBr\fR flag is only processed from the
.RE
.PP
Examples of the comments format are shown below.
.BP "'C' Programming language"
Format: \fC/* ... */\fR
.LP
.RS
.Me $emf-scheme
.CS 0
set-variable .fhook-c.comment "|/*| */|*| * | * |f|"
.CE 0
.RE
.Me $ehf-scheme
.IP
The comment output is defined as:-
.LP
.RS
.ne 6
.CS 0
/***************************************************************
 * This is a box comment                                       *
 ***************************************************************/

/* Comment to end of line **************************************/
.CE 0
.RE
.BP "C++ Programming language"
Format: \fC// ... <EOL>\fR
.LP
.RS
.Me $emf-scheme
.CS 0
set-variable .fhook-cpp.comment "|//||/|// | //||"
.CE 0
.Me $ehf-scheme
.RE
.IP
The comment output is defined as:-
.LP
.RS
.ne 6
.CS 0
/////////////////////////////////////////////////////////////////
// This is a box comment                                       //
/////////////////////////////////////////////////////////////////

// Comment to end of line ///////////////////////////////////////
.CE 0
.RE
.IP
C++ supports both C and C++ comment styles, both styles may be defined
in the language  template.  For C++ then \fC//\fR is assumed to be the default
style.
.LP
.RS
.ne 2
.Me $emf-scheme
.CS 0
set-variable .fhook-cpp.comment   "|//||/|// | //||"
set-variable .fhook-cpp.comment-1 "|/*| */|*| * | * |f|"
.CE 0
.Me $ehf-scheme
.RE
.BP "MicroEmacs macro language"
Format: \fC; ... <EOL>\fR
.LP
.RS
.Me $emf-scheme
.CS 0
set-variable .fhook-emf.comment "|;||;|; | ;||"
.CE 0
.Me $ehf-scheme
.RE
.IP
The comment output is defined as:-
.LP
.RS
.ne 6
.CS 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Box Comment                                                   ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Comment to end of line ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.CE 0
.RE
.BP "Shell script"
Format: \fC# ... <EOL>\fR
.LP
.RS
.Me $emf-scheme
.CS 0
set-variable .fhook-shell.comment "|#||#|# | #||"
.CE 0
.Me $ehf-scheme
.RE
.IP
The comment output is defined as:-
.LP
.RS
.ne 6
.CS 0
#################################################################
# Box Comment                                                   #
#################################################################

# Comment to end of line ########################################
.CE 0
.RE
.BP "MS-DOS Batch file"
Format: \fCrem ... <EOL>\fR
.LP
.RS
.Me $emf-scheme
.CS 0
set-variable .fhook-dos.comment "|rem |||rem |||"
.CE 0
.Me $ehf-scheme
.RE
.IP
The comment output is defined as:-
.LP
.RS
.ne 6
.CS 0
rem
rem Box Comment
rem

rem Comment to end of line
.CE 0
.RE
.SS "Commands and Key Bindings"
Local buffer  commands and key bindings for  over-riding key definitions  used
within the buffer are defined with the
.C fhook-XXX.command-*
variables.  These are defined as \*(mS list variables
(see
.Ht &lfind 4 ,
.Ht &lget 4 ,
etc. for the full syntax  definition)  and define a list of keys, commands and
bindings. Each command is typically  separated by the '\fC|\fR' character. The
field order in all of the
.C fhook-XXX.command-*
variables  MUST be consistent, so if a command is defined in field 5, then all
definitions  associated  with that  command MUST be defined in field 5 for all
variables. The command variables are defined as follows:-
.TP
\fI.fhook-c.command-flag\fR
.\"
A  configuration  flag that defines the components to use for the command. The
flags are set as individual characters and are defined as follows:-
.RS
.TP
\fCt\fR \- Toolbar
.\"
Show the command in the toolbar. The
.C .fhook-XXX.command-desc
variable  should  contain a  readable  name for the  command to display in the
menu. An optional hot key for selection in any
.Hl osd osd 2
is  specified by prefixing  the  character in the string with  \fC\\H\fR.
.TP
\fCh\fR \- Help Screen
.\"
Show the command in the help screen. The
.C .fhook-XXX.command-desc
variable  should  contain a  readable  name for the  command to display in the
menu. An optional hot key for selection in any
.Hl osd osd 2
is specified by prefixing the character in the string with \fC\\H\fR.
.TP
\fCb\fR \- Key binding
.\"
Create a buffer key binding for the command, the key to bind is defined by the
variable  \fCfhook-XXX.command-kbind\fR,  if the command  requires a numerical
argument  then this is defined in the variable  \fCfhook-XXX.command-nbind\fR.
The binding is only created if the key buffer binding does not already exist,
the  binding  may be forced by using the \fCo\fR flag. Where a key binding is
only to be created if  hilighting  is enabled  then the \fCb\fR flag should be
qualified with the \fCH\fR flag.
.TP
\fCo\fR \- Forced key binding
.\"
Optionally  used with the  \fCb\fR and forces the  binding to  over-write  any
existing binding.
.TP
\fCi\fR \- Emulated key binding
.\"
Used with the \fCb\fR flag, ignores key bindings that are emulation mappings.
.TP
\fCH\fR \- Hilighting key binding
.\"
Used with the \fCb\fR  flag, only  performs the key binding if  hilighting  is
enabled.
.RE
.TP
\fI.fhook-XXX.command-name\fR
.\"
Specifies  the name of the command to execute,  this may be a built in command
of a macro. Typically the command is a local macro defined in the hook file.
.TP
\fI.fhook-XXX.command-nbind\fR
.\"
The value of the numeric argument to pass to the command defined in the
\fI.fhook-XXX.command-name\fR  field.  This  field may be empty if no  numeric
argument is required.
.TP
\fI.fhook-XXX.command-kbind\fR
.\"
The local key binding to bind to the command,  this field is only  interpreted
if the \fCb\fR is specified,  otherwise the field may be empty. Where multiple
key  bindings  are  required to the same  command then a field  definition  is
required for each binding.
.TP
\fI.fhook-c.command-desc\fR
.\"
A short  description  of the command that is used for the help page  (\fCh\fR)
and toolbar  (\fCt\fR).  The field may be empty if the field is not  specified
for insertion into the toolbar or help page.
.LP
As an example, two new commands or bindings may be defined for a template, the
first field is bound to key \fCA-q\fR which executes macro \fCXXX-comp\fR with
a numerical argument of 2. The second field binds a new key to
.Ht comment-restyle 3 .
.ne 17
.Me $emf-scheme
.CS

\.....

set-variable .fhook-XXX.command-flag  "|th|bo|"
set-variable .fhook-XXX.command-name  "|XXX-comp|comment-restyle|"
set-variable .fhook-XXX.command-nbind "|2||"
set-variable .fhook-XXX.command-kbind "|A-q|esc o|"
set-variable .fhook-XXX.command-desc  "|Complete command||"

\.....

; Local macro definition to perform command completion
define-macro XXX-comp
    set-variable #l1 @#
    \.....
!emacro
.CE
.Me $ehf-scheme
The key bindings sometimes need to be protected where they have been redefined
to perform  some other  operation  for example when  emulation  modes are used
(i.e. \fBnedit\fR, \fBme3.8\fR). The buffer initialisation uses the command
.B buffer-bind-create
and the variables
.B .buffer-bind-create.map-from
and
.B .buffer-bind-create.map-to
which  define  replacement  keys for  bindings. As an example the  \fBnedit\fR
emulation  mode uses key binding  \fCC-c C-c\fR and provides a buffer  binding
mapping to translate any key buffer binding to a different key. i.e.
.Me $emf-scheme
.CS
; reconfigure the buffer bindings
set-variable .buffer-bind-key.map-from "|C-c C-c|C-c C-d|"
set-variable .buffer-bind-key.map-to   "|C-b|C-u|"
.CE 0
.Me $ehf-scheme
.SS "Information Hiding with Collapse"
\*(mE provides a generic, albeit coarse, folding mechanism which is applied to
some of the well known file modes. The folding  mechanism  allows parts of the
buffer to be  scrolled  up and  hidden,  leaving a residue  hilighting  marker
within   the   buffer   indicating   a   folded   region.   A  folded   buffer
typically  allows a summary of the buffer contents to be viewed within several
windows, hiding the detail of the buffer.
.PP
Note:
.B collapse
was called
.B fold
in earlier  releases  but the name was changed when real fold editing  support
was added, see \fCfold.emf\fR for more information.
.PP
The folding  mechanism  uses well defined  \fIstart\fR  and \fIend\fR  markers
which form part of the syntax of the well known file mode. i.e. in 'C' this is
the open and closed  braces that appear on the  left-hand  margin  (\fC{\fR ..
\fC}\fR).  The  intention  is that the  natural  syntax of the text is used to
determine  the fold  positions,  requiring  no  additional  text  formating or
special text tags to be inserted by the user.
.PP
The language template defines the syntax of blocks of information that
may be collapsed and hidden with
.Hl narrow narrow-buffer 2 .
In order to utilize the
.Ht collapse-current 3
and
.Ht collapse-all 3
commands  within a buffer, the  \fIstart\fR  and \fIend\fR  markers have to be
initialized  for the  syntactical  contents of the buffer. The buffer specific
variables are defined as follows, where \fIXXX\fR is the file hook base name.
The \fC.fhook-XXX.collapse-*\fR variables define the regular expression search
pattern and line positioning.
.IP "\fB.fhook-\fR\|\fIXXX\fR\|\fB-collapse-open\fR"
A regular expression search string used to locate the start of the string. For
speed the search string should  include a regular  expression  start or end of
line character whenever possible. i.e. in C the open is defined as "\fC^{\fR".
.IP "\fB.fhook-\fR\|\fIXXX\fR\|\fB-collapse-close\fR"
A regular  expression  search string used to locate the end of the string. For
speed the search string should include a regular  expression start or end line
character whenever possible. i.e. in C the close is defined as "\fC^}\fR".
.IP "\fB.fhook-\fR\|\fIXXX\fR\|\fB-collapse-mopen\fR"
An  integer  value  that  denotes  the number of lines to move in a forward or
(\-ve)  backward  direction  from the  \fIstart\fR  line located by the search
string to the  position  in the  buffer to be folded. If  default  value  when
\fBmopen\fR is omitted is 0, starting the fold from the search string line.
.IP "\fB.fhook-\fR\|\fIXXX\fR\|\fB-collapse-mclose\fR"
The relative  displacement from the close fold line to the fold position, this
is a positive or negative  displacement  depending  on where the fold is to be
positioned.
.IP "\fB.fhook-\fR\|\fIXXX\fR\|\fB-collapse-mnext\fR"
Specifies the number  of lines to advance  before the next search is continued
on the fold operation. This is only used by
.Hl collapse-all collapse-all 3 .
.PP
The following  examples show how the collapse  variables are set up in each of
the buffer modes.
.PP
.B "C and C++"
.br
.RS
\fBC\fR and  \fBC++\fR  collapse on the open and close brace  appearing in the
left-hand     margin.    The    collapse     variables    are    defined    in
\fChkc\fR/\fChkcpp.emf\fR as follows:-
.Me "$emf-scheme"
.CS
set-variable .fhook-c.collapse-open  "^{"
set-variable .fhook-c.collapse-close "^}"
set-variable .fhook-c.collapse-mopen  "-1"
set-variable .fhook-c.collapse-mclose "1"
set-variable .fhook-c.collapse-mnext "-1"
.CE
.Me "$ehf-scheme"
Given a 'C' function definition:-
.CS
static void
myfunc (int a, int b)
{
    /* Function body */
}
.CE
the folded version appears as follows:-
.CS
static void
myfunc (int a, int b) ... }
.CE
.RE
.B "emf"
.br
.RS
MicroEmacs  macro files \fBemf\fR  support folding of macro  definitions,  the
collapse variables are defined in \fChkemf.emf\fR as follows:-
.Me "$emf-scheme"
.CS
set-variable .fhook-emf.collapse-open  "^0? ?define-macro[ \\t]"
set-variable .fhook-emf.collapse-close "^!emacro"
set-variable .fhook-emf.collapse-mclose "1"
set-variable .fhook-emf.collapse-mnext "-1"
.CE
.Me "$ehf-scheme"
Given a macro definition:-
.Me "$emf-scheme"
.CS
0 define-macro mymacro
; This is the body of the macro
; ... and some more ...
!emacro
.CE
.Me "$ehf-scheme"
the collapsed version of the macro is defined as:-
.Me "$emf-scheme"
.CS
0 define-macro mymacro ... !emacro
.CE
.Me "$ehf-scheme"
.RE
.B nroff
.br
.RS
\fBnroff\fR  is configured  for manual pages only and folds between  \fC.SH\fR
and \fC.SS\fR sections, the hook variables are defined as follows:-
.Me "$emf-scheme"
.CS
set-variable .fhook-nroff.collapse-open  "^\\.S[SH]"
set-variable .fhook-nroff.collapse-close "^\\.S[SH]\\|\\'"
set-variable .fhook-nroff.collapse-mnext "-1"
.CE
.Me "$ehf-scheme"
Given an nroff block of text defined as:-
.CS
\&\.SH SYNOPSIS
\&\.\e" Some text
\&\.\e" Some more text
\&\.SH DESCRIPTION
.CE
Then the collapsed version appears as:
.CS
\&\.SH SYNOPSIS
\&\.SH DESCRIPTION
.CE
.RE
.B "tcl/tk"
.br
.RS
\fBtcl/tk\fR is configured to collapse  procedures. The collapse variables are
defined as:-
.Me "$emf-scheme"
.CS
set-variable .fhook-tcl.collapse-open  "^proc "
set-variable .fhook-tcl.collapse-close "^}"
set-variable .fhook-tcl.collapse-mclose "1"
set-variable .fhook-tcl.collapse-mnext "-1"
.CE
.Me "$ehf-scheme"
Given a tcl procedure definition:-
.CS
proc tixControl:InitWidgetRec {w} {
    upvar #0 $w data

    tixChainMethod $w InitWidgetRec

    set data(varInited)	  0
    set data(serial)	0
}
.CE
The collapsed version of the same section appears as:-
.CS
proc tixControl:InitWidgetRec {w} { ... }
.CE 0
.RE
Where folding is required using
.Ht fold-open 3
then the  collapse  methods  above are not  enacted  when  folding is enabled.
Folding may be enabled as defined by the
.Hl "File Hooks" fileHooks 2 ,
alternatively  the  folding  may be  explicitly  defined  using  the  variable
\fI.fhook-XXX.fold\fR. The \fI.fhook-XXX.fold\fR  variable argument is defined
as "\fB|\fR
.I "<literal-open>"
.B |
.I "<literal-close>"
.B |
.I "<comment-termination>"
.B |
.I "<regex-find-open>"
.B |
.I "<regex-find-close>"
.BR | .
Where the fields are defined as follows:-
.TP
\fI<literal-open>\fR
.\"
The literal fold open string.
.TP
\fI<literal-close>\fR
.\"
The literal fold close string.
.TP
\fI<comment-termination>\fR
.\"
The comment termination string.
.TP
\fI<regex-find-open>\fR
.\"
The regular expression to find an open fold.
.TP
\fI<regex-find-close>\fR
.\"
The regular expression to find a close string.
.LP
As an  example,  a  language  may  have  the  following  syntax  for  defining
folds:-
.CS
/* {{{ This is an example fold. */
This is
the body
of the fold
/* }}} */
.CE
The fold is defined as follows:-
.Me $emf-scheme
.CS
set-variable fhook-XXX.fold "|/\\\\* {{{|/\\\\* }}}|\\\\*/|/\\\\*[ \\t]*{{{|/\\\\*[ \\t]*}}}|"
.CE 0
.Me $ehf-scheme
.SS "Item Lists"
.Hl "Item Lists" item-list 3
perform  a regular  expression  search of a buffer,  presenting  a list of the
located text and associated  types in a separate  window which is presented to
the left of the buffer window or more typically in the toolbar. The command
.Ht item-list 3
is a generic command that interacts with the buffer  environment  variables to
present abbreviated buffer information to the user.
.PP
The  regular   expression  search  strings  are  predefined  in  the  language
templates,                 using                 the                 variables
\fB.fhook-\fR\|\fIXXX\fR\|\fB-item-list-s\fR\|\fIY\fR                     and
\fB.fhook-\fR\|\fIXXX\fR\|\fB-item-list-r\fR\|\fIY\fR  and are described more
fully in
.Ht item-list 3 .
.SS Hilighting
Buffer hilighting is defined by the
.Ht hilight 2
command.   Within  the  context  of   \fBbuffer-init\fR   then  the   standard
definitions and name space conventions should be adhered to:-
.Me "$emf-scheme"
.CS
!if &not &exist .hilight.XXX
    set-variable .hilight.XXX &pinc .hilight.next 1
!endif
!if &and &sin "h" .fhook-XXX.setup &band .hilight.flags 0x02
    ; High-light XXX Mode
    0 hilight    .hilight.XXX 0                    $global-scheme
    \.....
    ; Variable hilighting
    !if &band .hilight.flags 0x08
        ; hilight constants, e.g. numbers
        hilight .hilight.XXX 1 "[[:digit:]]+"       .scheme.constant
        \......
    !endif
!endif
.CE 0
.Me "$ehf-scheme"
.SS Indentation
Buffer indentation is defined by the
.Ht indent 2
command.   Within  the  context  of   \fBbuffer-init\fR   then  the   standard
definitions  and name  space  conventions  should be  adhered  to. The  buffer
indentation scheme uses the hilighting  variable, if hilighting is not defined
then the  variable  allocation  of  \fC.hilight.XXX\fR  should be performed as
defined in the previous Hilighting section.
.Me "$emf-scheme"
.CS
!if &sin "d" .fhook-XXX.setup
    0 indent  .hilight.XXX 0 10
    indent .hilight.XXX n "{"  4
    indent .hilight.XXX o "}" -4
    \.....
!endif
.CE 0
.Me "$ehf-scheme"
.SH HISTORY
The January 2005 version of \*(mS introduced the following changes:
.BS
The \fCmy-*hook-always\fR  introduced allowing global file hooks to manipulate
operate on any buffer.
.BU
The Electric-C indentation previously flagged as \fC>\fR was removed, as was
.Hr cmode 2m .
Indentation configuration for C mode is now performed by the
.Ht indent 2
command.
.BE 0
.SH "SEE ALSO"
.na
.Ht $buffer-hilight 5 ,
.Ht $buffer-indent 5 ,
.Ht add-file-hook 2 ,
.Ht buffer-abbrev-file 2 ,
.Ht buffer-setup 3 ,
.Ht collapse-all 3 ,
.Ht collapse-current 3 ,
.Ht ctags 3f ,
.Ht eaf 8 ,
.Ht emftags 3f ,
.Ht etf 8 ,
.Ht etfinsrt 3 ,
.Ht execute-buffer 2 ,
.Ht expand-abbrev 2 ,
.Ht global-abbrev-file 2 ,
.Ht hilight 2 ,
.Ht indent 2 ,
.Ht indent 2m ,
.Ht item-list 3 ,
.Ht narrow-buffer 2 ,
.Ht ntags 3f ,
.Ht restyle-buffer 3 ,
.Ht restyle-region 3 ,
.Ht scheme-editor 3 ,
.Ht time 2m ,
.br
.Hl "File Hooks" fileHooks 2 ,
.br
.Hl "File Language Templates" languageTemplates 2 .
.ad
.FH
